
MCU working project CubeIDE ver.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000013c  08005000  08005000  00005000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000fabc  0800513c  0800513c  0000513c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000007c8  08014bf8  08014bf8  00014bf8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  080153c0  080153c0  000153c0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  080153c4  080153c4  000153c4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000024  20000004  080153c8  00020004  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 TIMERSERVER_CONTEXT 00000099  20000028  080153ec  00020028  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 BLE_DRIVER_CONTEXT 00000044  200000c4  08015485  000200c4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 SYSTEM_DRIVER_CONTEXT 00000011  20000108  080154c9  00020108  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 BLE_APP_CONTEXT 00000084  2000011c  080154da  0002011c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .bss          0000536c  200001a0  0801555e  000201a0  2**2
                  ALLOC
 11 ._user_heap_stack 00010404  2000550c  0801555e  0002550c  2**0
                  ALLOC
 12 .ARM.attributes 00000030  00000000  00000000  000201a0  2**0
                  CONTENTS, READONLY
 13 MAPPING_TABLE 00000028  20030000  20030000  00030000  2**2
                  ALLOC
 14 MB_MEM1       000001b7  20030028  20030028  00030000  2**2
                  ALLOC
 15 MB_MEM2       00000877  200301e0  200301e0  00030000  2**2
                  ALLOC
 16 .debug_info   00045d54  00000000  00000000  000201d0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_abbrev 00008aa9  00000000  00000000  00065f24  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 00002da0  00000000  00000000  0006e9d0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_ranges 00002ac0  00000000  00000000  00071770  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  0002fdd1  00000000  00000000  00074230  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   0003780f  00000000  00000000  000a4001  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    00105a39  00000000  00000000  000db810  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000053  00000000  00000000  001e1249  2**0
                  CONTENTS, READONLY
 24 .debug_frame  0000ba54  00000000  00000000  001e129c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

0800513c <__do_global_dtors_aux>:
 800513c:	b510      	push	{r4, lr}
 800513e:	4c05      	ldr	r4, [pc, #20]	; (8005154 <__do_global_dtors_aux+0x18>)
 8005140:	7823      	ldrb	r3, [r4, #0]
 8005142:	b933      	cbnz	r3, 8005152 <__do_global_dtors_aux+0x16>
 8005144:	4b04      	ldr	r3, [pc, #16]	; (8005158 <__do_global_dtors_aux+0x1c>)
 8005146:	b113      	cbz	r3, 800514e <__do_global_dtors_aux+0x12>
 8005148:	4804      	ldr	r0, [pc, #16]	; (800515c <__do_global_dtors_aux+0x20>)
 800514a:	f3af 8000 	nop.w
 800514e:	2301      	movs	r3, #1
 8005150:	7023      	strb	r3, [r4, #0]
 8005152:	bd10      	pop	{r4, pc}
 8005154:	200001a0 	.word	0x200001a0
 8005158:	00000000 	.word	0x00000000
 800515c:	08014be0 	.word	0x08014be0

08005160 <frame_dummy>:
 8005160:	b508      	push	{r3, lr}
 8005162:	4b03      	ldr	r3, [pc, #12]	; (8005170 <frame_dummy+0x10>)
 8005164:	b11b      	cbz	r3, 800516e <frame_dummy+0xe>
 8005166:	4903      	ldr	r1, [pc, #12]	; (8005174 <frame_dummy+0x14>)
 8005168:	4803      	ldr	r0, [pc, #12]	; (8005178 <frame_dummy+0x18>)
 800516a:	f3af 8000 	nop.w
 800516e:	bd08      	pop	{r3, pc}
 8005170:	00000000 	.word	0x00000000
 8005174:	200001a4 	.word	0x200001a4
 8005178:	08014be0 	.word	0x08014be0

0800517c <strlen>:
 800517c:	4603      	mov	r3, r0
 800517e:	f813 2b01 	ldrb.w	r2, [r3], #1
 8005182:	2a00      	cmp	r2, #0
 8005184:	d1fb      	bne.n	800517e <strlen+0x2>
 8005186:	1a18      	subs	r0, r3, r0
 8005188:	3801      	subs	r0, #1
 800518a:	4770      	bx	lr

0800518c <disk_status>:
/*-----------------------------------------------------------------------*/
extern DSTATUS USER_Return_uSD_Status(void);
DSTATUS disk_status (
	BYTE pdrv		/* Physical drive nmuber to identify the drive */
)
{
 800518c:	b580      	push	{r7, lr}
 800518e:	b082      	sub	sp, #8
 8005190:	af00      	add	r7, sp, #0
 8005192:	4603      	mov	r3, r0
 8005194:	71fb      	strb	r3, [r7, #7]
   return USER_Return_uSD_Status();
 8005196:	f006 fa45 	bl	800b624 <USER_Return_uSD_Status>
 800519a:	4603      	mov	r3, r0
}
 800519c:	4618      	mov	r0, r3
 800519e:	3708      	adds	r7, #8
 80051a0:	46bd      	mov	sp, r7
 80051a2:	bd80      	pop	{r7, pc}

080051a4 <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
 80051a4:	b580      	push	{r7, lr}
 80051a6:	b084      	sub	sp, #16
 80051a8:	af00      	add	r7, sp, #0
 80051aa:	4603      	mov	r3, r0
 80051ac:	71fb      	strb	r3, [r7, #7]
	int code = SDCARD_Init();
 80051ae:	f003 fcb9 	bl	8008b24 <SDCARD_Init>
 80051b2:	60f8      	str	r0, [r7, #12]
    if(code < 0) {
 80051b4:	68fb      	ldr	r3, [r7, #12]
 80051b6:	2b00      	cmp	r3, #0
 80051b8:	da01      	bge.n	80051be <disk_initialize+0x1a>
        return STA_NOINIT;
 80051ba:	2301      	movs	r3, #1
 80051bc:	e000      	b.n	80051c0 <disk_initialize+0x1c>
    }
   return 0;
 80051be:	2300      	movs	r3, #0
}
 80051c0:	4618      	mov	r0, r3
 80051c2:	3710      	adds	r7, #16
 80051c4:	46bd      	mov	sp, r7
 80051c6:	bd80      	pop	{r7, pc}

080051c8 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	LBA_t sector,	/* Start sector in LBA */
	UINT count		/* Number of sectors to read */
)
{
 80051c8:	b580      	push	{r7, lr}
 80051ca:	b084      	sub	sp, #16
 80051cc:	af00      	add	r7, sp, #0
 80051ce:	60b9      	str	r1, [r7, #8]
 80051d0:	607a      	str	r2, [r7, #4]
 80051d2:	603b      	str	r3, [r7, #0]
 80051d4:	4603      	mov	r3, r0
 80051d6:	73fb      	strb	r3, [r7, #15]
	if(SDCARD_ReadBegin(sector) < 0) {
 80051d8:	6878      	ldr	r0, [r7, #4]
 80051da:	f003 fdbf 	bl	8008d5c <SDCARD_ReadBegin>
 80051de:	4603      	mov	r3, r0
 80051e0:	2b00      	cmp	r3, #0
 80051e2:	da10      	bge.n	8005206 <disk_read+0x3e>
        return RES_ERROR;
 80051e4:	2301      	movs	r3, #1
 80051e6:	e019      	b.n	800521c <disk_read+0x54>
    }

    while(count > 0) {
        if(SDCARD_ReadData(buff) < 0) {
 80051e8:	68b8      	ldr	r0, [r7, #8]
 80051ea:	f003 fdf9 	bl	8008de0 <SDCARD_ReadData>
 80051ee:	4603      	mov	r3, r0
 80051f0:	2b00      	cmp	r3, #0
 80051f2:	da01      	bge.n	80051f8 <disk_read+0x30>
            return RES_ERROR;
 80051f4:	2301      	movs	r3, #1
 80051f6:	e011      	b.n	800521c <disk_read+0x54>
        }
        buff += 512;
 80051f8:	68bb      	ldr	r3, [r7, #8]
 80051fa:	f503 7300 	add.w	r3, r3, #512	; 0x200
 80051fe:	60bb      	str	r3, [r7, #8]
        count--;
 8005200:	683b      	ldr	r3, [r7, #0]
 8005202:	3b01      	subs	r3, #1
 8005204:	603b      	str	r3, [r7, #0]
    while(count > 0) {
 8005206:	683b      	ldr	r3, [r7, #0]
 8005208:	2b00      	cmp	r3, #0
 800520a:	d1ed      	bne.n	80051e8 <disk_read+0x20>
    }

    if(SDCARD_ReadEnd() < 0) {
 800520c:	f003 fe24 	bl	8008e58 <SDCARD_ReadEnd>
 8005210:	4603      	mov	r3, r0
 8005212:	2b00      	cmp	r3, #0
 8005214:	da01      	bge.n	800521a <disk_read+0x52>
        return RES_ERROR;
 8005216:	2301      	movs	r3, #1
 8005218:	e000      	b.n	800521c <disk_read+0x54>
    }

    return RES_OK;
 800521a:	2300      	movs	r3, #0
}
 800521c:	4618      	mov	r0, r3
 800521e:	3710      	adds	r7, #16
 8005220:	46bd      	mov	sp, r7
 8005222:	bd80      	pop	{r7, pc}

08005224 <disk_write>:
	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	LBA_t sector,		/* Start sector in LBA */
	UINT count			/* Number of sectors to write */
)
{
 8005224:	b580      	push	{r7, lr}
 8005226:	b084      	sub	sp, #16
 8005228:	af00      	add	r7, sp, #0
 800522a:	60b9      	str	r1, [r7, #8]
 800522c:	607a      	str	r2, [r7, #4]
 800522e:	603b      	str	r3, [r7, #0]
 8005230:	4603      	mov	r3, r0
 8005232:	73fb      	strb	r3, [r7, #15]
	if(SDCARD_WriteBegin(sector) < 0) {
 8005234:	6878      	ldr	r0, [r7, #4]
 8005236:	f003 fe49 	bl	8008ecc <SDCARD_WriteBegin>
 800523a:	4603      	mov	r3, r0
 800523c:	2b00      	cmp	r3, #0
 800523e:	da10      	bge.n	8005262 <disk_write+0x3e>
        return RES_ERROR;
 8005240:	2301      	movs	r3, #1
 8005242:	e019      	b.n	8005278 <disk_write+0x54>
    }

    while(count > 0) {
        if(SDCARD_WriteData(buff) < 0) {
 8005244:	68b8      	ldr	r0, [r7, #8]
 8005246:	f003 fe83 	bl	8008f50 <SDCARD_WriteData>
 800524a:	4603      	mov	r3, r0
 800524c:	2b00      	cmp	r3, #0
 800524e:	da01      	bge.n	8005254 <disk_write+0x30>
            return RES_ERROR;
 8005250:	2301      	movs	r3, #1
 8005252:	e011      	b.n	8005278 <disk_write+0x54>
        }

        buff += 512;
 8005254:	68bb      	ldr	r3, [r7, #8]
 8005256:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800525a:	60bb      	str	r3, [r7, #8]
        count--;
 800525c:	683b      	ldr	r3, [r7, #0]
 800525e:	3b01      	subs	r3, #1
 8005260:	603b      	str	r3, [r7, #0]
    while(count > 0) {
 8005262:	683b      	ldr	r3, [r7, #0]
 8005264:	2b00      	cmp	r3, #0
 8005266:	d1ed      	bne.n	8005244 <disk_write+0x20>
    }

    if(SDCARD_WriteEnd() < 0) {
 8005268:	f003 feb7 	bl	8008fda <SDCARD_WriteEnd>
 800526c:	4603      	mov	r3, r0
 800526e:	2b00      	cmp	r3, #0
 8005270:	da01      	bge.n	8005276 <disk_write+0x52>
        return RES_ERROR;
 8005272:	2301      	movs	r3, #1
 8005274:	e000      	b.n	8005278 <disk_write+0x54>
    }

    return RES_OK;
 8005276:	2300      	movs	r3, #0
}
 8005278:	4618      	mov	r0, r3
 800527a:	3710      	adds	r7, #16
 800527c:	46bd      	mov	sp, r7
 800527e:	bd80      	pop	{r7, pc}

08005280 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
 8005280:	b480      	push	{r7}
 8005282:	b083      	sub	sp, #12
 8005284:	af00      	add	r7, sp, #0
 8005286:	4603      	mov	r3, r0
 8005288:	603a      	str	r2, [r7, #0]
 800528a:	71fb      	strb	r3, [r7, #7]
 800528c:	460b      	mov	r3, r1
 800528e:	71bb      	strb	r3, [r7, #6]
	if(cmd == CTRL_SYNC) {
 8005290:	79bb      	ldrb	r3, [r7, #6]
 8005292:	2b00      	cmp	r3, #0
 8005294:	d101      	bne.n	800529a <disk_ioctl+0x1a>
		return RES_OK;
 8005296:	2300      	movs	r3, #0
 8005298:	e000      	b.n	800529c <disk_ioctl+0x1c>
	} else {
		// should never be called
		return RES_ERROR;
 800529a:	2301      	movs	r3, #1
	}
}
 800529c:	4618      	mov	r0, r3
 800529e:	370c      	adds	r7, #12
 80052a0:	46bd      	mov	sp, r7
 80052a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80052a6:	4770      	bx	lr

080052a8 <ld_word>:
/*-----------------------------------------------------------------------*/
/* Load/Store multi-byte word in the FAT structure                       */
/*-----------------------------------------------------------------------*/

static WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
{
 80052a8:	b480      	push	{r7}
 80052aa:	b085      	sub	sp, #20
 80052ac:	af00      	add	r7, sp, #0
 80052ae:	6078      	str	r0, [r7, #4]
	WORD rv;

	rv = ptr[1];
 80052b0:	687b      	ldr	r3, [r7, #4]
 80052b2:	3301      	adds	r3, #1
 80052b4:	781b      	ldrb	r3, [r3, #0]
 80052b6:	81fb      	strh	r3, [r7, #14]
	rv = rv << 8 | ptr[0];
 80052b8:	89fb      	ldrh	r3, [r7, #14]
 80052ba:	021b      	lsls	r3, r3, #8
 80052bc:	b21a      	sxth	r2, r3
 80052be:	687b      	ldr	r3, [r7, #4]
 80052c0:	781b      	ldrb	r3, [r3, #0]
 80052c2:	b21b      	sxth	r3, r3
 80052c4:	4313      	orrs	r3, r2
 80052c6:	b21b      	sxth	r3, r3
 80052c8:	81fb      	strh	r3, [r7, #14]
	return rv;
 80052ca:	89fb      	ldrh	r3, [r7, #14]
}
 80052cc:	4618      	mov	r0, r3
 80052ce:	3714      	adds	r7, #20
 80052d0:	46bd      	mov	sp, r7
 80052d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80052d6:	4770      	bx	lr

080052d8 <ld_dword>:

static DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
{
 80052d8:	b480      	push	{r7}
 80052da:	b085      	sub	sp, #20
 80052dc:	af00      	add	r7, sp, #0
 80052de:	6078      	str	r0, [r7, #4]
	DWORD rv;

	rv = ptr[3];
 80052e0:	687b      	ldr	r3, [r7, #4]
 80052e2:	3303      	adds	r3, #3
 80052e4:	781b      	ldrb	r3, [r3, #0]
 80052e6:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[2];
 80052e8:	68fb      	ldr	r3, [r7, #12]
 80052ea:	021b      	lsls	r3, r3, #8
 80052ec:	687a      	ldr	r2, [r7, #4]
 80052ee:	3202      	adds	r2, #2
 80052f0:	7812      	ldrb	r2, [r2, #0]
 80052f2:	4313      	orrs	r3, r2
 80052f4:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[1];
 80052f6:	68fb      	ldr	r3, [r7, #12]
 80052f8:	021b      	lsls	r3, r3, #8
 80052fa:	687a      	ldr	r2, [r7, #4]
 80052fc:	3201      	adds	r2, #1
 80052fe:	7812      	ldrb	r2, [r2, #0]
 8005300:	4313      	orrs	r3, r2
 8005302:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[0];
 8005304:	68fb      	ldr	r3, [r7, #12]
 8005306:	021b      	lsls	r3, r3, #8
 8005308:	687a      	ldr	r2, [r7, #4]
 800530a:	7812      	ldrb	r2, [r2, #0]
 800530c:	4313      	orrs	r3, r2
 800530e:	60fb      	str	r3, [r7, #12]
	return rv;
 8005310:	68fb      	ldr	r3, [r7, #12]
}
 8005312:	4618      	mov	r0, r3
 8005314:	3714      	adds	r7, #20
 8005316:	46bd      	mov	sp, r7
 8005318:	f85d 7b04 	ldr.w	r7, [sp], #4
 800531c:	4770      	bx	lr

0800531e <st_word>:
}
#endif

#if !FF_FS_READONLY
static void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
{
 800531e:	b480      	push	{r7}
 8005320:	b083      	sub	sp, #12
 8005322:	af00      	add	r7, sp, #0
 8005324:	6078      	str	r0, [r7, #4]
 8005326:	460b      	mov	r3, r1
 8005328:	807b      	strh	r3, [r7, #2]
	*ptr++ = (BYTE)val; val >>= 8;
 800532a:	687b      	ldr	r3, [r7, #4]
 800532c:	1c5a      	adds	r2, r3, #1
 800532e:	607a      	str	r2, [r7, #4]
 8005330:	887a      	ldrh	r2, [r7, #2]
 8005332:	b2d2      	uxtb	r2, r2
 8005334:	701a      	strb	r2, [r3, #0]
 8005336:	887b      	ldrh	r3, [r7, #2]
 8005338:	0a1b      	lsrs	r3, r3, #8
 800533a:	807b      	strh	r3, [r7, #2]
	*ptr++ = (BYTE)val;
 800533c:	687b      	ldr	r3, [r7, #4]
 800533e:	1c5a      	adds	r2, r3, #1
 8005340:	607a      	str	r2, [r7, #4]
 8005342:	887a      	ldrh	r2, [r7, #2]
 8005344:	b2d2      	uxtb	r2, r2
 8005346:	701a      	strb	r2, [r3, #0]
}
 8005348:	bf00      	nop
 800534a:	370c      	adds	r7, #12
 800534c:	46bd      	mov	sp, r7
 800534e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005352:	4770      	bx	lr

08005354 <st_dword>:

static void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
{
 8005354:	b480      	push	{r7}
 8005356:	b083      	sub	sp, #12
 8005358:	af00      	add	r7, sp, #0
 800535a:	6078      	str	r0, [r7, #4]
 800535c:	6039      	str	r1, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 800535e:	687b      	ldr	r3, [r7, #4]
 8005360:	1c5a      	adds	r2, r3, #1
 8005362:	607a      	str	r2, [r7, #4]
 8005364:	683a      	ldr	r2, [r7, #0]
 8005366:	b2d2      	uxtb	r2, r2
 8005368:	701a      	strb	r2, [r3, #0]
 800536a:	683b      	ldr	r3, [r7, #0]
 800536c:	0a1b      	lsrs	r3, r3, #8
 800536e:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 8005370:	687b      	ldr	r3, [r7, #4]
 8005372:	1c5a      	adds	r2, r3, #1
 8005374:	607a      	str	r2, [r7, #4]
 8005376:	683a      	ldr	r2, [r7, #0]
 8005378:	b2d2      	uxtb	r2, r2
 800537a:	701a      	strb	r2, [r3, #0]
 800537c:	683b      	ldr	r3, [r7, #0]
 800537e:	0a1b      	lsrs	r3, r3, #8
 8005380:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 8005382:	687b      	ldr	r3, [r7, #4]
 8005384:	1c5a      	adds	r2, r3, #1
 8005386:	607a      	str	r2, [r7, #4]
 8005388:	683a      	ldr	r2, [r7, #0]
 800538a:	b2d2      	uxtb	r2, r2
 800538c:	701a      	strb	r2, [r3, #0]
 800538e:	683b      	ldr	r3, [r7, #0]
 8005390:	0a1b      	lsrs	r3, r3, #8
 8005392:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val;
 8005394:	687b      	ldr	r3, [r7, #4]
 8005396:	1c5a      	adds	r2, r3, #1
 8005398:	607a      	str	r2, [r7, #4]
 800539a:	683a      	ldr	r2, [r7, #0]
 800539c:	b2d2      	uxtb	r2, r2
 800539e:	701a      	strb	r2, [r3, #0]
}
 80053a0:	bf00      	nop
 80053a2:	370c      	adds	r7, #12
 80053a4:	46bd      	mov	sp, r7
 80053a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80053aa:	4770      	bx	lr

080053ac <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static void mem_cpy (void* dst, const void* src, UINT cnt)
{
 80053ac:	b480      	push	{r7}
 80053ae:	b087      	sub	sp, #28
 80053b0:	af00      	add	r7, sp, #0
 80053b2:	60f8      	str	r0, [r7, #12]
 80053b4:	60b9      	str	r1, [r7, #8]
 80053b6:	607a      	str	r2, [r7, #4]
	BYTE *d = (BYTE*)dst;
 80053b8:	68fb      	ldr	r3, [r7, #12]
 80053ba:	617b      	str	r3, [r7, #20]
	const BYTE *s = (const BYTE*)src;
 80053bc:	68bb      	ldr	r3, [r7, #8]
 80053be:	613b      	str	r3, [r7, #16]

	if (cnt != 0) {
 80053c0:	687b      	ldr	r3, [r7, #4]
 80053c2:	2b00      	cmp	r3, #0
 80053c4:	d00d      	beq.n	80053e2 <mem_cpy+0x36>
		do {
			*d++ = *s++;
 80053c6:	693a      	ldr	r2, [r7, #16]
 80053c8:	1c53      	adds	r3, r2, #1
 80053ca:	613b      	str	r3, [r7, #16]
 80053cc:	697b      	ldr	r3, [r7, #20]
 80053ce:	1c59      	adds	r1, r3, #1
 80053d0:	6179      	str	r1, [r7, #20]
 80053d2:	7812      	ldrb	r2, [r2, #0]
 80053d4:	701a      	strb	r2, [r3, #0]
		} while (--cnt);
 80053d6:	687b      	ldr	r3, [r7, #4]
 80053d8:	3b01      	subs	r3, #1
 80053da:	607b      	str	r3, [r7, #4]
 80053dc:	687b      	ldr	r3, [r7, #4]
 80053de:	2b00      	cmp	r3, #0
 80053e0:	d1f1      	bne.n	80053c6 <mem_cpy+0x1a>
	}
}
 80053e2:	bf00      	nop
 80053e4:	371c      	adds	r7, #28
 80053e6:	46bd      	mov	sp, r7
 80053e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80053ec:	4770      	bx	lr

080053ee <mem_set>:


/* Fill memory block */
static void mem_set (void* dst, int val, UINT cnt)
{
 80053ee:	b480      	push	{r7}
 80053f0:	b087      	sub	sp, #28
 80053f2:	af00      	add	r7, sp, #0
 80053f4:	60f8      	str	r0, [r7, #12]
 80053f6:	60b9      	str	r1, [r7, #8]
 80053f8:	607a      	str	r2, [r7, #4]
	BYTE *d = (BYTE*)dst;
 80053fa:	68fb      	ldr	r3, [r7, #12]
 80053fc:	617b      	str	r3, [r7, #20]

	do {
		*d++ = (BYTE)val;
 80053fe:	697b      	ldr	r3, [r7, #20]
 8005400:	1c5a      	adds	r2, r3, #1
 8005402:	617a      	str	r2, [r7, #20]
 8005404:	68ba      	ldr	r2, [r7, #8]
 8005406:	b2d2      	uxtb	r2, r2
 8005408:	701a      	strb	r2, [r3, #0]
	} while (--cnt);
 800540a:	687b      	ldr	r3, [r7, #4]
 800540c:	3b01      	subs	r3, #1
 800540e:	607b      	str	r3, [r7, #4]
 8005410:	687b      	ldr	r3, [r7, #4]
 8005412:	2b00      	cmp	r3, #0
 8005414:	d1f3      	bne.n	80053fe <mem_set+0x10>
}
 8005416:	bf00      	nop
 8005418:	bf00      	nop
 800541a:	371c      	adds	r7, #28
 800541c:	46bd      	mov	sp, r7
 800541e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005422:	4770      	bx	lr

08005424 <mem_cmp>:


/* Compare memory block */
static int mem_cmp (const void* dst, const void* src, UINT cnt)	/* ZR:same, NZ:different */
{
 8005424:	b480      	push	{r7}
 8005426:	b089      	sub	sp, #36	; 0x24
 8005428:	af00      	add	r7, sp, #0
 800542a:	60f8      	str	r0, [r7, #12]
 800542c:	60b9      	str	r1, [r7, #8]
 800542e:	607a      	str	r2, [r7, #4]
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
 8005430:	68fb      	ldr	r3, [r7, #12]
 8005432:	61fb      	str	r3, [r7, #28]
 8005434:	68bb      	ldr	r3, [r7, #8]
 8005436:	61bb      	str	r3, [r7, #24]
	int r = 0;
 8005438:	2300      	movs	r3, #0
 800543a:	617b      	str	r3, [r7, #20]

	do {
		r = *d++ - *s++;
 800543c:	69fb      	ldr	r3, [r7, #28]
 800543e:	1c5a      	adds	r2, r3, #1
 8005440:	61fa      	str	r2, [r7, #28]
 8005442:	781b      	ldrb	r3, [r3, #0]
 8005444:	4619      	mov	r1, r3
 8005446:	69bb      	ldr	r3, [r7, #24]
 8005448:	1c5a      	adds	r2, r3, #1
 800544a:	61ba      	str	r2, [r7, #24]
 800544c:	781b      	ldrb	r3, [r3, #0]
 800544e:	1acb      	subs	r3, r1, r3
 8005450:	617b      	str	r3, [r7, #20]
	} while (--cnt && r == 0);
 8005452:	687b      	ldr	r3, [r7, #4]
 8005454:	3b01      	subs	r3, #1
 8005456:	607b      	str	r3, [r7, #4]
 8005458:	687b      	ldr	r3, [r7, #4]
 800545a:	2b00      	cmp	r3, #0
 800545c:	d002      	beq.n	8005464 <mem_cmp+0x40>
 800545e:	697b      	ldr	r3, [r7, #20]
 8005460:	2b00      	cmp	r3, #0
 8005462:	d0eb      	beq.n	800543c <mem_cmp+0x18>

	return r;
 8005464:	697b      	ldr	r3, [r7, #20]
}
 8005466:	4618      	mov	r0, r3
 8005468:	3724      	adds	r7, #36	; 0x24
 800546a:	46bd      	mov	sp, r7
 800546c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005470:	4770      	bx	lr

08005472 <chk_chr>:


/* Check if chr is contained in the string */
static int chk_chr (const char* str, int chr)	/* NZ:contained, ZR:not contained */
{
 8005472:	b480      	push	{r7}
 8005474:	b083      	sub	sp, #12
 8005476:	af00      	add	r7, sp, #0
 8005478:	6078      	str	r0, [r7, #4]
 800547a:	6039      	str	r1, [r7, #0]
	while (*str && *str != chr) str++;
 800547c:	e002      	b.n	8005484 <chk_chr+0x12>
 800547e:	687b      	ldr	r3, [r7, #4]
 8005480:	3301      	adds	r3, #1
 8005482:	607b      	str	r3, [r7, #4]
 8005484:	687b      	ldr	r3, [r7, #4]
 8005486:	781b      	ldrb	r3, [r3, #0]
 8005488:	2b00      	cmp	r3, #0
 800548a:	d005      	beq.n	8005498 <chk_chr+0x26>
 800548c:	687b      	ldr	r3, [r7, #4]
 800548e:	781b      	ldrb	r3, [r3, #0]
 8005490:	461a      	mov	r2, r3
 8005492:	683b      	ldr	r3, [r7, #0]
 8005494:	4293      	cmp	r3, r2
 8005496:	d1f2      	bne.n	800547e <chk_chr+0xc>
	return *str;
 8005498:	687b      	ldr	r3, [r7, #4]
 800549a:	781b      	ldrb	r3, [r3, #0]
}
 800549c:	4618      	mov	r0, r3
 800549e:	370c      	adds	r7, #12
 80054a0:	46bd      	mov	sp, r7
 80054a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80054a6:	4770      	bx	lr

080054a8 <dbc_1st>:


/* Test if the byte is DBC 1st byte */
static int dbc_1st (BYTE c)
{
 80054a8:	b480      	push	{r7}
 80054aa:	b083      	sub	sp, #12
 80054ac:	af00      	add	r7, sp, #0
 80054ae:	4603      	mov	r3, r0
 80054b0:	71fb      	strb	r3, [r7, #7]
	if (c >= DbcTbl[0]) {
		if (c <= DbcTbl[1]) return 1;
		if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;
	}
#else						/* SBCS fixed code page */
	if (c != 0) return 0;	/* Always false */
 80054b2:	79fb      	ldrb	r3, [r7, #7]
 80054b4:	2b00      	cmp	r3, #0
 80054b6:	d001      	beq.n	80054bc <dbc_1st+0x14>
 80054b8:	2300      	movs	r3, #0
 80054ba:	e000      	b.n	80054be <dbc_1st+0x16>
#endif
	return 0;
 80054bc:	2300      	movs	r3, #0
}
 80054be:	4618      	mov	r0, r3
 80054c0:	370c      	adds	r7, #12
 80054c2:	46bd      	mov	sp, r7
 80054c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80054c8:	4770      	bx	lr

080054ca <dbc_2nd>:


/* Test if the byte is DBC 2nd byte */
static int dbc_2nd (BYTE c)
{
 80054ca:	b480      	push	{r7}
 80054cc:	b083      	sub	sp, #12
 80054ce:	af00      	add	r7, sp, #0
 80054d0:	4603      	mov	r3, r0
 80054d2:	71fb      	strb	r3, [r7, #7]
		if (c <= DbcTbl[5]) return 1;
		if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;
		if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;
	}
#else						/* SBCS fixed code page */
	if (c != 0) return 0;	/* Always false */
 80054d4:	79fb      	ldrb	r3, [r7, #7]
 80054d6:	2b00      	cmp	r3, #0
 80054d8:	d001      	beq.n	80054de <dbc_2nd+0x14>
 80054da:	2300      	movs	r3, #0
 80054dc:	e000      	b.n	80054e0 <dbc_2nd+0x16>
#endif
	return 0;
 80054de:	2300      	movs	r3, #0
}
 80054e0:	4618      	mov	r0, r3
 80054e2:	370c      	adds	r7, #12
 80054e4:	46bd      	mov	sp, r7
 80054e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80054ea:	4770      	bx	lr

080054ec <tchar2uni>:

/* Get a Unicode code point from the TCHAR string in defined API encodeing */
static DWORD tchar2uni (	/* Returns a character in UTF-16 encoding (>=0x10000 on surrogate pair, 0xFFFFFFFF on decode error) */
	const TCHAR** str		/* Pointer to pointer to TCHAR string in configured encoding */
)
{
 80054ec:	b580      	push	{r7, lr}
 80054ee:	b086      	sub	sp, #24
 80054f0:	af00      	add	r7, sp, #0
 80054f2:	6078      	str	r0, [r7, #4]
	DWORD uc;
	const TCHAR *p = *str;
 80054f4:	687b      	ldr	r3, [r7, #4]
 80054f6:	681b      	ldr	r3, [r3, #0]
 80054f8:	617b      	str	r3, [r7, #20]

#else		/* ANSI/OEM input */
	BYTE b;
	WCHAR wc;

	wc = (BYTE)*p++;			/* Get a byte */
 80054fa:	697b      	ldr	r3, [r7, #20]
 80054fc:	1c5a      	adds	r2, r3, #1
 80054fe:	617a      	str	r2, [r7, #20]
 8005500:	781b      	ldrb	r3, [r3, #0]
 8005502:	827b      	strh	r3, [r7, #18]
	if (dbc_1st((BYTE)wc)) {	/* Is it a DBC 1st byte? */
 8005504:	8a7b      	ldrh	r3, [r7, #18]
 8005506:	b2db      	uxtb	r3, r3
 8005508:	4618      	mov	r0, r3
 800550a:	f7ff ffcd 	bl	80054a8 <dbc_1st>
 800550e:	4603      	mov	r3, r0
 8005510:	2b00      	cmp	r3, #0
 8005512:	d015      	beq.n	8005540 <tchar2uni+0x54>
		b = (BYTE)*p++;			/* Get 2nd byte */
 8005514:	697b      	ldr	r3, [r7, #20]
 8005516:	1c5a      	adds	r2, r3, #1
 8005518:	617a      	str	r2, [r7, #20]
 800551a:	781b      	ldrb	r3, [r3, #0]
 800551c:	747b      	strb	r3, [r7, #17]
		if (!dbc_2nd(b)) return 0xFFFFFFFF;	/* Invalid code? */
 800551e:	7c7b      	ldrb	r3, [r7, #17]
 8005520:	4618      	mov	r0, r3
 8005522:	f7ff ffd2 	bl	80054ca <dbc_2nd>
 8005526:	4603      	mov	r3, r0
 8005528:	2b00      	cmp	r3, #0
 800552a:	d102      	bne.n	8005532 <tchar2uni+0x46>
 800552c:	f04f 33ff 	mov.w	r3, #4294967295
 8005530:	e01d      	b.n	800556e <tchar2uni+0x82>
		wc = (wc << 8) + b;		/* Make a DBC */
 8005532:	8a7b      	ldrh	r3, [r7, #18]
 8005534:	021b      	lsls	r3, r3, #8
 8005536:	b29a      	uxth	r2, r3
 8005538:	7c7b      	ldrb	r3, [r7, #17]
 800553a:	b29b      	uxth	r3, r3
 800553c:	4413      	add	r3, r2
 800553e:	827b      	strh	r3, [r7, #18]
	}
	if (wc != 0) {
 8005540:	8a7b      	ldrh	r3, [r7, #18]
 8005542:	2b00      	cmp	r3, #0
 8005544:	d00d      	beq.n	8005562 <tchar2uni+0x76>
		wc = ff_oem2uni(wc, CODEPAGE);	/* ANSI/OEM ==> Unicode */
 8005546:	8a7b      	ldrh	r3, [r7, #18]
 8005548:	f240 11b5 	movw	r1, #437	; 0x1b5
 800554c:	4618      	mov	r0, r3
 800554e:	f003 f981 	bl	8008854 <ff_oem2uni>
 8005552:	4603      	mov	r3, r0
 8005554:	827b      	strh	r3, [r7, #18]
		if (wc == 0) return 0xFFFFFFFF;	/* Invalid code? */
 8005556:	8a7b      	ldrh	r3, [r7, #18]
 8005558:	2b00      	cmp	r3, #0
 800555a:	d102      	bne.n	8005562 <tchar2uni+0x76>
 800555c:	f04f 33ff 	mov.w	r3, #4294967295
 8005560:	e005      	b.n	800556e <tchar2uni+0x82>
	}
	uc = wc;
 8005562:	8a7b      	ldrh	r3, [r7, #18]
 8005564:	60fb      	str	r3, [r7, #12]

#endif
	*str = p;	/* Next read pointer */
 8005566:	687b      	ldr	r3, [r7, #4]
 8005568:	697a      	ldr	r2, [r7, #20]
 800556a:	601a      	str	r2, [r3, #0]
	return uc;
 800556c:	68fb      	ldr	r3, [r7, #12]
}
 800556e:	4618      	mov	r0, r3
 8005570:	3718      	adds	r7, #24
 8005572:	46bd      	mov	sp, r7
 8005574:	bd80      	pop	{r7, pc}

08005576 <put_utf>:
static BYTE put_utf (	/* Returns number of encoding units written (0:buffer overflow or wrong encoding) */
	DWORD chr,	/* UTF-16 encoded character (Surrogate pair if >=0x10000) */
	TCHAR* buf,	/* Output buffer */
	UINT szb	/* Size of the buffer */
)
{
 8005576:	b580      	push	{r7, lr}
 8005578:	b086      	sub	sp, #24
 800557a:	af00      	add	r7, sp, #0
 800557c:	60f8      	str	r0, [r7, #12]
 800557e:	60b9      	str	r1, [r7, #8]
 8005580:	607a      	str	r2, [r7, #4]
	return 1;

#else						/* ANSI/OEM output */
	WCHAR wc;

	wc = ff_uni2oem(chr, CODEPAGE);
 8005582:	f240 11b5 	movw	r1, #437	; 0x1b5
 8005586:	68f8      	ldr	r0, [r7, #12]
 8005588:	f003 f92a 	bl	80087e0 <ff_uni2oem>
 800558c:	4603      	mov	r3, r0
 800558e:	82fb      	strh	r3, [r7, #22]
	if (wc >= 0x100) {	/* Is this a DBC? */
 8005590:	8afb      	ldrh	r3, [r7, #22]
 8005592:	2bff      	cmp	r3, #255	; 0xff
 8005594:	d914      	bls.n	80055c0 <put_utf+0x4a>
		if (szb < 2) return 0;
 8005596:	687b      	ldr	r3, [r7, #4]
 8005598:	2b01      	cmp	r3, #1
 800559a:	d801      	bhi.n	80055a0 <put_utf+0x2a>
 800559c:	2300      	movs	r3, #0
 800559e:	e01e      	b.n	80055de <put_utf+0x68>
		*buf++ = (char)(wc >> 8);	/* Store DBC 1st byte */
 80055a0:	8afb      	ldrh	r3, [r7, #22]
 80055a2:	0a1b      	lsrs	r3, r3, #8
 80055a4:	b299      	uxth	r1, r3
 80055a6:	68bb      	ldr	r3, [r7, #8]
 80055a8:	1c5a      	adds	r2, r3, #1
 80055aa:	60ba      	str	r2, [r7, #8]
 80055ac:	b2ca      	uxtb	r2, r1
 80055ae:	701a      	strb	r2, [r3, #0]
		*buf++ = (TCHAR)wc;			/* Store DBC 2nd byte */
 80055b0:	68bb      	ldr	r3, [r7, #8]
 80055b2:	1c5a      	adds	r2, r3, #1
 80055b4:	60ba      	str	r2, [r7, #8]
 80055b6:	8afa      	ldrh	r2, [r7, #22]
 80055b8:	b2d2      	uxtb	r2, r2
 80055ba:	701a      	strb	r2, [r3, #0]
		return 2;
 80055bc:	2302      	movs	r3, #2
 80055be:	e00e      	b.n	80055de <put_utf+0x68>
	}
	if (wc == 0 || szb < 1) return 0;	/* Invalid char or buffer overflow? */
 80055c0:	8afb      	ldrh	r3, [r7, #22]
 80055c2:	2b00      	cmp	r3, #0
 80055c4:	d002      	beq.n	80055cc <put_utf+0x56>
 80055c6:	687b      	ldr	r3, [r7, #4]
 80055c8:	2b00      	cmp	r3, #0
 80055ca:	d101      	bne.n	80055d0 <put_utf+0x5a>
 80055cc:	2300      	movs	r3, #0
 80055ce:	e006      	b.n	80055de <put_utf+0x68>
	*buf++ = (TCHAR)wc;					/* Store the character */
 80055d0:	68bb      	ldr	r3, [r7, #8]
 80055d2:	1c5a      	adds	r2, r3, #1
 80055d4:	60ba      	str	r2, [r7, #8]
 80055d6:	8afa      	ldrh	r2, [r7, #22]
 80055d8:	b2d2      	uxtb	r2, r2
 80055da:	701a      	strb	r2, [r3, #0]
	return 1;
 80055dc:	2301      	movs	r3, #1
#endif
}
 80055de:	4618      	mov	r0, r3
 80055e0:	3718      	adds	r7, #24
 80055e2:	46bd      	mov	sp, r7
 80055e4:	bd80      	pop	{r7, pc}

080055e6 <sync_window>:
/*-----------------------------------------------------------------------*/
#if !FF_FS_READONLY
static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
	FATFS* fs			/* Filesystem object */
)
{
 80055e6:	b580      	push	{r7, lr}
 80055e8:	b084      	sub	sp, #16
 80055ea:	af00      	add	r7, sp, #0
 80055ec:	6078      	str	r0, [r7, #4]
	FRESULT res = FR_OK;
 80055ee:	2300      	movs	r3, #0
 80055f0:	73fb      	strb	r3, [r7, #15]


	if (fs->wflag) {	/* Is the disk access window dirty? */
 80055f2:	687b      	ldr	r3, [r7, #4]
 80055f4:	78db      	ldrb	r3, [r3, #3]
 80055f6:	2b00      	cmp	r3, #0
 80055f8:	d02c      	beq.n	8005654 <sync_window+0x6e>
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write it back into the volume */
 80055fa:	687b      	ldr	r3, [r7, #4]
 80055fc:	7858      	ldrb	r0, [r3, #1]
 80055fe:	687b      	ldr	r3, [r7, #4]
 8005600:	f103 0134 	add.w	r1, r3, #52	; 0x34
 8005604:	687b      	ldr	r3, [r7, #4]
 8005606:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005608:	2301      	movs	r3, #1
 800560a:	f7ff fe0b 	bl	8005224 <disk_write>
 800560e:	4603      	mov	r3, r0
 8005610:	2b00      	cmp	r3, #0
 8005612:	d11d      	bne.n	8005650 <sync_window+0x6a>
			fs->wflag = 0;	/* Clear window dirty flag */
 8005614:	687b      	ldr	r3, [r7, #4]
 8005616:	2200      	movs	r2, #0
 8005618:	70da      	strb	r2, [r3, #3]
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
 800561a:	687b      	ldr	r3, [r7, #4]
 800561c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800561e:	687b      	ldr	r3, [r7, #4]
 8005620:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005622:	1ad2      	subs	r2, r2, r3
 8005624:	687b      	ldr	r3, [r7, #4]
 8005626:	69db      	ldr	r3, [r3, #28]
 8005628:	429a      	cmp	r2, r3
 800562a:	d213      	bcs.n	8005654 <sync_window+0x6e>
				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
 800562c:	687b      	ldr	r3, [r7, #4]
 800562e:	789b      	ldrb	r3, [r3, #2]
 8005630:	2b02      	cmp	r3, #2
 8005632:	d10f      	bne.n	8005654 <sync_window+0x6e>
 8005634:	687b      	ldr	r3, [r7, #4]
 8005636:	7858      	ldrb	r0, [r3, #1]
 8005638:	687b      	ldr	r3, [r7, #4]
 800563a:	f103 0134 	add.w	r1, r3, #52	; 0x34
 800563e:	687b      	ldr	r3, [r7, #4]
 8005640:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8005642:	687b      	ldr	r3, [r7, #4]
 8005644:	69db      	ldr	r3, [r3, #28]
 8005646:	441a      	add	r2, r3
 8005648:	2301      	movs	r3, #1
 800564a:	f7ff fdeb 	bl	8005224 <disk_write>
 800564e:	e001      	b.n	8005654 <sync_window+0x6e>
			}
		} else {
			res = FR_DISK_ERR;
 8005650:	2301      	movs	r3, #1
 8005652:	73fb      	strb	r3, [r7, #15]
		}
	}
	return res;
 8005654:	7bfb      	ldrb	r3, [r7, #15]
}
 8005656:	4618      	mov	r0, r3
 8005658:	3710      	adds	r7, #16
 800565a:	46bd      	mov	sp, r7
 800565c:	bd80      	pop	{r7, pc}

0800565e <move_window>:

static FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
	FATFS* fs,		/* Filesystem object */
	LBA_t sect		/* Sector LBA to make appearance in the fs->win[] */
)
{
 800565e:	b580      	push	{r7, lr}
 8005660:	b084      	sub	sp, #16
 8005662:	af00      	add	r7, sp, #0
 8005664:	6078      	str	r0, [r7, #4]
 8005666:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_OK;
 8005668:	2300      	movs	r3, #0
 800566a:	73fb      	strb	r3, [r7, #15]


	if (sect != fs->winsect) {	/* Window offset changed? */
 800566c:	687b      	ldr	r3, [r7, #4]
 800566e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005670:	683a      	ldr	r2, [r7, #0]
 8005672:	429a      	cmp	r2, r3
 8005674:	d01b      	beq.n	80056ae <move_window+0x50>
#if !FF_FS_READONLY
		res = sync_window(fs);		/* Flush the window */
 8005676:	6878      	ldr	r0, [r7, #4]
 8005678:	f7ff ffb5 	bl	80055e6 <sync_window>
 800567c:	4603      	mov	r3, r0
 800567e:	73fb      	strb	r3, [r7, #15]
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
 8005680:	7bfb      	ldrb	r3, [r7, #15]
 8005682:	2b00      	cmp	r3, #0
 8005684:	d113      	bne.n	80056ae <move_window+0x50>
			if (disk_read(fs->pdrv, fs->win, sect, 1) != RES_OK) {
 8005686:	687b      	ldr	r3, [r7, #4]
 8005688:	7858      	ldrb	r0, [r3, #1]
 800568a:	687b      	ldr	r3, [r7, #4]
 800568c:	f103 0134 	add.w	r1, r3, #52	; 0x34
 8005690:	2301      	movs	r3, #1
 8005692:	683a      	ldr	r2, [r7, #0]
 8005694:	f7ff fd98 	bl	80051c8 <disk_read>
 8005698:	4603      	mov	r3, r0
 800569a:	2b00      	cmp	r3, #0
 800569c:	d004      	beq.n	80056a8 <move_window+0x4a>
				sect = (LBA_t)0 - 1;	/* Invalidate window if read data is not valid */
 800569e:	f04f 33ff 	mov.w	r3, #4294967295
 80056a2:	603b      	str	r3, [r7, #0]
				res = FR_DISK_ERR;
 80056a4:	2301      	movs	r3, #1
 80056a6:	73fb      	strb	r3, [r7, #15]
			}
			fs->winsect = sect;
 80056a8:	687b      	ldr	r3, [r7, #4]
 80056aa:	683a      	ldr	r2, [r7, #0]
 80056ac:	631a      	str	r2, [r3, #48]	; 0x30
		}
	}
	return res;
 80056ae:	7bfb      	ldrb	r3, [r7, #15]
}
 80056b0:	4618      	mov	r0, r3
 80056b2:	3710      	adds	r7, #16
 80056b4:	46bd      	mov	sp, r7
 80056b6:	bd80      	pop	{r7, pc}

080056b8 <sync_fs>:
/*-----------------------------------------------------------------------*/

static FRESULT sync_fs (	/* Returns FR_OK or FR_DISK_ERR */
	FATFS* fs		/* Filesystem object */
)
{
 80056b8:	b580      	push	{r7, lr}
 80056ba:	b084      	sub	sp, #16
 80056bc:	af00      	add	r7, sp, #0
 80056be:	6078      	str	r0, [r7, #4]
	FRESULT res;


	res = sync_window(fs);
 80056c0:	6878      	ldr	r0, [r7, #4]
 80056c2:	f7ff ff90 	bl	80055e6 <sync_window>
 80056c6:	4603      	mov	r3, r0
 80056c8:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 80056ca:	7bfb      	ldrb	r3, [r7, #15]
 80056cc:	2b00      	cmp	r3, #0
 80056ce:	d158      	bne.n	8005782 <sync_fs+0xca>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
 80056d0:	687b      	ldr	r3, [r7, #4]
 80056d2:	781b      	ldrb	r3, [r3, #0]
 80056d4:	2b03      	cmp	r3, #3
 80056d6:	d148      	bne.n	800576a <sync_fs+0xb2>
 80056d8:	687b      	ldr	r3, [r7, #4]
 80056da:	791b      	ldrb	r3, [r3, #4]
 80056dc:	2b01      	cmp	r3, #1
 80056de:	d144      	bne.n	800576a <sync_fs+0xb2>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, sizeof fs->win);
 80056e0:	687b      	ldr	r3, [r7, #4]
 80056e2:	3334      	adds	r3, #52	; 0x34
 80056e4:	f44f 7200 	mov.w	r2, #512	; 0x200
 80056e8:	2100      	movs	r1, #0
 80056ea:	4618      	mov	r0, r3
 80056ec:	f7ff fe7f 	bl	80053ee <mem_set>
			st_word(fs->win + BS_55AA, 0xAA55);					/* Boot signature */
 80056f0:	687b      	ldr	r3, [r7, #4]
 80056f2:	3334      	adds	r3, #52	; 0x34
 80056f4:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
 80056f8:	f64a 2155 	movw	r1, #43605	; 0xaa55
 80056fc:	4618      	mov	r0, r3
 80056fe:	f7ff fe0e 	bl	800531e <st_word>
			st_dword(fs->win + FSI_LeadSig, 0x41615252);		/* Leading signature */
 8005702:	687b      	ldr	r3, [r7, #4]
 8005704:	3334      	adds	r3, #52	; 0x34
 8005706:	4921      	ldr	r1, [pc, #132]	; (800578c <sync_fs+0xd4>)
 8005708:	4618      	mov	r0, r3
 800570a:	f7ff fe23 	bl	8005354 <st_dword>
			st_dword(fs->win + FSI_StrucSig, 0x61417272);		/* Structure signature */
 800570e:	687b      	ldr	r3, [r7, #4]
 8005710:	3334      	adds	r3, #52	; 0x34
 8005712:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 8005716:	491e      	ldr	r1, [pc, #120]	; (8005790 <sync_fs+0xd8>)
 8005718:	4618      	mov	r0, r3
 800571a:	f7ff fe1b 	bl	8005354 <st_dword>
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);	/* Number of free clusters */
 800571e:	687b      	ldr	r3, [r7, #4]
 8005720:	3334      	adds	r3, #52	; 0x34
 8005722:	f503 72f4 	add.w	r2, r3, #488	; 0x1e8
 8005726:	687b      	ldr	r3, [r7, #4]
 8005728:	695b      	ldr	r3, [r3, #20]
 800572a:	4619      	mov	r1, r3
 800572c:	4610      	mov	r0, r2
 800572e:	f7ff fe11 	bl	8005354 <st_dword>
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);	/* Last allocated culuster */
 8005732:	687b      	ldr	r3, [r7, #4]
 8005734:	3334      	adds	r3, #52	; 0x34
 8005736:	f503 72f6 	add.w	r2, r3, #492	; 0x1ec
 800573a:	687b      	ldr	r3, [r7, #4]
 800573c:	691b      	ldr	r3, [r3, #16]
 800573e:	4619      	mov	r1, r3
 8005740:	4610      	mov	r0, r2
 8005742:	f7ff fe07 	bl	8005354 <st_dword>
			fs->winsect = fs->volbase + 1;						/* Write it into the FSInfo sector (Next to VBR) */
 8005746:	687b      	ldr	r3, [r7, #4]
 8005748:	6a1b      	ldr	r3, [r3, #32]
 800574a:	1c5a      	adds	r2, r3, #1
 800574c:	687b      	ldr	r3, [r7, #4]
 800574e:	631a      	str	r2, [r3, #48]	; 0x30
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
 8005750:	687b      	ldr	r3, [r7, #4]
 8005752:	7858      	ldrb	r0, [r3, #1]
 8005754:	687b      	ldr	r3, [r7, #4]
 8005756:	f103 0134 	add.w	r1, r3, #52	; 0x34
 800575a:	687b      	ldr	r3, [r7, #4]
 800575c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800575e:	2301      	movs	r3, #1
 8005760:	f7ff fd60 	bl	8005224 <disk_write>
			fs->fsi_flag = 0;
 8005764:	687b      	ldr	r3, [r7, #4]
 8005766:	2200      	movs	r2, #0
 8005768:	711a      	strb	r2, [r3, #4]
		}
		/* Make sure that no pending write process in the lower layer */
		if (disk_ioctl(fs->pdrv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 800576a:	687b      	ldr	r3, [r7, #4]
 800576c:	785b      	ldrb	r3, [r3, #1]
 800576e:	2200      	movs	r2, #0
 8005770:	2100      	movs	r1, #0
 8005772:	4618      	mov	r0, r3
 8005774:	f7ff fd84 	bl	8005280 <disk_ioctl>
 8005778:	4603      	mov	r3, r0
 800577a:	2b00      	cmp	r3, #0
 800577c:	d001      	beq.n	8005782 <sync_fs+0xca>
 800577e:	2301      	movs	r3, #1
 8005780:	73fb      	strb	r3, [r7, #15]
	}

	return res;
 8005782:	7bfb      	ldrb	r3, [r7, #15]
}
 8005784:	4618      	mov	r0, r3
 8005786:	3710      	adds	r7, #16
 8005788:	46bd      	mov	sp, r7
 800578a:	bd80      	pop	{r7, pc}
 800578c:	41615252 	.word	0x41615252
 8005790:	61417272 	.word	0x61417272

08005794 <clst2sect>:

static LBA_t clst2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* Filesystem object */
	DWORD clst		/* Cluster# to be converted */
)
{
 8005794:	b480      	push	{r7}
 8005796:	b083      	sub	sp, #12
 8005798:	af00      	add	r7, sp, #0
 800579a:	6078      	str	r0, [r7, #4]
 800579c:	6039      	str	r1, [r7, #0]
	clst -= 2;		/* Cluster number is origin from 2 */
 800579e:	683b      	ldr	r3, [r7, #0]
 80057a0:	3b02      	subs	r3, #2
 80057a2:	603b      	str	r3, [r7, #0]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 80057a4:	687b      	ldr	r3, [r7, #4]
 80057a6:	699b      	ldr	r3, [r3, #24]
 80057a8:	3b02      	subs	r3, #2
 80057aa:	683a      	ldr	r2, [r7, #0]
 80057ac:	429a      	cmp	r2, r3
 80057ae:	d301      	bcc.n	80057b4 <clst2sect+0x20>
 80057b0:	2300      	movs	r3, #0
 80057b2:	e008      	b.n	80057c6 <clst2sect+0x32>
	return fs->database + (LBA_t)fs->csize * clst;	/* Start sector number of the cluster */
 80057b4:	687b      	ldr	r3, [r7, #4]
 80057b6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80057b8:	687b      	ldr	r3, [r7, #4]
 80057ba:	895b      	ldrh	r3, [r3, #10]
 80057bc:	4619      	mov	r1, r3
 80057be:	683b      	ldr	r3, [r7, #0]
 80057c0:	fb03 f301 	mul.w	r3, r3, r1
 80057c4:	4413      	add	r3, r2
}
 80057c6:	4618      	mov	r0, r3
 80057c8:	370c      	adds	r7, #12
 80057ca:	46bd      	mov	sp, r7
 80057cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80057d0:	4770      	bx	lr

080057d2 <get_fat>:

static DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
	FFOBJID* obj,	/* Corresponding object */
	DWORD clst		/* Cluster number to get the value */
)
{
 80057d2:	b580      	push	{r7, lr}
 80057d4:	b086      	sub	sp, #24
 80057d6:	af00      	add	r7, sp, #0
 80057d8:	6078      	str	r0, [r7, #4]
 80057da:	6039      	str	r1, [r7, #0]
	UINT wc, bc;
	DWORD val;
	FATFS *fs = obj->fs;
 80057dc:	687b      	ldr	r3, [r7, #4]
 80057de:	681b      	ldr	r3, [r3, #0]
 80057e0:	613b      	str	r3, [r7, #16]


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 80057e2:	683b      	ldr	r3, [r7, #0]
 80057e4:	2b01      	cmp	r3, #1
 80057e6:	d904      	bls.n	80057f2 <get_fat+0x20>
 80057e8:	693b      	ldr	r3, [r7, #16]
 80057ea:	699b      	ldr	r3, [r3, #24]
 80057ec:	683a      	ldr	r2, [r7, #0]
 80057ee:	429a      	cmp	r2, r3
 80057f0:	d302      	bcc.n	80057f8 <get_fat+0x26>
		val = 1;	/* Internal error */
 80057f2:	2301      	movs	r3, #1
 80057f4:	617b      	str	r3, [r7, #20]
 80057f6:	e08f      	b.n	8005918 <get_fat+0x146>

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 80057f8:	f04f 33ff 	mov.w	r3, #4294967295
 80057fc:	617b      	str	r3, [r7, #20]

		switch (fs->fs_type) {
 80057fe:	693b      	ldr	r3, [r7, #16]
 8005800:	781b      	ldrb	r3, [r3, #0]
 8005802:	2b03      	cmp	r3, #3
 8005804:	d062      	beq.n	80058cc <get_fat+0xfa>
 8005806:	2b03      	cmp	r3, #3
 8005808:	dc7c      	bgt.n	8005904 <get_fat+0x132>
 800580a:	2b01      	cmp	r3, #1
 800580c:	d002      	beq.n	8005814 <get_fat+0x42>
 800580e:	2b02      	cmp	r3, #2
 8005810:	d042      	beq.n	8005898 <get_fat+0xc6>
 8005812:	e077      	b.n	8005904 <get_fat+0x132>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
 8005814:	683b      	ldr	r3, [r7, #0]
 8005816:	60fb      	str	r3, [r7, #12]
 8005818:	68fb      	ldr	r3, [r7, #12]
 800581a:	085b      	lsrs	r3, r3, #1
 800581c:	68fa      	ldr	r2, [r7, #12]
 800581e:	4413      	add	r3, r2
 8005820:	60fb      	str	r3, [r7, #12]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8005822:	693b      	ldr	r3, [r7, #16]
 8005824:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005826:	68fb      	ldr	r3, [r7, #12]
 8005828:	0a5b      	lsrs	r3, r3, #9
 800582a:	4413      	add	r3, r2
 800582c:	4619      	mov	r1, r3
 800582e:	6938      	ldr	r0, [r7, #16]
 8005830:	f7ff ff15 	bl	800565e <move_window>
 8005834:	4603      	mov	r3, r0
 8005836:	2b00      	cmp	r3, #0
 8005838:	d167      	bne.n	800590a <get_fat+0x138>
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 800583a:	68fb      	ldr	r3, [r7, #12]
 800583c:	1c5a      	adds	r2, r3, #1
 800583e:	60fa      	str	r2, [r7, #12]
 8005840:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005844:	693a      	ldr	r2, [r7, #16]
 8005846:	4413      	add	r3, r2
 8005848:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800584c:	60bb      	str	r3, [r7, #8]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800584e:	693b      	ldr	r3, [r7, #16]
 8005850:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005852:	68fb      	ldr	r3, [r7, #12]
 8005854:	0a5b      	lsrs	r3, r3, #9
 8005856:	4413      	add	r3, r2
 8005858:	4619      	mov	r1, r3
 800585a:	6938      	ldr	r0, [r7, #16]
 800585c:	f7ff feff 	bl	800565e <move_window>
 8005860:	4603      	mov	r3, r0
 8005862:	2b00      	cmp	r3, #0
 8005864:	d153      	bne.n	800590e <get_fat+0x13c>
			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
 8005866:	68fb      	ldr	r3, [r7, #12]
 8005868:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800586c:	693a      	ldr	r2, [r7, #16]
 800586e:	4413      	add	r3, r2
 8005870:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8005874:	021b      	lsls	r3, r3, #8
 8005876:	461a      	mov	r2, r3
 8005878:	68bb      	ldr	r3, [r7, #8]
 800587a:	4313      	orrs	r3, r2
 800587c:	60bb      	str	r3, [r7, #8]
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
 800587e:	683b      	ldr	r3, [r7, #0]
 8005880:	f003 0301 	and.w	r3, r3, #1
 8005884:	2b00      	cmp	r3, #0
 8005886:	d002      	beq.n	800588e <get_fat+0xbc>
 8005888:	68bb      	ldr	r3, [r7, #8]
 800588a:	091b      	lsrs	r3, r3, #4
 800588c:	e002      	b.n	8005894 <get_fat+0xc2>
 800588e:	68bb      	ldr	r3, [r7, #8]
 8005890:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8005894:	617b      	str	r3, [r7, #20]
			break;
 8005896:	e03f      	b.n	8005918 <get_fat+0x146>

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8005898:	693b      	ldr	r3, [r7, #16]
 800589a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800589c:	683b      	ldr	r3, [r7, #0]
 800589e:	0a1b      	lsrs	r3, r3, #8
 80058a0:	4413      	add	r3, r2
 80058a2:	4619      	mov	r1, r3
 80058a4:	6938      	ldr	r0, [r7, #16]
 80058a6:	f7ff feda 	bl	800565e <move_window>
 80058aa:	4603      	mov	r3, r0
 80058ac:	2b00      	cmp	r3, #0
 80058ae:	d130      	bne.n	8005912 <get_fat+0x140>
			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
 80058b0:	693b      	ldr	r3, [r7, #16]
 80058b2:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80058b6:	683b      	ldr	r3, [r7, #0]
 80058b8:	005b      	lsls	r3, r3, #1
 80058ba:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
 80058be:	4413      	add	r3, r2
 80058c0:	4618      	mov	r0, r3
 80058c2:	f7ff fcf1 	bl	80052a8 <ld_word>
 80058c6:	4603      	mov	r3, r0
 80058c8:	617b      	str	r3, [r7, #20]
			break;
 80058ca:	e025      	b.n	8005918 <get_fat+0x146>

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 80058cc:	693b      	ldr	r3, [r7, #16]
 80058ce:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80058d0:	683b      	ldr	r3, [r7, #0]
 80058d2:	09db      	lsrs	r3, r3, #7
 80058d4:	4413      	add	r3, r2
 80058d6:	4619      	mov	r1, r3
 80058d8:	6938      	ldr	r0, [r7, #16]
 80058da:	f7ff fec0 	bl	800565e <move_window>
 80058de:	4603      	mov	r3, r0
 80058e0:	2b00      	cmp	r3, #0
 80058e2:	d118      	bne.n	8005916 <get_fat+0x144>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
 80058e4:	693b      	ldr	r3, [r7, #16]
 80058e6:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80058ea:	683b      	ldr	r3, [r7, #0]
 80058ec:	009b      	lsls	r3, r3, #2
 80058ee:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
 80058f2:	4413      	add	r3, r2
 80058f4:	4618      	mov	r0, r3
 80058f6:	f7ff fcef 	bl	80052d8 <ld_dword>
 80058fa:	4603      	mov	r3, r0
 80058fc:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8005900:	617b      	str	r3, [r7, #20]
			break;
 8005902:	e009      	b.n	8005918 <get_fat+0x146>
			}
			val = 1;	/* Internal error */
			break;
#endif
		default:
			val = 1;	/* Internal error */
 8005904:	2301      	movs	r3, #1
 8005906:	617b      	str	r3, [r7, #20]
 8005908:	e006      	b.n	8005918 <get_fat+0x146>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800590a:	bf00      	nop
 800590c:	e004      	b.n	8005918 <get_fat+0x146>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800590e:	bf00      	nop
 8005910:	e002      	b.n	8005918 <get_fat+0x146>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8005912:	bf00      	nop
 8005914:	e000      	b.n	8005918 <get_fat+0x146>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8005916:	bf00      	nop
		}
	}

	return val;
 8005918:	697b      	ldr	r3, [r7, #20]
}
 800591a:	4618      	mov	r0, r3
 800591c:	3718      	adds	r7, #24
 800591e:	46bd      	mov	sp, r7
 8005920:	bd80      	pop	{r7, pc}

08005922 <put_fat>:
static FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* Corresponding filesystem object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
 8005922:	b590      	push	{r4, r7, lr}
 8005924:	b089      	sub	sp, #36	; 0x24
 8005926:	af00      	add	r7, sp, #0
 8005928:	60f8      	str	r0, [r7, #12]
 800592a:	60b9      	str	r1, [r7, #8]
 800592c:	607a      	str	r2, [r7, #4]
	UINT bc;
	BYTE *p;
	FRESULT res = FR_INT_ERR;
 800592e:	2302      	movs	r3, #2
 8005930:	77fb      	strb	r3, [r7, #31]


	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8005932:	68bb      	ldr	r3, [r7, #8]
 8005934:	2b01      	cmp	r3, #1
 8005936:	f240 80d2 	bls.w	8005ade <put_fat+0x1bc>
 800593a:	68fb      	ldr	r3, [r7, #12]
 800593c:	699b      	ldr	r3, [r3, #24]
 800593e:	68ba      	ldr	r2, [r7, #8]
 8005940:	429a      	cmp	r2, r3
 8005942:	f080 80cc 	bcs.w	8005ade <put_fat+0x1bc>
		switch (fs->fs_type) {
 8005946:	68fb      	ldr	r3, [r7, #12]
 8005948:	781b      	ldrb	r3, [r3, #0]
 800594a:	2b03      	cmp	r3, #3
 800594c:	f000 8096 	beq.w	8005a7c <put_fat+0x15a>
 8005950:	2b03      	cmp	r3, #3
 8005952:	f300 80cd 	bgt.w	8005af0 <put_fat+0x1ce>
 8005956:	2b01      	cmp	r3, #1
 8005958:	d002      	beq.n	8005960 <put_fat+0x3e>
 800595a:	2b02      	cmp	r3, #2
 800595c:	d06e      	beq.n	8005a3c <put_fat+0x11a>
 800595e:	e0c7      	b.n	8005af0 <put_fat+0x1ce>
		case FS_FAT12:
			bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
 8005960:	68bb      	ldr	r3, [r7, #8]
 8005962:	61bb      	str	r3, [r7, #24]
 8005964:	69bb      	ldr	r3, [r7, #24]
 8005966:	085b      	lsrs	r3, r3, #1
 8005968:	69ba      	ldr	r2, [r7, #24]
 800596a:	4413      	add	r3, r2
 800596c:	61bb      	str	r3, [r7, #24]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800596e:	68fb      	ldr	r3, [r7, #12]
 8005970:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005972:	69bb      	ldr	r3, [r7, #24]
 8005974:	0a5b      	lsrs	r3, r3, #9
 8005976:	4413      	add	r3, r2
 8005978:	4619      	mov	r1, r3
 800597a:	68f8      	ldr	r0, [r7, #12]
 800597c:	f7ff fe6f 	bl	800565e <move_window>
 8005980:	4603      	mov	r3, r0
 8005982:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 8005984:	7ffb      	ldrb	r3, [r7, #31]
 8005986:	2b00      	cmp	r3, #0
 8005988:	f040 80ab 	bne.w	8005ae2 <put_fat+0x1c0>
			p = fs->win + bc++ % SS(fs);
 800598c:	68fb      	ldr	r3, [r7, #12]
 800598e:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8005992:	69bb      	ldr	r3, [r7, #24]
 8005994:	1c59      	adds	r1, r3, #1
 8005996:	61b9      	str	r1, [r7, #24]
 8005998:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800599c:	4413      	add	r3, r2
 800599e:	617b      	str	r3, [r7, #20]
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Update 1st byte */
 80059a0:	68bb      	ldr	r3, [r7, #8]
 80059a2:	f003 0301 	and.w	r3, r3, #1
 80059a6:	2b00      	cmp	r3, #0
 80059a8:	d00d      	beq.n	80059c6 <put_fat+0xa4>
 80059aa:	697b      	ldr	r3, [r7, #20]
 80059ac:	781b      	ldrb	r3, [r3, #0]
 80059ae:	b25b      	sxtb	r3, r3
 80059b0:	f003 030f 	and.w	r3, r3, #15
 80059b4:	b25a      	sxtb	r2, r3
 80059b6:	687b      	ldr	r3, [r7, #4]
 80059b8:	b2db      	uxtb	r3, r3
 80059ba:	011b      	lsls	r3, r3, #4
 80059bc:	b25b      	sxtb	r3, r3
 80059be:	4313      	orrs	r3, r2
 80059c0:	b25b      	sxtb	r3, r3
 80059c2:	b2db      	uxtb	r3, r3
 80059c4:	e001      	b.n	80059ca <put_fat+0xa8>
 80059c6:	687b      	ldr	r3, [r7, #4]
 80059c8:	b2db      	uxtb	r3, r3
 80059ca:	697a      	ldr	r2, [r7, #20]
 80059cc:	7013      	strb	r3, [r2, #0]
			fs->wflag = 1;
 80059ce:	68fb      	ldr	r3, [r7, #12]
 80059d0:	2201      	movs	r2, #1
 80059d2:	70da      	strb	r2, [r3, #3]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80059d4:	68fb      	ldr	r3, [r7, #12]
 80059d6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80059d8:	69bb      	ldr	r3, [r7, #24]
 80059da:	0a5b      	lsrs	r3, r3, #9
 80059dc:	4413      	add	r3, r2
 80059de:	4619      	mov	r1, r3
 80059e0:	68f8      	ldr	r0, [r7, #12]
 80059e2:	f7ff fe3c 	bl	800565e <move_window>
 80059e6:	4603      	mov	r3, r0
 80059e8:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 80059ea:	7ffb      	ldrb	r3, [r7, #31]
 80059ec:	2b00      	cmp	r3, #0
 80059ee:	d17a      	bne.n	8005ae6 <put_fat+0x1c4>
			p = fs->win + bc % SS(fs);
 80059f0:	68fb      	ldr	r3, [r7, #12]
 80059f2:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80059f6:	69bb      	ldr	r3, [r7, #24]
 80059f8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80059fc:	4413      	add	r3, r2
 80059fe:	617b      	str	r3, [r7, #20]
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Update 2nd byte */
 8005a00:	68bb      	ldr	r3, [r7, #8]
 8005a02:	f003 0301 	and.w	r3, r3, #1
 8005a06:	2b00      	cmp	r3, #0
 8005a08:	d003      	beq.n	8005a12 <put_fat+0xf0>
 8005a0a:	687b      	ldr	r3, [r7, #4]
 8005a0c:	091b      	lsrs	r3, r3, #4
 8005a0e:	b2db      	uxtb	r3, r3
 8005a10:	e00e      	b.n	8005a30 <put_fat+0x10e>
 8005a12:	697b      	ldr	r3, [r7, #20]
 8005a14:	781b      	ldrb	r3, [r3, #0]
 8005a16:	b25b      	sxtb	r3, r3
 8005a18:	f023 030f 	bic.w	r3, r3, #15
 8005a1c:	b25a      	sxtb	r2, r3
 8005a1e:	687b      	ldr	r3, [r7, #4]
 8005a20:	0a1b      	lsrs	r3, r3, #8
 8005a22:	b25b      	sxtb	r3, r3
 8005a24:	f003 030f 	and.w	r3, r3, #15
 8005a28:	b25b      	sxtb	r3, r3
 8005a2a:	4313      	orrs	r3, r2
 8005a2c:	b25b      	sxtb	r3, r3
 8005a2e:	b2db      	uxtb	r3, r3
 8005a30:	697a      	ldr	r2, [r7, #20]
 8005a32:	7013      	strb	r3, [r2, #0]
			fs->wflag = 1;
 8005a34:	68fb      	ldr	r3, [r7, #12]
 8005a36:	2201      	movs	r2, #1
 8005a38:	70da      	strb	r2, [r3, #3]
			break;
 8005a3a:	e059      	b.n	8005af0 <put_fat+0x1ce>

		case FS_FAT16:
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8005a3c:	68fb      	ldr	r3, [r7, #12]
 8005a3e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005a40:	68bb      	ldr	r3, [r7, #8]
 8005a42:	0a1b      	lsrs	r3, r3, #8
 8005a44:	4413      	add	r3, r2
 8005a46:	4619      	mov	r1, r3
 8005a48:	68f8      	ldr	r0, [r7, #12]
 8005a4a:	f7ff fe08 	bl	800565e <move_window>
 8005a4e:	4603      	mov	r3, r0
 8005a50:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 8005a52:	7ffb      	ldrb	r3, [r7, #31]
 8005a54:	2b00      	cmp	r3, #0
 8005a56:	d148      	bne.n	8005aea <put_fat+0x1c8>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
 8005a58:	68fb      	ldr	r3, [r7, #12]
 8005a5a:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8005a5e:	68bb      	ldr	r3, [r7, #8]
 8005a60:	005b      	lsls	r3, r3, #1
 8005a62:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
 8005a66:	4413      	add	r3, r2
 8005a68:	687a      	ldr	r2, [r7, #4]
 8005a6a:	b292      	uxth	r2, r2
 8005a6c:	4611      	mov	r1, r2
 8005a6e:	4618      	mov	r0, r3
 8005a70:	f7ff fc55 	bl	800531e <st_word>
			fs->wflag = 1;
 8005a74:	68fb      	ldr	r3, [r7, #12]
 8005a76:	2201      	movs	r2, #1
 8005a78:	70da      	strb	r2, [r3, #3]
			break;
 8005a7a:	e039      	b.n	8005af0 <put_fat+0x1ce>

		case FS_FAT32:
#if FF_FS_EXFAT
		case FS_EXFAT:
#endif
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8005a7c:	68fb      	ldr	r3, [r7, #12]
 8005a7e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005a80:	68bb      	ldr	r3, [r7, #8]
 8005a82:	09db      	lsrs	r3, r3, #7
 8005a84:	4413      	add	r3, r2
 8005a86:	4619      	mov	r1, r3
 8005a88:	68f8      	ldr	r0, [r7, #12]
 8005a8a:	f7ff fde8 	bl	800565e <move_window>
 8005a8e:	4603      	mov	r3, r0
 8005a90:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 8005a92:	7ffb      	ldrb	r3, [r7, #31]
 8005a94:	2b00      	cmp	r3, #0
 8005a96:	d12a      	bne.n	8005aee <put_fat+0x1cc>
			if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 8005a98:	687b      	ldr	r3, [r7, #4]
 8005a9a:	f023 4470 	bic.w	r4, r3, #4026531840	; 0xf0000000
 8005a9e:	68fb      	ldr	r3, [r7, #12]
 8005aa0:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8005aa4:	68bb      	ldr	r3, [r7, #8]
 8005aa6:	009b      	lsls	r3, r3, #2
 8005aa8:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
 8005aac:	4413      	add	r3, r2
 8005aae:	4618      	mov	r0, r3
 8005ab0:	f7ff fc12 	bl	80052d8 <ld_dword>
 8005ab4:	4603      	mov	r3, r0
 8005ab6:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 8005aba:	4323      	orrs	r3, r4
 8005abc:	607b      	str	r3, [r7, #4]
			}
			st_dword(fs->win + clst * 4 % SS(fs), val);
 8005abe:	68fb      	ldr	r3, [r7, #12]
 8005ac0:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8005ac4:	68bb      	ldr	r3, [r7, #8]
 8005ac6:	009b      	lsls	r3, r3, #2
 8005ac8:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
 8005acc:	4413      	add	r3, r2
 8005ace:	6879      	ldr	r1, [r7, #4]
 8005ad0:	4618      	mov	r0, r3
 8005ad2:	f7ff fc3f 	bl	8005354 <st_dword>
			fs->wflag = 1;
 8005ad6:	68fb      	ldr	r3, [r7, #12]
 8005ad8:	2201      	movs	r2, #1
 8005ada:	70da      	strb	r2, [r3, #3]
			break;
 8005adc:	e008      	b.n	8005af0 <put_fat+0x1ce>
		}
	}
 8005ade:	bf00      	nop
 8005ae0:	e006      	b.n	8005af0 <put_fat+0x1ce>
			if (res != FR_OK) break;
 8005ae2:	bf00      	nop
 8005ae4:	e004      	b.n	8005af0 <put_fat+0x1ce>
			if (res != FR_OK) break;
 8005ae6:	bf00      	nop
 8005ae8:	e002      	b.n	8005af0 <put_fat+0x1ce>
			if (res != FR_OK) break;
 8005aea:	bf00      	nop
 8005aec:	e000      	b.n	8005af0 <put_fat+0x1ce>
			if (res != FR_OK) break;
 8005aee:	bf00      	nop
	return res;
 8005af0:	7ffb      	ldrb	r3, [r7, #31]
}
 8005af2:	4618      	mov	r0, r3
 8005af4:	3724      	adds	r7, #36	; 0x24
 8005af6:	46bd      	mov	sp, r7
 8005af8:	bd90      	pop	{r4, r7, pc}

08005afa <remove_chain>:
static FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	FFOBJID* obj,		/* Corresponding object */
	DWORD clst,			/* Cluster to remove a chain from */
	DWORD pclst			/* Previous cluster of clst (0 if entire chain) */
)
{
 8005afa:	b580      	push	{r7, lr}
 8005afc:	b088      	sub	sp, #32
 8005afe:	af00      	add	r7, sp, #0
 8005b00:	60f8      	str	r0, [r7, #12]
 8005b02:	60b9      	str	r1, [r7, #8]
 8005b04:	607a      	str	r2, [r7, #4]
	FRESULT res = FR_OK;
 8005b06:	2300      	movs	r3, #0
 8005b08:	77fb      	strb	r3, [r7, #31]
	DWORD nxt;
	FATFS *fs = obj->fs;
 8005b0a:	68fb      	ldr	r3, [r7, #12]
 8005b0c:	681b      	ldr	r3, [r3, #0]
 8005b0e:	61bb      	str	r3, [r7, #24]
#endif
#if FF_USE_TRIM
	LBA_t rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8005b10:	68bb      	ldr	r3, [r7, #8]
 8005b12:	2b01      	cmp	r3, #1
 8005b14:	d904      	bls.n	8005b20 <remove_chain+0x26>
 8005b16:	69bb      	ldr	r3, [r7, #24]
 8005b18:	699b      	ldr	r3, [r3, #24]
 8005b1a:	68ba      	ldr	r2, [r7, #8]
 8005b1c:	429a      	cmp	r2, r3
 8005b1e:	d301      	bcc.n	8005b24 <remove_chain+0x2a>
 8005b20:	2302      	movs	r3, #2
 8005b22:	e04b      	b.n	8005bbc <remove_chain+0xc2>

	/* Mark the previous cluster 'EOC' on the FAT if it exists */
	if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 8005b24:	687b      	ldr	r3, [r7, #4]
 8005b26:	2b00      	cmp	r3, #0
 8005b28:	d00c      	beq.n	8005b44 <remove_chain+0x4a>
		res = put_fat(fs, pclst, 0xFFFFFFFF);
 8005b2a:	f04f 32ff 	mov.w	r2, #4294967295
 8005b2e:	6879      	ldr	r1, [r7, #4]
 8005b30:	69b8      	ldr	r0, [r7, #24]
 8005b32:	f7ff fef6 	bl	8005922 <put_fat>
 8005b36:	4603      	mov	r3, r0
 8005b38:	77fb      	strb	r3, [r7, #31]
		if (res != FR_OK) return res;
 8005b3a:	7ffb      	ldrb	r3, [r7, #31]
 8005b3c:	2b00      	cmp	r3, #0
 8005b3e:	d001      	beq.n	8005b44 <remove_chain+0x4a>
 8005b40:	7ffb      	ldrb	r3, [r7, #31]
 8005b42:	e03b      	b.n	8005bbc <remove_chain+0xc2>
	}

	/* Remove the chain */
	do {
		nxt = get_fat(obj, clst);			/* Get cluster status */
 8005b44:	68b9      	ldr	r1, [r7, #8]
 8005b46:	68f8      	ldr	r0, [r7, #12]
 8005b48:	f7ff fe43 	bl	80057d2 <get_fat>
 8005b4c:	6178      	str	r0, [r7, #20]
		if (nxt == 0) break;				/* Empty cluster? */
 8005b4e:	697b      	ldr	r3, [r7, #20]
 8005b50:	2b00      	cmp	r3, #0
 8005b52:	d031      	beq.n	8005bb8 <remove_chain+0xbe>
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 8005b54:	697b      	ldr	r3, [r7, #20]
 8005b56:	2b01      	cmp	r3, #1
 8005b58:	d101      	bne.n	8005b5e <remove_chain+0x64>
 8005b5a:	2302      	movs	r3, #2
 8005b5c:	e02e      	b.n	8005bbc <remove_chain+0xc2>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 8005b5e:	697b      	ldr	r3, [r7, #20]
 8005b60:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005b64:	d101      	bne.n	8005b6a <remove_chain+0x70>
 8005b66:	2301      	movs	r3, #1
 8005b68:	e028      	b.n	8005bbc <remove_chain+0xc2>
		if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
 8005b6a:	2200      	movs	r2, #0
 8005b6c:	68b9      	ldr	r1, [r7, #8]
 8005b6e:	69b8      	ldr	r0, [r7, #24]
 8005b70:	f7ff fed7 	bl	8005922 <put_fat>
 8005b74:	4603      	mov	r3, r0
 8005b76:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) return res;
 8005b78:	7ffb      	ldrb	r3, [r7, #31]
 8005b7a:	2b00      	cmp	r3, #0
 8005b7c:	d001      	beq.n	8005b82 <remove_chain+0x88>
 8005b7e:	7ffb      	ldrb	r3, [r7, #31]
 8005b80:	e01c      	b.n	8005bbc <remove_chain+0xc2>
		}
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 8005b82:	69bb      	ldr	r3, [r7, #24]
 8005b84:	695a      	ldr	r2, [r3, #20]
 8005b86:	69bb      	ldr	r3, [r7, #24]
 8005b88:	699b      	ldr	r3, [r3, #24]
 8005b8a:	3b02      	subs	r3, #2
 8005b8c:	429a      	cmp	r2, r3
 8005b8e:	d20b      	bcs.n	8005ba8 <remove_chain+0xae>
			fs->free_clst++;
 8005b90:	69bb      	ldr	r3, [r7, #24]
 8005b92:	695b      	ldr	r3, [r3, #20]
 8005b94:	1c5a      	adds	r2, r3, #1
 8005b96:	69bb      	ldr	r3, [r7, #24]
 8005b98:	615a      	str	r2, [r3, #20]
			fs->fsi_flag |= 1;
 8005b9a:	69bb      	ldr	r3, [r7, #24]
 8005b9c:	791b      	ldrb	r3, [r3, #4]
 8005b9e:	f043 0301 	orr.w	r3, r3, #1
 8005ba2:	b2da      	uxtb	r2, r3
 8005ba4:	69bb      	ldr	r3, [r7, #24]
 8005ba6:	711a      	strb	r2, [r3, #4]
			disk_ioctl(fs->pdrv, CTRL_TRIM, rt);		/* Inform storage device that the data in the block may be erased */
#endif
			scl = ecl = nxt;
		}
#endif
		clst = nxt;					/* Next cluster */
 8005ba8:	697b      	ldr	r3, [r7, #20]
 8005baa:	60bb      	str	r3, [r7, #8]
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
 8005bac:	69bb      	ldr	r3, [r7, #24]
 8005bae:	699b      	ldr	r3, [r3, #24]
 8005bb0:	68ba      	ldr	r2, [r7, #8]
 8005bb2:	429a      	cmp	r2, r3
 8005bb4:	d3c6      	bcc.n	8005b44 <remove_chain+0x4a>
 8005bb6:	e000      	b.n	8005bba <remove_chain+0xc0>
		if (nxt == 0) break;				/* Empty cluster? */
 8005bb8:	bf00      	nop
				}
			}
		}
	}
#endif
	return FR_OK;
 8005bba:	2300      	movs	r3, #0
}
 8005bbc:	4618      	mov	r0, r3
 8005bbe:	3720      	adds	r7, #32
 8005bc0:	46bd      	mov	sp, r7
 8005bc2:	bd80      	pop	{r7, pc}

08005bc4 <create_chain>:

static DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FFOBJID* obj,		/* Corresponding object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
 8005bc4:	b580      	push	{r7, lr}
 8005bc6:	b088      	sub	sp, #32
 8005bc8:	af00      	add	r7, sp, #0
 8005bca:	6078      	str	r0, [r7, #4]
 8005bcc:	6039      	str	r1, [r7, #0]
	DWORD cs, ncl, scl;
	FRESULT res;
	FATFS *fs = obj->fs;
 8005bce:	687b      	ldr	r3, [r7, #4]
 8005bd0:	681b      	ldr	r3, [r3, #0]
 8005bd2:	613b      	str	r3, [r7, #16]


	if (clst == 0) {	/* Create a new chain */
 8005bd4:	683b      	ldr	r3, [r7, #0]
 8005bd6:	2b00      	cmp	r3, #0
 8005bd8:	d10d      	bne.n	8005bf6 <create_chain+0x32>
		scl = fs->last_clst;				/* Suggested cluster to start to find */
 8005bda:	693b      	ldr	r3, [r7, #16]
 8005bdc:	691b      	ldr	r3, [r3, #16]
 8005bde:	61bb      	str	r3, [r7, #24]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 8005be0:	69bb      	ldr	r3, [r7, #24]
 8005be2:	2b00      	cmp	r3, #0
 8005be4:	d004      	beq.n	8005bf0 <create_chain+0x2c>
 8005be6:	693b      	ldr	r3, [r7, #16]
 8005be8:	699b      	ldr	r3, [r3, #24]
 8005bea:	69ba      	ldr	r2, [r7, #24]
 8005bec:	429a      	cmp	r2, r3
 8005bee:	d31b      	bcc.n	8005c28 <create_chain+0x64>
 8005bf0:	2301      	movs	r3, #1
 8005bf2:	61bb      	str	r3, [r7, #24]
 8005bf4:	e018      	b.n	8005c28 <create_chain+0x64>
	}
	else {				/* Stretch a chain */
		cs = get_fat(obj, clst);			/* Check the cluster status */
 8005bf6:	6839      	ldr	r1, [r7, #0]
 8005bf8:	6878      	ldr	r0, [r7, #4]
 8005bfa:	f7ff fdea 	bl	80057d2 <get_fat>
 8005bfe:	60f8      	str	r0, [r7, #12]
		if (cs < 2) return 1;				/* Test for insanity */
 8005c00:	68fb      	ldr	r3, [r7, #12]
 8005c02:	2b01      	cmp	r3, #1
 8005c04:	d801      	bhi.n	8005c0a <create_chain+0x46>
 8005c06:	2301      	movs	r3, #1
 8005c08:	e0a9      	b.n	8005d5e <create_chain+0x19a>
		if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
 8005c0a:	68fb      	ldr	r3, [r7, #12]
 8005c0c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005c10:	d101      	bne.n	8005c16 <create_chain+0x52>
 8005c12:	68fb      	ldr	r3, [r7, #12]
 8005c14:	e0a3      	b.n	8005d5e <create_chain+0x19a>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 8005c16:	693b      	ldr	r3, [r7, #16]
 8005c18:	699b      	ldr	r3, [r3, #24]
 8005c1a:	68fa      	ldr	r2, [r7, #12]
 8005c1c:	429a      	cmp	r2, r3
 8005c1e:	d201      	bcs.n	8005c24 <create_chain+0x60>
 8005c20:	68fb      	ldr	r3, [r7, #12]
 8005c22:	e09c      	b.n	8005d5e <create_chain+0x19a>
		scl = clst;							/* Cluster to start to find */
 8005c24:	683b      	ldr	r3, [r7, #0]
 8005c26:	61bb      	str	r3, [r7, #24]
	}
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 8005c28:	693b      	ldr	r3, [r7, #16]
 8005c2a:	695b      	ldr	r3, [r3, #20]
 8005c2c:	2b00      	cmp	r3, #0
 8005c2e:	d101      	bne.n	8005c34 <create_chain+0x70>
 8005c30:	2300      	movs	r3, #0
 8005c32:	e094      	b.n	8005d5e <create_chain+0x19a>
			}
		}
	} else
#endif
	{	/* On the FAT/FAT32 volume */
		ncl = 0;
 8005c34:	2300      	movs	r3, #0
 8005c36:	61fb      	str	r3, [r7, #28]
		if (scl == clst) {						/* Stretching an existing chain? */
 8005c38:	69ba      	ldr	r2, [r7, #24]
 8005c3a:	683b      	ldr	r3, [r7, #0]
 8005c3c:	429a      	cmp	r2, r3
 8005c3e:	d129      	bne.n	8005c94 <create_chain+0xd0>
			ncl = scl + 1;						/* Test if next cluster is free */
 8005c40:	69bb      	ldr	r3, [r7, #24]
 8005c42:	3301      	adds	r3, #1
 8005c44:	61fb      	str	r3, [r7, #28]
			if (ncl >= fs->n_fatent) ncl = 2;
 8005c46:	693b      	ldr	r3, [r7, #16]
 8005c48:	699b      	ldr	r3, [r3, #24]
 8005c4a:	69fa      	ldr	r2, [r7, #28]
 8005c4c:	429a      	cmp	r2, r3
 8005c4e:	d301      	bcc.n	8005c54 <create_chain+0x90>
 8005c50:	2302      	movs	r3, #2
 8005c52:	61fb      	str	r3, [r7, #28]
			cs = get_fat(obj, ncl);				/* Get next cluster status */
 8005c54:	69f9      	ldr	r1, [r7, #28]
 8005c56:	6878      	ldr	r0, [r7, #4]
 8005c58:	f7ff fdbb 	bl	80057d2 <get_fat>
 8005c5c:	60f8      	str	r0, [r7, #12]
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 8005c5e:	68fb      	ldr	r3, [r7, #12]
 8005c60:	2b01      	cmp	r3, #1
 8005c62:	d003      	beq.n	8005c6c <create_chain+0xa8>
 8005c64:	68fb      	ldr	r3, [r7, #12]
 8005c66:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005c6a:	d101      	bne.n	8005c70 <create_chain+0xac>
 8005c6c:	68fb      	ldr	r3, [r7, #12]
 8005c6e:	e076      	b.n	8005d5e <create_chain+0x19a>
			if (cs != 0) {						/* Not free? */
 8005c70:	68fb      	ldr	r3, [r7, #12]
 8005c72:	2b00      	cmp	r3, #0
 8005c74:	d00e      	beq.n	8005c94 <create_chain+0xd0>
				cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
 8005c76:	693b      	ldr	r3, [r7, #16]
 8005c78:	691b      	ldr	r3, [r3, #16]
 8005c7a:	60fb      	str	r3, [r7, #12]
				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
 8005c7c:	68fb      	ldr	r3, [r7, #12]
 8005c7e:	2b01      	cmp	r3, #1
 8005c80:	d906      	bls.n	8005c90 <create_chain+0xcc>
 8005c82:	693b      	ldr	r3, [r7, #16]
 8005c84:	699b      	ldr	r3, [r3, #24]
 8005c86:	68fa      	ldr	r2, [r7, #12]
 8005c88:	429a      	cmp	r2, r3
 8005c8a:	d201      	bcs.n	8005c90 <create_chain+0xcc>
 8005c8c:	68fb      	ldr	r3, [r7, #12]
 8005c8e:	61bb      	str	r3, [r7, #24]
				ncl = 0;
 8005c90:	2300      	movs	r3, #0
 8005c92:	61fb      	str	r3, [r7, #28]
			}
		}
		if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
 8005c94:	69fb      	ldr	r3, [r7, #28]
 8005c96:	2b00      	cmp	r3, #0
 8005c98:	d129      	bne.n	8005cee <create_chain+0x12a>
			ncl = scl;	/* Start cluster */
 8005c9a:	69bb      	ldr	r3, [r7, #24]
 8005c9c:	61fb      	str	r3, [r7, #28]
			for (;;) {
				ncl++;							/* Next cluster */
 8005c9e:	69fb      	ldr	r3, [r7, #28]
 8005ca0:	3301      	adds	r3, #1
 8005ca2:	61fb      	str	r3, [r7, #28]
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 8005ca4:	693b      	ldr	r3, [r7, #16]
 8005ca6:	699b      	ldr	r3, [r3, #24]
 8005ca8:	69fa      	ldr	r2, [r7, #28]
 8005caa:	429a      	cmp	r2, r3
 8005cac:	d307      	bcc.n	8005cbe <create_chain+0xfa>
					ncl = 2;
 8005cae:	2302      	movs	r3, #2
 8005cb0:	61fb      	str	r3, [r7, #28]
					if (ncl > scl) return 0;	/* No free cluster found? */
 8005cb2:	69fa      	ldr	r2, [r7, #28]
 8005cb4:	69bb      	ldr	r3, [r7, #24]
 8005cb6:	429a      	cmp	r2, r3
 8005cb8:	d901      	bls.n	8005cbe <create_chain+0xfa>
 8005cba:	2300      	movs	r3, #0
 8005cbc:	e04f      	b.n	8005d5e <create_chain+0x19a>
				}
				cs = get_fat(obj, ncl);			/* Get the cluster status */
 8005cbe:	69f9      	ldr	r1, [r7, #28]
 8005cc0:	6878      	ldr	r0, [r7, #4]
 8005cc2:	f7ff fd86 	bl	80057d2 <get_fat>
 8005cc6:	60f8      	str	r0, [r7, #12]
				if (cs == 0) break;				/* Found a free cluster? */
 8005cc8:	68fb      	ldr	r3, [r7, #12]
 8005cca:	2b00      	cmp	r3, #0
 8005ccc:	d00e      	beq.n	8005cec <create_chain+0x128>
				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 8005cce:	68fb      	ldr	r3, [r7, #12]
 8005cd0:	2b01      	cmp	r3, #1
 8005cd2:	d003      	beq.n	8005cdc <create_chain+0x118>
 8005cd4:	68fb      	ldr	r3, [r7, #12]
 8005cd6:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005cda:	d101      	bne.n	8005ce0 <create_chain+0x11c>
 8005cdc:	68fb      	ldr	r3, [r7, #12]
 8005cde:	e03e      	b.n	8005d5e <create_chain+0x19a>
				if (ncl == scl) return 0;		/* No free cluster found? */
 8005ce0:	69fa      	ldr	r2, [r7, #28]
 8005ce2:	69bb      	ldr	r3, [r7, #24]
 8005ce4:	429a      	cmp	r2, r3
 8005ce6:	d1da      	bne.n	8005c9e <create_chain+0xda>
 8005ce8:	2300      	movs	r3, #0
 8005cea:	e038      	b.n	8005d5e <create_chain+0x19a>
				if (cs == 0) break;				/* Found a free cluster? */
 8005cec:	bf00      	nop
			}
		}
		res = put_fat(fs, ncl, 0xFFFFFFFF);		/* Mark the new cluster 'EOC' */
 8005cee:	f04f 32ff 	mov.w	r2, #4294967295
 8005cf2:	69f9      	ldr	r1, [r7, #28]
 8005cf4:	6938      	ldr	r0, [r7, #16]
 8005cf6:	f7ff fe14 	bl	8005922 <put_fat>
 8005cfa:	4603      	mov	r3, r0
 8005cfc:	75fb      	strb	r3, [r7, #23]
		if (res == FR_OK && clst != 0) {
 8005cfe:	7dfb      	ldrb	r3, [r7, #23]
 8005d00:	2b00      	cmp	r3, #0
 8005d02:	d109      	bne.n	8005d18 <create_chain+0x154>
 8005d04:	683b      	ldr	r3, [r7, #0]
 8005d06:	2b00      	cmp	r3, #0
 8005d08:	d006      	beq.n	8005d18 <create_chain+0x154>
			res = put_fat(fs, clst, ncl);		/* Link it from the previous one if needed */
 8005d0a:	69fa      	ldr	r2, [r7, #28]
 8005d0c:	6839      	ldr	r1, [r7, #0]
 8005d0e:	6938      	ldr	r0, [r7, #16]
 8005d10:	f7ff fe07 	bl	8005922 <put_fat>
 8005d14:	4603      	mov	r3, r0
 8005d16:	75fb      	strb	r3, [r7, #23]
		}
	}

	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 8005d18:	7dfb      	ldrb	r3, [r7, #23]
 8005d1a:	2b00      	cmp	r3, #0
 8005d1c:	d116      	bne.n	8005d4c <create_chain+0x188>
		fs->last_clst = ncl;
 8005d1e:	693b      	ldr	r3, [r7, #16]
 8005d20:	69fa      	ldr	r2, [r7, #28]
 8005d22:	611a      	str	r2, [r3, #16]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 8005d24:	693b      	ldr	r3, [r7, #16]
 8005d26:	695a      	ldr	r2, [r3, #20]
 8005d28:	693b      	ldr	r3, [r7, #16]
 8005d2a:	699b      	ldr	r3, [r3, #24]
 8005d2c:	3b02      	subs	r3, #2
 8005d2e:	429a      	cmp	r2, r3
 8005d30:	d804      	bhi.n	8005d3c <create_chain+0x178>
 8005d32:	693b      	ldr	r3, [r7, #16]
 8005d34:	695b      	ldr	r3, [r3, #20]
 8005d36:	1e5a      	subs	r2, r3, #1
 8005d38:	693b      	ldr	r3, [r7, #16]
 8005d3a:	615a      	str	r2, [r3, #20]
		fs->fsi_flag |= 1;
 8005d3c:	693b      	ldr	r3, [r7, #16]
 8005d3e:	791b      	ldrb	r3, [r3, #4]
 8005d40:	f043 0301 	orr.w	r3, r3, #1
 8005d44:	b2da      	uxtb	r2, r3
 8005d46:	693b      	ldr	r3, [r7, #16]
 8005d48:	711a      	strb	r2, [r3, #4]
 8005d4a:	e007      	b.n	8005d5c <create_chain+0x198>
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 8005d4c:	7dfb      	ldrb	r3, [r7, #23]
 8005d4e:	2b01      	cmp	r3, #1
 8005d50:	d102      	bne.n	8005d58 <create_chain+0x194>
 8005d52:	f04f 33ff 	mov.w	r3, #4294967295
 8005d56:	e000      	b.n	8005d5a <create_chain+0x196>
 8005d58:	2301      	movs	r3, #1
 8005d5a:	61fb      	str	r3, [r7, #28]
	}

	return ncl;		/* Return new cluster number or error status */
 8005d5c:	69fb      	ldr	r3, [r7, #28]
}
 8005d5e:	4618      	mov	r0, r3
 8005d60:	3720      	adds	r7, #32
 8005d62:	46bd      	mov	sp, r7
 8005d64:	bd80      	pop	{r7, pc}

08005d66 <dir_clear>:
#if !FF_FS_READONLY
static FRESULT dir_clear (	/* Returns FR_OK or FR_DISK_ERR */
	FATFS *fs,		/* Filesystem object */
	DWORD clst		/* Directory table to clear */
)
{
 8005d66:	b580      	push	{r7, lr}
 8005d68:	b086      	sub	sp, #24
 8005d6a:	af00      	add	r7, sp, #0
 8005d6c:	6078      	str	r0, [r7, #4]
 8005d6e:	6039      	str	r1, [r7, #0]
	LBA_t sect;
	UINT n, szb;
	BYTE *ibuf;


	if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 8005d70:	6878      	ldr	r0, [r7, #4]
 8005d72:	f7ff fc38 	bl	80055e6 <sync_window>
 8005d76:	4603      	mov	r3, r0
 8005d78:	2b00      	cmp	r3, #0
 8005d7a:	d001      	beq.n	8005d80 <dir_clear+0x1a>
 8005d7c:	2301      	movs	r3, #1
 8005d7e:	e036      	b.n	8005dee <dir_clear+0x88>
	sect = clst2sect(fs, clst);		/* Top of the cluster */
 8005d80:	6839      	ldr	r1, [r7, #0]
 8005d82:	6878      	ldr	r0, [r7, #4]
 8005d84:	f7ff fd06 	bl	8005794 <clst2sect>
 8005d88:	6138      	str	r0, [r7, #16]
	fs->winsect = sect;				/* Set window to top of the cluster */
 8005d8a:	687b      	ldr	r3, [r7, #4]
 8005d8c:	693a      	ldr	r2, [r7, #16]
 8005d8e:	631a      	str	r2, [r3, #48]	; 0x30
	mem_set(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
 8005d90:	687b      	ldr	r3, [r7, #4]
 8005d92:	3334      	adds	r3, #52	; 0x34
 8005d94:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005d98:	2100      	movs	r1, #0
 8005d9a:	4618      	mov	r0, r3
 8005d9c:	f7ff fb27 	bl	80053ee <mem_set>
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
		ff_memfree(ibuf);
	} else
#endif
	{
		ibuf = fs->win; szb = 1;	/* Use window buffer (many single-sector writes may take a time) */
 8005da0:	687b      	ldr	r3, [r7, #4]
 8005da2:	3334      	adds	r3, #52	; 0x34
 8005da4:	60fb      	str	r3, [r7, #12]
 8005da6:	2301      	movs	r3, #1
 8005da8:	60bb      	str	r3, [r7, #8]
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 8005daa:	2300      	movs	r3, #0
 8005dac:	617b      	str	r3, [r7, #20]
 8005dae:	e003      	b.n	8005db8 <dir_clear+0x52>
 8005db0:	697a      	ldr	r2, [r7, #20]
 8005db2:	68bb      	ldr	r3, [r7, #8]
 8005db4:	4413      	add	r3, r2
 8005db6:	617b      	str	r3, [r7, #20]
 8005db8:	687b      	ldr	r3, [r7, #4]
 8005dba:	895b      	ldrh	r3, [r3, #10]
 8005dbc:	461a      	mov	r2, r3
 8005dbe:	697b      	ldr	r3, [r7, #20]
 8005dc0:	4293      	cmp	r3, r2
 8005dc2:	d20b      	bcs.n	8005ddc <dir_clear+0x76>
 8005dc4:	687b      	ldr	r3, [r7, #4]
 8005dc6:	7858      	ldrb	r0, [r3, #1]
 8005dc8:	693a      	ldr	r2, [r7, #16]
 8005dca:	697b      	ldr	r3, [r7, #20]
 8005dcc:	441a      	add	r2, r3
 8005dce:	68bb      	ldr	r3, [r7, #8]
 8005dd0:	68f9      	ldr	r1, [r7, #12]
 8005dd2:	f7ff fa27 	bl	8005224 <disk_write>
 8005dd6:	4603      	mov	r3, r0
 8005dd8:	2b00      	cmp	r3, #0
 8005dda:	d0e9      	beq.n	8005db0 <dir_clear+0x4a>
	}
	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
 8005ddc:	687b      	ldr	r3, [r7, #4]
 8005dde:	895b      	ldrh	r3, [r3, #10]
 8005de0:	461a      	mov	r2, r3
 8005de2:	697b      	ldr	r3, [r7, #20]
 8005de4:	4293      	cmp	r3, r2
 8005de6:	bf14      	ite	ne
 8005de8:	2301      	movne	r3, #1
 8005dea:	2300      	moveq	r3, #0
 8005dec:	b2db      	uxtb	r3, r3
}
 8005dee:	4618      	mov	r0, r3
 8005df0:	3718      	adds	r7, #24
 8005df2:	46bd      	mov	sp, r7
 8005df4:	bd80      	pop	{r7, pc}

08005df6 <dir_sdi>:

static FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	DWORD ofs		/* Offset of directory table */
)
{
 8005df6:	b580      	push	{r7, lr}
 8005df8:	b086      	sub	sp, #24
 8005dfa:	af00      	add	r7, sp, #0
 8005dfc:	6078      	str	r0, [r7, #4]
 8005dfe:	6039      	str	r1, [r7, #0]
	DWORD csz, clst;
	FATFS *fs = dp->obj.fs;
 8005e00:	687b      	ldr	r3, [r7, #4]
 8005e02:	681b      	ldr	r3, [r3, #0]
 8005e04:	613b      	str	r3, [r7, #16]


	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 8005e06:	683b      	ldr	r3, [r7, #0]
 8005e08:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8005e0c:	d204      	bcs.n	8005e18 <dir_sdi+0x22>
 8005e0e:	683b      	ldr	r3, [r7, #0]
 8005e10:	f003 031f 	and.w	r3, r3, #31
 8005e14:	2b00      	cmp	r3, #0
 8005e16:	d001      	beq.n	8005e1c <dir_sdi+0x26>
		return FR_INT_ERR;
 8005e18:	2302      	movs	r3, #2
 8005e1a:	e063      	b.n	8005ee4 <dir_sdi+0xee>
	}
	dp->dptr = ofs;				/* Set current offset */
 8005e1c:	687b      	ldr	r3, [r7, #4]
 8005e1e:	683a      	ldr	r2, [r7, #0]
 8005e20:	611a      	str	r2, [r3, #16]
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 8005e22:	687b      	ldr	r3, [r7, #4]
 8005e24:	689b      	ldr	r3, [r3, #8]
 8005e26:	617b      	str	r3, [r7, #20]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 8005e28:	697b      	ldr	r3, [r7, #20]
 8005e2a:	2b00      	cmp	r3, #0
 8005e2c:	d106      	bne.n	8005e3c <dir_sdi+0x46>
 8005e2e:	693b      	ldr	r3, [r7, #16]
 8005e30:	781b      	ldrb	r3, [r3, #0]
 8005e32:	2b02      	cmp	r3, #2
 8005e34:	d902      	bls.n	8005e3c <dir_sdi+0x46>
		clst = (DWORD)fs->dirbase;
 8005e36:	693b      	ldr	r3, [r7, #16]
 8005e38:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005e3a:	617b      	str	r3, [r7, #20]
		if (FF_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
	}

	if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
 8005e3c:	697b      	ldr	r3, [r7, #20]
 8005e3e:	2b00      	cmp	r3, #0
 8005e40:	d10c      	bne.n	8005e5c <dir_sdi+0x66>
		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
 8005e42:	683b      	ldr	r3, [r7, #0]
 8005e44:	095b      	lsrs	r3, r3, #5
 8005e46:	693a      	ldr	r2, [r7, #16]
 8005e48:	8912      	ldrh	r2, [r2, #8]
 8005e4a:	4293      	cmp	r3, r2
 8005e4c:	d301      	bcc.n	8005e52 <dir_sdi+0x5c>
 8005e4e:	2302      	movs	r3, #2
 8005e50:	e048      	b.n	8005ee4 <dir_sdi+0xee>
		dp->sect = fs->dirbase;
 8005e52:	693b      	ldr	r3, [r7, #16]
 8005e54:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005e56:	687b      	ldr	r3, [r7, #4]
 8005e58:	619a      	str	r2, [r3, #24]
 8005e5a:	e029      	b.n	8005eb0 <dir_sdi+0xba>

	} else {			/* Dynamic table (sub-directory or root-directory on the FAT32/exFAT volume) */
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 8005e5c:	693b      	ldr	r3, [r7, #16]
 8005e5e:	895b      	ldrh	r3, [r3, #10]
 8005e60:	025b      	lsls	r3, r3, #9
 8005e62:	60fb      	str	r3, [r7, #12]
		while (ofs >= csz) {				/* Follow cluster chain */
 8005e64:	e019      	b.n	8005e9a <dir_sdi+0xa4>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 8005e66:	687b      	ldr	r3, [r7, #4]
 8005e68:	6979      	ldr	r1, [r7, #20]
 8005e6a:	4618      	mov	r0, r3
 8005e6c:	f7ff fcb1 	bl	80057d2 <get_fat>
 8005e70:	6178      	str	r0, [r7, #20]
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8005e72:	697b      	ldr	r3, [r7, #20]
 8005e74:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005e78:	d101      	bne.n	8005e7e <dir_sdi+0x88>
 8005e7a:	2301      	movs	r3, #1
 8005e7c:	e032      	b.n	8005ee4 <dir_sdi+0xee>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 8005e7e:	697b      	ldr	r3, [r7, #20]
 8005e80:	2b01      	cmp	r3, #1
 8005e82:	d904      	bls.n	8005e8e <dir_sdi+0x98>
 8005e84:	693b      	ldr	r3, [r7, #16]
 8005e86:	699b      	ldr	r3, [r3, #24]
 8005e88:	697a      	ldr	r2, [r7, #20]
 8005e8a:	429a      	cmp	r2, r3
 8005e8c:	d301      	bcc.n	8005e92 <dir_sdi+0x9c>
 8005e8e:	2302      	movs	r3, #2
 8005e90:	e028      	b.n	8005ee4 <dir_sdi+0xee>
			ofs -= csz;
 8005e92:	683a      	ldr	r2, [r7, #0]
 8005e94:	68fb      	ldr	r3, [r7, #12]
 8005e96:	1ad3      	subs	r3, r2, r3
 8005e98:	603b      	str	r3, [r7, #0]
		while (ofs >= csz) {				/* Follow cluster chain */
 8005e9a:	683a      	ldr	r2, [r7, #0]
 8005e9c:	68fb      	ldr	r3, [r7, #12]
 8005e9e:	429a      	cmp	r2, r3
 8005ea0:	d2e1      	bcs.n	8005e66 <dir_sdi+0x70>
		}
		dp->sect = clst2sect(fs, clst);
 8005ea2:	6979      	ldr	r1, [r7, #20]
 8005ea4:	6938      	ldr	r0, [r7, #16]
 8005ea6:	f7ff fc75 	bl	8005794 <clst2sect>
 8005eaa:	4602      	mov	r2, r0
 8005eac:	687b      	ldr	r3, [r7, #4]
 8005eae:	619a      	str	r2, [r3, #24]
	}
	dp->clust = clst;					/* Current cluster# */
 8005eb0:	687b      	ldr	r3, [r7, #4]
 8005eb2:	697a      	ldr	r2, [r7, #20]
 8005eb4:	615a      	str	r2, [r3, #20]
	if (dp->sect == 0) return FR_INT_ERR;
 8005eb6:	687b      	ldr	r3, [r7, #4]
 8005eb8:	699b      	ldr	r3, [r3, #24]
 8005eba:	2b00      	cmp	r3, #0
 8005ebc:	d101      	bne.n	8005ec2 <dir_sdi+0xcc>
 8005ebe:	2302      	movs	r3, #2
 8005ec0:	e010      	b.n	8005ee4 <dir_sdi+0xee>
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 8005ec2:	687b      	ldr	r3, [r7, #4]
 8005ec4:	699a      	ldr	r2, [r3, #24]
 8005ec6:	683b      	ldr	r3, [r7, #0]
 8005ec8:	0a5b      	lsrs	r3, r3, #9
 8005eca:	441a      	add	r2, r3
 8005ecc:	687b      	ldr	r3, [r7, #4]
 8005ece:	619a      	str	r2, [r3, #24]
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 8005ed0:	693b      	ldr	r3, [r7, #16]
 8005ed2:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8005ed6:	683b      	ldr	r3, [r7, #0]
 8005ed8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005edc:	441a      	add	r2, r3
 8005ede:	687b      	ldr	r3, [r7, #4]
 8005ee0:	61da      	str	r2, [r3, #28]

	return FR_OK;
 8005ee2:	2300      	movs	r3, #0
}
 8005ee4:	4618      	mov	r0, r3
 8005ee6:	3718      	adds	r7, #24
 8005ee8:	46bd      	mov	sp, r7
 8005eea:	bd80      	pop	{r7, pc}

08005eec <dir_next>:

static FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,				/* Pointer to the directory object */
	int stretch				/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
 8005eec:	b580      	push	{r7, lr}
 8005eee:	b086      	sub	sp, #24
 8005ef0:	af00      	add	r7, sp, #0
 8005ef2:	6078      	str	r0, [r7, #4]
 8005ef4:	6039      	str	r1, [r7, #0]
	DWORD ofs, clst;
	FATFS *fs = dp->obj.fs;
 8005ef6:	687b      	ldr	r3, [r7, #4]
 8005ef8:	681b      	ldr	r3, [r3, #0]
 8005efa:	613b      	str	r3, [r7, #16]


	ofs = dp->dptr + SZDIRE;	/* Next entry */
 8005efc:	687b      	ldr	r3, [r7, #4]
 8005efe:	691b      	ldr	r3, [r3, #16]
 8005f00:	3320      	adds	r3, #32
 8005f02:	60fb      	str	r3, [r7, #12]
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
 8005f04:	68fb      	ldr	r3, [r7, #12]
 8005f06:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8005f0a:	d302      	bcc.n	8005f12 <dir_next+0x26>
 8005f0c:	687b      	ldr	r3, [r7, #4]
 8005f0e:	2200      	movs	r2, #0
 8005f10:	619a      	str	r2, [r3, #24]
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 8005f12:	687b      	ldr	r3, [r7, #4]
 8005f14:	699b      	ldr	r3, [r3, #24]
 8005f16:	2b00      	cmp	r3, #0
 8005f18:	d101      	bne.n	8005f1e <dir_next+0x32>
 8005f1a:	2304      	movs	r3, #4
 8005f1c:	e078      	b.n	8006010 <dir_next+0x124>

	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 8005f1e:	68fb      	ldr	r3, [r7, #12]
 8005f20:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005f24:	2b00      	cmp	r3, #0
 8005f26:	d166      	bne.n	8005ff6 <dir_next+0x10a>
		dp->sect++;				/* Next sector */
 8005f28:	687b      	ldr	r3, [r7, #4]
 8005f2a:	699b      	ldr	r3, [r3, #24]
 8005f2c:	1c5a      	adds	r2, r3, #1
 8005f2e:	687b      	ldr	r3, [r7, #4]
 8005f30:	619a      	str	r2, [r3, #24]

		if (dp->clust == 0) {	/* Static table */
 8005f32:	687b      	ldr	r3, [r7, #4]
 8005f34:	695b      	ldr	r3, [r3, #20]
 8005f36:	2b00      	cmp	r3, #0
 8005f38:	d10a      	bne.n	8005f50 <dir_next+0x64>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 8005f3a:	68fb      	ldr	r3, [r7, #12]
 8005f3c:	095b      	lsrs	r3, r3, #5
 8005f3e:	693a      	ldr	r2, [r7, #16]
 8005f40:	8912      	ldrh	r2, [r2, #8]
 8005f42:	4293      	cmp	r3, r2
 8005f44:	d357      	bcc.n	8005ff6 <dir_next+0x10a>
				dp->sect = 0; return FR_NO_FILE;
 8005f46:	687b      	ldr	r3, [r7, #4]
 8005f48:	2200      	movs	r2, #0
 8005f4a:	619a      	str	r2, [r3, #24]
 8005f4c:	2304      	movs	r3, #4
 8005f4e:	e05f      	b.n	8006010 <dir_next+0x124>
			}
		}
		else {					/* Dynamic table */
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
 8005f50:	68fb      	ldr	r3, [r7, #12]
 8005f52:	0a5b      	lsrs	r3, r3, #9
 8005f54:	693a      	ldr	r2, [r7, #16]
 8005f56:	8952      	ldrh	r2, [r2, #10]
 8005f58:	3a01      	subs	r2, #1
 8005f5a:	4013      	ands	r3, r2
 8005f5c:	2b00      	cmp	r3, #0
 8005f5e:	d14a      	bne.n	8005ff6 <dir_next+0x10a>
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
 8005f60:	687a      	ldr	r2, [r7, #4]
 8005f62:	687b      	ldr	r3, [r7, #4]
 8005f64:	695b      	ldr	r3, [r3, #20]
 8005f66:	4619      	mov	r1, r3
 8005f68:	4610      	mov	r0, r2
 8005f6a:	f7ff fc32 	bl	80057d2 <get_fat>
 8005f6e:	6178      	str	r0, [r7, #20]
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 8005f70:	697b      	ldr	r3, [r7, #20]
 8005f72:	2b01      	cmp	r3, #1
 8005f74:	d801      	bhi.n	8005f7a <dir_next+0x8e>
 8005f76:	2302      	movs	r3, #2
 8005f78:	e04a      	b.n	8006010 <dir_next+0x124>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8005f7a:	697b      	ldr	r3, [r7, #20]
 8005f7c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005f80:	d101      	bne.n	8005f86 <dir_next+0x9a>
 8005f82:	2301      	movs	r3, #1
 8005f84:	e044      	b.n	8006010 <dir_next+0x124>
				if (clst >= fs->n_fatent) {					/* It reached end of dynamic table */
 8005f86:	693b      	ldr	r3, [r7, #16]
 8005f88:	699b      	ldr	r3, [r3, #24]
 8005f8a:	697a      	ldr	r2, [r7, #20]
 8005f8c:	429a      	cmp	r2, r3
 8005f8e:	d328      	bcc.n	8005fe2 <dir_next+0xf6>
#if !FF_FS_READONLY
					if (!stretch) {								/* If no stretch, report EOT */
 8005f90:	683b      	ldr	r3, [r7, #0]
 8005f92:	2b00      	cmp	r3, #0
 8005f94:	d104      	bne.n	8005fa0 <dir_next+0xb4>
						dp->sect = 0; return FR_NO_FILE;
 8005f96:	687b      	ldr	r3, [r7, #4]
 8005f98:	2200      	movs	r2, #0
 8005f9a:	619a      	str	r2, [r3, #24]
 8005f9c:	2304      	movs	r3, #4
 8005f9e:	e037      	b.n	8006010 <dir_next+0x124>
					}
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 8005fa0:	687a      	ldr	r2, [r7, #4]
 8005fa2:	687b      	ldr	r3, [r7, #4]
 8005fa4:	695b      	ldr	r3, [r3, #20]
 8005fa6:	4619      	mov	r1, r3
 8005fa8:	4610      	mov	r0, r2
 8005faa:	f7ff fe0b 	bl	8005bc4 <create_chain>
 8005fae:	6178      	str	r0, [r7, #20]
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8005fb0:	697b      	ldr	r3, [r7, #20]
 8005fb2:	2b00      	cmp	r3, #0
 8005fb4:	d101      	bne.n	8005fba <dir_next+0xce>
 8005fb6:	2307      	movs	r3, #7
 8005fb8:	e02a      	b.n	8006010 <dir_next+0x124>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 8005fba:	697b      	ldr	r3, [r7, #20]
 8005fbc:	2b01      	cmp	r3, #1
 8005fbe:	d101      	bne.n	8005fc4 <dir_next+0xd8>
 8005fc0:	2302      	movs	r3, #2
 8005fc2:	e025      	b.n	8006010 <dir_next+0x124>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8005fc4:	697b      	ldr	r3, [r7, #20]
 8005fc6:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005fca:	d101      	bne.n	8005fd0 <dir_next+0xe4>
 8005fcc:	2301      	movs	r3, #1
 8005fce:	e01f      	b.n	8006010 <dir_next+0x124>
					if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
 8005fd0:	6979      	ldr	r1, [r7, #20]
 8005fd2:	6938      	ldr	r0, [r7, #16]
 8005fd4:	f7ff fec7 	bl	8005d66 <dir_clear>
 8005fd8:	4603      	mov	r3, r0
 8005fda:	2b00      	cmp	r3, #0
 8005fdc:	d001      	beq.n	8005fe2 <dir_next+0xf6>
 8005fde:	2301      	movs	r3, #1
 8005fe0:	e016      	b.n	8006010 <dir_next+0x124>
#else
					if (!stretch) dp->sect = 0;					/* (this line is to suppress compiler warning) */
					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dp->clust = clst;		/* Initialize data for new cluster */
 8005fe2:	687b      	ldr	r3, [r7, #4]
 8005fe4:	697a      	ldr	r2, [r7, #20]
 8005fe6:	615a      	str	r2, [r3, #20]
				dp->sect = clst2sect(fs, clst);
 8005fe8:	6979      	ldr	r1, [r7, #20]
 8005fea:	6938      	ldr	r0, [r7, #16]
 8005fec:	f7ff fbd2 	bl	8005794 <clst2sect>
 8005ff0:	4602      	mov	r2, r0
 8005ff2:	687b      	ldr	r3, [r7, #4]
 8005ff4:	619a      	str	r2, [r3, #24]
			}
		}
	}
	dp->dptr = ofs;						/* Current entry */
 8005ff6:	687b      	ldr	r3, [r7, #4]
 8005ff8:	68fa      	ldr	r2, [r7, #12]
 8005ffa:	611a      	str	r2, [r3, #16]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 8005ffc:	693b      	ldr	r3, [r7, #16]
 8005ffe:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8006002:	68fb      	ldr	r3, [r7, #12]
 8006004:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8006008:	441a      	add	r2, r3
 800600a:	687b      	ldr	r3, [r7, #4]
 800600c:	61da      	str	r2, [r3, #28]

	return FR_OK;
 800600e:	2300      	movs	r3, #0
}
 8006010:	4618      	mov	r0, r3
 8006012:	3718      	adds	r7, #24
 8006014:	46bd      	mov	sp, r7
 8006016:	bd80      	pop	{r7, pc}

08006018 <dir_alloc>:

static FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,				/* Pointer to the directory object */
	UINT n_ent				/* Number of contiguous entries to allocate */
)
{
 8006018:	b580      	push	{r7, lr}
 800601a:	b086      	sub	sp, #24
 800601c:	af00      	add	r7, sp, #0
 800601e:	6078      	str	r0, [r7, #4]
 8006020:	6039      	str	r1, [r7, #0]
	FRESULT res;
	UINT n;
	FATFS *fs = dp->obj.fs;
 8006022:	687b      	ldr	r3, [r7, #4]
 8006024:	681b      	ldr	r3, [r3, #0]
 8006026:	60fb      	str	r3, [r7, #12]


	res = dir_sdi(dp, 0);
 8006028:	2100      	movs	r1, #0
 800602a:	6878      	ldr	r0, [r7, #4]
 800602c:	f7ff fee3 	bl	8005df6 <dir_sdi>
 8006030:	4603      	mov	r3, r0
 8006032:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 8006034:	7dfb      	ldrb	r3, [r7, #23]
 8006036:	2b00      	cmp	r3, #0
 8006038:	d12b      	bne.n	8006092 <dir_alloc+0x7a>
		n = 0;
 800603a:	2300      	movs	r3, #0
 800603c:	613b      	str	r3, [r7, #16]
		do {
			res = move_window(fs, dp->sect);
 800603e:	687b      	ldr	r3, [r7, #4]
 8006040:	699b      	ldr	r3, [r3, #24]
 8006042:	4619      	mov	r1, r3
 8006044:	68f8      	ldr	r0, [r7, #12]
 8006046:	f7ff fb0a 	bl	800565e <move_window>
 800604a:	4603      	mov	r3, r0
 800604c:	75fb      	strb	r3, [r7, #23]
			if (res != FR_OK) break;
 800604e:	7dfb      	ldrb	r3, [r7, #23]
 8006050:	2b00      	cmp	r3, #0
 8006052:	d11d      	bne.n	8006090 <dir_alloc+0x78>
#if FF_FS_EXFAT
			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {	/* Is the entry free? */
#else
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {	/* Is the entry free? */
 8006054:	687b      	ldr	r3, [r7, #4]
 8006056:	69db      	ldr	r3, [r3, #28]
 8006058:	781b      	ldrb	r3, [r3, #0]
 800605a:	2be5      	cmp	r3, #229	; 0xe5
 800605c:	d004      	beq.n	8006068 <dir_alloc+0x50>
 800605e:	687b      	ldr	r3, [r7, #4]
 8006060:	69db      	ldr	r3, [r3, #28]
 8006062:	781b      	ldrb	r3, [r3, #0]
 8006064:	2b00      	cmp	r3, #0
 8006066:	d107      	bne.n	8006078 <dir_alloc+0x60>
#endif
				if (++n == n_ent) break;	/* Is a block of contiguous free entries found? */
 8006068:	693b      	ldr	r3, [r7, #16]
 800606a:	3301      	adds	r3, #1
 800606c:	613b      	str	r3, [r7, #16]
 800606e:	693a      	ldr	r2, [r7, #16]
 8006070:	683b      	ldr	r3, [r7, #0]
 8006072:	429a      	cmp	r2, r3
 8006074:	d102      	bne.n	800607c <dir_alloc+0x64>
 8006076:	e00c      	b.n	8006092 <dir_alloc+0x7a>
			} else {
				n = 0;				/* Not a free entry, restart to search */
 8006078:	2300      	movs	r3, #0
 800607a:	613b      	str	r3, [r7, #16]
			}
			res = dir_next(dp, 1);	/* Next entry with table stretch enabled */
 800607c:	2101      	movs	r1, #1
 800607e:	6878      	ldr	r0, [r7, #4]
 8006080:	f7ff ff34 	bl	8005eec <dir_next>
 8006084:	4603      	mov	r3, r0
 8006086:	75fb      	strb	r3, [r7, #23]
		} while (res == FR_OK);
 8006088:	7dfb      	ldrb	r3, [r7, #23]
 800608a:	2b00      	cmp	r3, #0
 800608c:	d0d7      	beq.n	800603e <dir_alloc+0x26>
 800608e:	e000      	b.n	8006092 <dir_alloc+0x7a>
			if (res != FR_OK) break;
 8006090:	bf00      	nop
	}

	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 8006092:	7dfb      	ldrb	r3, [r7, #23]
 8006094:	2b04      	cmp	r3, #4
 8006096:	d101      	bne.n	800609c <dir_alloc+0x84>
 8006098:	2307      	movs	r3, #7
 800609a:	75fb      	strb	r3, [r7, #23]
	return res;
 800609c:	7dfb      	ldrb	r3, [r7, #23]
}
 800609e:	4618      	mov	r0, r3
 80060a0:	3718      	adds	r7, #24
 80060a2:	46bd      	mov	sp, r7
 80060a4:	bd80      	pop	{r7, pc}

080060a6 <ld_clust>:

static DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
	FATFS* fs,			/* Pointer to the fs object */
	const BYTE* dir		/* Pointer to the key entry */
)
{
 80060a6:	b580      	push	{r7, lr}
 80060a8:	b084      	sub	sp, #16
 80060aa:	af00      	add	r7, sp, #0
 80060ac:	6078      	str	r0, [r7, #4]
 80060ae:	6039      	str	r1, [r7, #0]
	DWORD cl;

	cl = ld_word(dir + DIR_FstClusLO);
 80060b0:	683b      	ldr	r3, [r7, #0]
 80060b2:	331a      	adds	r3, #26
 80060b4:	4618      	mov	r0, r3
 80060b6:	f7ff f8f7 	bl	80052a8 <ld_word>
 80060ba:	4603      	mov	r3, r0
 80060bc:	60fb      	str	r3, [r7, #12]
	if (fs->fs_type == FS_FAT32) {
 80060be:	687b      	ldr	r3, [r7, #4]
 80060c0:	781b      	ldrb	r3, [r3, #0]
 80060c2:	2b03      	cmp	r3, #3
 80060c4:	d109      	bne.n	80060da <ld_clust+0x34>
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 80060c6:	683b      	ldr	r3, [r7, #0]
 80060c8:	3314      	adds	r3, #20
 80060ca:	4618      	mov	r0, r3
 80060cc:	f7ff f8ec 	bl	80052a8 <ld_word>
 80060d0:	4603      	mov	r3, r0
 80060d2:	041b      	lsls	r3, r3, #16
 80060d4:	68fa      	ldr	r2, [r7, #12]
 80060d6:	4313      	orrs	r3, r2
 80060d8:	60fb      	str	r3, [r7, #12]
	}

	return cl;
 80060da:	68fb      	ldr	r3, [r7, #12]
}
 80060dc:	4618      	mov	r0, r3
 80060de:	3710      	adds	r7, #16
 80060e0:	46bd      	mov	sp, r7
 80060e2:	bd80      	pop	{r7, pc}

080060e4 <st_clust>:
static void st_clust (
	FATFS* fs,	/* Pointer to the fs object */
	BYTE* dir,	/* Pointer to the key entry */
	DWORD cl	/* Value to be set */
)
{
 80060e4:	b580      	push	{r7, lr}
 80060e6:	b084      	sub	sp, #16
 80060e8:	af00      	add	r7, sp, #0
 80060ea:	60f8      	str	r0, [r7, #12]
 80060ec:	60b9      	str	r1, [r7, #8]
 80060ee:	607a      	str	r2, [r7, #4]
	st_word(dir + DIR_FstClusLO, (WORD)cl);
 80060f0:	68bb      	ldr	r3, [r7, #8]
 80060f2:	331a      	adds	r3, #26
 80060f4:	687a      	ldr	r2, [r7, #4]
 80060f6:	b292      	uxth	r2, r2
 80060f8:	4611      	mov	r1, r2
 80060fa:	4618      	mov	r0, r3
 80060fc:	f7ff f90f 	bl	800531e <st_word>
	if (fs->fs_type == FS_FAT32) {
 8006100:	68fb      	ldr	r3, [r7, #12]
 8006102:	781b      	ldrb	r3, [r3, #0]
 8006104:	2b03      	cmp	r3, #3
 8006106:	d109      	bne.n	800611c <st_clust+0x38>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 8006108:	68bb      	ldr	r3, [r7, #8]
 800610a:	f103 0214 	add.w	r2, r3, #20
 800610e:	687b      	ldr	r3, [r7, #4]
 8006110:	0c1b      	lsrs	r3, r3, #16
 8006112:	b29b      	uxth	r3, r3
 8006114:	4619      	mov	r1, r3
 8006116:	4610      	mov	r0, r2
 8006118:	f7ff f901 	bl	800531e <st_word>
	}
}
 800611c:	bf00      	nop
 800611e:	3710      	adds	r7, #16
 8006120:	46bd      	mov	sp, r7
 8006122:	bd80      	pop	{r7, pc}

08006124 <cmp_lfn>:

static int cmp_lfn (		/* 1:matched, 0:not matched */
	const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer to be compared */
	BYTE* dir				/* Pointer to the directory entry containing the part of LFN */
)
{
 8006124:	b590      	push	{r4, r7, lr}
 8006126:	b087      	sub	sp, #28
 8006128:	af00      	add	r7, sp, #0
 800612a:	6078      	str	r0, [r7, #4]
 800612c:	6039      	str	r1, [r7, #0]
	UINT i, s;
	WCHAR wc, uc;


	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
 800612e:	683b      	ldr	r3, [r7, #0]
 8006130:	331a      	adds	r3, #26
 8006132:	4618      	mov	r0, r3
 8006134:	f7ff f8b8 	bl	80052a8 <ld_word>
 8006138:	4603      	mov	r3, r0
 800613a:	2b00      	cmp	r3, #0
 800613c:	d001      	beq.n	8006142 <cmp_lfn+0x1e>
 800613e:	2300      	movs	r3, #0
 8006140:	e058      	b.n	80061f4 <cmp_lfn+0xd0>

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 8006142:	683b      	ldr	r3, [r7, #0]
 8006144:	781b      	ldrb	r3, [r3, #0]
 8006146:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800614a:	1e5a      	subs	r2, r3, #1
 800614c:	4613      	mov	r3, r2
 800614e:	005b      	lsls	r3, r3, #1
 8006150:	4413      	add	r3, r2
 8006152:	009b      	lsls	r3, r3, #2
 8006154:	4413      	add	r3, r2
 8006156:	617b      	str	r3, [r7, #20]

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8006158:	2301      	movs	r3, #1
 800615a:	81fb      	strh	r3, [r7, #14]
 800615c:	2300      	movs	r3, #0
 800615e:	613b      	str	r3, [r7, #16]
 8006160:	e032      	b.n	80061c8 <cmp_lfn+0xa4>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 8006162:	4a26      	ldr	r2, [pc, #152]	; (80061fc <cmp_lfn+0xd8>)
 8006164:	693b      	ldr	r3, [r7, #16]
 8006166:	4413      	add	r3, r2
 8006168:	781b      	ldrb	r3, [r3, #0]
 800616a:	461a      	mov	r2, r3
 800616c:	683b      	ldr	r3, [r7, #0]
 800616e:	4413      	add	r3, r2
 8006170:	4618      	mov	r0, r3
 8006172:	f7ff f899 	bl	80052a8 <ld_word>
 8006176:	4603      	mov	r3, r0
 8006178:	81bb      	strh	r3, [r7, #12]
		if (wc != 0) {
 800617a:	89fb      	ldrh	r3, [r7, #14]
 800617c:	2b00      	cmp	r3, #0
 800617e:	d019      	beq.n	80061b4 <cmp_lfn+0x90>
			if (i >= FF_MAX_LFN + 1 || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 8006180:	697b      	ldr	r3, [r7, #20]
 8006182:	2bff      	cmp	r3, #255	; 0xff
 8006184:	d811      	bhi.n	80061aa <cmp_lfn+0x86>
 8006186:	89bb      	ldrh	r3, [r7, #12]
 8006188:	4618      	mov	r0, r3
 800618a:	f002 fb8f 	bl	80088ac <ff_wtoupper>
 800618e:	4604      	mov	r4, r0
 8006190:	697b      	ldr	r3, [r7, #20]
 8006192:	1c5a      	adds	r2, r3, #1
 8006194:	617a      	str	r2, [r7, #20]
 8006196:	005b      	lsls	r3, r3, #1
 8006198:	687a      	ldr	r2, [r7, #4]
 800619a:	4413      	add	r3, r2
 800619c:	881b      	ldrh	r3, [r3, #0]
 800619e:	4618      	mov	r0, r3
 80061a0:	f002 fb84 	bl	80088ac <ff_wtoupper>
 80061a4:	4603      	mov	r3, r0
 80061a6:	429c      	cmp	r4, r3
 80061a8:	d001      	beq.n	80061ae <cmp_lfn+0x8a>
				return 0;					/* Not matched */
 80061aa:	2300      	movs	r3, #0
 80061ac:	e022      	b.n	80061f4 <cmp_lfn+0xd0>
			}
			wc = uc;
 80061ae:	89bb      	ldrh	r3, [r7, #12]
 80061b0:	81fb      	strh	r3, [r7, #14]
 80061b2:	e006      	b.n	80061c2 <cmp_lfn+0x9e>
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
 80061b4:	89bb      	ldrh	r3, [r7, #12]
 80061b6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80061ba:	4293      	cmp	r3, r2
 80061bc:	d001      	beq.n	80061c2 <cmp_lfn+0x9e>
 80061be:	2300      	movs	r3, #0
 80061c0:	e018      	b.n	80061f4 <cmp_lfn+0xd0>
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 80061c2:	693b      	ldr	r3, [r7, #16]
 80061c4:	3301      	adds	r3, #1
 80061c6:	613b      	str	r3, [r7, #16]
 80061c8:	693b      	ldr	r3, [r7, #16]
 80061ca:	2b0c      	cmp	r3, #12
 80061cc:	d9c9      	bls.n	8006162 <cmp_lfn+0x3e>
		}
	}

	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 80061ce:	683b      	ldr	r3, [r7, #0]
 80061d0:	781b      	ldrb	r3, [r3, #0]
 80061d2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80061d6:	2b00      	cmp	r3, #0
 80061d8:	d00b      	beq.n	80061f2 <cmp_lfn+0xce>
 80061da:	89fb      	ldrh	r3, [r7, #14]
 80061dc:	2b00      	cmp	r3, #0
 80061de:	d008      	beq.n	80061f2 <cmp_lfn+0xce>
 80061e0:	697b      	ldr	r3, [r7, #20]
 80061e2:	005b      	lsls	r3, r3, #1
 80061e4:	687a      	ldr	r2, [r7, #4]
 80061e6:	4413      	add	r3, r2
 80061e8:	881b      	ldrh	r3, [r3, #0]
 80061ea:	2b00      	cmp	r3, #0
 80061ec:	d001      	beq.n	80061f2 <cmp_lfn+0xce>
 80061ee:	2300      	movs	r3, #0
 80061f0:	e000      	b.n	80061f4 <cmp_lfn+0xd0>

	return 1;		/* The part of LFN matched */
 80061f2:	2301      	movs	r3, #1
}
 80061f4:	4618      	mov	r0, r3
 80061f6:	371c      	adds	r7, #28
 80061f8:	46bd      	mov	sp, r7
 80061fa:	bd90      	pop	{r4, r7, pc}
 80061fc:	08014db8 	.word	0x08014db8

08006200 <pick_lfn>:

static int pick_lfn (	/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
	WCHAR* lfnbuf,		/* Pointer to the LFN working buffer */
	BYTE* dir			/* Pointer to the LFN entry */
)
{
 8006200:	b580      	push	{r7, lr}
 8006202:	b086      	sub	sp, #24
 8006204:	af00      	add	r7, sp, #0
 8006206:	6078      	str	r0, [r7, #4]
 8006208:	6039      	str	r1, [r7, #0]
	UINT i, s;
	WCHAR wc, uc;


	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO is 0 */
 800620a:	683b      	ldr	r3, [r7, #0]
 800620c:	331a      	adds	r3, #26
 800620e:	4618      	mov	r0, r3
 8006210:	f7ff f84a 	bl	80052a8 <ld_word>
 8006214:	4603      	mov	r3, r0
 8006216:	2b00      	cmp	r3, #0
 8006218:	d001      	beq.n	800621e <pick_lfn+0x1e>
 800621a:	2300      	movs	r3, #0
 800621c:	e050      	b.n	80062c0 <pick_lfn+0xc0>

	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 800621e:	683b      	ldr	r3, [r7, #0]
 8006220:	781b      	ldrb	r3, [r3, #0]
 8006222:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8006226:	1e5a      	subs	r2, r3, #1
 8006228:	4613      	mov	r3, r2
 800622a:	005b      	lsls	r3, r3, #1
 800622c:	4413      	add	r3, r2
 800622e:	009b      	lsls	r3, r3, #2
 8006230:	4413      	add	r3, r2
 8006232:	617b      	str	r3, [r7, #20]

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8006234:	2301      	movs	r3, #1
 8006236:	81fb      	strh	r3, [r7, #14]
 8006238:	2300      	movs	r3, #0
 800623a:	613b      	str	r3, [r7, #16]
 800623c:	e028      	b.n	8006290 <pick_lfn+0x90>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800623e:	4a22      	ldr	r2, [pc, #136]	; (80062c8 <pick_lfn+0xc8>)
 8006240:	693b      	ldr	r3, [r7, #16]
 8006242:	4413      	add	r3, r2
 8006244:	781b      	ldrb	r3, [r3, #0]
 8006246:	461a      	mov	r2, r3
 8006248:	683b      	ldr	r3, [r7, #0]
 800624a:	4413      	add	r3, r2
 800624c:	4618      	mov	r0, r3
 800624e:	f7ff f82b 	bl	80052a8 <ld_word>
 8006252:	4603      	mov	r3, r0
 8006254:	81bb      	strh	r3, [r7, #12]
		if (wc != 0) {
 8006256:	89fb      	ldrh	r3, [r7, #14]
 8006258:	2b00      	cmp	r3, #0
 800625a:	d00f      	beq.n	800627c <pick_lfn+0x7c>
			if (i >= FF_MAX_LFN + 1) return 0;	/* Buffer overflow? */
 800625c:	697b      	ldr	r3, [r7, #20]
 800625e:	2bff      	cmp	r3, #255	; 0xff
 8006260:	d901      	bls.n	8006266 <pick_lfn+0x66>
 8006262:	2300      	movs	r3, #0
 8006264:	e02c      	b.n	80062c0 <pick_lfn+0xc0>
			lfnbuf[i++] = wc = uc;			/* Store it */
 8006266:	89bb      	ldrh	r3, [r7, #12]
 8006268:	81fb      	strh	r3, [r7, #14]
 800626a:	697b      	ldr	r3, [r7, #20]
 800626c:	1c5a      	adds	r2, r3, #1
 800626e:	617a      	str	r2, [r7, #20]
 8006270:	005b      	lsls	r3, r3, #1
 8006272:	687a      	ldr	r2, [r7, #4]
 8006274:	4413      	add	r3, r2
 8006276:	89fa      	ldrh	r2, [r7, #14]
 8006278:	801a      	strh	r2, [r3, #0]
 800627a:	e006      	b.n	800628a <pick_lfn+0x8a>
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800627c:	89bb      	ldrh	r3, [r7, #12]
 800627e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006282:	4293      	cmp	r3, r2
 8006284:	d001      	beq.n	800628a <pick_lfn+0x8a>
 8006286:	2300      	movs	r3, #0
 8006288:	e01a      	b.n	80062c0 <pick_lfn+0xc0>
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800628a:	693b      	ldr	r3, [r7, #16]
 800628c:	3301      	adds	r3, #1
 800628e:	613b      	str	r3, [r7, #16]
 8006290:	693b      	ldr	r3, [r7, #16]
 8006292:	2b0c      	cmp	r3, #12
 8006294:	d9d3      	bls.n	800623e <pick_lfn+0x3e>
		}
	}

	if (dir[LDIR_Ord] & LLEF && wc != 0) {	/* Put terminator if it is the last LFN part and not terminated */
 8006296:	683b      	ldr	r3, [r7, #0]
 8006298:	781b      	ldrb	r3, [r3, #0]
 800629a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800629e:	2b00      	cmp	r3, #0
 80062a0:	d00d      	beq.n	80062be <pick_lfn+0xbe>
 80062a2:	89fb      	ldrh	r3, [r7, #14]
 80062a4:	2b00      	cmp	r3, #0
 80062a6:	d00a      	beq.n	80062be <pick_lfn+0xbe>
		if (i >= FF_MAX_LFN + 1) return 0;	/* Buffer overflow? */
 80062a8:	697b      	ldr	r3, [r7, #20]
 80062aa:	2bff      	cmp	r3, #255	; 0xff
 80062ac:	d901      	bls.n	80062b2 <pick_lfn+0xb2>
 80062ae:	2300      	movs	r3, #0
 80062b0:	e006      	b.n	80062c0 <pick_lfn+0xc0>
		lfnbuf[i] = 0;
 80062b2:	697b      	ldr	r3, [r7, #20]
 80062b4:	005b      	lsls	r3, r3, #1
 80062b6:	687a      	ldr	r2, [r7, #4]
 80062b8:	4413      	add	r3, r2
 80062ba:	2200      	movs	r2, #0
 80062bc:	801a      	strh	r2, [r3, #0]
	}

	return 1;		/* The part of LFN is valid */
 80062be:	2301      	movs	r3, #1
}
 80062c0:	4618      	mov	r0, r3
 80062c2:	3718      	adds	r7, #24
 80062c4:	46bd      	mov	sp, r7
 80062c6:	bd80      	pop	{r7, pc}
 80062c8:	08014db8 	.word	0x08014db8

080062cc <put_lfn>:
	const WCHAR* lfn,	/* Pointer to the LFN */
	BYTE* dir,			/* Pointer to the LFN entry to be created */
	BYTE ord,			/* LFN order (1-20) */
	BYTE sum			/* Checksum of the corresponding SFN */
)
{
 80062cc:	b580      	push	{r7, lr}
 80062ce:	b088      	sub	sp, #32
 80062d0:	af00      	add	r7, sp, #0
 80062d2:	60f8      	str	r0, [r7, #12]
 80062d4:	60b9      	str	r1, [r7, #8]
 80062d6:	4611      	mov	r1, r2
 80062d8:	461a      	mov	r2, r3
 80062da:	460b      	mov	r3, r1
 80062dc:	71fb      	strb	r3, [r7, #7]
 80062de:	4613      	mov	r3, r2
 80062e0:	71bb      	strb	r3, [r7, #6]
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set checksum */
 80062e2:	68bb      	ldr	r3, [r7, #8]
 80062e4:	330d      	adds	r3, #13
 80062e6:	79ba      	ldrb	r2, [r7, #6]
 80062e8:	701a      	strb	r2, [r3, #0]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 80062ea:	68bb      	ldr	r3, [r7, #8]
 80062ec:	330b      	adds	r3, #11
 80062ee:	220f      	movs	r2, #15
 80062f0:	701a      	strb	r2, [r3, #0]
	dir[LDIR_Type] = 0;
 80062f2:	68bb      	ldr	r3, [r7, #8]
 80062f4:	330c      	adds	r3, #12
 80062f6:	2200      	movs	r2, #0
 80062f8:	701a      	strb	r2, [r3, #0]
	st_word(dir + LDIR_FstClusLO, 0);
 80062fa:	68bb      	ldr	r3, [r7, #8]
 80062fc:	331a      	adds	r3, #26
 80062fe:	2100      	movs	r1, #0
 8006300:	4618      	mov	r0, r3
 8006302:	f7ff f80c 	bl	800531e <st_word>

	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 8006306:	79fb      	ldrb	r3, [r7, #7]
 8006308:	1e5a      	subs	r2, r3, #1
 800630a:	4613      	mov	r3, r2
 800630c:	005b      	lsls	r3, r3, #1
 800630e:	4413      	add	r3, r2
 8006310:	009b      	lsls	r3, r3, #2
 8006312:	4413      	add	r3, r2
 8006314:	61fb      	str	r3, [r7, #28]
	s = wc = 0;
 8006316:	2300      	movs	r3, #0
 8006318:	82fb      	strh	r3, [r7, #22]
 800631a:	2300      	movs	r3, #0
 800631c:	61bb      	str	r3, [r7, #24]
	do {
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800631e:	8afb      	ldrh	r3, [r7, #22]
 8006320:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8006324:	4293      	cmp	r3, r2
 8006326:	d007      	beq.n	8006338 <put_lfn+0x6c>
 8006328:	69fb      	ldr	r3, [r7, #28]
 800632a:	1c5a      	adds	r2, r3, #1
 800632c:	61fa      	str	r2, [r7, #28]
 800632e:	005b      	lsls	r3, r3, #1
 8006330:	68fa      	ldr	r2, [r7, #12]
 8006332:	4413      	add	r3, r2
 8006334:	881b      	ldrh	r3, [r3, #0]
 8006336:	82fb      	strh	r3, [r7, #22]
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 8006338:	4a17      	ldr	r2, [pc, #92]	; (8006398 <put_lfn+0xcc>)
 800633a:	69bb      	ldr	r3, [r7, #24]
 800633c:	4413      	add	r3, r2
 800633e:	781b      	ldrb	r3, [r3, #0]
 8006340:	461a      	mov	r2, r3
 8006342:	68bb      	ldr	r3, [r7, #8]
 8006344:	4413      	add	r3, r2
 8006346:	8afa      	ldrh	r2, [r7, #22]
 8006348:	4611      	mov	r1, r2
 800634a:	4618      	mov	r0, r3
 800634c:	f7fe ffe7 	bl	800531e <st_word>
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for following items */
 8006350:	8afb      	ldrh	r3, [r7, #22]
 8006352:	2b00      	cmp	r3, #0
 8006354:	d102      	bne.n	800635c <put_lfn+0x90>
 8006356:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800635a:	82fb      	strh	r3, [r7, #22]
	} while (++s < 13);
 800635c:	69bb      	ldr	r3, [r7, #24]
 800635e:	3301      	adds	r3, #1
 8006360:	61bb      	str	r3, [r7, #24]
 8006362:	69bb      	ldr	r3, [r7, #24]
 8006364:	2b0c      	cmp	r3, #12
 8006366:	d9da      	bls.n	800631e <put_lfn+0x52>
	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
 8006368:	8afb      	ldrh	r3, [r7, #22]
 800636a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800636e:	4293      	cmp	r3, r2
 8006370:	d006      	beq.n	8006380 <put_lfn+0xb4>
 8006372:	69fb      	ldr	r3, [r7, #28]
 8006374:	005b      	lsls	r3, r3, #1
 8006376:	68fa      	ldr	r2, [r7, #12]
 8006378:	4413      	add	r3, r2
 800637a:	881b      	ldrh	r3, [r3, #0]
 800637c:	2b00      	cmp	r3, #0
 800637e:	d103      	bne.n	8006388 <put_lfn+0xbc>
 8006380:	79fb      	ldrb	r3, [r7, #7]
 8006382:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8006386:	71fb      	strb	r3, [r7, #7]
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 8006388:	68bb      	ldr	r3, [r7, #8]
 800638a:	79fa      	ldrb	r2, [r7, #7]
 800638c:	701a      	strb	r2, [r3, #0]
}
 800638e:	bf00      	nop
 8006390:	3720      	adds	r7, #32
 8006392:	46bd      	mov	sp, r7
 8006394:	bd80      	pop	{r7, pc}
 8006396:	bf00      	nop
 8006398:	08014db8 	.word	0x08014db8

0800639c <gen_numname>:
	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
	const BYTE* src,	/* Pointer to SFN */
	const WCHAR* lfn,	/* Pointer to LFN */
	UINT seq			/* Sequence number */
)
{
 800639c:	b580      	push	{r7, lr}
 800639e:	b08c      	sub	sp, #48	; 0x30
 80063a0:	af00      	add	r7, sp, #0
 80063a2:	60f8      	str	r0, [r7, #12]
 80063a4:	60b9      	str	r1, [r7, #8]
 80063a6:	607a      	str	r2, [r7, #4]
 80063a8:	603b      	str	r3, [r7, #0]
	UINT i, j;
	WCHAR wc;
	DWORD sreg;


	mem_cpy(dst, src, 11);
 80063aa:	220b      	movs	r2, #11
 80063ac:	68b9      	ldr	r1, [r7, #8]
 80063ae:	68f8      	ldr	r0, [r7, #12]
 80063b0:	f7fe fffc 	bl	80053ac <mem_cpy>

	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 80063b4:	683b      	ldr	r3, [r7, #0]
 80063b6:	2b05      	cmp	r3, #5
 80063b8:	d92b      	bls.n	8006412 <gen_numname+0x76>
		sreg = seq;
 80063ba:	683b      	ldr	r3, [r7, #0]
 80063bc:	61fb      	str	r3, [r7, #28]
		while (*lfn) {	/* Create a CRC as hash value */
 80063be:	e022      	b.n	8006406 <gen_numname+0x6a>
			wc = *lfn++;
 80063c0:	687b      	ldr	r3, [r7, #4]
 80063c2:	1c9a      	adds	r2, r3, #2
 80063c4:	607a      	str	r2, [r7, #4]
 80063c6:	881b      	ldrh	r3, [r3, #0]
 80063c8:	847b      	strh	r3, [r7, #34]	; 0x22
			for (i = 0; i < 16; i++) {
 80063ca:	2300      	movs	r3, #0
 80063cc:	62bb      	str	r3, [r7, #40]	; 0x28
 80063ce:	e017      	b.n	8006400 <gen_numname+0x64>
				sreg = (sreg << 1) + (wc & 1);
 80063d0:	69fb      	ldr	r3, [r7, #28]
 80063d2:	005a      	lsls	r2, r3, #1
 80063d4:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80063d6:	f003 0301 	and.w	r3, r3, #1
 80063da:	4413      	add	r3, r2
 80063dc:	61fb      	str	r3, [r7, #28]
				wc >>= 1;
 80063de:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80063e0:	085b      	lsrs	r3, r3, #1
 80063e2:	847b      	strh	r3, [r7, #34]	; 0x22
				if (sreg & 0x10000) sreg ^= 0x11021;
 80063e4:	69fb      	ldr	r3, [r7, #28]
 80063e6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80063ea:	2b00      	cmp	r3, #0
 80063ec:	d005      	beq.n	80063fa <gen_numname+0x5e>
 80063ee:	69fb      	ldr	r3, [r7, #28]
 80063f0:	f483 3388 	eor.w	r3, r3, #69632	; 0x11000
 80063f4:	f083 0321 	eor.w	r3, r3, #33	; 0x21
 80063f8:	61fb      	str	r3, [r7, #28]
			for (i = 0; i < 16; i++) {
 80063fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80063fc:	3301      	adds	r3, #1
 80063fe:	62bb      	str	r3, [r7, #40]	; 0x28
 8006400:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006402:	2b0f      	cmp	r3, #15
 8006404:	d9e4      	bls.n	80063d0 <gen_numname+0x34>
		while (*lfn) {	/* Create a CRC as hash value */
 8006406:	687b      	ldr	r3, [r7, #4]
 8006408:	881b      	ldrh	r3, [r3, #0]
 800640a:	2b00      	cmp	r3, #0
 800640c:	d1d8      	bne.n	80063c0 <gen_numname+0x24>
			}
		}
		seq = (UINT)sreg;
 800640e:	69fb      	ldr	r3, [r7, #28]
 8006410:	603b      	str	r3, [r7, #0]
	}

	/* itoa (hexdecimal) */
	i = 7;
 8006412:	2307      	movs	r3, #7
 8006414:	62bb      	str	r3, [r7, #40]	; 0x28
	do {
		c = (BYTE)((seq % 16) + '0');
 8006416:	683b      	ldr	r3, [r7, #0]
 8006418:	b2db      	uxtb	r3, r3
 800641a:	f003 030f 	and.w	r3, r3, #15
 800641e:	b2db      	uxtb	r3, r3
 8006420:	3330      	adds	r3, #48	; 0x30
 8006422:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
		if (c > '9') c += 7;
 8006426:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800642a:	2b39      	cmp	r3, #57	; 0x39
 800642c:	d904      	bls.n	8006438 <gen_numname+0x9c>
 800642e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8006432:	3307      	adds	r3, #7
 8006434:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
		ns[i--] = c;
 8006438:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800643a:	1e5a      	subs	r2, r3, #1
 800643c:	62ba      	str	r2, [r7, #40]	; 0x28
 800643e:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8006442:	4413      	add	r3, r2
 8006444:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 8006448:	f803 2c1c 	strb.w	r2, [r3, #-28]
		seq /= 16;
 800644c:	683b      	ldr	r3, [r7, #0]
 800644e:	091b      	lsrs	r3, r3, #4
 8006450:	603b      	str	r3, [r7, #0]
	} while (seq);
 8006452:	683b      	ldr	r3, [r7, #0]
 8006454:	2b00      	cmp	r3, #0
 8006456:	d1de      	bne.n	8006416 <gen_numname+0x7a>
	ns[i] = '~';
 8006458:	f107 0214 	add.w	r2, r7, #20
 800645c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800645e:	4413      	add	r3, r2
 8006460:	227e      	movs	r2, #126	; 0x7e
 8006462:	701a      	strb	r2, [r3, #0]

	/* Append the number to the SFN body */
	for (j = 0; j < i && dst[j] != ' '; j++) {
 8006464:	2300      	movs	r3, #0
 8006466:	627b      	str	r3, [r7, #36]	; 0x24
 8006468:	e014      	b.n	8006494 <gen_numname+0xf8>
		if (dbc_1st(dst[j])) {
 800646a:	68fa      	ldr	r2, [r7, #12]
 800646c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800646e:	4413      	add	r3, r2
 8006470:	781b      	ldrb	r3, [r3, #0]
 8006472:	4618      	mov	r0, r3
 8006474:	f7ff f818 	bl	80054a8 <dbc_1st>
 8006478:	4603      	mov	r3, r0
 800647a:	2b00      	cmp	r3, #0
 800647c:	d007      	beq.n	800648e <gen_numname+0xf2>
			if (j == i - 1) break;
 800647e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006480:	3b01      	subs	r3, #1
 8006482:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006484:	429a      	cmp	r2, r3
 8006486:	d010      	beq.n	80064aa <gen_numname+0x10e>
			j++;
 8006488:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800648a:	3301      	adds	r3, #1
 800648c:	627b      	str	r3, [r7, #36]	; 0x24
	for (j = 0; j < i && dst[j] != ' '; j++) {
 800648e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006490:	3301      	adds	r3, #1
 8006492:	627b      	str	r3, [r7, #36]	; 0x24
 8006494:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006496:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006498:	429a      	cmp	r2, r3
 800649a:	d207      	bcs.n	80064ac <gen_numname+0x110>
 800649c:	68fa      	ldr	r2, [r7, #12]
 800649e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80064a0:	4413      	add	r3, r2
 80064a2:	781b      	ldrb	r3, [r3, #0]
 80064a4:	2b20      	cmp	r3, #32
 80064a6:	d1e0      	bne.n	800646a <gen_numname+0xce>
 80064a8:	e000      	b.n	80064ac <gen_numname+0x110>
			if (j == i - 1) break;
 80064aa:	bf00      	nop
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 80064ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80064ae:	2b07      	cmp	r3, #7
 80064b0:	d808      	bhi.n	80064c4 <gen_numname+0x128>
 80064b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80064b4:	1c5a      	adds	r2, r3, #1
 80064b6:	62ba      	str	r2, [r7, #40]	; 0x28
 80064b8:	f107 0230 	add.w	r2, r7, #48	; 0x30
 80064bc:	4413      	add	r3, r2
 80064be:	f813 1c1c 	ldrb.w	r1, [r3, #-28]
 80064c2:	e000      	b.n	80064c6 <gen_numname+0x12a>
 80064c4:	2120      	movs	r1, #32
 80064c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80064c8:	1c5a      	adds	r2, r3, #1
 80064ca:	627a      	str	r2, [r7, #36]	; 0x24
 80064cc:	68fa      	ldr	r2, [r7, #12]
 80064ce:	4413      	add	r3, r2
 80064d0:	460a      	mov	r2, r1
 80064d2:	701a      	strb	r2, [r3, #0]
	} while (j < 8);
 80064d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80064d6:	2b07      	cmp	r3, #7
 80064d8:	d9e8      	bls.n	80064ac <gen_numname+0x110>
}
 80064da:	bf00      	nop
 80064dc:	bf00      	nop
 80064de:	3730      	adds	r7, #48	; 0x30
 80064e0:	46bd      	mov	sp, r7
 80064e2:	bd80      	pop	{r7, pc}

080064e4 <sum_sfn>:
/*-----------------------------------------------------------------------*/

static BYTE sum_sfn (
	const BYTE* dir		/* Pointer to the SFN entry */
)
{
 80064e4:	b480      	push	{r7}
 80064e6:	b085      	sub	sp, #20
 80064e8:	af00      	add	r7, sp, #0
 80064ea:	6078      	str	r0, [r7, #4]
	BYTE sum = 0;
 80064ec:	2300      	movs	r3, #0
 80064ee:	73fb      	strb	r3, [r7, #15]
	UINT n = 11;
 80064f0:	230b      	movs	r3, #11
 80064f2:	60bb      	str	r3, [r7, #8]

	do {
		sum = (sum >> 1) + (sum << 7) + *dir++;
 80064f4:	7bfb      	ldrb	r3, [r7, #15]
 80064f6:	b2da      	uxtb	r2, r3
 80064f8:	0852      	lsrs	r2, r2, #1
 80064fa:	01db      	lsls	r3, r3, #7
 80064fc:	4313      	orrs	r3, r2
 80064fe:	b2da      	uxtb	r2, r3
 8006500:	687b      	ldr	r3, [r7, #4]
 8006502:	1c59      	adds	r1, r3, #1
 8006504:	6079      	str	r1, [r7, #4]
 8006506:	781b      	ldrb	r3, [r3, #0]
 8006508:	4413      	add	r3, r2
 800650a:	73fb      	strb	r3, [r7, #15]
	} while (--n);
 800650c:	68bb      	ldr	r3, [r7, #8]
 800650e:	3b01      	subs	r3, #1
 8006510:	60bb      	str	r3, [r7, #8]
 8006512:	68bb      	ldr	r3, [r7, #8]
 8006514:	2b00      	cmp	r3, #0
 8006516:	d1ed      	bne.n	80064f4 <sum_sfn+0x10>
	return sum;
 8006518:	7bfb      	ldrb	r3, [r7, #15]
}
 800651a:	4618      	mov	r0, r3
 800651c:	3714      	adds	r7, #20
 800651e:	46bd      	mov	sp, r7
 8006520:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006524:	4770      	bx	lr

08006526 <dir_read>:

static FRESULT dir_read (
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
 8006526:	b580      	push	{r7, lr}
 8006528:	b086      	sub	sp, #24
 800652a:	af00      	add	r7, sp, #0
 800652c:	6078      	str	r0, [r7, #4]
 800652e:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_NO_FILE;
 8006530:	2304      	movs	r3, #4
 8006532:	75fb      	strb	r3, [r7, #23]
	FATFS *fs = dp->obj.fs;
 8006534:	687b      	ldr	r3, [r7, #4]
 8006536:	681b      	ldr	r3, [r3, #0]
 8006538:	613b      	str	r3, [r7, #16]
	BYTE attr, b;
#if FF_USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
 800653a:	23ff      	movs	r3, #255	; 0xff
 800653c:	757b      	strb	r3, [r7, #21]
 800653e:	23ff      	movs	r3, #255	; 0xff
 8006540:	753b      	strb	r3, [r7, #20]
#endif

	while (dp->sect) {
 8006542:	e081      	b.n	8006648 <dir_read+0x122>
		res = move_window(fs, dp->sect);
 8006544:	687b      	ldr	r3, [r7, #4]
 8006546:	699b      	ldr	r3, [r3, #24]
 8006548:	4619      	mov	r1, r3
 800654a:	6938      	ldr	r0, [r7, #16]
 800654c:	f7ff f887 	bl	800565e <move_window>
 8006550:	4603      	mov	r3, r0
 8006552:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 8006554:	7dfb      	ldrb	r3, [r7, #23]
 8006556:	2b00      	cmp	r3, #0
 8006558:	d17c      	bne.n	8006654 <dir_read+0x12e>
		b = dp->dir[DIR_Name];	/* Test for the entry type */
 800655a:	687b      	ldr	r3, [r7, #4]
 800655c:	69db      	ldr	r3, [r3, #28]
 800655e:	781b      	ldrb	r3, [r3, #0]
 8006560:	75bb      	strb	r3, [r7, #22]
		if (b == 0) {
 8006562:	7dbb      	ldrb	r3, [r7, #22]
 8006564:	2b00      	cmp	r3, #0
 8006566:	d102      	bne.n	800656e <dir_read+0x48>
			res = FR_NO_FILE; break; /* Reached to end of the directory */
 8006568:	2304      	movs	r3, #4
 800656a:	75fb      	strb	r3, [r7, #23]
 800656c:	e077      	b.n	800665e <dir_read+0x138>
				}
			}
		} else
#endif
		{	/* On the FAT/FAT32 volume */
			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 800656e:	687b      	ldr	r3, [r7, #4]
 8006570:	69db      	ldr	r3, [r3, #28]
 8006572:	330b      	adds	r3, #11
 8006574:	781b      	ldrb	r3, [r3, #0]
 8006576:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800657a:	73fb      	strb	r3, [r7, #15]
 800657c:	687b      	ldr	r3, [r7, #4]
 800657e:	7bfa      	ldrb	r2, [r7, #15]
 8006580:	719a      	strb	r2, [r3, #6]
#if FF_USE_LFN		/* LFN configuration */
			if (b == DDEM || b == '.' || (int)((attr & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 8006582:	7dbb      	ldrb	r3, [r7, #22]
 8006584:	2be5      	cmp	r3, #229	; 0xe5
 8006586:	d00e      	beq.n	80065a6 <dir_read+0x80>
 8006588:	7dbb      	ldrb	r3, [r7, #22]
 800658a:	2b2e      	cmp	r3, #46	; 0x2e
 800658c:	d00b      	beq.n	80065a6 <dir_read+0x80>
 800658e:	7bfb      	ldrb	r3, [r7, #15]
 8006590:	f023 0320 	bic.w	r3, r3, #32
 8006594:	2b08      	cmp	r3, #8
 8006596:	bf0c      	ite	eq
 8006598:	2301      	moveq	r3, #1
 800659a:	2300      	movne	r3, #0
 800659c:	b2db      	uxtb	r3, r3
 800659e:	461a      	mov	r2, r3
 80065a0:	683b      	ldr	r3, [r7, #0]
 80065a2:	4293      	cmp	r3, r2
 80065a4:	d002      	beq.n	80065ac <dir_read+0x86>
				ord = 0xFF;
 80065a6:	23ff      	movs	r3, #255	; 0xff
 80065a8:	757b      	strb	r3, [r7, #21]
 80065aa:	e044      	b.n	8006636 <dir_read+0x110>
			} else {
				if (attr == AM_LFN) {			/* An LFN entry is found */
 80065ac:	7bfb      	ldrb	r3, [r7, #15]
 80065ae:	2b0f      	cmp	r3, #15
 80065b0:	d12f      	bne.n	8006612 <dir_read+0xec>
					if (b & LLEF) {			/* Is it start of an LFN sequence? */
 80065b2:	7dbb      	ldrb	r3, [r7, #22]
 80065b4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80065b8:	2b00      	cmp	r3, #0
 80065ba:	d00d      	beq.n	80065d8 <dir_read+0xb2>
						sum = dp->dir[LDIR_Chksum];
 80065bc:	687b      	ldr	r3, [r7, #4]
 80065be:	69db      	ldr	r3, [r3, #28]
 80065c0:	7b5b      	ldrb	r3, [r3, #13]
 80065c2:	753b      	strb	r3, [r7, #20]
						b &= (BYTE)~LLEF; ord = b;
 80065c4:	7dbb      	ldrb	r3, [r7, #22]
 80065c6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80065ca:	75bb      	strb	r3, [r7, #22]
 80065cc:	7dbb      	ldrb	r3, [r7, #22]
 80065ce:	757b      	strb	r3, [r7, #21]
						dp->blk_ofs = dp->dptr;
 80065d0:	687b      	ldr	r3, [r7, #4]
 80065d2:	691a      	ldr	r2, [r3, #16]
 80065d4:	687b      	ldr	r3, [r7, #4]
 80065d6:	62da      	str	r2, [r3, #44]	; 0x2c
					}
					/* Check LFN validity and capture it */
					ord = (b == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 80065d8:	7dba      	ldrb	r2, [r7, #22]
 80065da:	7d7b      	ldrb	r3, [r7, #21]
 80065dc:	429a      	cmp	r2, r3
 80065de:	d115      	bne.n	800660c <dir_read+0xe6>
 80065e0:	687b      	ldr	r3, [r7, #4]
 80065e2:	69db      	ldr	r3, [r3, #28]
 80065e4:	330d      	adds	r3, #13
 80065e6:	781b      	ldrb	r3, [r3, #0]
 80065e8:	7d3a      	ldrb	r2, [r7, #20]
 80065ea:	429a      	cmp	r2, r3
 80065ec:	d10e      	bne.n	800660c <dir_read+0xe6>
 80065ee:	693b      	ldr	r3, [r7, #16]
 80065f0:	68da      	ldr	r2, [r3, #12]
 80065f2:	687b      	ldr	r3, [r7, #4]
 80065f4:	69db      	ldr	r3, [r3, #28]
 80065f6:	4619      	mov	r1, r3
 80065f8:	4610      	mov	r0, r2
 80065fa:	f7ff fe01 	bl	8006200 <pick_lfn>
 80065fe:	4603      	mov	r3, r0
 8006600:	2b00      	cmp	r3, #0
 8006602:	d003      	beq.n	800660c <dir_read+0xe6>
 8006604:	7d7b      	ldrb	r3, [r7, #21]
 8006606:	3b01      	subs	r3, #1
 8006608:	b2db      	uxtb	r3, r3
 800660a:	e000      	b.n	800660e <dir_read+0xe8>
 800660c:	23ff      	movs	r3, #255	; 0xff
 800660e:	757b      	strb	r3, [r7, #21]
 8006610:	e011      	b.n	8006636 <dir_read+0x110>
				} else {					/* An SFN entry is found */
					if (ord != 0 || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
 8006612:	7d7b      	ldrb	r3, [r7, #21]
 8006614:	2b00      	cmp	r3, #0
 8006616:	d109      	bne.n	800662c <dir_read+0x106>
 8006618:	687b      	ldr	r3, [r7, #4]
 800661a:	69db      	ldr	r3, [r3, #28]
 800661c:	4618      	mov	r0, r3
 800661e:	f7ff ff61 	bl	80064e4 <sum_sfn>
 8006622:	4603      	mov	r3, r0
 8006624:	461a      	mov	r2, r3
 8006626:	7d3b      	ldrb	r3, [r7, #20]
 8006628:	4293      	cmp	r3, r2
 800662a:	d015      	beq.n	8006658 <dir_read+0x132>
						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
 800662c:	687b      	ldr	r3, [r7, #4]
 800662e:	f04f 32ff 	mov.w	r2, #4294967295
 8006632:	62da      	str	r2, [r3, #44]	; 0x2c
					}
					break;
 8006634:	e010      	b.n	8006658 <dir_read+0x132>
			if (b != DDEM && b != '.' && attr != AM_LFN && (int)((attr & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
				break;
			}
#endif
		}
		res = dir_next(dp, 0);		/* Next entry */
 8006636:	2100      	movs	r1, #0
 8006638:	6878      	ldr	r0, [r7, #4]
 800663a:	f7ff fc57 	bl	8005eec <dir_next>
 800663e:	4603      	mov	r3, r0
 8006640:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 8006642:	7dfb      	ldrb	r3, [r7, #23]
 8006644:	2b00      	cmp	r3, #0
 8006646:	d109      	bne.n	800665c <dir_read+0x136>
	while (dp->sect) {
 8006648:	687b      	ldr	r3, [r7, #4]
 800664a:	699b      	ldr	r3, [r3, #24]
 800664c:	2b00      	cmp	r3, #0
 800664e:	f47f af79 	bne.w	8006544 <dir_read+0x1e>
 8006652:	e004      	b.n	800665e <dir_read+0x138>
		if (res != FR_OK) break;
 8006654:	bf00      	nop
 8006656:	e002      	b.n	800665e <dir_read+0x138>
					break;
 8006658:	bf00      	nop
 800665a:	e000      	b.n	800665e <dir_read+0x138>
		if (res != FR_OK) break;
 800665c:	bf00      	nop
	}

	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 800665e:	7dfb      	ldrb	r3, [r7, #23]
 8006660:	2b00      	cmp	r3, #0
 8006662:	d002      	beq.n	800666a <dir_read+0x144>
 8006664:	687b      	ldr	r3, [r7, #4]
 8006666:	2200      	movs	r2, #0
 8006668:	619a      	str	r2, [r3, #24]
	return res;
 800666a:	7dfb      	ldrb	r3, [r7, #23]
}
 800666c:	4618      	mov	r0, r3
 800666e:	3718      	adds	r7, #24
 8006670:	46bd      	mov	sp, r7
 8006672:	bd80      	pop	{r7, pc}

08006674 <dir_find>:
/*-----------------------------------------------------------------------*/

static FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp					/* Pointer to the directory object with the file name */
)
{
 8006674:	b580      	push	{r7, lr}
 8006676:	b086      	sub	sp, #24
 8006678:	af00      	add	r7, sp, #0
 800667a:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs = dp->obj.fs;
 800667c:	687b      	ldr	r3, [r7, #4]
 800667e:	681b      	ldr	r3, [r3, #0]
 8006680:	613b      	str	r3, [r7, #16]
	BYTE c;
#if FF_USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8006682:	2100      	movs	r1, #0
 8006684:	6878      	ldr	r0, [r7, #4]
 8006686:	f7ff fbb6 	bl	8005df6 <dir_sdi>
 800668a:	4603      	mov	r3, r0
 800668c:	75fb      	strb	r3, [r7, #23]
	if (res != FR_OK) return res;
 800668e:	7dfb      	ldrb	r3, [r7, #23]
 8006690:	2b00      	cmp	r3, #0
 8006692:	d001      	beq.n	8006698 <dir_find+0x24>
 8006694:	7dfb      	ldrb	r3, [r7, #23]
 8006696:	e0a9      	b.n	80067ec <dir_find+0x178>
		return res;
	}
#endif
	/* On the FAT/FAT32 volume */
#if FF_USE_LFN
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 8006698:	23ff      	movs	r3, #255	; 0xff
 800669a:	753b      	strb	r3, [r7, #20]
 800669c:	7d3b      	ldrb	r3, [r7, #20]
 800669e:	757b      	strb	r3, [r7, #21]
 80066a0:	687b      	ldr	r3, [r7, #4]
 80066a2:	f04f 32ff 	mov.w	r2, #4294967295
 80066a6:	62da      	str	r2, [r3, #44]	; 0x2c
#endif
	do {
		res = move_window(fs, dp->sect);
 80066a8:	687b      	ldr	r3, [r7, #4]
 80066aa:	699b      	ldr	r3, [r3, #24]
 80066ac:	4619      	mov	r1, r3
 80066ae:	6938      	ldr	r0, [r7, #16]
 80066b0:	f7fe ffd5 	bl	800565e <move_window>
 80066b4:	4603      	mov	r3, r0
 80066b6:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 80066b8:	7dfb      	ldrb	r3, [r7, #23]
 80066ba:	2b00      	cmp	r3, #0
 80066bc:	f040 8090 	bne.w	80067e0 <dir_find+0x16c>
		c = dp->dir[DIR_Name];
 80066c0:	687b      	ldr	r3, [r7, #4]
 80066c2:	69db      	ldr	r3, [r3, #28]
 80066c4:	781b      	ldrb	r3, [r3, #0]
 80066c6:	75bb      	strb	r3, [r7, #22]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 80066c8:	7dbb      	ldrb	r3, [r7, #22]
 80066ca:	2b00      	cmp	r3, #0
 80066cc:	d102      	bne.n	80066d4 <dir_find+0x60>
 80066ce:	2304      	movs	r3, #4
 80066d0:	75fb      	strb	r3, [r7, #23]
 80066d2:	e08a      	b.n	80067ea <dir_find+0x176>
#if FF_USE_LFN		/* LFN configuration */
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 80066d4:	687b      	ldr	r3, [r7, #4]
 80066d6:	69db      	ldr	r3, [r3, #28]
 80066d8:	330b      	adds	r3, #11
 80066da:	781b      	ldrb	r3, [r3, #0]
 80066dc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80066e0:	73fb      	strb	r3, [r7, #15]
 80066e2:	687b      	ldr	r3, [r7, #4]
 80066e4:	7bfa      	ldrb	r2, [r7, #15]
 80066e6:	719a      	strb	r2, [r3, #6]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 80066e8:	7dbb      	ldrb	r3, [r7, #22]
 80066ea:	2be5      	cmp	r3, #229	; 0xe5
 80066ec:	d007      	beq.n	80066fe <dir_find+0x8a>
 80066ee:	7bfb      	ldrb	r3, [r7, #15]
 80066f0:	f003 0308 	and.w	r3, r3, #8
 80066f4:	2b00      	cmp	r3, #0
 80066f6:	d009      	beq.n	800670c <dir_find+0x98>
 80066f8:	7bfb      	ldrb	r3, [r7, #15]
 80066fa:	2b0f      	cmp	r3, #15
 80066fc:	d006      	beq.n	800670c <dir_find+0x98>
			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 80066fe:	23ff      	movs	r3, #255	; 0xff
 8006700:	757b      	strb	r3, [r7, #21]
 8006702:	687b      	ldr	r3, [r7, #4]
 8006704:	f04f 32ff 	mov.w	r2, #4294967295
 8006708:	62da      	str	r2, [r3, #44]	; 0x2c
 800670a:	e05e      	b.n	80067ca <dir_find+0x156>
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
 800670c:	7bfb      	ldrb	r3, [r7, #15]
 800670e:	2b0f      	cmp	r3, #15
 8006710:	d136      	bne.n	8006780 <dir_find+0x10c>
				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
 8006712:	687b      	ldr	r3, [r7, #4]
 8006714:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
 8006718:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800671c:	2b00      	cmp	r3, #0
 800671e:	d154      	bne.n	80067ca <dir_find+0x156>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 8006720:	7dbb      	ldrb	r3, [r7, #22]
 8006722:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006726:	2b00      	cmp	r3, #0
 8006728:	d00d      	beq.n	8006746 <dir_find+0xd2>
						sum = dp->dir[LDIR_Chksum];
 800672a:	687b      	ldr	r3, [r7, #4]
 800672c:	69db      	ldr	r3, [r3, #28]
 800672e:	7b5b      	ldrb	r3, [r3, #13]
 8006730:	753b      	strb	r3, [r7, #20]
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
 8006732:	7dbb      	ldrb	r3, [r7, #22]
 8006734:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8006738:	75bb      	strb	r3, [r7, #22]
 800673a:	7dbb      	ldrb	r3, [r7, #22]
 800673c:	757b      	strb	r3, [r7, #21]
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 800673e:	687b      	ldr	r3, [r7, #4]
 8006740:	691a      	ldr	r2, [r3, #16]
 8006742:	687b      	ldr	r3, [r7, #4]
 8006744:	62da      	str	r2, [r3, #44]	; 0x2c
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8006746:	7dba      	ldrb	r2, [r7, #22]
 8006748:	7d7b      	ldrb	r3, [r7, #21]
 800674a:	429a      	cmp	r2, r3
 800674c:	d115      	bne.n	800677a <dir_find+0x106>
 800674e:	687b      	ldr	r3, [r7, #4]
 8006750:	69db      	ldr	r3, [r3, #28]
 8006752:	330d      	adds	r3, #13
 8006754:	781b      	ldrb	r3, [r3, #0]
 8006756:	7d3a      	ldrb	r2, [r7, #20]
 8006758:	429a      	cmp	r2, r3
 800675a:	d10e      	bne.n	800677a <dir_find+0x106>
 800675c:	693b      	ldr	r3, [r7, #16]
 800675e:	68da      	ldr	r2, [r3, #12]
 8006760:	687b      	ldr	r3, [r7, #4]
 8006762:	69db      	ldr	r3, [r3, #28]
 8006764:	4619      	mov	r1, r3
 8006766:	4610      	mov	r0, r2
 8006768:	f7ff fcdc 	bl	8006124 <cmp_lfn>
 800676c:	4603      	mov	r3, r0
 800676e:	2b00      	cmp	r3, #0
 8006770:	d003      	beq.n	800677a <dir_find+0x106>
 8006772:	7d7b      	ldrb	r3, [r7, #21]
 8006774:	3b01      	subs	r3, #1
 8006776:	b2db      	uxtb	r3, r3
 8006778:	e000      	b.n	800677c <dir_find+0x108>
 800677a:	23ff      	movs	r3, #255	; 0xff
 800677c:	757b      	strb	r3, [r7, #21]
 800677e:	e024      	b.n	80067ca <dir_find+0x156>
				}
			} else {					/* An SFN entry is found */
				if (ord == 0 && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 8006780:	7d7b      	ldrb	r3, [r7, #21]
 8006782:	2b00      	cmp	r3, #0
 8006784:	d109      	bne.n	800679a <dir_find+0x126>
 8006786:	687b      	ldr	r3, [r7, #4]
 8006788:	69db      	ldr	r3, [r3, #28]
 800678a:	4618      	mov	r0, r3
 800678c:	f7ff feaa 	bl	80064e4 <sum_sfn>
 8006790:	4603      	mov	r3, r0
 8006792:	461a      	mov	r2, r3
 8006794:	7d3b      	ldrb	r3, [r7, #20]
 8006796:	4293      	cmp	r3, r2
 8006798:	d024      	beq.n	80067e4 <dir_find+0x170>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 800679a:	687b      	ldr	r3, [r7, #4]
 800679c:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
 80067a0:	f003 0301 	and.w	r3, r3, #1
 80067a4:	2b00      	cmp	r3, #0
 80067a6:	d10a      	bne.n	80067be <dir_find+0x14a>
 80067a8:	687b      	ldr	r3, [r7, #4]
 80067aa:	69d8      	ldr	r0, [r3, #28]
 80067ac:	687b      	ldr	r3, [r7, #4]
 80067ae:	3320      	adds	r3, #32
 80067b0:	220b      	movs	r2, #11
 80067b2:	4619      	mov	r1, r3
 80067b4:	f7fe fe36 	bl	8005424 <mem_cmp>
 80067b8:	4603      	mov	r3, r0
 80067ba:	2b00      	cmp	r3, #0
 80067bc:	d014      	beq.n	80067e8 <dir_find+0x174>
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 80067be:	23ff      	movs	r3, #255	; 0xff
 80067c0:	757b      	strb	r3, [r7, #21]
 80067c2:	687b      	ldr	r3, [r7, #4]
 80067c4:	f04f 32ff 	mov.w	r2, #4294967295
 80067c8:	62da      	str	r2, [r3, #44]	; 0x2c
		}
#else		/* Non LFN configuration */
		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
#endif
		res = dir_next(dp, 0);	/* Next entry */
 80067ca:	2100      	movs	r1, #0
 80067cc:	6878      	ldr	r0, [r7, #4]
 80067ce:	f7ff fb8d 	bl	8005eec <dir_next>
 80067d2:	4603      	mov	r3, r0
 80067d4:	75fb      	strb	r3, [r7, #23]
	} while (res == FR_OK);
 80067d6:	7dfb      	ldrb	r3, [r7, #23]
 80067d8:	2b00      	cmp	r3, #0
 80067da:	f43f af65 	beq.w	80066a8 <dir_find+0x34>
 80067de:	e004      	b.n	80067ea <dir_find+0x176>
		if (res != FR_OK) break;
 80067e0:	bf00      	nop
 80067e2:	e002      	b.n	80067ea <dir_find+0x176>
				if (ord == 0 && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 80067e4:	bf00      	nop
 80067e6:	e000      	b.n	80067ea <dir_find+0x176>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 80067e8:	bf00      	nop

	return res;
 80067ea:	7dfb      	ldrb	r3, [r7, #23]
}
 80067ec:	4618      	mov	r0, r3
 80067ee:	3718      	adds	r7, #24
 80067f0:	46bd      	mov	sp, r7
 80067f2:	bd80      	pop	{r7, pc}

080067f4 <dir_register>:
/*-----------------------------------------------------------------------*/

static FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp						/* Target directory with object name to be created */
)
{
 80067f4:	b580      	push	{r7, lr}
 80067f6:	b08c      	sub	sp, #48	; 0x30
 80067f8:	af00      	add	r7, sp, #0
 80067fa:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs = dp->obj.fs;
 80067fc:	687b      	ldr	r3, [r7, #4]
 80067fe:	681b      	ldr	r3, [r3, #0]
 8006800:	61fb      	str	r3, [r7, #28]
#if FF_USE_LFN		/* LFN configuration */
	UINT n, len, n_ent;
	BYTE sn[12], sum;


	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 8006802:	687b      	ldr	r3, [r7, #4]
 8006804:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
 8006808:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
 800680c:	2b00      	cmp	r3, #0
 800680e:	d001      	beq.n	8006814 <dir_register+0x20>
 8006810:	2306      	movs	r3, #6
 8006812:	e0e0      	b.n	80069d6 <dir_register+0x1e2>
	for (len = 0; fs->lfnbuf[len]; len++) ;	/* Get lfn length */
 8006814:	2300      	movs	r3, #0
 8006816:	627b      	str	r3, [r7, #36]	; 0x24
 8006818:	e002      	b.n	8006820 <dir_register+0x2c>
 800681a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800681c:	3301      	adds	r3, #1
 800681e:	627b      	str	r3, [r7, #36]	; 0x24
 8006820:	69fb      	ldr	r3, [r7, #28]
 8006822:	68da      	ldr	r2, [r3, #12]
 8006824:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006826:	005b      	lsls	r3, r3, #1
 8006828:	4413      	add	r3, r2
 800682a:	881b      	ldrh	r3, [r3, #0]
 800682c:	2b00      	cmp	r3, #0
 800682e:	d1f4      	bne.n	800681a <dir_register+0x26>
		create_xdir(fs->dirbuf, fs->lfnbuf);	/* Create on-memory directory block to be written later */
		return FR_OK;
	}
#endif
	/* On the FAT/FAT32 volume */
	mem_cpy(sn, dp->fn, 12);
 8006830:	687b      	ldr	r3, [r7, #4]
 8006832:	f103 0120 	add.w	r1, r3, #32
 8006836:	f107 030c 	add.w	r3, r7, #12
 800683a:	220c      	movs	r2, #12
 800683c:	4618      	mov	r0, r3
 800683e:	f7fe fdb5 	bl	80053ac <mem_cpy>
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 8006842:	7dfb      	ldrb	r3, [r7, #23]
 8006844:	f003 0301 	and.w	r3, r3, #1
 8006848:	2b00      	cmp	r3, #0
 800684a:	d032      	beq.n	80068b2 <dir_register+0xbe>
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
 800684c:	687b      	ldr	r3, [r7, #4]
 800684e:	2240      	movs	r2, #64	; 0x40
 8006850:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
		for (n = 1; n < 100; n++) {
 8006854:	2301      	movs	r3, #1
 8006856:	62bb      	str	r3, [r7, #40]	; 0x28
 8006858:	e016      	b.n	8006888 <dir_register+0x94>
			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
 800685a:	687b      	ldr	r3, [r7, #4]
 800685c:	f103 0020 	add.w	r0, r3, #32
 8006860:	69fb      	ldr	r3, [r7, #28]
 8006862:	68da      	ldr	r2, [r3, #12]
 8006864:	f107 010c 	add.w	r1, r7, #12
 8006868:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800686a:	f7ff fd97 	bl	800639c <gen_numname>
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
 800686e:	6878      	ldr	r0, [r7, #4]
 8006870:	f7ff ff00 	bl	8006674 <dir_find>
 8006874:	4603      	mov	r3, r0
 8006876:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
			if (res != FR_OK) break;
 800687a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800687e:	2b00      	cmp	r3, #0
 8006880:	d106      	bne.n	8006890 <dir_register+0x9c>
		for (n = 1; n < 100; n++) {
 8006882:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006884:	3301      	adds	r3, #1
 8006886:	62bb      	str	r3, [r7, #40]	; 0x28
 8006888:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800688a:	2b63      	cmp	r3, #99	; 0x63
 800688c:	d9e5      	bls.n	800685a <dir_register+0x66>
 800688e:	e000      	b.n	8006892 <dir_register+0x9e>
			if (res != FR_OK) break;
 8006890:	bf00      	nop
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 8006892:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006894:	2b64      	cmp	r3, #100	; 0x64
 8006896:	d101      	bne.n	800689c <dir_register+0xa8>
 8006898:	2307      	movs	r3, #7
 800689a:	e09c      	b.n	80069d6 <dir_register+0x1e2>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 800689c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 80068a0:	2b04      	cmp	r3, #4
 80068a2:	d002      	beq.n	80068aa <dir_register+0xb6>
 80068a4:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 80068a8:	e095      	b.n	80069d6 <dir_register+0x1e2>
		dp->fn[NSFLAG] = sn[NSFLAG];
 80068aa:	7dfa      	ldrb	r2, [r7, #23]
 80068ac:	687b      	ldr	r3, [r7, #4]
 80068ae:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
	}

	/* Create an SFN with/without LFNs. */
	n_ent = (sn[NSFLAG] & NS_LFN) ? (len + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 80068b2:	7dfb      	ldrb	r3, [r7, #23]
 80068b4:	f003 0302 	and.w	r3, r3, #2
 80068b8:	2b00      	cmp	r3, #0
 80068ba:	d007      	beq.n	80068cc <dir_register+0xd8>
 80068bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80068be:	330c      	adds	r3, #12
 80068c0:	4a47      	ldr	r2, [pc, #284]	; (80069e0 <dir_register+0x1ec>)
 80068c2:	fba2 2303 	umull	r2, r3, r2, r3
 80068c6:	089b      	lsrs	r3, r3, #2
 80068c8:	3301      	adds	r3, #1
 80068ca:	e000      	b.n	80068ce <dir_register+0xda>
 80068cc:	2301      	movs	r3, #1
 80068ce:	623b      	str	r3, [r7, #32]
	res = dir_alloc(dp, n_ent);		/* Allocate entries */
 80068d0:	6a39      	ldr	r1, [r7, #32]
 80068d2:	6878      	ldr	r0, [r7, #4]
 80068d4:	f7ff fba0 	bl	8006018 <dir_alloc>
 80068d8:	4603      	mov	r3, r0
 80068da:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	if (res == FR_OK && --n_ent) {	/* Set LFN entry if needed */
 80068de:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 80068e2:	2b00      	cmp	r3, #0
 80068e4:	d148      	bne.n	8006978 <dir_register+0x184>
 80068e6:	6a3b      	ldr	r3, [r7, #32]
 80068e8:	3b01      	subs	r3, #1
 80068ea:	623b      	str	r3, [r7, #32]
 80068ec:	6a3b      	ldr	r3, [r7, #32]
 80068ee:	2b00      	cmp	r3, #0
 80068f0:	d042      	beq.n	8006978 <dir_register+0x184>
		res = dir_sdi(dp, dp->dptr - n_ent * SZDIRE);
 80068f2:	687b      	ldr	r3, [r7, #4]
 80068f4:	691a      	ldr	r2, [r3, #16]
 80068f6:	6a3b      	ldr	r3, [r7, #32]
 80068f8:	015b      	lsls	r3, r3, #5
 80068fa:	1ad3      	subs	r3, r2, r3
 80068fc:	4619      	mov	r1, r3
 80068fe:	6878      	ldr	r0, [r7, #4]
 8006900:	f7ff fa79 	bl	8005df6 <dir_sdi>
 8006904:	4603      	mov	r3, r0
 8006906:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
		if (res == FR_OK) {
 800690a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800690e:	2b00      	cmp	r3, #0
 8006910:	d132      	bne.n	8006978 <dir_register+0x184>
			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
 8006912:	687b      	ldr	r3, [r7, #4]
 8006914:	3320      	adds	r3, #32
 8006916:	4618      	mov	r0, r3
 8006918:	f7ff fde4 	bl	80064e4 <sum_sfn>
 800691c:	4603      	mov	r3, r0
 800691e:	76fb      	strb	r3, [r7, #27]
			do {					/* Store LFN entries in bottom first */
				res = move_window(fs, dp->sect);
 8006920:	687b      	ldr	r3, [r7, #4]
 8006922:	699b      	ldr	r3, [r3, #24]
 8006924:	4619      	mov	r1, r3
 8006926:	69f8      	ldr	r0, [r7, #28]
 8006928:	f7fe fe99 	bl	800565e <move_window>
 800692c:	4603      	mov	r3, r0
 800692e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
				if (res != FR_OK) break;
 8006932:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8006936:	2b00      	cmp	r3, #0
 8006938:	d11d      	bne.n	8006976 <dir_register+0x182>
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)n_ent, sum);
 800693a:	69fb      	ldr	r3, [r7, #28]
 800693c:	68d8      	ldr	r0, [r3, #12]
 800693e:	687b      	ldr	r3, [r7, #4]
 8006940:	69d9      	ldr	r1, [r3, #28]
 8006942:	6a3b      	ldr	r3, [r7, #32]
 8006944:	b2da      	uxtb	r2, r3
 8006946:	7efb      	ldrb	r3, [r7, #27]
 8006948:	f7ff fcc0 	bl	80062cc <put_lfn>
				fs->wflag = 1;
 800694c:	69fb      	ldr	r3, [r7, #28]
 800694e:	2201      	movs	r2, #1
 8006950:	70da      	strb	r2, [r3, #3]
				res = dir_next(dp, 0);	/* Next entry */
 8006952:	2100      	movs	r1, #0
 8006954:	6878      	ldr	r0, [r7, #4]
 8006956:	f7ff fac9 	bl	8005eec <dir_next>
 800695a:	4603      	mov	r3, r0
 800695c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
			} while (res == FR_OK && --n_ent);
 8006960:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8006964:	2b00      	cmp	r3, #0
 8006966:	d107      	bne.n	8006978 <dir_register+0x184>
 8006968:	6a3b      	ldr	r3, [r7, #32]
 800696a:	3b01      	subs	r3, #1
 800696c:	623b      	str	r3, [r7, #32]
 800696e:	6a3b      	ldr	r3, [r7, #32]
 8006970:	2b00      	cmp	r3, #0
 8006972:	d1d5      	bne.n	8006920 <dir_register+0x12c>
 8006974:	e000      	b.n	8006978 <dir_register+0x184>
				if (res != FR_OK) break;
 8006976:	bf00      	nop
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */

#endif

	/* Set SFN entry */
	if (res == FR_OK) {
 8006978:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800697c:	2b00      	cmp	r3, #0
 800697e:	d128      	bne.n	80069d2 <dir_register+0x1de>
		res = move_window(fs, dp->sect);
 8006980:	687b      	ldr	r3, [r7, #4]
 8006982:	699b      	ldr	r3, [r3, #24]
 8006984:	4619      	mov	r1, r3
 8006986:	69f8      	ldr	r0, [r7, #28]
 8006988:	f7fe fe69 	bl	800565e <move_window>
 800698c:	4603      	mov	r3, r0
 800698e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
		if (res == FR_OK) {
 8006992:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8006996:	2b00      	cmp	r3, #0
 8006998:	d11b      	bne.n	80069d2 <dir_register+0x1de>
			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
 800699a:	687b      	ldr	r3, [r7, #4]
 800699c:	69db      	ldr	r3, [r3, #28]
 800699e:	2220      	movs	r2, #32
 80069a0:	2100      	movs	r1, #0
 80069a2:	4618      	mov	r0, r3
 80069a4:	f7fe fd23 	bl	80053ee <mem_set>
			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
 80069a8:	687b      	ldr	r3, [r7, #4]
 80069aa:	69d8      	ldr	r0, [r3, #28]
 80069ac:	687b      	ldr	r3, [r7, #4]
 80069ae:	3320      	adds	r3, #32
 80069b0:	220b      	movs	r2, #11
 80069b2:	4619      	mov	r1, r3
 80069b4:	f7fe fcfa 	bl	80053ac <mem_cpy>
#if FF_USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 80069b8:	687b      	ldr	r3, [r7, #4]
 80069ba:	f893 202b 	ldrb.w	r2, [r3, #43]	; 0x2b
 80069be:	687b      	ldr	r3, [r7, #4]
 80069c0:	69db      	ldr	r3, [r3, #28]
 80069c2:	330c      	adds	r3, #12
 80069c4:	f002 0218 	and.w	r2, r2, #24
 80069c8:	b2d2      	uxtb	r2, r2
 80069ca:	701a      	strb	r2, [r3, #0]
#endif
			fs->wflag = 1;
 80069cc:	69fb      	ldr	r3, [r7, #28]
 80069ce:	2201      	movs	r2, #1
 80069d0:	70da      	strb	r2, [r3, #3]
		}
	}

	return res;
 80069d2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
}
 80069d6:	4618      	mov	r0, r3
 80069d8:	3730      	adds	r7, #48	; 0x30
 80069da:	46bd      	mov	sp, r7
 80069dc:	bd80      	pop	{r7, pc}
 80069de:	bf00      	nop
 80069e0:	4ec4ec4f 	.word	0x4ec4ec4f

080069e4 <get_fileinfo>:

static void get_fileinfo (
	DIR* dp,			/* Pointer to the directory object */
	FILINFO* fno		/* Pointer to the file information to be filled */
)
{
 80069e4:	b580      	push	{r7, lr}
 80069e6:	b088      	sub	sp, #32
 80069e8:	af00      	add	r7, sp, #0
 80069ea:	6078      	str	r0, [r7, #4]
 80069ec:	6039      	str	r1, [r7, #0]
	UINT si, di;
#if FF_USE_LFN
	BYTE lcf;
	WCHAR wc, hs;
	FATFS *fs = dp->obj.fs;
 80069ee:	687b      	ldr	r3, [r7, #4]
 80069f0:	681b      	ldr	r3, [r3, #0]
 80069f2:	60fb      	str	r3, [r7, #12]
#else
	TCHAR c;
#endif


	fno->fname[0] = 0;			/* Invaidate file info */
 80069f4:	683b      	ldr	r3, [r7, #0]
 80069f6:	2200      	movs	r2, #0
 80069f8:	759a      	strb	r2, [r3, #22]
	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
 80069fa:	687b      	ldr	r3, [r7, #4]
 80069fc:	699b      	ldr	r3, [r3, #24]
 80069fe:	2b00      	cmp	r3, #0
 8006a00:	f000 8103 	beq.w	8006c0a <get_fileinfo+0x226>
		get_xfileinfo(fs->dirbuf, fno);
		return;
	} else
#endif
	{	/* On the FAT/FAT32 volume */
		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
 8006a04:	687b      	ldr	r3, [r7, #4]
 8006a06:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006a08:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006a0c:	d04e      	beq.n	8006aac <get_fileinfo+0xc8>
			si = di = hs = 0;
 8006a0e:	2300      	movs	r3, #0
 8006a10:	827b      	strh	r3, [r7, #18]
 8006a12:	2300      	movs	r3, #0
 8006a14:	61bb      	str	r3, [r7, #24]
 8006a16:	69bb      	ldr	r3, [r7, #24]
 8006a18:	61fb      	str	r3, [r7, #28]
			while (fs->lfnbuf[si] != 0) {
 8006a1a:	e034      	b.n	8006a86 <get_fileinfo+0xa2>
				wc = fs->lfnbuf[si++];		/* Get an LFN character (UTF-16) */
 8006a1c:	68fb      	ldr	r3, [r7, #12]
 8006a1e:	68da      	ldr	r2, [r3, #12]
 8006a20:	69fb      	ldr	r3, [r7, #28]
 8006a22:	1c59      	adds	r1, r3, #1
 8006a24:	61f9      	str	r1, [r7, #28]
 8006a26:	005b      	lsls	r3, r3, #1
 8006a28:	4413      	add	r3, r2
 8006a2a:	881b      	ldrh	r3, [r3, #0]
 8006a2c:	82bb      	strh	r3, [r7, #20]
				if (hs == 0 && IsSurrogate(wc)) {	/* Is it a surrogate? */
 8006a2e:	8a7b      	ldrh	r3, [r7, #18]
 8006a30:	2b00      	cmp	r3, #0
 8006a32:	d10a      	bne.n	8006a4a <get_fileinfo+0x66>
 8006a34:	8abb      	ldrh	r3, [r7, #20]
 8006a36:	f5b3 4f58 	cmp.w	r3, #55296	; 0xd800
 8006a3a:	d306      	bcc.n	8006a4a <get_fileinfo+0x66>
 8006a3c:	8abb      	ldrh	r3, [r7, #20]
 8006a3e:	f5b3 4f60 	cmp.w	r3, #57344	; 0xe000
 8006a42:	d202      	bcs.n	8006a4a <get_fileinfo+0x66>
					hs = wc; continue;		/* Get low surrogate */
 8006a44:	8abb      	ldrh	r3, [r7, #20]
 8006a46:	827b      	strh	r3, [r7, #18]
 8006a48:	e01d      	b.n	8006a86 <get_fileinfo+0xa2>
				}
				wc = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in UTF-16 or UTF-8 encoding */
 8006a4a:	8a7b      	ldrh	r3, [r7, #18]
 8006a4c:	041a      	lsls	r2, r3, #16
 8006a4e:	8abb      	ldrh	r3, [r7, #20]
 8006a50:	ea42 0003 	orr.w	r0, r2, r3
 8006a54:	69bb      	ldr	r3, [r7, #24]
 8006a56:	3310      	adds	r3, #16
 8006a58:	683a      	ldr	r2, [r7, #0]
 8006a5a:	4413      	add	r3, r2
 8006a5c:	1d99      	adds	r1, r3, #6
 8006a5e:	69bb      	ldr	r3, [r7, #24]
 8006a60:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8006a64:	461a      	mov	r2, r3
 8006a66:	f7fe fd86 	bl	8005576 <put_utf>
 8006a6a:	4603      	mov	r3, r0
 8006a6c:	82bb      	strh	r3, [r7, #20]
				if (wc == 0) { di = 0; break; }	/* Invalid char or buffer overflow? */
 8006a6e:	8abb      	ldrh	r3, [r7, #20]
 8006a70:	2b00      	cmp	r3, #0
 8006a72:	d102      	bne.n	8006a7a <get_fileinfo+0x96>
 8006a74:	2300      	movs	r3, #0
 8006a76:	61bb      	str	r3, [r7, #24]
 8006a78:	e00d      	b.n	8006a96 <get_fileinfo+0xb2>
				di += wc;
 8006a7a:	8abb      	ldrh	r3, [r7, #20]
 8006a7c:	69ba      	ldr	r2, [r7, #24]
 8006a7e:	4413      	add	r3, r2
 8006a80:	61bb      	str	r3, [r7, #24]
				hs = 0;
 8006a82:	2300      	movs	r3, #0
 8006a84:	827b      	strh	r3, [r7, #18]
			while (fs->lfnbuf[si] != 0) {
 8006a86:	68fb      	ldr	r3, [r7, #12]
 8006a88:	68da      	ldr	r2, [r3, #12]
 8006a8a:	69fb      	ldr	r3, [r7, #28]
 8006a8c:	005b      	lsls	r3, r3, #1
 8006a8e:	4413      	add	r3, r2
 8006a90:	881b      	ldrh	r3, [r3, #0]
 8006a92:	2b00      	cmp	r3, #0
 8006a94:	d1c2      	bne.n	8006a1c <get_fileinfo+0x38>
			}
			if (hs != 0) di = 0;	/* Broken surrogate pair? */
 8006a96:	8a7b      	ldrh	r3, [r7, #18]
 8006a98:	2b00      	cmp	r3, #0
 8006a9a:	d001      	beq.n	8006aa0 <get_fileinfo+0xbc>
 8006a9c:	2300      	movs	r3, #0
 8006a9e:	61bb      	str	r3, [r7, #24]
			fno->fname[di] = 0;		/* Terminate the LFN (null string means LFN is invalid) */
 8006aa0:	683a      	ldr	r2, [r7, #0]
 8006aa2:	69bb      	ldr	r3, [r7, #24]
 8006aa4:	4413      	add	r3, r2
 8006aa6:	3316      	adds	r3, #22
 8006aa8:	2200      	movs	r2, #0
 8006aaa:	701a      	strb	r2, [r3, #0]
		}
	}

	si = di = 0;
 8006aac:	2300      	movs	r3, #0
 8006aae:	61bb      	str	r3, [r7, #24]
 8006ab0:	69bb      	ldr	r3, [r7, #24]
 8006ab2:	61fb      	str	r3, [r7, #28]
	while (si < 11) {		/* Get SFN from SFN entry */
 8006ab4:	e026      	b.n	8006b04 <get_fileinfo+0x120>
		wc = dp->dir[si++];			/* Get a char */
 8006ab6:	687b      	ldr	r3, [r7, #4]
 8006ab8:	69da      	ldr	r2, [r3, #28]
 8006aba:	69fb      	ldr	r3, [r7, #28]
 8006abc:	1c59      	adds	r1, r3, #1
 8006abe:	61f9      	str	r1, [r7, #28]
 8006ac0:	4413      	add	r3, r2
 8006ac2:	781b      	ldrb	r3, [r3, #0]
 8006ac4:	82bb      	strh	r3, [r7, #20]
		if (wc == ' ') continue;	/* Skip padding spaces */
 8006ac6:	8abb      	ldrh	r3, [r7, #20]
 8006ac8:	2b20      	cmp	r3, #32
 8006aca:	d100      	bne.n	8006ace <get_fileinfo+0xea>
 8006acc:	e01a      	b.n	8006b04 <get_fileinfo+0x120>
		if (wc == RDDEM) wc = DDEM;	/* Restore replaced DDEM character */
 8006ace:	8abb      	ldrh	r3, [r7, #20]
 8006ad0:	2b05      	cmp	r3, #5
 8006ad2:	d101      	bne.n	8006ad8 <get_fileinfo+0xf4>
 8006ad4:	23e5      	movs	r3, #229	; 0xe5
 8006ad6:	82bb      	strh	r3, [r7, #20]
		if (si == 9 && di < FF_SFN_BUF) fno->altname[di++] = '.';	/* Insert a . if extension is exist */
 8006ad8:	69fb      	ldr	r3, [r7, #28]
 8006ada:	2b09      	cmp	r3, #9
 8006adc:	d109      	bne.n	8006af2 <get_fileinfo+0x10e>
 8006ade:	69bb      	ldr	r3, [r7, #24]
 8006ae0:	2b0b      	cmp	r3, #11
 8006ae2:	d806      	bhi.n	8006af2 <get_fileinfo+0x10e>
 8006ae4:	69bb      	ldr	r3, [r7, #24]
 8006ae6:	1c5a      	adds	r2, r3, #1
 8006ae8:	61ba      	str	r2, [r7, #24]
 8006aea:	683a      	ldr	r2, [r7, #0]
 8006aec:	4413      	add	r3, r2
 8006aee:	222e      	movs	r2, #46	; 0x2e
 8006af0:	725a      	strb	r2, [r3, #9]
		if (wc == 0) { di = 0; break; }		/* Wrong char in the current code page? */
		wc = put_utf(wc, &fno->altname[di], FF_SFN_BUF - di);	/* Store it in Unicode */
		if (wc == 0) { di = 0; break; }		/* Buffer overflow? */
		di += wc;
#else					/* ANSI/OEM output */
		fno->altname[di++] = (TCHAR)wc;	/* Store it without any conversion */
 8006af2:	69bb      	ldr	r3, [r7, #24]
 8006af4:	1c5a      	adds	r2, r3, #1
 8006af6:	61ba      	str	r2, [r7, #24]
 8006af8:	8aba      	ldrh	r2, [r7, #20]
 8006afa:	b2d1      	uxtb	r1, r2
 8006afc:	683a      	ldr	r2, [r7, #0]
 8006afe:	4413      	add	r3, r2
 8006b00:	460a      	mov	r2, r1
 8006b02:	725a      	strb	r2, [r3, #9]
	while (si < 11) {		/* Get SFN from SFN entry */
 8006b04:	69fb      	ldr	r3, [r7, #28]
 8006b06:	2b0a      	cmp	r3, #10
 8006b08:	d9d5      	bls.n	8006ab6 <get_fileinfo+0xd2>
#endif
	}
	fno->altname[di] = 0;	/* Terminate the SFN  (null string means SFN is invalid) */
 8006b0a:	683a      	ldr	r2, [r7, #0]
 8006b0c:	69bb      	ldr	r3, [r7, #24]
 8006b0e:	4413      	add	r3, r2
 8006b10:	3309      	adds	r3, #9
 8006b12:	2200      	movs	r2, #0
 8006b14:	701a      	strb	r2, [r3, #0]

	if (fno->fname[0] == 0) {	/* If LFN is invalid, altname[] needs to be copied to fname[] */
 8006b16:	683b      	ldr	r3, [r7, #0]
 8006b18:	7d9b      	ldrb	r3, [r3, #22]
 8006b1a:	2b00      	cmp	r3, #0
 8006b1c:	d152      	bne.n	8006bc4 <get_fileinfo+0x1e0>
		if (di == 0) {	/* If LFN and SFN both are invalid, this object is inaccesible */
 8006b1e:	69bb      	ldr	r3, [r7, #24]
 8006b20:	2b00      	cmp	r3, #0
 8006b22:	d107      	bne.n	8006b34 <get_fileinfo+0x150>
			fno->fname[di++] = '?';
 8006b24:	69bb      	ldr	r3, [r7, #24]
 8006b26:	1c5a      	adds	r2, r3, #1
 8006b28:	61ba      	str	r2, [r7, #24]
 8006b2a:	683a      	ldr	r2, [r7, #0]
 8006b2c:	4413      	add	r3, r2
 8006b2e:	223f      	movs	r2, #63	; 0x3f
 8006b30:	759a      	strb	r2, [r3, #22]
 8006b32:	e038      	b.n	8006ba6 <get_fileinfo+0x1c2>
		} else {
			for (si = di = 0, lcf = NS_BODY; fno->altname[si]; si++, di++) {	/* Copy altname[] to fname[] with case information */
 8006b34:	2300      	movs	r3, #0
 8006b36:	61bb      	str	r3, [r7, #24]
 8006b38:	69bb      	ldr	r3, [r7, #24]
 8006b3a:	61fb      	str	r3, [r7, #28]
 8006b3c:	2308      	movs	r3, #8
 8006b3e:	75fb      	strb	r3, [r7, #23]
 8006b40:	e02a      	b.n	8006b98 <get_fileinfo+0x1b4>
				wc = (WCHAR)fno->altname[si];
 8006b42:	683a      	ldr	r2, [r7, #0]
 8006b44:	69fb      	ldr	r3, [r7, #28]
 8006b46:	4413      	add	r3, r2
 8006b48:	3309      	adds	r3, #9
 8006b4a:	781b      	ldrb	r3, [r3, #0]
 8006b4c:	82bb      	strh	r3, [r7, #20]
				if (wc == '.') lcf = NS_EXT;
 8006b4e:	8abb      	ldrh	r3, [r7, #20]
 8006b50:	2b2e      	cmp	r3, #46	; 0x2e
 8006b52:	d101      	bne.n	8006b58 <get_fileinfo+0x174>
 8006b54:	2310      	movs	r3, #16
 8006b56:	75fb      	strb	r3, [r7, #23]
				if (IsUpper(wc) && (dp->dir[DIR_NTres] & lcf)) wc += 0x20;
 8006b58:	8abb      	ldrh	r3, [r7, #20]
 8006b5a:	2b40      	cmp	r3, #64	; 0x40
 8006b5c:	d90e      	bls.n	8006b7c <get_fileinfo+0x198>
 8006b5e:	8abb      	ldrh	r3, [r7, #20]
 8006b60:	2b5a      	cmp	r3, #90	; 0x5a
 8006b62:	d80b      	bhi.n	8006b7c <get_fileinfo+0x198>
 8006b64:	687b      	ldr	r3, [r7, #4]
 8006b66:	69db      	ldr	r3, [r3, #28]
 8006b68:	330c      	adds	r3, #12
 8006b6a:	781a      	ldrb	r2, [r3, #0]
 8006b6c:	7dfb      	ldrb	r3, [r7, #23]
 8006b6e:	4013      	ands	r3, r2
 8006b70:	b2db      	uxtb	r3, r3
 8006b72:	2b00      	cmp	r3, #0
 8006b74:	d002      	beq.n	8006b7c <get_fileinfo+0x198>
 8006b76:	8abb      	ldrh	r3, [r7, #20]
 8006b78:	3320      	adds	r3, #32
 8006b7a:	82bb      	strh	r3, [r7, #20]
				fno->fname[di] = (TCHAR)wc;
 8006b7c:	8abb      	ldrh	r3, [r7, #20]
 8006b7e:	b2d9      	uxtb	r1, r3
 8006b80:	683a      	ldr	r2, [r7, #0]
 8006b82:	69bb      	ldr	r3, [r7, #24]
 8006b84:	4413      	add	r3, r2
 8006b86:	3316      	adds	r3, #22
 8006b88:	460a      	mov	r2, r1
 8006b8a:	701a      	strb	r2, [r3, #0]
			for (si = di = 0, lcf = NS_BODY; fno->altname[si]; si++, di++) {	/* Copy altname[] to fname[] with case information */
 8006b8c:	69fb      	ldr	r3, [r7, #28]
 8006b8e:	3301      	adds	r3, #1
 8006b90:	61fb      	str	r3, [r7, #28]
 8006b92:	69bb      	ldr	r3, [r7, #24]
 8006b94:	3301      	adds	r3, #1
 8006b96:	61bb      	str	r3, [r7, #24]
 8006b98:	683a      	ldr	r2, [r7, #0]
 8006b9a:	69fb      	ldr	r3, [r7, #28]
 8006b9c:	4413      	add	r3, r2
 8006b9e:	3309      	adds	r3, #9
 8006ba0:	781b      	ldrb	r3, [r3, #0]
 8006ba2:	2b00      	cmp	r3, #0
 8006ba4:	d1cd      	bne.n	8006b42 <get_fileinfo+0x15e>
			}
		}
		fno->fname[di] = 0;	/* Terminate the LFN */
 8006ba6:	683a      	ldr	r2, [r7, #0]
 8006ba8:	69bb      	ldr	r3, [r7, #24]
 8006baa:	4413      	add	r3, r2
 8006bac:	3316      	adds	r3, #22
 8006bae:	2200      	movs	r2, #0
 8006bb0:	701a      	strb	r2, [r3, #0]
		if (!dp->dir[DIR_NTres]) fno->altname[0] = 0;	/* Altname is not needed if neither LFN nor case info is exist. */
 8006bb2:	687b      	ldr	r3, [r7, #4]
 8006bb4:	69db      	ldr	r3, [r3, #28]
 8006bb6:	330c      	adds	r3, #12
 8006bb8:	781b      	ldrb	r3, [r3, #0]
 8006bba:	2b00      	cmp	r3, #0
 8006bbc:	d102      	bne.n	8006bc4 <get_fileinfo+0x1e0>
 8006bbe:	683b      	ldr	r3, [r7, #0]
 8006bc0:	2200      	movs	r2, #0
 8006bc2:	725a      	strb	r2, [r3, #9]
		fno->fname[di++] = c;
	}
	fno->fname[di] = 0;
#endif

	fno->fattrib = dp->dir[DIR_Attr];					/* Attribute */
 8006bc4:	687b      	ldr	r3, [r7, #4]
 8006bc6:	69db      	ldr	r3, [r3, #28]
 8006bc8:	7ada      	ldrb	r2, [r3, #11]
 8006bca:	683b      	ldr	r3, [r7, #0]
 8006bcc:	721a      	strb	r2, [r3, #8]
	fno->fsize = ld_dword(dp->dir + DIR_FileSize);		/* Size */
 8006bce:	687b      	ldr	r3, [r7, #4]
 8006bd0:	69db      	ldr	r3, [r3, #28]
 8006bd2:	331c      	adds	r3, #28
 8006bd4:	4618      	mov	r0, r3
 8006bd6:	f7fe fb7f 	bl	80052d8 <ld_dword>
 8006bda:	4602      	mov	r2, r0
 8006bdc:	683b      	ldr	r3, [r7, #0]
 8006bde:	601a      	str	r2, [r3, #0]
	fno->ftime = ld_word(dp->dir + DIR_ModTime + 0);	/* Time */
 8006be0:	687b      	ldr	r3, [r7, #4]
 8006be2:	69db      	ldr	r3, [r3, #28]
 8006be4:	3316      	adds	r3, #22
 8006be6:	4618      	mov	r0, r3
 8006be8:	f7fe fb5e 	bl	80052a8 <ld_word>
 8006bec:	4603      	mov	r3, r0
 8006bee:	461a      	mov	r2, r3
 8006bf0:	683b      	ldr	r3, [r7, #0]
 8006bf2:	80da      	strh	r2, [r3, #6]
	fno->fdate = ld_word(dp->dir + DIR_ModTime + 2);	/* Date */
 8006bf4:	687b      	ldr	r3, [r7, #4]
 8006bf6:	69db      	ldr	r3, [r3, #28]
 8006bf8:	3318      	adds	r3, #24
 8006bfa:	4618      	mov	r0, r3
 8006bfc:	f7fe fb54 	bl	80052a8 <ld_word>
 8006c00:	4603      	mov	r3, r0
 8006c02:	461a      	mov	r2, r3
 8006c04:	683b      	ldr	r3, [r7, #0]
 8006c06:	809a      	strh	r2, [r3, #4]
 8006c08:	e000      	b.n	8006c0c <get_fileinfo+0x228>
	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
 8006c0a:	bf00      	nop
}
 8006c0c:	3720      	adds	r7, #32
 8006c0e:	46bd      	mov	sp, r7
 8006c10:	bd80      	pop	{r7, pc}
	...

08006c14 <get_achar>:


static DWORD get_achar (	/* Get a character and advance ptr */
	const TCHAR** ptr		/* Pointer to pointer to the ANSI/OEM or Unicode string */
)
{
 8006c14:	b480      	push	{r7}
 8006c16:	b085      	sub	sp, #20
 8006c18:	af00      	add	r7, sp, #0
 8006c1a:	6078      	str	r0, [r7, #4]
	chr = tchar2uni(ptr);
	if (chr == 0xFFFFFFFF) chr = 0;		/* Wrong UTF encoding is recognized as end of the string */
	chr = ff_wtoupper(chr);

#else									/* ANSI/OEM input */
	chr = (BYTE)*(*ptr)++;				/* Get a byte */
 8006c1c:	687b      	ldr	r3, [r7, #4]
 8006c1e:	681b      	ldr	r3, [r3, #0]
 8006c20:	1c59      	adds	r1, r3, #1
 8006c22:	687a      	ldr	r2, [r7, #4]
 8006c24:	6011      	str	r1, [r2, #0]
 8006c26:	781b      	ldrb	r3, [r3, #0]
 8006c28:	60fb      	str	r3, [r7, #12]
	if (IsLower(chr)) chr -= 0x20;		/* To upper ASCII char */
 8006c2a:	68fb      	ldr	r3, [r7, #12]
 8006c2c:	2b60      	cmp	r3, #96	; 0x60
 8006c2e:	d905      	bls.n	8006c3c <get_achar+0x28>
 8006c30:	68fb      	ldr	r3, [r7, #12]
 8006c32:	2b7a      	cmp	r3, #122	; 0x7a
 8006c34:	d802      	bhi.n	8006c3c <get_achar+0x28>
 8006c36:	68fb      	ldr	r3, [r7, #12]
 8006c38:	3b20      	subs	r3, #32
 8006c3a:	60fb      	str	r3, [r7, #12]
#if FF_CODE_PAGE == 0
	if (ExCvt && chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
#elif FF_CODE_PAGE < 900
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 8006c3c:	68fb      	ldr	r3, [r7, #12]
 8006c3e:	2b7f      	cmp	r3, #127	; 0x7f
 8006c40:	d904      	bls.n	8006c4c <get_achar+0x38>
 8006c42:	68fb      	ldr	r3, [r7, #12]
 8006c44:	3b80      	subs	r3, #128	; 0x80
 8006c46:	4a05      	ldr	r2, [pc, #20]	; (8006c5c <get_achar+0x48>)
 8006c48:	5cd3      	ldrb	r3, [r2, r3]
 8006c4a:	60fb      	str	r3, [r7, #12]
		chr = dbc_2nd((BYTE)**ptr) ? chr << 8 | (BYTE)*(*ptr)++ : 0;
	}
#endif

#endif
	return chr;
 8006c4c:	68fb      	ldr	r3, [r7, #12]
}
 8006c4e:	4618      	mov	r0, r3
 8006c50:	3714      	adds	r7, #20
 8006c52:	46bd      	mov	sp, r7
 8006c54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006c58:	4770      	bx	lr
 8006c5a:	bf00      	nop
 8006c5c:	08014dc8 	.word	0x08014dc8

08006c60 <pattern_match>:
	const TCHAR* pat,	/* Matching pattern */
	const TCHAR* nam,	/* String to be tested */
	UINT skip,			/* Number of pre-skip chars (number of ?s, b8:infinite (* specified)) */
	UINT recur			/* Recursion count */
)
{
 8006c60:	b580      	push	{r7, lr}
 8006c62:	b08a      	sub	sp, #40	; 0x28
 8006c64:	af00      	add	r7, sp, #0
 8006c66:	60f8      	str	r0, [r7, #12]
 8006c68:	60b9      	str	r1, [r7, #8]
 8006c6a:	607a      	str	r2, [r7, #4]
 8006c6c:	603b      	str	r3, [r7, #0]
	const TCHAR *pptr, *nptr;
	DWORD pchr, nchr;
	UINT sk;


	while ((skip & 0xFF) != 0) {		/* Pre-skip name chars */
 8006c6e:	e00c      	b.n	8006c8a <pattern_match+0x2a>
		if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
 8006c70:	f107 0308 	add.w	r3, r7, #8
 8006c74:	4618      	mov	r0, r3
 8006c76:	f7ff ffcd 	bl	8006c14 <get_achar>
 8006c7a:	4603      	mov	r3, r0
 8006c7c:	2b00      	cmp	r3, #0
 8006c7e:	d101      	bne.n	8006c84 <pattern_match+0x24>
 8006c80:	2300      	movs	r3, #0
 8006c82:	e06a      	b.n	8006d5a <pattern_match+0xfa>
		skip--;
 8006c84:	687b      	ldr	r3, [r7, #4]
 8006c86:	3b01      	subs	r3, #1
 8006c88:	607b      	str	r3, [r7, #4]
	while ((skip & 0xFF) != 0) {		/* Pre-skip name chars */
 8006c8a:	687b      	ldr	r3, [r7, #4]
 8006c8c:	b2db      	uxtb	r3, r3
 8006c8e:	2b00      	cmp	r3, #0
 8006c90:	d1ee      	bne.n	8006c70 <pattern_match+0x10>
	}
	if (*pat == 0 && skip) return 1;	/* Matched? (short circuit) */
 8006c92:	68fb      	ldr	r3, [r7, #12]
 8006c94:	781b      	ldrb	r3, [r3, #0]
 8006c96:	2b00      	cmp	r3, #0
 8006c98:	d104      	bne.n	8006ca4 <pattern_match+0x44>
 8006c9a:	687b      	ldr	r3, [r7, #4]
 8006c9c:	2b00      	cmp	r3, #0
 8006c9e:	d001      	beq.n	8006ca4 <pattern_match+0x44>
 8006ca0:	2301      	movs	r3, #1
 8006ca2:	e05a      	b.n	8006d5a <pattern_match+0xfa>

	do {
		pptr = pat; nptr = nam;			/* Top of pattern and name to match */
 8006ca4:	68fb      	ldr	r3, [r7, #12]
 8006ca6:	61bb      	str	r3, [r7, #24]
 8006ca8:	68bb      	ldr	r3, [r7, #8]
 8006caa:	617b      	str	r3, [r7, #20]
		for (;;) {
			if (*pptr == '?' || *pptr == '*') {	/* Wildcard term? */
 8006cac:	69bb      	ldr	r3, [r7, #24]
 8006cae:	781b      	ldrb	r3, [r3, #0]
 8006cb0:	2b3f      	cmp	r3, #63	; 0x3f
 8006cb2:	d003      	beq.n	8006cbc <pattern_match+0x5c>
 8006cb4:	69bb      	ldr	r3, [r7, #24]
 8006cb6:	781b      	ldrb	r3, [r3, #0]
 8006cb8:	2b2a      	cmp	r3, #42	; 0x2a
 8006cba:	d12c      	bne.n	8006d16 <pattern_match+0xb6>
				if (recur == 0) return 0;	/* Too many wildcard terms? */
 8006cbc:	683b      	ldr	r3, [r7, #0]
 8006cbe:	2b00      	cmp	r3, #0
 8006cc0:	d101      	bne.n	8006cc6 <pattern_match+0x66>
 8006cc2:	2300      	movs	r3, #0
 8006cc4:	e049      	b.n	8006d5a <pattern_match+0xfa>
				sk = 0;
 8006cc6:	2300      	movs	r3, #0
 8006cc8:	623b      	str	r3, [r7, #32]
				do {	/* Analyze the wildcard term */
					if (*pptr++ == '?') sk++; else sk |= 0x100;
 8006cca:	69bb      	ldr	r3, [r7, #24]
 8006ccc:	1c5a      	adds	r2, r3, #1
 8006cce:	61ba      	str	r2, [r7, #24]
 8006cd0:	781b      	ldrb	r3, [r3, #0]
 8006cd2:	2b3f      	cmp	r3, #63	; 0x3f
 8006cd4:	d103      	bne.n	8006cde <pattern_match+0x7e>
 8006cd6:	6a3b      	ldr	r3, [r7, #32]
 8006cd8:	3301      	adds	r3, #1
 8006cda:	623b      	str	r3, [r7, #32]
 8006cdc:	e003      	b.n	8006ce6 <pattern_match+0x86>
 8006cde:	6a3b      	ldr	r3, [r7, #32]
 8006ce0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8006ce4:	623b      	str	r3, [r7, #32]
				} while (*pptr == '?' || *pptr == '*');
 8006ce6:	69bb      	ldr	r3, [r7, #24]
 8006ce8:	781b      	ldrb	r3, [r3, #0]
 8006cea:	2b3f      	cmp	r3, #63	; 0x3f
 8006cec:	d0ed      	beq.n	8006cca <pattern_match+0x6a>
 8006cee:	69bb      	ldr	r3, [r7, #24]
 8006cf0:	781b      	ldrb	r3, [r3, #0]
 8006cf2:	2b2a      	cmp	r3, #42	; 0x2a
 8006cf4:	d0e9      	beq.n	8006cca <pattern_match+0x6a>
				if (pattern_match(pptr, nptr, sk, recur - 1)) return 1;	/* Test new branch (recursive call) */
 8006cf6:	69b8      	ldr	r0, [r7, #24]
 8006cf8:	6979      	ldr	r1, [r7, #20]
 8006cfa:	683b      	ldr	r3, [r7, #0]
 8006cfc:	3b01      	subs	r3, #1
 8006cfe:	6a3a      	ldr	r2, [r7, #32]
 8006d00:	f7ff ffae 	bl	8006c60 <pattern_match>
 8006d04:	4603      	mov	r3, r0
 8006d06:	2b00      	cmp	r3, #0
 8006d08:	d001      	beq.n	8006d0e <pattern_match+0xae>
 8006d0a:	2301      	movs	r3, #1
 8006d0c:	e025      	b.n	8006d5a <pattern_match+0xfa>
				nchr = *nptr; break;	/* Branch mismatched */
 8006d0e:	697b      	ldr	r3, [r7, #20]
 8006d10:	781b      	ldrb	r3, [r3, #0]
 8006d12:	627b      	str	r3, [r7, #36]	; 0x24
 8006d14:	e015      	b.n	8006d42 <pattern_match+0xe2>
			}
			pchr = get_achar(&pptr);	/* Get a pattern char */
 8006d16:	f107 0318 	add.w	r3, r7, #24
 8006d1a:	4618      	mov	r0, r3
 8006d1c:	f7ff ff7a 	bl	8006c14 <get_achar>
 8006d20:	61f8      	str	r0, [r7, #28]
			nchr = get_achar(&nptr);	/* Get a name char */
 8006d22:	f107 0314 	add.w	r3, r7, #20
 8006d26:	4618      	mov	r0, r3
 8006d28:	f7ff ff74 	bl	8006c14 <get_achar>
 8006d2c:	6278      	str	r0, [r7, #36]	; 0x24
			if (pchr != nchr) break;	/* Branch mismatched? */
 8006d2e:	69fa      	ldr	r2, [r7, #28]
 8006d30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006d32:	429a      	cmp	r2, r3
 8006d34:	d104      	bne.n	8006d40 <pattern_match+0xe0>
			if (pchr == 0) return 1;	/* Branch matched? (matched at end of both strings) */
 8006d36:	69fb      	ldr	r3, [r7, #28]
 8006d38:	2b00      	cmp	r3, #0
 8006d3a:	d1b7      	bne.n	8006cac <pattern_match+0x4c>
 8006d3c:	2301      	movs	r3, #1
 8006d3e:	e00c      	b.n	8006d5a <pattern_match+0xfa>
			if (pchr != nchr) break;	/* Branch mismatched? */
 8006d40:	bf00      	nop
		}
		get_achar(&nam);			/* nam++ */
 8006d42:	f107 0308 	add.w	r3, r7, #8
 8006d46:	4618      	mov	r0, r3
 8006d48:	f7ff ff64 	bl	8006c14 <get_achar>
	} while (skip && nchr);		/* Retry until end of name if infinite search is specified */
 8006d4c:	687b      	ldr	r3, [r7, #4]
 8006d4e:	2b00      	cmp	r3, #0
 8006d50:	d002      	beq.n	8006d58 <pattern_match+0xf8>
 8006d52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006d54:	2b00      	cmp	r3, #0
 8006d56:	d1a5      	bne.n	8006ca4 <pattern_match+0x44>

	return 0;
 8006d58:	2300      	movs	r3, #0
}
 8006d5a:	4618      	mov	r0, r3
 8006d5c:	3728      	adds	r7, #40	; 0x28
 8006d5e:	46bd      	mov	sp, r7
 8006d60:	bd80      	pop	{r7, pc}
	...

08006d64 <create_name>:

static FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
	DIR* dp,					/* Pointer to the directory object */
	const TCHAR** path			/* Pointer to pointer to the segment in the path string */
)
{
 8006d64:	b580      	push	{r7, lr}
 8006d66:	b08a      	sub	sp, #40	; 0x28
 8006d68:	af00      	add	r7, sp, #0
 8006d6a:	6078      	str	r0, [r7, #4]
 8006d6c:	6039      	str	r1, [r7, #0]
	UINT i, ni, si, di;
	const TCHAR *p;


	/* Create LFN into LFN working buffer */
	p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
 8006d6e:	683b      	ldr	r3, [r7, #0]
 8006d70:	681b      	ldr	r3, [r3, #0]
 8006d72:	60bb      	str	r3, [r7, #8]
 8006d74:	687b      	ldr	r3, [r7, #4]
 8006d76:	681b      	ldr	r3, [r3, #0]
 8006d78:	68db      	ldr	r3, [r3, #12]
 8006d7a:	613b      	str	r3, [r7, #16]
 8006d7c:	2300      	movs	r3, #0
 8006d7e:	617b      	str	r3, [r7, #20]
	for (;;) {
		uc = tchar2uni(&p);			/* Get a character */
 8006d80:	f107 0308 	add.w	r3, r7, #8
 8006d84:	4618      	mov	r0, r3
 8006d86:	f7fe fbb1 	bl	80054ec <tchar2uni>
 8006d8a:	60f8      	str	r0, [r7, #12]
		if (uc == 0xFFFFFFFF) return FR_INVALID_NAME;		/* Invalid code or UTF decode error */
 8006d8c:	68fb      	ldr	r3, [r7, #12]
 8006d8e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006d92:	d101      	bne.n	8006d98 <create_name+0x34>
 8006d94:	2306      	movs	r3, #6
 8006d96:	e1b9      	b.n	800710c <create_name+0x3a8>
		if (uc >= 0x10000) lfn[di++] = (WCHAR)(uc >> 16);	/* Store high surrogate if needed */
 8006d98:	68fb      	ldr	r3, [r7, #12]
 8006d9a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8006d9e:	d309      	bcc.n	8006db4 <create_name+0x50>
 8006da0:	68fb      	ldr	r3, [r7, #12]
 8006da2:	0c19      	lsrs	r1, r3, #16
 8006da4:	697b      	ldr	r3, [r7, #20]
 8006da6:	1c5a      	adds	r2, r3, #1
 8006da8:	617a      	str	r2, [r7, #20]
 8006daa:	005b      	lsls	r3, r3, #1
 8006dac:	693a      	ldr	r2, [r7, #16]
 8006dae:	4413      	add	r3, r2
 8006db0:	b28a      	uxth	r2, r1
 8006db2:	801a      	strh	r2, [r3, #0]
		wc = (WCHAR)uc;
 8006db4:	68fb      	ldr	r3, [r7, #12]
 8006db6:	84bb      	strh	r3, [r7, #36]	; 0x24
		if (wc < ' ' || wc == '/' || wc == '\\') break;	/* Break if end of the path or a separator is found */
 8006db8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006dba:	2b1f      	cmp	r3, #31
 8006dbc:	d920      	bls.n	8006e00 <create_name+0x9c>
 8006dbe:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006dc0:	2b2f      	cmp	r3, #47	; 0x2f
 8006dc2:	d01d      	beq.n	8006e00 <create_name+0x9c>
 8006dc4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006dc6:	2b5c      	cmp	r3, #92	; 0x5c
 8006dc8:	d01a      	beq.n	8006e00 <create_name+0x9c>
		if (wc < 0x80 && chk_chr("\"*:<>\?|\x7F", wc)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
 8006dca:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006dcc:	2b7f      	cmp	r3, #127	; 0x7f
 8006dce:	d809      	bhi.n	8006de4 <create_name+0x80>
 8006dd0:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006dd2:	4619      	mov	r1, r3
 8006dd4:	48a6      	ldr	r0, [pc, #664]	; (8007070 <create_name+0x30c>)
 8006dd6:	f7fe fb4c 	bl	8005472 <chk_chr>
 8006dda:	4603      	mov	r3, r0
 8006ddc:	2b00      	cmp	r3, #0
 8006dde:	d001      	beq.n	8006de4 <create_name+0x80>
 8006de0:	2306      	movs	r3, #6
 8006de2:	e193      	b.n	800710c <create_name+0x3a8>
		if (di >= FF_MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
 8006de4:	697b      	ldr	r3, [r7, #20]
 8006de6:	2bfe      	cmp	r3, #254	; 0xfe
 8006de8:	d901      	bls.n	8006dee <create_name+0x8a>
 8006dea:	2306      	movs	r3, #6
 8006dec:	e18e      	b.n	800710c <create_name+0x3a8>
		lfn[di++] = wc;					/* Store the Unicode character */
 8006dee:	697b      	ldr	r3, [r7, #20]
 8006df0:	1c5a      	adds	r2, r3, #1
 8006df2:	617a      	str	r2, [r7, #20]
 8006df4:	005b      	lsls	r3, r3, #1
 8006df6:	693a      	ldr	r2, [r7, #16]
 8006df8:	4413      	add	r3, r2
 8006dfa:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8006dfc:	801a      	strh	r2, [r3, #0]
		uc = tchar2uni(&p);			/* Get a character */
 8006dfe:	e7bf      	b.n	8006d80 <create_name+0x1c>
	}
	if (wc < ' ') {				/* End of path? */
 8006e00:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006e02:	2b1f      	cmp	r3, #31
 8006e04:	d803      	bhi.n	8006e0e <create_name+0xaa>
		cf = NS_LAST;			/* Set last segment flag */
 8006e06:	2304      	movs	r3, #4
 8006e08:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
 8006e0c:	e00e      	b.n	8006e2c <create_name+0xc8>
	} else {
		cf = 0;					/* Next segment follows */
 8006e0e:	2300      	movs	r3, #0
 8006e10:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
		while (*p == '/' || *p == '\\') p++;	/* Skip duplicated separators if exist */
 8006e14:	e002      	b.n	8006e1c <create_name+0xb8>
 8006e16:	68bb      	ldr	r3, [r7, #8]
 8006e18:	3301      	adds	r3, #1
 8006e1a:	60bb      	str	r3, [r7, #8]
 8006e1c:	68bb      	ldr	r3, [r7, #8]
 8006e1e:	781b      	ldrb	r3, [r3, #0]
 8006e20:	2b2f      	cmp	r3, #47	; 0x2f
 8006e22:	d0f8      	beq.n	8006e16 <create_name+0xb2>
 8006e24:	68bb      	ldr	r3, [r7, #8]
 8006e26:	781b      	ldrb	r3, [r3, #0]
 8006e28:	2b5c      	cmp	r3, #92	; 0x5c
 8006e2a:	d0f4      	beq.n	8006e16 <create_name+0xb2>
	}
	*path = p;					/* Return pointer to the next segment */
 8006e2c:	68ba      	ldr	r2, [r7, #8]
 8006e2e:	683b      	ldr	r3, [r7, #0]
 8006e30:	601a      	str	r2, [r3, #0]
		}
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Snip off trailing spaces and dots if exist */
 8006e32:	e011      	b.n	8006e58 <create_name+0xf4>
		wc = lfn[di - 1];
 8006e34:	697b      	ldr	r3, [r7, #20]
 8006e36:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8006e3a:	3b01      	subs	r3, #1
 8006e3c:	005b      	lsls	r3, r3, #1
 8006e3e:	693a      	ldr	r2, [r7, #16]
 8006e40:	4413      	add	r3, r2
 8006e42:	881b      	ldrh	r3, [r3, #0]
 8006e44:	84bb      	strh	r3, [r7, #36]	; 0x24
		if (wc != ' ' && wc != '.') break;
 8006e46:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006e48:	2b20      	cmp	r3, #32
 8006e4a:	d002      	beq.n	8006e52 <create_name+0xee>
 8006e4c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006e4e:	2b2e      	cmp	r3, #46	; 0x2e
 8006e50:	d106      	bne.n	8006e60 <create_name+0xfc>
		di--;
 8006e52:	697b      	ldr	r3, [r7, #20]
 8006e54:	3b01      	subs	r3, #1
 8006e56:	617b      	str	r3, [r7, #20]
	while (di) {						/* Snip off trailing spaces and dots if exist */
 8006e58:	697b      	ldr	r3, [r7, #20]
 8006e5a:	2b00      	cmp	r3, #0
 8006e5c:	d1ea      	bne.n	8006e34 <create_name+0xd0>
 8006e5e:	e000      	b.n	8006e62 <create_name+0xfe>
		if (wc != ' ' && wc != '.') break;
 8006e60:	bf00      	nop
	}
	lfn[di] = 0;							/* LFN is created into the working buffer */
 8006e62:	697b      	ldr	r3, [r7, #20]
 8006e64:	005b      	lsls	r3, r3, #1
 8006e66:	693a      	ldr	r2, [r7, #16]
 8006e68:	4413      	add	r3, r2
 8006e6a:	2200      	movs	r2, #0
 8006e6c:	801a      	strh	r2, [r3, #0]
	if (di == 0) return FR_INVALID_NAME;	/* Reject null name */
 8006e6e:	697b      	ldr	r3, [r7, #20]
 8006e70:	2b00      	cmp	r3, #0
 8006e72:	d101      	bne.n	8006e78 <create_name+0x114>
 8006e74:	2306      	movs	r3, #6
 8006e76:	e149      	b.n	800710c <create_name+0x3a8>

	/* Create SFN in directory form */
	for (si = 0; lfn[si] == ' '; si++) ;	/* Remove leading spaces */
 8006e78:	2300      	movs	r3, #0
 8006e7a:	61bb      	str	r3, [r7, #24]
 8006e7c:	e002      	b.n	8006e84 <create_name+0x120>
 8006e7e:	69bb      	ldr	r3, [r7, #24]
 8006e80:	3301      	adds	r3, #1
 8006e82:	61bb      	str	r3, [r7, #24]
 8006e84:	69bb      	ldr	r3, [r7, #24]
 8006e86:	005b      	lsls	r3, r3, #1
 8006e88:	693a      	ldr	r2, [r7, #16]
 8006e8a:	4413      	add	r3, r2
 8006e8c:	881b      	ldrh	r3, [r3, #0]
 8006e8e:	2b20      	cmp	r3, #32
 8006e90:	d0f5      	beq.n	8006e7e <create_name+0x11a>
	if (si > 0 || lfn[si] == '.') cf |= NS_LOSS | NS_LFN;	/* Is there any leading space or dot? */
 8006e92:	69bb      	ldr	r3, [r7, #24]
 8006e94:	2b00      	cmp	r3, #0
 8006e96:	d106      	bne.n	8006ea6 <create_name+0x142>
 8006e98:	69bb      	ldr	r3, [r7, #24]
 8006e9a:	005b      	lsls	r3, r3, #1
 8006e9c:	693a      	ldr	r2, [r7, #16]
 8006e9e:	4413      	add	r3, r2
 8006ea0:	881b      	ldrh	r3, [r3, #0]
 8006ea2:	2b2e      	cmp	r3, #46	; 0x2e
 8006ea4:	d109      	bne.n	8006eba <create_name+0x156>
 8006ea6:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8006eaa:	f043 0303 	orr.w	r3, r3, #3
 8006eae:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	while (di > 0 && lfn[di - 1] != '.') di--;	/* Find last dot (di<=si: no extension) */
 8006eb2:	e002      	b.n	8006eba <create_name+0x156>
 8006eb4:	697b      	ldr	r3, [r7, #20]
 8006eb6:	3b01      	subs	r3, #1
 8006eb8:	617b      	str	r3, [r7, #20]
 8006eba:	697b      	ldr	r3, [r7, #20]
 8006ebc:	2b00      	cmp	r3, #0
 8006ebe:	d009      	beq.n	8006ed4 <create_name+0x170>
 8006ec0:	697b      	ldr	r3, [r7, #20]
 8006ec2:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8006ec6:	3b01      	subs	r3, #1
 8006ec8:	005b      	lsls	r3, r3, #1
 8006eca:	693a      	ldr	r2, [r7, #16]
 8006ecc:	4413      	add	r3, r2
 8006ece:	881b      	ldrh	r3, [r3, #0]
 8006ed0:	2b2e      	cmp	r3, #46	; 0x2e
 8006ed2:	d1ef      	bne.n	8006eb4 <create_name+0x150>

	mem_set(dp->fn, ' ', 11);
 8006ed4:	687b      	ldr	r3, [r7, #4]
 8006ed6:	3320      	adds	r3, #32
 8006ed8:	220b      	movs	r2, #11
 8006eda:	2120      	movs	r1, #32
 8006edc:	4618      	mov	r0, r3
 8006ede:	f7fe fa86 	bl	80053ee <mem_set>
	i = b = 0; ni = 8;
 8006ee2:	2300      	movs	r3, #0
 8006ee4:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8006ee8:	2300      	movs	r3, #0
 8006eea:	623b      	str	r3, [r7, #32]
 8006eec:	2308      	movs	r3, #8
 8006eee:	61fb      	str	r3, [r7, #28]
	for (;;) {
		wc = lfn[si++];					/* Get an LFN character */
 8006ef0:	69bb      	ldr	r3, [r7, #24]
 8006ef2:	1c5a      	adds	r2, r3, #1
 8006ef4:	61ba      	str	r2, [r7, #24]
 8006ef6:	005b      	lsls	r3, r3, #1
 8006ef8:	693a      	ldr	r2, [r7, #16]
 8006efa:	4413      	add	r3, r2
 8006efc:	881b      	ldrh	r3, [r3, #0]
 8006efe:	84bb      	strh	r3, [r7, #36]	; 0x24
		if (wc == 0) break;				/* Break on end of the LFN */
 8006f00:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006f02:	2b00      	cmp	r3, #0
 8006f04:	f000 80b2 	beq.w	800706c <create_name+0x308>
		if (wc == ' ' || (wc == '.' && si != di)) {	/* Remove embedded spaces and dots */
 8006f08:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006f0a:	2b20      	cmp	r3, #32
 8006f0c:	d006      	beq.n	8006f1c <create_name+0x1b8>
 8006f0e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006f10:	2b2e      	cmp	r3, #46	; 0x2e
 8006f12:	d10a      	bne.n	8006f2a <create_name+0x1c6>
 8006f14:	69ba      	ldr	r2, [r7, #24]
 8006f16:	697b      	ldr	r3, [r7, #20]
 8006f18:	429a      	cmp	r2, r3
 8006f1a:	d006      	beq.n	8006f2a <create_name+0x1c6>
			cf |= NS_LOSS | NS_LFN;
 8006f1c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8006f20:	f043 0303 	orr.w	r3, r3, #3
 8006f24:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
			continue;
 8006f28:	e09f      	b.n	800706a <create_name+0x306>
		}

		if (i >= ni || si == di) {		/* End of field? */
 8006f2a:	6a3a      	ldr	r2, [r7, #32]
 8006f2c:	69fb      	ldr	r3, [r7, #28]
 8006f2e:	429a      	cmp	r2, r3
 8006f30:	d203      	bcs.n	8006f3a <create_name+0x1d6>
 8006f32:	69ba      	ldr	r2, [r7, #24]
 8006f34:	697b      	ldr	r3, [r7, #20]
 8006f36:	429a      	cmp	r2, r3
 8006f38:	d124      	bne.n	8006f84 <create_name+0x220>
			if (ni == 11) {				/* Name extension overflow? */
 8006f3a:	69fb      	ldr	r3, [r7, #28]
 8006f3c:	2b0b      	cmp	r3, #11
 8006f3e:	d106      	bne.n	8006f4e <create_name+0x1ea>
				cf |= NS_LOSS | NS_LFN;
 8006f40:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8006f44:	f043 0303 	orr.w	r3, r3, #3
 8006f48:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
				break;
 8006f4c:	e097      	b.n	800707e <create_name+0x31a>
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Name body overflow? */
 8006f4e:	69ba      	ldr	r2, [r7, #24]
 8006f50:	697b      	ldr	r3, [r7, #20]
 8006f52:	429a      	cmp	r2, r3
 8006f54:	d005      	beq.n	8006f62 <create_name+0x1fe>
 8006f56:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8006f5a:	f043 0303 	orr.w	r3, r3, #3
 8006f5e:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
			if (si > di) break;						/* No name extension? */
 8006f62:	69ba      	ldr	r2, [r7, #24]
 8006f64:	697b      	ldr	r3, [r7, #20]
 8006f66:	429a      	cmp	r2, r3
 8006f68:	f200 8088 	bhi.w	800707c <create_name+0x318>
			si = di; i = 8; ni = 11; b <<= 2;		/* Enter name extension */
 8006f6c:	697b      	ldr	r3, [r7, #20]
 8006f6e:	61bb      	str	r3, [r7, #24]
 8006f70:	2308      	movs	r3, #8
 8006f72:	623b      	str	r3, [r7, #32]
 8006f74:	230b      	movs	r3, #11
 8006f76:	61fb      	str	r3, [r7, #28]
 8006f78:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8006f7c:	009b      	lsls	r3, r3, #2
 8006f7e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
			continue;
 8006f82:	e072      	b.n	800706a <create_name+0x306>
		}

		if (wc >= 0x80) {	/* Is this a non-ASCII character? */
 8006f84:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006f86:	2b7f      	cmp	r3, #127	; 0x7f
 8006f88:	d918      	bls.n	8006fbc <create_name+0x258>
			cf |= NS_LFN;	/* LFN entry needs to be created */
 8006f8a:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8006f8e:	f043 0302 	orr.w	r3, r3, #2
 8006f92:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
				if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
			} else {		/* At DBCS */
				wc = ff_uni2oem(ff_wtoupper(wc), CODEPAGE);	/* Unicode ==> Upper convert ==> ANSI/OEM code */
			}
#elif FF_CODE_PAGE < 900	/* SBCS cfg */
			wc = ff_uni2oem(wc, CODEPAGE);			/* Unicode ==> ANSI/OEM code */
 8006f96:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006f98:	f240 11b5 	movw	r1, #437	; 0x1b5
 8006f9c:	4618      	mov	r0, r3
 8006f9e:	f001 fc1f 	bl	80087e0 <ff_uni2oem>
 8006fa2:	4603      	mov	r3, r0
 8006fa4:	84bb      	strh	r3, [r7, #36]	; 0x24
			if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
 8006fa6:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006fa8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006fac:	2b00      	cmp	r3, #0
 8006fae:	d005      	beq.n	8006fbc <create_name+0x258>
 8006fb0:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006fb2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8006fb6:	4a2f      	ldr	r2, [pc, #188]	; (8007074 <create_name+0x310>)
 8006fb8:	5cd3      	ldrb	r3, [r2, r3]
 8006fba:	84bb      	strh	r3, [r7, #36]	; 0x24
#else						/* DBCS cfg */
			wc = ff_uni2oem(ff_wtoupper(wc), CODEPAGE);	/* Unicode ==> Upper convert ==> ANSI/OEM code */
#endif
		}

		if (wc >= 0x100) {				/* Is this a DBC? */
 8006fbc:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006fbe:	2bff      	cmp	r3, #255	; 0xff
 8006fc0:	d91a      	bls.n	8006ff8 <create_name+0x294>
			if (i >= ni - 1) {			/* Field overflow? */
 8006fc2:	69fb      	ldr	r3, [r7, #28]
 8006fc4:	3b01      	subs	r3, #1
 8006fc6:	6a3a      	ldr	r2, [r7, #32]
 8006fc8:	429a      	cmp	r2, r3
 8006fca:	d308      	bcc.n	8006fde <create_name+0x27a>
				cf |= NS_LOSS | NS_LFN;
 8006fcc:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8006fd0:	f043 0303 	orr.w	r3, r3, #3
 8006fd4:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
				i = ni; continue;		/* Next field */
 8006fd8:	69fb      	ldr	r3, [r7, #28]
 8006fda:	623b      	str	r3, [r7, #32]
 8006fdc:	e045      	b.n	800706a <create_name+0x306>
			}
			dp->fn[i++] = (BYTE)(wc >> 8);	/* Put 1st byte */
 8006fde:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006fe0:	0a1b      	lsrs	r3, r3, #8
 8006fe2:	b299      	uxth	r1, r3
 8006fe4:	6a3b      	ldr	r3, [r7, #32]
 8006fe6:	1c5a      	adds	r2, r3, #1
 8006fe8:	623a      	str	r2, [r7, #32]
 8006fea:	b2c9      	uxtb	r1, r1
 8006fec:	687a      	ldr	r2, [r7, #4]
 8006fee:	4413      	add	r3, r2
 8006ff0:	460a      	mov	r2, r1
 8006ff2:	f883 2020 	strb.w	r2, [r3, #32]
 8006ff6:	e02e      	b.n	8007056 <create_name+0x2f2>
		} else {						/* SBC */
			if (wc == 0 || chk_chr("+,;=[]", wc)) {	/* Replace illegal characters for SFN if needed */
 8006ff8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8006ffa:	2b00      	cmp	r3, #0
 8006ffc:	d007      	beq.n	800700e <create_name+0x2aa>
 8006ffe:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8007000:	4619      	mov	r1, r3
 8007002:	481d      	ldr	r0, [pc, #116]	; (8007078 <create_name+0x314>)
 8007004:	f7fe fa35 	bl	8005472 <chk_chr>
 8007008:	4603      	mov	r3, r0
 800700a:	2b00      	cmp	r3, #0
 800700c:	d008      	beq.n	8007020 <create_name+0x2bc>
				wc = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 800700e:	235f      	movs	r3, #95	; 0x5f
 8007010:	84bb      	strh	r3, [r7, #36]	; 0x24
 8007012:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8007016:	f043 0303 	orr.w	r3, r3, #3
 800701a:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
 800701e:	e01a      	b.n	8007056 <create_name+0x2f2>
			} else {
				if (IsUpper(wc)) {		/* ASCII upper case? */
 8007020:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8007022:	2b40      	cmp	r3, #64	; 0x40
 8007024:	d908      	bls.n	8007038 <create_name+0x2d4>
 8007026:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8007028:	2b5a      	cmp	r3, #90	; 0x5a
 800702a:	d805      	bhi.n	8007038 <create_name+0x2d4>
					b |= 2;
 800702c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8007030:	f043 0302 	orr.w	r3, r3, #2
 8007034:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
				}
				if (IsLower(wc)) {		/* ASCII lower case? */
 8007038:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800703a:	2b60      	cmp	r3, #96	; 0x60
 800703c:	d90b      	bls.n	8007056 <create_name+0x2f2>
 800703e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8007040:	2b7a      	cmp	r3, #122	; 0x7a
 8007042:	d808      	bhi.n	8007056 <create_name+0x2f2>
					b |= 1; wc -= 0x20;
 8007044:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8007048:	f043 0301 	orr.w	r3, r3, #1
 800704c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8007050:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8007052:	3b20      	subs	r3, #32
 8007054:	84bb      	strh	r3, [r7, #36]	; 0x24
				}
			}
		}
		dp->fn[i++] = (BYTE)wc;
 8007056:	6a3b      	ldr	r3, [r7, #32]
 8007058:	1c5a      	adds	r2, r3, #1
 800705a:	623a      	str	r2, [r7, #32]
 800705c:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 800705e:	b2d1      	uxtb	r1, r2
 8007060:	687a      	ldr	r2, [r7, #4]
 8007062:	4413      	add	r3, r2
 8007064:	460a      	mov	r2, r1
 8007066:	f883 2020 	strb.w	r2, [r3, #32]
		wc = lfn[si++];					/* Get an LFN character */
 800706a:	e741      	b.n	8006ef0 <create_name+0x18c>
		if (wc == 0) break;				/* Break on end of the LFN */
 800706c:	bf00      	nop
 800706e:	e006      	b.n	800707e <create_name+0x31a>
 8007070:	08014bf8 	.word	0x08014bf8
 8007074:	08014dc8 	.word	0x08014dc8
 8007078:	08014c04 	.word	0x08014c04
			if (si > di) break;						/* No name extension? */
 800707c:	bf00      	nop
	}

	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800707e:	687b      	ldr	r3, [r7, #4]
 8007080:	f893 3020 	ldrb.w	r3, [r3, #32]
 8007084:	2be5      	cmp	r3, #229	; 0xe5
 8007086:	d103      	bne.n	8007090 <create_name+0x32c>
 8007088:	687b      	ldr	r3, [r7, #4]
 800708a:	2205      	movs	r2, #5
 800708c:	f883 2020 	strb.w	r2, [r3, #32]

	if (ni == 8) b <<= 2;				/* Shift capital flags if no extension */
 8007090:	69fb      	ldr	r3, [r7, #28]
 8007092:	2b08      	cmp	r3, #8
 8007094:	d104      	bne.n	80070a0 <create_name+0x33c>
 8007096:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800709a:	009b      	lsls	r3, r3, #2
 800709c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* LFN entry needs to be created if composite capitals */
 80070a0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80070a4:	f003 030c 	and.w	r3, r3, #12
 80070a8:	2b0c      	cmp	r3, #12
 80070aa:	d005      	beq.n	80070b8 <create_name+0x354>
 80070ac:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80070b0:	f003 0303 	and.w	r3, r3, #3
 80070b4:	2b03      	cmp	r3, #3
 80070b6:	d105      	bne.n	80070c4 <create_name+0x360>
 80070b8:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 80070bc:	f043 0302 	orr.w	r3, r3, #2
 80070c0:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	if (!(cf & NS_LFN)) {				/* When LFN is in 8.3 format without extended character, NT flags are created */
 80070c4:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 80070c8:	f003 0302 	and.w	r3, r3, #2
 80070cc:	2b00      	cmp	r3, #0
 80070ce:	d117      	bne.n	8007100 <create_name+0x39c>
		if (b & 0x01) cf |= NS_EXT;		/* NT flag (Extension has small capital letters only) */
 80070d0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80070d4:	f003 0301 	and.w	r3, r3, #1
 80070d8:	2b00      	cmp	r3, #0
 80070da:	d005      	beq.n	80070e8 <create_name+0x384>
 80070dc:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 80070e0:	f043 0310 	orr.w	r3, r3, #16
 80070e4:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
		if (b & 0x04) cf |= NS_BODY;	/* NT flag (Body has small capital letters only) */
 80070e8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80070ec:	f003 0304 	and.w	r3, r3, #4
 80070f0:	2b00      	cmp	r3, #0
 80070f2:	d005      	beq.n	8007100 <create_name+0x39c>
 80070f4:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 80070f8:	f043 0308 	orr.w	r3, r3, #8
 80070fc:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	}

	dp->fn[NSFLAG] = cf;	/* SFN is created into dp->fn[] */
 8007100:	687b      	ldr	r3, [r7, #4]
 8007102:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 8007106:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b

	return FR_OK;
 800710a:	2300      	movs	r3, #0
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */

	return FR_OK;
#endif /* FF_USE_LFN */
}
 800710c:	4618      	mov	r0, r3
 800710e:	3728      	adds	r7, #40	; 0x28
 8007110:	46bd      	mov	sp, r7
 8007112:	bd80      	pop	{r7, pc}

08007114 <follow_path>:

static FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,					/* Directory object to return last directory and found object */
	const TCHAR* path			/* Full-path string to find a file or directory */
)
{
 8007114:	b580      	push	{r7, lr}
 8007116:	b086      	sub	sp, #24
 8007118:	af00      	add	r7, sp, #0
 800711a:	6078      	str	r0, [r7, #4]
 800711c:	6039      	str	r1, [r7, #0]
	FRESULT res;
	BYTE ns;
	FATFS *fs = dp->obj.fs;
 800711e:	687b      	ldr	r3, [r7, #4]
 8007120:	681b      	ldr	r3, [r3, #0]
 8007122:	613b      	str	r3, [r7, #16]
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
		dp->obj.sclust = fs->cdir;				/* Start from current directory */
	} else
#endif
	{										/* With heading separator */
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 8007124:	e002      	b.n	800712c <follow_path+0x18>
 8007126:	683b      	ldr	r3, [r7, #0]
 8007128:	3301      	adds	r3, #1
 800712a:	603b      	str	r3, [r7, #0]
 800712c:	683b      	ldr	r3, [r7, #0]
 800712e:	781b      	ldrb	r3, [r3, #0]
 8007130:	2b2f      	cmp	r3, #47	; 0x2f
 8007132:	d0f8      	beq.n	8007126 <follow_path+0x12>
 8007134:	683b      	ldr	r3, [r7, #0]
 8007136:	781b      	ldrb	r3, [r3, #0]
 8007138:	2b5c      	cmp	r3, #92	; 0x5c
 800713a:	d0f4      	beq.n	8007126 <follow_path+0x12>
		dp->obj.sclust = 0;					/* Start from root directory */
 800713c:	687b      	ldr	r3, [r7, #4]
 800713e:	2200      	movs	r2, #0
 8007140:	609a      	str	r2, [r3, #8]
		dp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
	}
#endif
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 8007142:	683b      	ldr	r3, [r7, #0]
 8007144:	781b      	ldrb	r3, [r3, #0]
 8007146:	2b1f      	cmp	r3, #31
 8007148:	d80a      	bhi.n	8007160 <follow_path+0x4c>
		dp->fn[NSFLAG] = NS_NONAME;
 800714a:	687b      	ldr	r3, [r7, #4]
 800714c:	2280      	movs	r2, #128	; 0x80
 800714e:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
		res = dir_sdi(dp, 0);
 8007152:	2100      	movs	r1, #0
 8007154:	6878      	ldr	r0, [r7, #4]
 8007156:	f7fe fe4e 	bl	8005df6 <dir_sdi>
 800715a:	4603      	mov	r3, r0
 800715c:	75fb      	strb	r3, [r7, #23]
 800715e:	e043      	b.n	80071e8 <follow_path+0xd4>

	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
 8007160:	463b      	mov	r3, r7
 8007162:	4619      	mov	r1, r3
 8007164:	6878      	ldr	r0, [r7, #4]
 8007166:	f7ff fdfd 	bl	8006d64 <create_name>
 800716a:	4603      	mov	r3, r0
 800716c:	75fb      	strb	r3, [r7, #23]
			if (res != FR_OK) break;
 800716e:	7dfb      	ldrb	r3, [r7, #23]
 8007170:	2b00      	cmp	r3, #0
 8007172:	d134      	bne.n	80071de <follow_path+0xca>
			res = dir_find(dp);				/* Find an object with the segment name */
 8007174:	6878      	ldr	r0, [r7, #4]
 8007176:	f7ff fa7d 	bl	8006674 <dir_find>
 800717a:	4603      	mov	r3, r0
 800717c:	75fb      	strb	r3, [r7, #23]
			ns = dp->fn[NSFLAG];
 800717e:	687b      	ldr	r3, [r7, #4]
 8007180:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
 8007184:	73fb      	strb	r3, [r7, #15]
			if (res != FR_OK) {				/* Failed to find the object */
 8007186:	7dfb      	ldrb	r3, [r7, #23]
 8007188:	2b00      	cmp	r3, #0
 800718a:	d00a      	beq.n	80071a2 <follow_path+0x8e>
				if (res == FR_NO_FILE) {	/* Object is not found */
 800718c:	7dfb      	ldrb	r3, [r7, #23]
 800718e:	2b04      	cmp	r3, #4
 8007190:	d127      	bne.n	80071e2 <follow_path+0xce>
					if (FF_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						dp->fn[NSFLAG] = NS_NONAME;
						res = FR_OK;
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8007192:	7bfb      	ldrb	r3, [r7, #15]
 8007194:	f003 0304 	and.w	r3, r3, #4
 8007198:	2b00      	cmp	r3, #0
 800719a:	d122      	bne.n	80071e2 <follow_path+0xce>
 800719c:	2305      	movs	r3, #5
 800719e:	75fb      	strb	r3, [r7, #23]
					}
				}
				break;
 80071a0:	e01f      	b.n	80071e2 <follow_path+0xce>
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 80071a2:	7bfb      	ldrb	r3, [r7, #15]
 80071a4:	f003 0304 	and.w	r3, r3, #4
 80071a8:	2b00      	cmp	r3, #0
 80071aa:	d11c      	bne.n	80071e6 <follow_path+0xd2>
			/* Get into the sub-directory */
			if (!(dp->obj.attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 80071ac:	687b      	ldr	r3, [r7, #4]
 80071ae:	799b      	ldrb	r3, [r3, #6]
 80071b0:	f003 0310 	and.w	r3, r3, #16
 80071b4:	2b00      	cmp	r3, #0
 80071b6:	d102      	bne.n	80071be <follow_path+0xaa>
				res = FR_NO_PATH; break;
 80071b8:	2305      	movs	r3, #5
 80071ba:	75fb      	strb	r3, [r7, #23]
 80071bc:	e014      	b.n	80071e8 <follow_path+0xd4>
				dp->obj.c_ofs = dp->blk_ofs;
				init_alloc_info(fs, &dp->obj);	/* Open next directory */
			} else
#endif
			{
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 80071be:	693b      	ldr	r3, [r7, #16]
 80071c0:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80071c4:	687b      	ldr	r3, [r7, #4]
 80071c6:	691b      	ldr	r3, [r3, #16]
 80071c8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80071cc:	4413      	add	r3, r2
 80071ce:	4619      	mov	r1, r3
 80071d0:	6938      	ldr	r0, [r7, #16]
 80071d2:	f7fe ff68 	bl	80060a6 <ld_clust>
 80071d6:	4602      	mov	r2, r0
 80071d8:	687b      	ldr	r3, [r7, #4]
 80071da:	609a      	str	r2, [r3, #8]
			res = create_name(dp, &path);	/* Get a segment name of the path */
 80071dc:	e7c0      	b.n	8007160 <follow_path+0x4c>
			if (res != FR_OK) break;
 80071de:	bf00      	nop
 80071e0:	e002      	b.n	80071e8 <follow_path+0xd4>
				break;
 80071e2:	bf00      	nop
 80071e4:	e000      	b.n	80071e8 <follow_path+0xd4>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 80071e6:	bf00      	nop
			}
		}
	}

	return res;
 80071e8:	7dfb      	ldrb	r3, [r7, #23]
}
 80071ea:	4618      	mov	r0, r3
 80071ec:	3718      	adds	r7, #24
 80071ee:	46bd      	mov	sp, r7
 80071f0:	bd80      	pop	{r7, pc}

080071f2 <get_ldnumber>:
/*-----------------------------------------------------------------------*/

static int get_ldnumber (	/* Returns logical drive number (-1:invalid drive number or null pointer) */
	const TCHAR** path		/* Pointer to pointer to the path name */
)
{
 80071f2:	b480      	push	{r7}
 80071f4:	b089      	sub	sp, #36	; 0x24
 80071f6:	af00      	add	r7, sp, #0
 80071f8:	6078      	str	r0, [r7, #4]
	const TCHAR *tp, *tt;
	TCHAR tc;
	int i, vol = -1;
 80071fa:	f04f 33ff 	mov.w	r3, #4294967295
 80071fe:	617b      	str	r3, [r7, #20]
#if FF_STR_VOLUME_ID		/* Find string volume ID */
	const char *sp;
	char c;
#endif

	tt = tp = *path;
 8007200:	687b      	ldr	r3, [r7, #4]
 8007202:	681b      	ldr	r3, [r3, #0]
 8007204:	613b      	str	r3, [r7, #16]
 8007206:	693b      	ldr	r3, [r7, #16]
 8007208:	61fb      	str	r3, [r7, #28]
	if (!tp) return vol;	/* Invalid path name? */
 800720a:	693b      	ldr	r3, [r7, #16]
 800720c:	2b00      	cmp	r3, #0
 800720e:	d101      	bne.n	8007214 <get_ldnumber+0x22>
 8007210:	697b      	ldr	r3, [r7, #20]
 8007212:	e02d      	b.n	8007270 <get_ldnumber+0x7e>
	do tc = *tt++; while ((UINT)tc >= (FF_USE_LFN ? ' ' : '!') && tc != ':');	/* Find a colon in the path */
 8007214:	69fb      	ldr	r3, [r7, #28]
 8007216:	1c5a      	adds	r2, r3, #1
 8007218:	61fa      	str	r2, [r7, #28]
 800721a:	781b      	ldrb	r3, [r3, #0]
 800721c:	73fb      	strb	r3, [r7, #15]
 800721e:	7bfb      	ldrb	r3, [r7, #15]
 8007220:	2b1f      	cmp	r3, #31
 8007222:	d902      	bls.n	800722a <get_ldnumber+0x38>
 8007224:	7bfb      	ldrb	r3, [r7, #15]
 8007226:	2b3a      	cmp	r3, #58	; 0x3a
 8007228:	d1f4      	bne.n	8007214 <get_ldnumber+0x22>

	if (tc == ':') {	/* DOS/Windows style volume ID? */
 800722a:	7bfb      	ldrb	r3, [r7, #15]
 800722c:	2b3a      	cmp	r3, #58	; 0x3a
 800722e:	d11c      	bne.n	800726a <get_ldnumber+0x78>
		i = FF_VOLUMES;
 8007230:	2301      	movs	r3, #1
 8007232:	61bb      	str	r3, [r7, #24]
		if (IsDigit(*tp) && tp + 2 == tt) {	/* Is there a numeric volume ID + colon? */
 8007234:	693b      	ldr	r3, [r7, #16]
 8007236:	781b      	ldrb	r3, [r3, #0]
 8007238:	2b2f      	cmp	r3, #47	; 0x2f
 800723a:	d90c      	bls.n	8007256 <get_ldnumber+0x64>
 800723c:	693b      	ldr	r3, [r7, #16]
 800723e:	781b      	ldrb	r3, [r3, #0]
 8007240:	2b39      	cmp	r3, #57	; 0x39
 8007242:	d808      	bhi.n	8007256 <get_ldnumber+0x64>
 8007244:	693b      	ldr	r3, [r7, #16]
 8007246:	3302      	adds	r3, #2
 8007248:	69fa      	ldr	r2, [r7, #28]
 800724a:	429a      	cmp	r2, r3
 800724c:	d103      	bne.n	8007256 <get_ldnumber+0x64>
			i = (int)*tp - '0';	/* Get the LD number */
 800724e:	693b      	ldr	r3, [r7, #16]
 8007250:	781b      	ldrb	r3, [r3, #0]
 8007252:	3b30      	subs	r3, #48	; 0x30
 8007254:	61bb      	str	r3, [r7, #24]
					if (IsLower(tc)) tc -= 0x20;
				} while (c && (TCHAR)c == tc);
			} while ((c || tp != tt) && ++i < FF_VOLUMES);	/* Repeat for each id until pattern match */
		}
#endif
		if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
 8007256:	69bb      	ldr	r3, [r7, #24]
 8007258:	2b00      	cmp	r3, #0
 800725a:	dc04      	bgt.n	8007266 <get_ldnumber+0x74>
			vol = i;		/* Drive number */
 800725c:	69bb      	ldr	r3, [r7, #24]
 800725e:	617b      	str	r3, [r7, #20]
			*path = tt;		/* Snip the drive prefix off */
 8007260:	687b      	ldr	r3, [r7, #4]
 8007262:	69fa      	ldr	r2, [r7, #28]
 8007264:	601a      	str	r2, [r3, #0]
		}
		return vol;
 8007266:	697b      	ldr	r3, [r7, #20]
 8007268:	e002      	b.n	8007270 <get_ldnumber+0x7e>
#endif
	/* No drive prefix is found */
#if FF_FS_RPATH != 0
	vol = CurrVol;	/* Default drive is current drive */
#else
	vol = 0;		/* Default drive is 0 */
 800726a:	2300      	movs	r3, #0
 800726c:	617b      	str	r3, [r7, #20]
#endif
	return vol;		/* Return the default drive */
 800726e:	697b      	ldr	r3, [r7, #20]
}
 8007270:	4618      	mov	r0, r3
 8007272:	3724      	adds	r7, #36	; 0x24
 8007274:	46bd      	mov	sp, r7
 8007276:	f85d 7b04 	ldr.w	r7, [sp], #4
 800727a:	4770      	bx	lr

0800727c <check_fs>:

static UINT check_fs (	/* 0:FAT VBR, 1:exFAT VBR, 2:Not FAT and valid BS, 3:Not FAT and invalid BS, 4:Disk error */
	FATFS* fs,			/* Filesystem object */
	LBA_t sect			/* Sector to load and check if it is an FAT-VBR or not */
)
{
 800727c:	b580      	push	{r7, lr}
 800727e:	b084      	sub	sp, #16
 8007280:	af00      	add	r7, sp, #0
 8007282:	6078      	str	r0, [r7, #4]
 8007284:	6039      	str	r1, [r7, #0]
	WORD w, sign;
	BYTE b;


	fs->wflag = 0; fs->winsect = (LBA_t)0 - 1;		/* Invaidate window */
 8007286:	687b      	ldr	r3, [r7, #4]
 8007288:	2200      	movs	r2, #0
 800728a:	70da      	strb	r2, [r3, #3]
 800728c:	687b      	ldr	r3, [r7, #4]
 800728e:	f04f 32ff 	mov.w	r2, #4294967295
 8007292:	631a      	str	r2, [r3, #48]	; 0x30
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load the boot sector */
 8007294:	6839      	ldr	r1, [r7, #0]
 8007296:	6878      	ldr	r0, [r7, #4]
 8007298:	f7fe f9e1 	bl	800565e <move_window>
 800729c:	4603      	mov	r3, r0
 800729e:	2b00      	cmp	r3, #0
 80072a0:	d001      	beq.n	80072a6 <check_fs+0x2a>
 80072a2:	2304      	movs	r3, #4
 80072a4:	e070      	b.n	8007388 <check_fs+0x10c>
	sign = ld_word(fs->win + BS_55AA);
 80072a6:	687b      	ldr	r3, [r7, #4]
 80072a8:	3334      	adds	r3, #52	; 0x34
 80072aa:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
 80072ae:	4618      	mov	r0, r3
 80072b0:	f7fd fffa 	bl	80052a8 <ld_word>
 80072b4:	4603      	mov	r3, r0
 80072b6:	81fb      	strh	r3, [r7, #14]
#if FF_FS_EXFAT
	if (sign == 0xAA55 && !mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;	/* It is an exFAT VBR */
#endif
	b = fs->win[BS_JmpBoot];
 80072b8:	687b      	ldr	r3, [r7, #4]
 80072ba:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 80072be:	737b      	strb	r3, [r7, #13]
	if (b == 0xEB || b == 0xE9 || b == 0xE8) {	/* Valid JumpBoot code? (short jump, near jump or near call) */
 80072c0:	7b7b      	ldrb	r3, [r7, #13]
 80072c2:	2beb      	cmp	r3, #235	; 0xeb
 80072c4:	d005      	beq.n	80072d2 <check_fs+0x56>
 80072c6:	7b7b      	ldrb	r3, [r7, #13]
 80072c8:	2be9      	cmp	r3, #233	; 0xe9
 80072ca:	d002      	beq.n	80072d2 <check_fs+0x56>
 80072cc:	7b7b      	ldrb	r3, [r7, #13]
 80072ce:	2be8      	cmp	r3, #232	; 0xe8
 80072d0:	d152      	bne.n	8007378 <check_fs+0xfc>
		if (sign == 0xAA55 && !mem_cmp(fs->win + BS_FilSysType32, "FAT32   ", 8)) return 0;	/* It is an FAT32 VBR */
 80072d2:	89fb      	ldrh	r3, [r7, #14]
 80072d4:	f64a 2255 	movw	r2, #43605	; 0xaa55
 80072d8:	4293      	cmp	r3, r2
 80072da:	d10c      	bne.n	80072f6 <check_fs+0x7a>
 80072dc:	687b      	ldr	r3, [r7, #4]
 80072de:	3334      	adds	r3, #52	; 0x34
 80072e0:	3352      	adds	r3, #82	; 0x52
 80072e2:	2208      	movs	r2, #8
 80072e4:	492a      	ldr	r1, [pc, #168]	; (8007390 <check_fs+0x114>)
 80072e6:	4618      	mov	r0, r3
 80072e8:	f7fe f89c 	bl	8005424 <mem_cmp>
 80072ec:	4603      	mov	r3, r0
 80072ee:	2b00      	cmp	r3, #0
 80072f0:	d101      	bne.n	80072f6 <check_fs+0x7a>
 80072f2:	2300      	movs	r3, #0
 80072f4:	e048      	b.n	8007388 <check_fs+0x10c>
		/* FAT volumes formatted with early MS-DOS lack boot signature and FAT string, so that we need to identify the FAT VBR without them. */
		w = ld_word(fs->win + BPB_BytsPerSec);
 80072f6:	687b      	ldr	r3, [r7, #4]
 80072f8:	3334      	adds	r3, #52	; 0x34
 80072fa:	330b      	adds	r3, #11
 80072fc:	4618      	mov	r0, r3
 80072fe:	f7fd ffd3 	bl	80052a8 <ld_word>
 8007302:	4603      	mov	r3, r0
 8007304:	817b      	strh	r3, [r7, #10]
		if ((w & (w - 1)) == 0 && w >= FF_MIN_SS && w <= FF_MAX_SS) {	/* Properness of sector size */
 8007306:	897a      	ldrh	r2, [r7, #10]
 8007308:	897b      	ldrh	r3, [r7, #10]
 800730a:	3b01      	subs	r3, #1
 800730c:	4013      	ands	r3, r2
 800730e:	2b00      	cmp	r3, #0
 8007310:	d132      	bne.n	8007378 <check_fs+0xfc>
 8007312:	897b      	ldrh	r3, [r7, #10]
 8007314:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8007318:	d32e      	bcc.n	8007378 <check_fs+0xfc>
 800731a:	897b      	ldrh	r3, [r7, #10]
 800731c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8007320:	d82a      	bhi.n	8007378 <check_fs+0xfc>
			b = fs->win[BPB_SecPerClus];
 8007322:	687b      	ldr	r3, [r7, #4]
 8007324:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8007328:	737b      	strb	r3, [r7, #13]
			if (b != 0 && (b & (b - 1)) == 0						/* Properness of cluster size */
 800732a:	7b7b      	ldrb	r3, [r7, #13]
 800732c:	2b00      	cmp	r3, #0
 800732e:	d023      	beq.n	8007378 <check_fs+0xfc>
 8007330:	7b7a      	ldrb	r2, [r7, #13]
 8007332:	7b7b      	ldrb	r3, [r7, #13]
 8007334:	3b01      	subs	r3, #1
 8007336:	4013      	ands	r3, r2
 8007338:	2b00      	cmp	r3, #0
 800733a:	d11d      	bne.n	8007378 <check_fs+0xfc>
			&& (fs->win[BPB_NumFATs] == 1 || fs->win[BPB_NumFATs] == 2)	/* Properness of number of FATs */
 800733c:	687b      	ldr	r3, [r7, #4]
 800733e:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8007342:	2b01      	cmp	r3, #1
 8007344:	d004      	beq.n	8007350 <check_fs+0xd4>
 8007346:	687b      	ldr	r3, [r7, #4]
 8007348:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800734c:	2b02      	cmp	r3, #2
 800734e:	d113      	bne.n	8007378 <check_fs+0xfc>
			&& ld_word(fs->win + BPB_RootEntCnt) != 0				/* Properness of root entry count */
 8007350:	687b      	ldr	r3, [r7, #4]
 8007352:	3334      	adds	r3, #52	; 0x34
 8007354:	3311      	adds	r3, #17
 8007356:	4618      	mov	r0, r3
 8007358:	f7fd ffa6 	bl	80052a8 <ld_word>
 800735c:	4603      	mov	r3, r0
 800735e:	2b00      	cmp	r3, #0
 8007360:	d00a      	beq.n	8007378 <check_fs+0xfc>
			&& ld_word(fs->win + BPB_FATSz16) != 0) {				/* Properness of FAT size */
 8007362:	687b      	ldr	r3, [r7, #4]
 8007364:	3334      	adds	r3, #52	; 0x34
 8007366:	3316      	adds	r3, #22
 8007368:	4618      	mov	r0, r3
 800736a:	f7fd ff9d 	bl	80052a8 <ld_word>
 800736e:	4603      	mov	r3, r0
 8007370:	2b00      	cmp	r3, #0
 8007372:	d001      	beq.n	8007378 <check_fs+0xfc>
				return 0;	/* Sector can be presumed an FAT VBR */
 8007374:	2300      	movs	r3, #0
 8007376:	e007      	b.n	8007388 <check_fs+0x10c>
			}
		}
	}
	return sign == 0xAA55 ? 2 : 3;	/* Not an FAT VBR (valid or invalid BS) */
 8007378:	89fb      	ldrh	r3, [r7, #14]
 800737a:	f64a 2255 	movw	r2, #43605	; 0xaa55
 800737e:	4293      	cmp	r3, r2
 8007380:	d101      	bne.n	8007386 <check_fs+0x10a>
 8007382:	2302      	movs	r3, #2
 8007384:	e000      	b.n	8007388 <check_fs+0x10c>
 8007386:	2303      	movs	r3, #3
}
 8007388:	4618      	mov	r0, r3
 800738a:	3710      	adds	r7, #16
 800738c:	46bd      	mov	sp, r7
 800738e:	bd80      	pop	{r7, pc}
 8007390:	08014c0c 	.word	0x08014c0c

08007394 <find_volume>:

static UINT find_volume (	/* Returns BS status found in the hosting drive */
	FATFS* fs,		/* Filesystem object */
	UINT part		/* Partition to fined = 0:auto, 1..:forced */
)
{
 8007394:	b580      	push	{r7, lr}
 8007396:	b088      	sub	sp, #32
 8007398:	af00      	add	r7, sp, #0
 800739a:	6078      	str	r0, [r7, #4]
 800739c:	6039      	str	r1, [r7, #0]
	UINT fmt, i;
	DWORD mbr_pt[4];


	fmt = check_fs(fs, 0);				/* Load sector 0 and check if it is an FAT VBR as SFD */
 800739e:	2100      	movs	r1, #0
 80073a0:	6878      	ldr	r0, [r7, #4]
 80073a2:	f7ff ff6b 	bl	800727c <check_fs>
 80073a6:	61b8      	str	r0, [r7, #24]
	if (fmt != 2 && (fmt >= 3 || part == 0)) return fmt;	/* Returns if it is a FAT VBR as auto scan, not a BS or disk error */
 80073a8:	69bb      	ldr	r3, [r7, #24]
 80073aa:	2b02      	cmp	r3, #2
 80073ac:	d007      	beq.n	80073be <find_volume+0x2a>
 80073ae:	69bb      	ldr	r3, [r7, #24]
 80073b0:	2b02      	cmp	r3, #2
 80073b2:	d802      	bhi.n	80073ba <find_volume+0x26>
 80073b4:	683b      	ldr	r3, [r7, #0]
 80073b6:	2b00      	cmp	r3, #0
 80073b8:	d101      	bne.n	80073be <find_volume+0x2a>
 80073ba:	69bb      	ldr	r3, [r7, #24]
 80073bc:	e048      	b.n	8007450 <find_volume+0xbc>
		}
		return 3;	/* Not found */
	}
#endif
	if (FF_MULTI_PARTITION && part > 4) return 3;	/* MBR has 4 partitions max */
	for (i = 0; i < 4; i++) {		/* Load partition offset in the MBR */
 80073be:	2300      	movs	r3, #0
 80073c0:	61fb      	str	r3, [r7, #28]
 80073c2:	e015      	b.n	80073f0 <find_volume+0x5c>
		mbr_pt[i] = ld_dword(fs->win + MBR_Table + i * SZ_PTE + PTE_StLba);
 80073c4:	687b      	ldr	r3, [r7, #4]
 80073c6:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80073ca:	69fb      	ldr	r3, [r7, #28]
 80073cc:	011b      	lsls	r3, r3, #4
 80073ce:	f503 73e3 	add.w	r3, r3, #454	; 0x1c6
 80073d2:	4413      	add	r3, r2
 80073d4:	4618      	mov	r0, r3
 80073d6:	f7fd ff7f 	bl	80052d8 <ld_dword>
 80073da:	4602      	mov	r2, r0
 80073dc:	69fb      	ldr	r3, [r7, #28]
 80073de:	009b      	lsls	r3, r3, #2
 80073e0:	f107 0120 	add.w	r1, r7, #32
 80073e4:	440b      	add	r3, r1
 80073e6:	f843 2c18 	str.w	r2, [r3, #-24]
	for (i = 0; i < 4; i++) {		/* Load partition offset in the MBR */
 80073ea:	69fb      	ldr	r3, [r7, #28]
 80073ec:	3301      	adds	r3, #1
 80073ee:	61fb      	str	r3, [r7, #28]
 80073f0:	69fb      	ldr	r3, [r7, #28]
 80073f2:	2b03      	cmp	r3, #3
 80073f4:	d9e6      	bls.n	80073c4 <find_volume+0x30>
	}
	i = part ? part - 1 : 0;		/* Table index to find first */
 80073f6:	683b      	ldr	r3, [r7, #0]
 80073f8:	2b00      	cmp	r3, #0
 80073fa:	d002      	beq.n	8007402 <find_volume+0x6e>
 80073fc:	683b      	ldr	r3, [r7, #0]
 80073fe:	3b01      	subs	r3, #1
 8007400:	e000      	b.n	8007404 <find_volume+0x70>
 8007402:	2300      	movs	r3, #0
 8007404:	61fb      	str	r3, [r7, #28]
	do {							/* Find an FAT volume */
		fmt = mbr_pt[i] ? check_fs(fs, mbr_pt[i]) : 3;	/* Check if the partition is FAT */
 8007406:	69fb      	ldr	r3, [r7, #28]
 8007408:	009b      	lsls	r3, r3, #2
 800740a:	f107 0220 	add.w	r2, r7, #32
 800740e:	4413      	add	r3, r2
 8007410:	f853 3c18 	ldr.w	r3, [r3, #-24]
 8007414:	2b00      	cmp	r3, #0
 8007416:	d00c      	beq.n	8007432 <find_volume+0x9e>
 8007418:	69fb      	ldr	r3, [r7, #28]
 800741a:	009b      	lsls	r3, r3, #2
 800741c:	f107 0220 	add.w	r2, r7, #32
 8007420:	4413      	add	r3, r2
 8007422:	f853 3c18 	ldr.w	r3, [r3, #-24]
 8007426:	4619      	mov	r1, r3
 8007428:	6878      	ldr	r0, [r7, #4]
 800742a:	f7ff ff27 	bl	800727c <check_fs>
 800742e:	4603      	mov	r3, r0
 8007430:	e000      	b.n	8007434 <find_volume+0xa0>
 8007432:	2303      	movs	r3, #3
 8007434:	61bb      	str	r3, [r7, #24]
	} while (part == 0 && fmt >= 2 && ++i < 4);
 8007436:	683b      	ldr	r3, [r7, #0]
 8007438:	2b00      	cmp	r3, #0
 800743a:	d108      	bne.n	800744e <find_volume+0xba>
 800743c:	69bb      	ldr	r3, [r7, #24]
 800743e:	2b01      	cmp	r3, #1
 8007440:	d905      	bls.n	800744e <find_volume+0xba>
 8007442:	69fb      	ldr	r3, [r7, #28]
 8007444:	3301      	adds	r3, #1
 8007446:	61fb      	str	r3, [r7, #28]
 8007448:	69fb      	ldr	r3, [r7, #28]
 800744a:	2b03      	cmp	r3, #3
 800744c:	d9db      	bls.n	8007406 <find_volume+0x72>
	return fmt;
 800744e:	69bb      	ldr	r3, [r7, #24]
}
 8007450:	4618      	mov	r0, r3
 8007452:	3720      	adds	r7, #32
 8007454:	46bd      	mov	sp, r7
 8007456:	bd80      	pop	{r7, pc}

08007458 <mount_volume>:
static FRESULT mount_volume (	/* FR_OK(0): successful, !=0: an error occurred */
	const TCHAR** path,			/* Pointer to pointer to the path name (drive number) */
	FATFS** rfs,				/* Pointer to pointer to the found filesystem object */
	BYTE mode					/* !=0: Check write protection for write access */
)
{
 8007458:	b580      	push	{r7, lr}
 800745a:	b090      	sub	sp, #64	; 0x40
 800745c:	af00      	add	r7, sp, #0
 800745e:	60f8      	str	r0, [r7, #12]
 8007460:	60b9      	str	r1, [r7, #8]
 8007462:	4613      	mov	r3, r2
 8007464:	71fb      	strb	r3, [r7, #7]
	FATFS *fs;
	UINT fmt;


	/* Get logical drive number */
	*rfs = 0;
 8007466:	68bb      	ldr	r3, [r7, #8]
 8007468:	2200      	movs	r2, #0
 800746a:	601a      	str	r2, [r3, #0]
	vol = get_ldnumber(path);
 800746c:	68f8      	ldr	r0, [r7, #12]
 800746e:	f7ff fec0 	bl	80071f2 <get_ldnumber>
 8007472:	62f8      	str	r0, [r7, #44]	; 0x2c
	if (vol < 0) return FR_INVALID_DRIVE;
 8007474:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007476:	2b00      	cmp	r3, #0
 8007478:	da01      	bge.n	800747e <mount_volume+0x26>
 800747a:	230b      	movs	r3, #11
 800747c:	e1e3      	b.n	8007846 <mount_volume+0x3ee>

	/* Check if the filesystem object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the filesystem object */
 800747e:	4aa9      	ldr	r2, [pc, #676]	; (8007724 <mount_volume+0x2cc>)
 8007480:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007482:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8007486:	62bb      	str	r3, [r7, #40]	; 0x28
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
 8007488:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800748a:	2b00      	cmp	r3, #0
 800748c:	d101      	bne.n	8007492 <mount_volume+0x3a>
 800748e:	230c      	movs	r3, #12
 8007490:	e1d9      	b.n	8007846 <mount_volume+0x3ee>
#if FF_FS_REENTRANT
	if (!lock_fs(fs)) return FR_TIMEOUT;	/* Lock the volume */
#endif
	*rfs = fs;							/* Return pointer to the filesystem object */
 8007492:	68bb      	ldr	r3, [r7, #8]
 8007494:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007496:	601a      	str	r2, [r3, #0]

	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 8007498:	79fb      	ldrb	r3, [r7, #7]
 800749a:	f023 0301 	bic.w	r3, r3, #1
 800749e:	71fb      	strb	r3, [r7, #7]
	if (fs->fs_type != 0) {				/* If the volume has been mounted */
 80074a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80074a2:	781b      	ldrb	r3, [r3, #0]
 80074a4:	2b00      	cmp	r3, #0
 80074a6:	d01a      	beq.n	80074de <mount_volume+0x86>
		stat = disk_status(fs->pdrv);
 80074a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80074aa:	785b      	ldrb	r3, [r3, #1]
 80074ac:	4618      	mov	r0, r3
 80074ae:	f7fd fe6d 	bl	800518c <disk_status>
 80074b2:	4603      	mov	r3, r0
 80074b4:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 80074b8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80074bc:	f003 0301 	and.w	r3, r3, #1
 80074c0:	2b00      	cmp	r3, #0
 80074c2:	d10c      	bne.n	80074de <mount_volume+0x86>
			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 80074c4:	79fb      	ldrb	r3, [r7, #7]
 80074c6:	2b00      	cmp	r3, #0
 80074c8:	d007      	beq.n	80074da <mount_volume+0x82>
 80074ca:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80074ce:	f003 0304 	and.w	r3, r3, #4
 80074d2:	2b00      	cmp	r3, #0
 80074d4:	d001      	beq.n	80074da <mount_volume+0x82>
				return FR_WRITE_PROTECTED;
 80074d6:	230a      	movs	r3, #10
 80074d8:	e1b5      	b.n	8007846 <mount_volume+0x3ee>
			}
			return FR_OK;				/* The filesystem object is already valid */
 80074da:	2300      	movs	r3, #0
 80074dc:	e1b3      	b.n	8007846 <mount_volume+0x3ee>
	}

	/* The filesystem object is not valid. */
	/* Following code attempts to mount the volume. (find a FAT volume, analyze the BPB and initialize the filesystem object) */

	fs->fs_type = 0;					/* Clear the filesystem object */
 80074de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80074e0:	2200      	movs	r2, #0
 80074e2:	701a      	strb	r2, [r3, #0]
	fs->pdrv = LD2PD(vol);				/* Volume hosting physical drive */
 80074e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80074e6:	b2da      	uxtb	r2, r3
 80074e8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80074ea:	705a      	strb	r2, [r3, #1]
	stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
 80074ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80074ee:	785b      	ldrb	r3, [r3, #1]
 80074f0:	4618      	mov	r0, r3
 80074f2:	f7fd fe57 	bl	80051a4 <disk_initialize>
 80074f6:	4603      	mov	r3, r0
 80074f8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 80074fc:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8007500:	f003 0301 	and.w	r3, r3, #1
 8007504:	2b00      	cmp	r3, #0
 8007506:	d001      	beq.n	800750c <mount_volume+0xb4>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8007508:	2303      	movs	r3, #3
 800750a:	e19c      	b.n	8007846 <mount_volume+0x3ee>
	}
	if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 800750c:	79fb      	ldrb	r3, [r7, #7]
 800750e:	2b00      	cmp	r3, #0
 8007510:	d007      	beq.n	8007522 <mount_volume+0xca>
 8007512:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8007516:	f003 0304 	and.w	r3, r3, #4
 800751a:	2b00      	cmp	r3, #0
 800751c:	d001      	beq.n	8007522 <mount_volume+0xca>
		return FR_WRITE_PROTECTED;
 800751e:	230a      	movs	r3, #10
 8007520:	e191      	b.n	8007846 <mount_volume+0x3ee>
	if (disk_ioctl(fs->pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK) return FR_DISK_ERR;
	if (SS(fs) > FF_MAX_SS || SS(fs) < FF_MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
#endif

	/* Find an FAT volume on the drive */
	fmt = find_volume(fs, LD2PT(vol));
 8007522:	2100      	movs	r1, #0
 8007524:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8007526:	f7ff ff35 	bl	8007394 <find_volume>
 800752a:	6338      	str	r0, [r7, #48]	; 0x30
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 800752c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800752e:	2b04      	cmp	r3, #4
 8007530:	d101      	bne.n	8007536 <mount_volume+0xde>
 8007532:	2301      	movs	r3, #1
 8007534:	e187      	b.n	8007846 <mount_volume+0x3ee>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 8007536:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007538:	2b01      	cmp	r3, #1
 800753a:	d901      	bls.n	8007540 <mount_volume+0xe8>
 800753c:	230d      	movs	r3, #13
 800753e:	e182      	b.n	8007846 <mount_volume+0x3ee>
	bsect = fs->winsect;					/* Volume location */
 8007540:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007542:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007544:	623b      	str	r3, [r7, #32]
#endif
		fmt = FS_EXFAT;			/* FAT sub-type */
	} else
#endif	/* FF_FS_EXFAT */
	{
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8007546:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007548:	3334      	adds	r3, #52	; 0x34
 800754a:	330b      	adds	r3, #11
 800754c:	4618      	mov	r0, r3
 800754e:	f7fd feab 	bl	80052a8 <ld_word>
 8007552:	4603      	mov	r3, r0
 8007554:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8007558:	d001      	beq.n	800755e <mount_volume+0x106>
 800755a:	230d      	movs	r3, #13
 800755c:	e173      	b.n	8007846 <mount_volume+0x3ee>

		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
 800755e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007560:	3334      	adds	r3, #52	; 0x34
 8007562:	3316      	adds	r3, #22
 8007564:	4618      	mov	r0, r3
 8007566:	f7fd fe9f 	bl	80052a8 <ld_word>
 800756a:	4603      	mov	r3, r0
 800756c:	63bb      	str	r3, [r7, #56]	; 0x38
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 800756e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007570:	2b00      	cmp	r3, #0
 8007572:	d106      	bne.n	8007582 <mount_volume+0x12a>
 8007574:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007576:	3334      	adds	r3, #52	; 0x34
 8007578:	3324      	adds	r3, #36	; 0x24
 800757a:	4618      	mov	r0, r3
 800757c:	f7fd feac 	bl	80052d8 <ld_dword>
 8007580:	63b8      	str	r0, [r7, #56]	; 0x38
		fs->fsize = fasize;
 8007582:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007584:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8007586:	61da      	str	r2, [r3, #28]

		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 8007588:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800758a:	f893 2044 	ldrb.w	r2, [r3, #68]	; 0x44
 800758e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007590:	709a      	strb	r2, [r3, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 8007592:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007594:	789b      	ldrb	r3, [r3, #2]
 8007596:	2b01      	cmp	r3, #1
 8007598:	d005      	beq.n	80075a6 <mount_volume+0x14e>
 800759a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800759c:	789b      	ldrb	r3, [r3, #2]
 800759e:	2b02      	cmp	r3, #2
 80075a0:	d001      	beq.n	80075a6 <mount_volume+0x14e>
 80075a2:	230d      	movs	r3, #13
 80075a4:	e14f      	b.n	8007846 <mount_volume+0x3ee>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 80075a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80075a8:	789b      	ldrb	r3, [r3, #2]
 80075aa:	461a      	mov	r2, r3
 80075ac:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80075ae:	fb02 f303 	mul.w	r3, r2, r3
 80075b2:	63bb      	str	r3, [r7, #56]	; 0x38

		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 80075b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80075b6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 80075ba:	b29a      	uxth	r2, r3
 80075bc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80075be:	815a      	strh	r2, [r3, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 80075c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80075c2:	895b      	ldrh	r3, [r3, #10]
 80075c4:	2b00      	cmp	r3, #0
 80075c6:	d008      	beq.n	80075da <mount_volume+0x182>
 80075c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80075ca:	895b      	ldrh	r3, [r3, #10]
 80075cc:	461a      	mov	r2, r3
 80075ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80075d0:	895b      	ldrh	r3, [r3, #10]
 80075d2:	3b01      	subs	r3, #1
 80075d4:	4013      	ands	r3, r2
 80075d6:	2b00      	cmp	r3, #0
 80075d8:	d001      	beq.n	80075de <mount_volume+0x186>
 80075da:	230d      	movs	r3, #13
 80075dc:	e133      	b.n	8007846 <mount_volume+0x3ee>

		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 80075de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80075e0:	3334      	adds	r3, #52	; 0x34
 80075e2:	3311      	adds	r3, #17
 80075e4:	4618      	mov	r0, r3
 80075e6:	f7fd fe5f 	bl	80052a8 <ld_word>
 80075ea:	4603      	mov	r3, r0
 80075ec:	461a      	mov	r2, r3
 80075ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80075f0:	811a      	strh	r2, [r3, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 80075f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80075f4:	891b      	ldrh	r3, [r3, #8]
 80075f6:	f003 030f 	and.w	r3, r3, #15
 80075fa:	b29b      	uxth	r3, r3
 80075fc:	2b00      	cmp	r3, #0
 80075fe:	d001      	beq.n	8007604 <mount_volume+0x1ac>
 8007600:	230d      	movs	r3, #13
 8007602:	e120      	b.n	8007846 <mount_volume+0x3ee>

		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
 8007604:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007606:	3334      	adds	r3, #52	; 0x34
 8007608:	3313      	adds	r3, #19
 800760a:	4618      	mov	r0, r3
 800760c:	f7fd fe4c 	bl	80052a8 <ld_word>
 8007610:	4603      	mov	r3, r0
 8007612:	63fb      	str	r3, [r7, #60]	; 0x3c
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 8007614:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8007616:	2b00      	cmp	r3, #0
 8007618:	d106      	bne.n	8007628 <mount_volume+0x1d0>
 800761a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800761c:	3334      	adds	r3, #52	; 0x34
 800761e:	3320      	adds	r3, #32
 8007620:	4618      	mov	r0, r3
 8007622:	f7fd fe59 	bl	80052d8 <ld_dword>
 8007626:	63f8      	str	r0, [r7, #60]	; 0x3c

		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */
 8007628:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800762a:	3334      	adds	r3, #52	; 0x34
 800762c:	330e      	adds	r3, #14
 800762e:	4618      	mov	r0, r3
 8007630:	f7fd fe3a 	bl	80052a8 <ld_word>
 8007634:	4603      	mov	r3, r0
 8007636:	83fb      	strh	r3, [r7, #30]
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 8007638:	8bfb      	ldrh	r3, [r7, #30]
 800763a:	2b00      	cmp	r3, #0
 800763c:	d101      	bne.n	8007642 <mount_volume+0x1ea>
 800763e:	230d      	movs	r3, #13
 8007640:	e101      	b.n	8007846 <mount_volume+0x3ee>

		/* Determine the FAT sub type */
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 8007642:	8bfa      	ldrh	r2, [r7, #30]
 8007644:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007646:	4413      	add	r3, r2
 8007648:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800764a:	8912      	ldrh	r2, [r2, #8]
 800764c:	0912      	lsrs	r2, r2, #4
 800764e:	b292      	uxth	r2, r2
 8007650:	4413      	add	r3, r2
 8007652:	61bb      	str	r3, [r7, #24]
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 8007654:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8007656:	69bb      	ldr	r3, [r7, #24]
 8007658:	429a      	cmp	r2, r3
 800765a:	d201      	bcs.n	8007660 <mount_volume+0x208>
 800765c:	230d      	movs	r3, #13
 800765e:	e0f2      	b.n	8007846 <mount_volume+0x3ee>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 8007660:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8007662:	69bb      	ldr	r3, [r7, #24]
 8007664:	1ad3      	subs	r3, r2, r3
 8007666:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007668:	8952      	ldrh	r2, [r2, #10]
 800766a:	fbb3 f3f2 	udiv	r3, r3, r2
 800766e:	617b      	str	r3, [r7, #20]
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8007670:	697b      	ldr	r3, [r7, #20]
 8007672:	2b00      	cmp	r3, #0
 8007674:	d101      	bne.n	800767a <mount_volume+0x222>
 8007676:	230d      	movs	r3, #13
 8007678:	e0e5      	b.n	8007846 <mount_volume+0x3ee>
		fmt = 0;
 800767a:	2300      	movs	r3, #0
 800767c:	633b      	str	r3, [r7, #48]	; 0x30
		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
 800767e:	697b      	ldr	r3, [r7, #20]
 8007680:	4a29      	ldr	r2, [pc, #164]	; (8007728 <mount_volume+0x2d0>)
 8007682:	4293      	cmp	r3, r2
 8007684:	d801      	bhi.n	800768a <mount_volume+0x232>
 8007686:	2303      	movs	r3, #3
 8007688:	633b      	str	r3, [r7, #48]	; 0x30
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 800768a:	697b      	ldr	r3, [r7, #20]
 800768c:	f64f 72f5 	movw	r2, #65525	; 0xfff5
 8007690:	4293      	cmp	r3, r2
 8007692:	d801      	bhi.n	8007698 <mount_volume+0x240>
 8007694:	2302      	movs	r3, #2
 8007696:	633b      	str	r3, [r7, #48]	; 0x30
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 8007698:	697b      	ldr	r3, [r7, #20]
 800769a:	f640 72f5 	movw	r2, #4085	; 0xff5
 800769e:	4293      	cmp	r3, r2
 80076a0:	d801      	bhi.n	80076a6 <mount_volume+0x24e>
 80076a2:	2301      	movs	r3, #1
 80076a4:	633b      	str	r3, [r7, #48]	; 0x30
		if (fmt == 0) return FR_NO_FILESYSTEM;
 80076a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80076a8:	2b00      	cmp	r3, #0
 80076aa:	d101      	bne.n	80076b0 <mount_volume+0x258>
 80076ac:	230d      	movs	r3, #13
 80076ae:	e0ca      	b.n	8007846 <mount_volume+0x3ee>

		/* Boundaries and Limits */
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 80076b0:	697b      	ldr	r3, [r7, #20]
 80076b2:	1c9a      	adds	r2, r3, #2
 80076b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80076b6:	619a      	str	r2, [r3, #24]
		fs->volbase = bsect;							/* Volume start sector */
 80076b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80076ba:	6a3a      	ldr	r2, [r7, #32]
 80076bc:	621a      	str	r2, [r3, #32]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 80076be:	8bfa      	ldrh	r2, [r7, #30]
 80076c0:	6a3b      	ldr	r3, [r7, #32]
 80076c2:	441a      	add	r2, r3
 80076c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80076c6:	625a      	str	r2, [r3, #36]	; 0x24
		fs->database = bsect + sysect;					/* Data start sector */
 80076c8:	6a3a      	ldr	r2, [r7, #32]
 80076ca:	69bb      	ldr	r3, [r7, #24]
 80076cc:	441a      	add	r2, r3
 80076ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80076d0:	62da      	str	r2, [r3, #44]	; 0x2c
		if (fmt == FS_FAT32) {
 80076d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80076d4:	2b03      	cmp	r3, #3
 80076d6:	d11e      	bne.n	8007716 <mount_volume+0x2be>
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 80076d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80076da:	3334      	adds	r3, #52	; 0x34
 80076dc:	332a      	adds	r3, #42	; 0x2a
 80076de:	4618      	mov	r0, r3
 80076e0:	f7fd fde2 	bl	80052a8 <ld_word>
 80076e4:	4603      	mov	r3, r0
 80076e6:	2b00      	cmp	r3, #0
 80076e8:	d001      	beq.n	80076ee <mount_volume+0x296>
 80076ea:	230d      	movs	r3, #13
 80076ec:	e0ab      	b.n	8007846 <mount_volume+0x3ee>
			if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 80076ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80076f0:	891b      	ldrh	r3, [r3, #8]
 80076f2:	2b00      	cmp	r3, #0
 80076f4:	d001      	beq.n	80076fa <mount_volume+0x2a2>
 80076f6:	230d      	movs	r3, #13
 80076f8:	e0a5      	b.n	8007846 <mount_volume+0x3ee>
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 80076fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80076fc:	3334      	adds	r3, #52	; 0x34
 80076fe:	332c      	adds	r3, #44	; 0x2c
 8007700:	4618      	mov	r0, r3
 8007702:	f7fd fde9 	bl	80052d8 <ld_dword>
 8007706:	4602      	mov	r2, r0
 8007708:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800770a:	629a      	str	r2, [r3, #40]	; 0x28
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 800770c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800770e:	699b      	ldr	r3, [r3, #24]
 8007710:	009b      	lsls	r3, r3, #2
 8007712:	637b      	str	r3, [r7, #52]	; 0x34
 8007714:	e023      	b.n	800775e <mount_volume+0x306>
		} else {
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8007716:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007718:	891b      	ldrh	r3, [r3, #8]
 800771a:	2b00      	cmp	r3, #0
 800771c:	d106      	bne.n	800772c <mount_volume+0x2d4>
 800771e:	230d      	movs	r3, #13
 8007720:	e091      	b.n	8007846 <mount_volume+0x3ee>
 8007722:	bf00      	nop
 8007724:	200001bc 	.word	0x200001bc
 8007728:	0ffffff5 	.word	0x0ffffff5
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800772c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800772e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8007730:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8007732:	441a      	add	r2, r3
 8007734:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007736:	629a      	str	r2, [r3, #40]	; 0x28
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8007738:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800773a:	2b02      	cmp	r3, #2
 800773c:	d103      	bne.n	8007746 <mount_volume+0x2ee>
 800773e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007740:	699b      	ldr	r3, [r3, #24]
 8007742:	005b      	lsls	r3, r3, #1
 8007744:	e00a      	b.n	800775c <mount_volume+0x304>
 8007746:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007748:	699a      	ldr	r2, [r3, #24]
 800774a:	4613      	mov	r3, r2
 800774c:	005b      	lsls	r3, r3, #1
 800774e:	4413      	add	r3, r2
 8007750:	085a      	lsrs	r2, r3, #1
 8007752:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007754:	699b      	ldr	r3, [r3, #24]
 8007756:	f003 0301 	and.w	r3, r3, #1
 800775a:	4413      	add	r3, r2
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
 800775c:	637b      	str	r3, [r7, #52]	; 0x34
		}
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 800775e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007760:	69da      	ldr	r2, [r3, #28]
 8007762:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007764:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
 8007768:	0a5b      	lsrs	r3, r3, #9
 800776a:	429a      	cmp	r2, r3
 800776c:	d201      	bcs.n	8007772 <mount_volume+0x31a>
 800776e:	230d      	movs	r3, #13
 8007770:	e069      	b.n	8007846 <mount_volume+0x3ee>

#if !FF_FS_READONLY
		/* Get FSInfo if available */
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 8007772:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007774:	f04f 32ff 	mov.w	r2, #4294967295
 8007778:	615a      	str	r2, [r3, #20]
 800777a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800777c:	695a      	ldr	r2, [r3, #20]
 800777e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007780:	611a      	str	r2, [r3, #16]
		fs->fsi_flag = 0x80;
 8007782:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007784:	2280      	movs	r2, #128	; 0x80
 8007786:	711a      	strb	r2, [r3, #4]
#if (FF_FS_NOFSINFO & 3) != 3
		if (fmt == FS_FAT32				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
 8007788:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800778a:	2b03      	cmp	r3, #3
 800778c:	d149      	bne.n	8007822 <mount_volume+0x3ca>
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 800778e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007790:	3334      	adds	r3, #52	; 0x34
 8007792:	3330      	adds	r3, #48	; 0x30
 8007794:	4618      	mov	r0, r3
 8007796:	f7fd fd87 	bl	80052a8 <ld_word>
 800779a:	4603      	mov	r3, r0
 800779c:	2b01      	cmp	r3, #1
 800779e:	d140      	bne.n	8007822 <mount_volume+0x3ca>
			&& move_window(fs, bsect + 1) == FR_OK)
 80077a0:	6a3b      	ldr	r3, [r7, #32]
 80077a2:	3301      	adds	r3, #1
 80077a4:	4619      	mov	r1, r3
 80077a6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80077a8:	f7fd ff59 	bl	800565e <move_window>
 80077ac:	4603      	mov	r3, r0
 80077ae:	2b00      	cmp	r3, #0
 80077b0:	d137      	bne.n	8007822 <mount_volume+0x3ca>
		{
			fs->fsi_flag = 0;
 80077b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80077b4:	2200      	movs	r2, #0
 80077b6:	711a      	strb	r2, [r3, #4]
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
 80077b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80077ba:	3334      	adds	r3, #52	; 0x34
 80077bc:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
 80077c0:	4618      	mov	r0, r3
 80077c2:	f7fd fd71 	bl	80052a8 <ld_word>
 80077c6:	4603      	mov	r3, r0
 80077c8:	461a      	mov	r2, r3
 80077ca:	f64a 2355 	movw	r3, #43605	; 0xaa55
 80077ce:	429a      	cmp	r2, r3
 80077d0:	d127      	bne.n	8007822 <mount_volume+0x3ca>
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 80077d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80077d4:	3334      	adds	r3, #52	; 0x34
 80077d6:	4618      	mov	r0, r3
 80077d8:	f7fd fd7e 	bl	80052d8 <ld_dword>
 80077dc:	4603      	mov	r3, r0
 80077de:	4a1c      	ldr	r2, [pc, #112]	; (8007850 <mount_volume+0x3f8>)
 80077e0:	4293      	cmp	r3, r2
 80077e2:	d11e      	bne.n	8007822 <mount_volume+0x3ca>
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 80077e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80077e6:	3334      	adds	r3, #52	; 0x34
 80077e8:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 80077ec:	4618      	mov	r0, r3
 80077ee:	f7fd fd73 	bl	80052d8 <ld_dword>
 80077f2:	4603      	mov	r3, r0
 80077f4:	4a17      	ldr	r2, [pc, #92]	; (8007854 <mount_volume+0x3fc>)
 80077f6:	4293      	cmp	r3, r2
 80077f8:	d113      	bne.n	8007822 <mount_volume+0x3ca>
			{
#if (FF_FS_NOFSINFO & 1) == 0
				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
 80077fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80077fc:	3334      	adds	r3, #52	; 0x34
 80077fe:	f503 73f4 	add.w	r3, r3, #488	; 0x1e8
 8007802:	4618      	mov	r0, r3
 8007804:	f7fd fd68 	bl	80052d8 <ld_dword>
 8007808:	4602      	mov	r2, r0
 800780a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800780c:	615a      	str	r2, [r3, #20]
#endif
#if (FF_FS_NOFSINFO & 2) == 0
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 800780e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007810:	3334      	adds	r3, #52	; 0x34
 8007812:	f503 73f6 	add.w	r3, r3, #492	; 0x1ec
 8007816:	4618      	mov	r0, r3
 8007818:	f7fd fd5e 	bl	80052d8 <ld_dword>
 800781c:	4602      	mov	r2, r0
 800781e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007820:	611a      	str	r2, [r3, #16]
		}
#endif	/* (FF_FS_NOFSINFO & 3) != 3 */
#endif	/* !FF_FS_READONLY */
	}

	fs->fs_type = (BYTE)fmt;/* FAT sub-type */
 8007822:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007824:	b2da      	uxtb	r2, r3
 8007826:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007828:	701a      	strb	r2, [r3, #0]
	fs->id = ++Fsid;		/* Volume mount ID */
 800782a:	4b0b      	ldr	r3, [pc, #44]	; (8007858 <mount_volume+0x400>)
 800782c:	881b      	ldrh	r3, [r3, #0]
 800782e:	3301      	adds	r3, #1
 8007830:	b29a      	uxth	r2, r3
 8007832:	4b09      	ldr	r3, [pc, #36]	; (8007858 <mount_volume+0x400>)
 8007834:	801a      	strh	r2, [r3, #0]
 8007836:	4b08      	ldr	r3, [pc, #32]	; (8007858 <mount_volume+0x400>)
 8007838:	881a      	ldrh	r2, [r3, #0]
 800783a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800783c:	80da      	strh	r2, [r3, #6]
#if FF_USE_LFN == 1
	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
 800783e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007840:	4a06      	ldr	r2, [pc, #24]	; (800785c <mount_volume+0x404>)
 8007842:	60da      	str	r2, [r3, #12]
	fs->cdir = 0;			/* Initialize current directory */
#endif
#if FF_FS_LOCK != 0			/* Clear file lock semaphores */
	clear_lock(fs);
#endif
	return FR_OK;
 8007844:	2300      	movs	r3, #0
}
 8007846:	4618      	mov	r0, r3
 8007848:	3740      	adds	r7, #64	; 0x40
 800784a:	46bd      	mov	sp, r7
 800784c:	bd80      	pop	{r7, pc}
 800784e:	bf00      	nop
 8007850:	41615252 	.word	0x41615252
 8007854:	61417272 	.word	0x61417272
 8007858:	200001c0 	.word	0x200001c0
 800785c:	200001c4 	.word	0x200001c4

08007860 <validate>:

static FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
	FFOBJID* obj,			/* Pointer to the FFOBJID, the 1st member in the FIL/DIR object, to check validity */
	FATFS** rfs				/* Pointer to pointer to the owner filesystem object to return */
)
{
 8007860:	b580      	push	{r7, lr}
 8007862:	b084      	sub	sp, #16
 8007864:	af00      	add	r7, sp, #0
 8007866:	6078      	str	r0, [r7, #4]
 8007868:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_INVALID_OBJECT;
 800786a:	2309      	movs	r3, #9
 800786c:	73fb      	strb	r3, [r7, #15]


	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 800786e:	687b      	ldr	r3, [r7, #4]
 8007870:	2b00      	cmp	r3, #0
 8007872:	d01c      	beq.n	80078ae <validate+0x4e>
 8007874:	687b      	ldr	r3, [r7, #4]
 8007876:	681b      	ldr	r3, [r3, #0]
 8007878:	2b00      	cmp	r3, #0
 800787a:	d018      	beq.n	80078ae <validate+0x4e>
 800787c:	687b      	ldr	r3, [r7, #4]
 800787e:	681b      	ldr	r3, [r3, #0]
 8007880:	781b      	ldrb	r3, [r3, #0]
 8007882:	2b00      	cmp	r3, #0
 8007884:	d013      	beq.n	80078ae <validate+0x4e>
 8007886:	687b      	ldr	r3, [r7, #4]
 8007888:	889a      	ldrh	r2, [r3, #4]
 800788a:	687b      	ldr	r3, [r7, #4]
 800788c:	681b      	ldr	r3, [r3, #0]
 800788e:	88db      	ldrh	r3, [r3, #6]
 8007890:	429a      	cmp	r2, r3
 8007892:	d10c      	bne.n	80078ae <validate+0x4e>
			}
		} else {
			res = FR_TIMEOUT;
		}
#else
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8007894:	687b      	ldr	r3, [r7, #4]
 8007896:	681b      	ldr	r3, [r3, #0]
 8007898:	785b      	ldrb	r3, [r3, #1]
 800789a:	4618      	mov	r0, r3
 800789c:	f7fd fc76 	bl	800518c <disk_status>
 80078a0:	4603      	mov	r3, r0
 80078a2:	f003 0301 	and.w	r3, r3, #1
 80078a6:	2b00      	cmp	r3, #0
 80078a8:	d101      	bne.n	80078ae <validate+0x4e>
			res = FR_OK;
 80078aa:	2300      	movs	r3, #0
 80078ac:	73fb      	strb	r3, [r7, #15]
		}
#endif
	}
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 80078ae:	7bfb      	ldrb	r3, [r7, #15]
 80078b0:	2b00      	cmp	r3, #0
 80078b2:	d102      	bne.n	80078ba <validate+0x5a>
 80078b4:	687b      	ldr	r3, [r7, #4]
 80078b6:	681b      	ldr	r3, [r3, #0]
 80078b8:	e000      	b.n	80078bc <validate+0x5c>
 80078ba:	2300      	movs	r3, #0
 80078bc:	683a      	ldr	r2, [r7, #0]
 80078be:	6013      	str	r3, [r2, #0]
	return res;
 80078c0:	7bfb      	ldrb	r3, [r7, #15]
}
 80078c2:	4618      	mov	r0, r3
 80078c4:	3710      	adds	r7, #16
 80078c6:	46bd      	mov	sp, r7
 80078c8:	bd80      	pop	{r7, pc}
	...

080078cc <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the filesystem object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 80078cc:	b580      	push	{r7, lr}
 80078ce:	b088      	sub	sp, #32
 80078d0:	af00      	add	r7, sp, #0
 80078d2:	60f8      	str	r0, [r7, #12]
 80078d4:	60b9      	str	r1, [r7, #8]
 80078d6:	4613      	mov	r3, r2
 80078d8:	71fb      	strb	r3, [r7, #7]
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 80078da:	68bb      	ldr	r3, [r7, #8]
 80078dc:	613b      	str	r3, [r7, #16]


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
 80078de:	f107 0310 	add.w	r3, r7, #16
 80078e2:	4618      	mov	r0, r3
 80078e4:	f7ff fc85 	bl	80071f2 <get_ldnumber>
 80078e8:	61f8      	str	r0, [r7, #28]
	if (vol < 0) return FR_INVALID_DRIVE;
 80078ea:	69fb      	ldr	r3, [r7, #28]
 80078ec:	2b00      	cmp	r3, #0
 80078ee:	da01      	bge.n	80078f4 <f_mount+0x28>
 80078f0:	230b      	movs	r3, #11
 80078f2:	e025      	b.n	8007940 <f_mount+0x74>
	cfs = FatFs[vol];					/* Pointer to fs object */
 80078f4:	4a14      	ldr	r2, [pc, #80]	; (8007948 <f_mount+0x7c>)
 80078f6:	69fb      	ldr	r3, [r7, #28]
 80078f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80078fc:	61bb      	str	r3, [r7, #24]

	if (cfs) {
 80078fe:	69bb      	ldr	r3, [r7, #24]
 8007900:	2b00      	cmp	r3, #0
 8007902:	d002      	beq.n	800790a <f_mount+0x3e>
		clear_lock(cfs);
#endif
#if FF_FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 8007904:	69bb      	ldr	r3, [r7, #24]
 8007906:	2200      	movs	r2, #0
 8007908:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
 800790a:	68fb      	ldr	r3, [r7, #12]
 800790c:	2b00      	cmp	r3, #0
 800790e:	d002      	beq.n	8007916 <f_mount+0x4a>
		fs->fs_type = 0;				/* Clear new fs object */
 8007910:	68fb      	ldr	r3, [r7, #12]
 8007912:	2200      	movs	r2, #0
 8007914:	701a      	strb	r2, [r3, #0]
#if FF_FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 8007916:	68fa      	ldr	r2, [r7, #12]
 8007918:	490b      	ldr	r1, [pc, #44]	; (8007948 <f_mount+0x7c>)
 800791a:	69fb      	ldr	r3, [r7, #28]
 800791c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

	if (opt == 0) return FR_OK;			/* Do not mount now, it will be mounted later */
 8007920:	79fb      	ldrb	r3, [r7, #7]
 8007922:	2b00      	cmp	r3, #0
 8007924:	d101      	bne.n	800792a <f_mount+0x5e>
 8007926:	2300      	movs	r3, #0
 8007928:	e00a      	b.n	8007940 <f_mount+0x74>

	res = mount_volume(&path, &fs, 0);	/* Force mounted the volume */
 800792a:	f107 010c 	add.w	r1, r7, #12
 800792e:	f107 0308 	add.w	r3, r7, #8
 8007932:	2200      	movs	r2, #0
 8007934:	4618      	mov	r0, r3
 8007936:	f7ff fd8f 	bl	8007458 <mount_volume>
 800793a:	4603      	mov	r3, r0
 800793c:	75fb      	strb	r3, [r7, #23]
	LEAVE_FF(fs, res);
 800793e:	7dfb      	ldrb	r3, [r7, #23]
}
 8007940:	4618      	mov	r0, r3
 8007942:	3720      	adds	r7, #32
 8007944:	46bd      	mov	sp, r7
 8007946:	bd80      	pop	{r7, pc}
 8007948:	200001bc 	.word	0x200001bc

0800794c <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 800794c:	b580      	push	{r7, lr}
 800794e:	b09a      	sub	sp, #104	; 0x68
 8007950:	af00      	add	r7, sp, #0
 8007952:	60f8      	str	r0, [r7, #12]
 8007954:	60b9      	str	r1, [r7, #8]
 8007956:	4613      	mov	r3, r2
 8007958:	71fb      	strb	r3, [r7, #7]
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
 800795a:	68fb      	ldr	r3, [r7, #12]
 800795c:	2b00      	cmp	r3, #0
 800795e:	d101      	bne.n	8007964 <f_open+0x18>
 8007960:	2309      	movs	r3, #9
 8007962:	e176      	b.n	8007c52 <f_open+0x306>

	/* Get logical drive number */
	mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND;
 8007964:	79fb      	ldrb	r3, [r7, #7]
 8007966:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800796a:	71fb      	strb	r3, [r7, #7]
	res = mount_volume(&path, &fs, mode);
 800796c:	79fa      	ldrb	r2, [r7, #7]
 800796e:	f107 0114 	add.w	r1, r7, #20
 8007972:	f107 0308 	add.w	r3, r7, #8
 8007976:	4618      	mov	r0, r3
 8007978:	f7ff fd6e 	bl	8007458 <mount_volume>
 800797c:	4603      	mov	r3, r0
 800797e:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
	if (res == FR_OK) {
 8007982:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8007986:	2b00      	cmp	r3, #0
 8007988:	f040 815a 	bne.w	8007c40 <f_open+0x2f4>
		dj.obj.fs = fs;
 800798c:	697b      	ldr	r3, [r7, #20]
 800798e:	61bb      	str	r3, [r7, #24]
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);	/* Follow the file path */
 8007990:	68ba      	ldr	r2, [r7, #8]
 8007992:	f107 0318 	add.w	r3, r7, #24
 8007996:	4611      	mov	r1, r2
 8007998:	4618      	mov	r0, r3
 800799a:	f7ff fbbb 	bl	8007114 <follow_path>
 800799e:	4603      	mov	r3, r0
 80079a0:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
#if !FF_FS_READONLY	/* Read/Write configuration */
		if (res == FR_OK) {
 80079a4:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 80079a8:	2b00      	cmp	r3, #0
 80079aa:	d107      	bne.n	80079bc <f_open+0x70>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 80079ac:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 80079b0:	b25b      	sxtb	r3, r3
 80079b2:	2b00      	cmp	r3, #0
 80079b4:	da02      	bge.n	80079bc <f_open+0x70>
				res = FR_INVALID_NAME;
 80079b6:	2306      	movs	r3, #6
 80079b8:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);		/* Check if the file can be used */
			}
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 80079bc:	79fb      	ldrb	r3, [r7, #7]
 80079be:	f003 031c 	and.w	r3, r3, #28
 80079c2:	2b00      	cmp	r3, #0
 80079c4:	d077      	beq.n	8007ab6 <f_open+0x16a>
			if (res != FR_OK) {					/* No file, create new */
 80079c6:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 80079ca:	2b00      	cmp	r3, #0
 80079cc:	d010      	beq.n	80079f0 <f_open+0xa4>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 80079ce:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 80079d2:	2b04      	cmp	r3, #4
 80079d4:	d107      	bne.n	80079e6 <f_open+0x9a>
#if FF_FS_LOCK != 0
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
 80079d6:	f107 0318 	add.w	r3, r7, #24
 80079da:	4618      	mov	r0, r3
 80079dc:	f7fe ff0a 	bl	80067f4 <dir_register>
 80079e0:	4603      	mov	r3, r0
 80079e2:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
#endif
				}
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 80079e6:	79fb      	ldrb	r3, [r7, #7]
 80079e8:	f043 0308 	orr.w	r3, r3, #8
 80079ec:	71fb      	strb	r3, [r7, #7]
 80079ee:	e010      	b.n	8007a12 <f_open+0xc6>
			}
			else {								/* Any object with the same name is already existing */
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 80079f0:	7fbb      	ldrb	r3, [r7, #30]
 80079f2:	f003 0311 	and.w	r3, r3, #17
 80079f6:	2b00      	cmp	r3, #0
 80079f8:	d003      	beq.n	8007a02 <f_open+0xb6>
					res = FR_DENIED;
 80079fa:	2307      	movs	r3, #7
 80079fc:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 8007a00:	e007      	b.n	8007a12 <f_open+0xc6>
				} else {
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 8007a02:	79fb      	ldrb	r3, [r7, #7]
 8007a04:	f003 0304 	and.w	r3, r3, #4
 8007a08:	2b00      	cmp	r3, #0
 8007a0a:	d002      	beq.n	8007a12 <f_open+0xc6>
 8007a0c:	2308      	movs	r3, #8
 8007a0e:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
 8007a12:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8007a16:	2b00      	cmp	r3, #0
 8007a18:	d167      	bne.n	8007aea <f_open+0x19e>
 8007a1a:	79fb      	ldrb	r3, [r7, #7]
 8007a1c:	f003 0308 	and.w	r3, r3, #8
 8007a20:	2b00      	cmp	r3, #0
 8007a22:	d062      	beq.n	8007aea <f_open+0x19e>
					}
				} else
#endif
				{
					/* Set directory entry initial state */
					tm = GET_FATTIME();					/* Set created time */
 8007a24:	4b8d      	ldr	r3, [pc, #564]	; (8007c5c <f_open+0x310>)
 8007a26:	65bb      	str	r3, [r7, #88]	; 0x58
					st_dword(dj.dir + DIR_CrtTime, tm);
 8007a28:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007a2a:	330e      	adds	r3, #14
 8007a2c:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8007a2e:	4618      	mov	r0, r3
 8007a30:	f7fd fc90 	bl	8005354 <st_dword>
					st_dword(dj.dir + DIR_ModTime, tm);
 8007a34:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007a36:	3316      	adds	r3, #22
 8007a38:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8007a3a:	4618      	mov	r0, r3
 8007a3c:	f7fd fc8a 	bl	8005354 <st_dword>
					cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
 8007a40:	697b      	ldr	r3, [r7, #20]
 8007a42:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8007a44:	4611      	mov	r1, r2
 8007a46:	4618      	mov	r0, r3
 8007a48:	f7fe fb2d 	bl	80060a6 <ld_clust>
 8007a4c:	6578      	str	r0, [r7, #84]	; 0x54
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 8007a4e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007a50:	330b      	adds	r3, #11
 8007a52:	2220      	movs	r2, #32
 8007a54:	701a      	strb	r2, [r3, #0]
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
 8007a56:	697b      	ldr	r3, [r7, #20]
 8007a58:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8007a5a:	2200      	movs	r2, #0
 8007a5c:	4618      	mov	r0, r3
 8007a5e:	f7fe fb41 	bl	80060e4 <st_clust>
					st_dword(dj.dir + DIR_FileSize, 0);
 8007a62:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007a64:	331c      	adds	r3, #28
 8007a66:	2100      	movs	r1, #0
 8007a68:	4618      	mov	r0, r3
 8007a6a:	f7fd fc73 	bl	8005354 <st_dword>
					fs->wflag = 1;
 8007a6e:	697b      	ldr	r3, [r7, #20]
 8007a70:	2201      	movs	r2, #1
 8007a72:	70da      	strb	r2, [r3, #3]
					if (cl != 0) {						/* Remove the cluster chain if exist */
 8007a74:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8007a76:	2b00      	cmp	r3, #0
 8007a78:	d037      	beq.n	8007aea <f_open+0x19e>
						sc = fs->winsect;
 8007a7a:	697b      	ldr	r3, [r7, #20]
 8007a7c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007a7e:	653b      	str	r3, [r7, #80]	; 0x50
						res = remove_chain(&dj.obj, cl, 0);
 8007a80:	f107 0318 	add.w	r3, r7, #24
 8007a84:	2200      	movs	r2, #0
 8007a86:	6d79      	ldr	r1, [r7, #84]	; 0x54
 8007a88:	4618      	mov	r0, r3
 8007a8a:	f7fe f836 	bl	8005afa <remove_chain>
 8007a8e:	4603      	mov	r3, r0
 8007a90:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
						if (res == FR_OK) {
 8007a94:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8007a98:	2b00      	cmp	r3, #0
 8007a9a:	d126      	bne.n	8007aea <f_open+0x19e>
							res = move_window(fs, sc);
 8007a9c:	697b      	ldr	r3, [r7, #20]
 8007a9e:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8007aa0:	4618      	mov	r0, r3
 8007aa2:	f7fd fddc 	bl	800565e <move_window>
 8007aa6:	4603      	mov	r3, r0
 8007aa8:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 8007aac:	697b      	ldr	r3, [r7, #20]
 8007aae:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8007ab0:	3a01      	subs	r2, #1
 8007ab2:	611a      	str	r2, [r3, #16]
 8007ab4:	e019      	b.n	8007aea <f_open+0x19e>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Is the object exsiting? */
 8007ab6:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8007aba:	2b00      	cmp	r3, #0
 8007abc:	d115      	bne.n	8007aea <f_open+0x19e>
				if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
 8007abe:	7fbb      	ldrb	r3, [r7, #30]
 8007ac0:	f003 0310 	and.w	r3, r3, #16
 8007ac4:	2b00      	cmp	r3, #0
 8007ac6:	d003      	beq.n	8007ad0 <f_open+0x184>
					res = FR_NO_FILE;
 8007ac8:	2304      	movs	r3, #4
 8007aca:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 8007ace:	e00c      	b.n	8007aea <f_open+0x19e>
				} else {
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open against R/O file */
 8007ad0:	79fb      	ldrb	r3, [r7, #7]
 8007ad2:	f003 0302 	and.w	r3, r3, #2
 8007ad6:	2b00      	cmp	r3, #0
 8007ad8:	d007      	beq.n	8007aea <f_open+0x19e>
 8007ada:	7fbb      	ldrb	r3, [r7, #30]
 8007adc:	f003 0301 	and.w	r3, r3, #1
 8007ae0:	2b00      	cmp	r3, #0
 8007ae2:	d002      	beq.n	8007aea <f_open+0x19e>
						res = FR_DENIED;
 8007ae4:	2307      	movs	r3, #7
 8007ae6:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
					}
				}
			}
		}
		if (res == FR_OK) {
 8007aea:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8007aee:	2b00      	cmp	r3, #0
 8007af0:	d10f      	bne.n	8007b12 <f_open+0x1c6>
			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
 8007af2:	79fb      	ldrb	r3, [r7, #7]
 8007af4:	f003 0308 	and.w	r3, r3, #8
 8007af8:	2b00      	cmp	r3, #0
 8007afa:	d003      	beq.n	8007b04 <f_open+0x1b8>
 8007afc:	79fb      	ldrb	r3, [r7, #7]
 8007afe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8007b02:	71fb      	strb	r3, [r7, #7]
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 8007b04:	697b      	ldr	r3, [r7, #20]
 8007b06:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8007b08:	68fb      	ldr	r3, [r7, #12]
 8007b0a:	621a      	str	r2, [r3, #32]
			fp->dir_ptr = dj.dir;
 8007b0c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8007b0e:	68fb      	ldr	r3, [r7, #12]
 8007b10:	625a      	str	r2, [r3, #36]	; 0x24
				}
			}
		}
#endif

		if (res == FR_OK) {
 8007b12:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8007b16:	2b00      	cmp	r3, #0
 8007b18:	f040 8092 	bne.w	8007c40 <f_open+0x2f4>
				fp->obj.c_ofs = dj.blk_ofs;
				init_alloc_info(fs, &fp->obj);
			} else
#endif
			{
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 8007b1c:	697b      	ldr	r3, [r7, #20]
 8007b1e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8007b20:	4611      	mov	r1, r2
 8007b22:	4618      	mov	r0, r3
 8007b24:	f7fe fabf 	bl	80060a6 <ld_clust>
 8007b28:	4602      	mov	r2, r0
 8007b2a:	68fb      	ldr	r3, [r7, #12]
 8007b2c:	609a      	str	r2, [r3, #8]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 8007b2e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007b30:	331c      	adds	r3, #28
 8007b32:	4618      	mov	r0, r3
 8007b34:	f7fd fbd0 	bl	80052d8 <ld_dword>
 8007b38:	4602      	mov	r2, r0
 8007b3a:	68fb      	ldr	r3, [r7, #12]
 8007b3c:	60da      	str	r2, [r3, #12]
			}
#if FF_USE_FASTSEEK
			fp->cltbl = 0;			/* Disable fast seek mode */
#endif
			fp->obj.fs = fs;	 	/* Validate the file object */
 8007b3e:	697a      	ldr	r2, [r7, #20]
 8007b40:	68fb      	ldr	r3, [r7, #12]
 8007b42:	601a      	str	r2, [r3, #0]
			fp->obj.id = fs->id;
 8007b44:	697b      	ldr	r3, [r7, #20]
 8007b46:	88da      	ldrh	r2, [r3, #6]
 8007b48:	68fb      	ldr	r3, [r7, #12]
 8007b4a:	809a      	strh	r2, [r3, #4]
			fp->flag = mode;		/* Set file access mode */
 8007b4c:	68fb      	ldr	r3, [r7, #12]
 8007b4e:	79fa      	ldrb	r2, [r7, #7]
 8007b50:	741a      	strb	r2, [r3, #16]
			fp->err = 0;			/* Clear error flag */
 8007b52:	68fb      	ldr	r3, [r7, #12]
 8007b54:	2200      	movs	r2, #0
 8007b56:	745a      	strb	r2, [r3, #17]
			fp->sect = 0;			/* Invalidate current data sector */
 8007b58:	68fb      	ldr	r3, [r7, #12]
 8007b5a:	2200      	movs	r2, #0
 8007b5c:	61da      	str	r2, [r3, #28]
			fp->fptr = 0;			/* Set file pointer top of the file */
 8007b5e:	68fb      	ldr	r3, [r7, #12]
 8007b60:	2200      	movs	r2, #0
 8007b62:	615a      	str	r2, [r3, #20]
#if !FF_FS_READONLY
#if !FF_FS_TINY
			mem_set(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
 8007b64:	68fb      	ldr	r3, [r7, #12]
 8007b66:	3328      	adds	r3, #40	; 0x28
 8007b68:	f44f 7200 	mov.w	r2, #512	; 0x200
 8007b6c:	2100      	movs	r1, #0
 8007b6e:	4618      	mov	r0, r3
 8007b70:	f7fd fc3d 	bl	80053ee <mem_set>
#endif
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 8007b74:	79fb      	ldrb	r3, [r7, #7]
 8007b76:	f003 0320 	and.w	r3, r3, #32
 8007b7a:	2b00      	cmp	r3, #0
 8007b7c:	d060      	beq.n	8007c40 <f_open+0x2f4>
 8007b7e:	68fb      	ldr	r3, [r7, #12]
 8007b80:	68db      	ldr	r3, [r3, #12]
 8007b82:	2b00      	cmp	r3, #0
 8007b84:	d05c      	beq.n	8007c40 <f_open+0x2f4>
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
 8007b86:	68fb      	ldr	r3, [r7, #12]
 8007b88:	68da      	ldr	r2, [r3, #12]
 8007b8a:	68fb      	ldr	r3, [r7, #12]
 8007b8c:	615a      	str	r2, [r3, #20]
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 8007b8e:	697b      	ldr	r3, [r7, #20]
 8007b90:	895b      	ldrh	r3, [r3, #10]
 8007b92:	025b      	lsls	r3, r3, #9
 8007b94:	64fb      	str	r3, [r7, #76]	; 0x4c
				clst = fp->obj.sclust;				/* Follow the cluster chain */
 8007b96:	68fb      	ldr	r3, [r7, #12]
 8007b98:	689b      	ldr	r3, [r3, #8]
 8007b9a:	663b      	str	r3, [r7, #96]	; 0x60
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 8007b9c:	68fb      	ldr	r3, [r7, #12]
 8007b9e:	68db      	ldr	r3, [r3, #12]
 8007ba0:	65fb      	str	r3, [r7, #92]	; 0x5c
 8007ba2:	e016      	b.n	8007bd2 <f_open+0x286>
					clst = get_fat(&fp->obj, clst);
 8007ba4:	68fb      	ldr	r3, [r7, #12]
 8007ba6:	6e39      	ldr	r1, [r7, #96]	; 0x60
 8007ba8:	4618      	mov	r0, r3
 8007baa:	f7fd fe12 	bl	80057d2 <get_fat>
 8007bae:	6638      	str	r0, [r7, #96]	; 0x60
					if (clst <= 1) res = FR_INT_ERR;
 8007bb0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8007bb2:	2b01      	cmp	r3, #1
 8007bb4:	d802      	bhi.n	8007bbc <f_open+0x270>
 8007bb6:	2302      	movs	r3, #2
 8007bb8:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 8007bbc:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8007bbe:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007bc2:	d102      	bne.n	8007bca <f_open+0x27e>
 8007bc4:	2301      	movs	r3, #1
 8007bc6:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 8007bca:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8007bcc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007bce:	1ad3      	subs	r3, r2, r3
 8007bd0:	65fb      	str	r3, [r7, #92]	; 0x5c
 8007bd2:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8007bd6:	2b00      	cmp	r3, #0
 8007bd8:	d103      	bne.n	8007be2 <f_open+0x296>
 8007bda:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8007bdc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007bde:	429a      	cmp	r2, r3
 8007be0:	d8e0      	bhi.n	8007ba4 <f_open+0x258>
				}
				fp->clust = clst;
 8007be2:	68fb      	ldr	r3, [r7, #12]
 8007be4:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8007be6:	619a      	str	r2, [r3, #24]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 8007be8:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8007bec:	2b00      	cmp	r3, #0
 8007bee:	d127      	bne.n	8007c40 <f_open+0x2f4>
 8007bf0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007bf2:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8007bf6:	2b00      	cmp	r3, #0
 8007bf8:	d022      	beq.n	8007c40 <f_open+0x2f4>
					sc = clst2sect(fs, clst);
 8007bfa:	697b      	ldr	r3, [r7, #20]
 8007bfc:	6e39      	ldr	r1, [r7, #96]	; 0x60
 8007bfe:	4618      	mov	r0, r3
 8007c00:	f7fd fdc8 	bl	8005794 <clst2sect>
 8007c04:	6538      	str	r0, [r7, #80]	; 0x50
					if (sc == 0) {
 8007c06:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8007c08:	2b00      	cmp	r3, #0
 8007c0a:	d103      	bne.n	8007c14 <f_open+0x2c8>
						res = FR_INT_ERR;
 8007c0c:	2302      	movs	r3, #2
 8007c0e:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 8007c12:	e015      	b.n	8007c40 <f_open+0x2f4>
					} else {
						fp->sect = sc + (DWORD)(ofs / SS(fs));
 8007c14:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007c16:	0a5a      	lsrs	r2, r3, #9
 8007c18:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8007c1a:	441a      	add	r2, r3
 8007c1c:	68fb      	ldr	r3, [r7, #12]
 8007c1e:	61da      	str	r2, [r3, #28]
#if !FF_FS_TINY
						if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 8007c20:	697b      	ldr	r3, [r7, #20]
 8007c22:	7858      	ldrb	r0, [r3, #1]
 8007c24:	68fb      	ldr	r3, [r7, #12]
 8007c26:	f103 0128 	add.w	r1, r3, #40	; 0x28
 8007c2a:	68fb      	ldr	r3, [r7, #12]
 8007c2c:	69da      	ldr	r2, [r3, #28]
 8007c2e:	2301      	movs	r3, #1
 8007c30:	f7fd faca 	bl	80051c8 <disk_read>
 8007c34:	4603      	mov	r3, r0
 8007c36:	2b00      	cmp	r3, #0
 8007c38:	d002      	beq.n	8007c40 <f_open+0x2f4>
 8007c3a:	2301      	movs	r3, #1
 8007c3c:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
		}

		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 8007c40:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8007c44:	2b00      	cmp	r3, #0
 8007c46:	d002      	beq.n	8007c4e <f_open+0x302>
 8007c48:	68fb      	ldr	r3, [r7, #12]
 8007c4a:	2200      	movs	r2, #0
 8007c4c:	601a      	str	r2, [r3, #0]

	LEAVE_FF(fs, res);
 8007c4e:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
}
 8007c52:	4618      	mov	r0, r3
 8007c54:	3768      	adds	r7, #104	; 0x68
 8007c56:	46bd      	mov	sp, r7
 8007c58:	bd80      	pop	{r7, pc}
 8007c5a:	bf00      	nop
 8007c5c:	52750000 	.word	0x52750000

08007c60 <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
 8007c60:	b580      	push	{r7, lr}
 8007c62:	b08e      	sub	sp, #56	; 0x38
 8007c64:	af00      	add	r7, sp, #0
 8007c66:	60f8      	str	r0, [r7, #12]
 8007c68:	60b9      	str	r1, [r7, #8]
 8007c6a:	607a      	str	r2, [r7, #4]
 8007c6c:	603b      	str	r3, [r7, #0]
	FATFS *fs;
	DWORD clst;
	LBA_t sect;
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;
 8007c6e:	68bb      	ldr	r3, [r7, #8]
 8007c70:	627b      	str	r3, [r7, #36]	; 0x24


	*br = 0;	/* Clear read byte counter */
 8007c72:	683b      	ldr	r3, [r7, #0]
 8007c74:	2200      	movs	r2, #0
 8007c76:	601a      	str	r2, [r3, #0]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 8007c78:	68fb      	ldr	r3, [r7, #12]
 8007c7a:	f107 0214 	add.w	r2, r7, #20
 8007c7e:	4611      	mov	r1, r2
 8007c80:	4618      	mov	r0, r3
 8007c82:	f7ff fded 	bl	8007860 <validate>
 8007c86:	4603      	mov	r3, r0
 8007c88:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8007c8c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8007c90:	2b00      	cmp	r3, #0
 8007c92:	d107      	bne.n	8007ca4 <f_read+0x44>
 8007c94:	68fb      	ldr	r3, [r7, #12]
 8007c96:	7c5b      	ldrb	r3, [r3, #17]
 8007c98:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 8007c9c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8007ca0:	2b00      	cmp	r3, #0
 8007ca2:	d002      	beq.n	8007caa <f_read+0x4a>
 8007ca4:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8007ca8:	e109      	b.n	8007ebe <f_read+0x25e>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 8007caa:	68fb      	ldr	r3, [r7, #12]
 8007cac:	7c1b      	ldrb	r3, [r3, #16]
 8007cae:	f003 0301 	and.w	r3, r3, #1
 8007cb2:	2b00      	cmp	r3, #0
 8007cb4:	d101      	bne.n	8007cba <f_read+0x5a>
 8007cb6:	2307      	movs	r3, #7
 8007cb8:	e101      	b.n	8007ebe <f_read+0x25e>
	remain = fp->obj.objsize - fp->fptr;
 8007cba:	68fb      	ldr	r3, [r7, #12]
 8007cbc:	68da      	ldr	r2, [r3, #12]
 8007cbe:	68fb      	ldr	r3, [r7, #12]
 8007cc0:	695b      	ldr	r3, [r3, #20]
 8007cc2:	1ad3      	subs	r3, r2, r3
 8007cc4:	623b      	str	r3, [r7, #32]
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 8007cc6:	687a      	ldr	r2, [r7, #4]
 8007cc8:	6a3b      	ldr	r3, [r7, #32]
 8007cca:	429a      	cmp	r2, r3
 8007ccc:	f240 80f2 	bls.w	8007eb4 <f_read+0x254>
 8007cd0:	6a3b      	ldr	r3, [r7, #32]
 8007cd2:	607b      	str	r3, [r7, #4]

	for ( ;  btr;								/* Repeat until btr bytes read */
 8007cd4:	e0ee      	b.n	8007eb4 <f_read+0x254>
		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 8007cd6:	68fb      	ldr	r3, [r7, #12]
 8007cd8:	695b      	ldr	r3, [r3, #20]
 8007cda:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8007cde:	2b00      	cmp	r3, #0
 8007ce0:	f040 80ba 	bne.w	8007e58 <f_read+0x1f8>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 8007ce4:	68fb      	ldr	r3, [r7, #12]
 8007ce6:	695b      	ldr	r3, [r3, #20]
 8007ce8:	0a5b      	lsrs	r3, r3, #9
 8007cea:	697a      	ldr	r2, [r7, #20]
 8007cec:	8952      	ldrh	r2, [r2, #10]
 8007cee:	3a01      	subs	r2, #1
 8007cf0:	4013      	ands	r3, r2
 8007cf2:	61fb      	str	r3, [r7, #28]
			if (csect == 0) {					/* On the cluster boundary? */
 8007cf4:	69fb      	ldr	r3, [r7, #28]
 8007cf6:	2b00      	cmp	r3, #0
 8007cf8:	d123      	bne.n	8007d42 <f_read+0xe2>
				if (fp->fptr == 0) {			/* On the top of the file? */
 8007cfa:	68fb      	ldr	r3, [r7, #12]
 8007cfc:	695b      	ldr	r3, [r3, #20]
 8007cfe:	2b00      	cmp	r3, #0
 8007d00:	d103      	bne.n	8007d0a <f_read+0xaa>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 8007d02:	68fb      	ldr	r3, [r7, #12]
 8007d04:	689b      	ldr	r3, [r3, #8]
 8007d06:	633b      	str	r3, [r7, #48]	; 0x30
 8007d08:	e007      	b.n	8007d1a <f_read+0xba>
					if (fp->cltbl) {
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					} else
#endif
					{
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 8007d0a:	68fa      	ldr	r2, [r7, #12]
 8007d0c:	68fb      	ldr	r3, [r7, #12]
 8007d0e:	699b      	ldr	r3, [r3, #24]
 8007d10:	4619      	mov	r1, r3
 8007d12:	4610      	mov	r0, r2
 8007d14:	f7fd fd5d 	bl	80057d2 <get_fat>
 8007d18:	6338      	str	r0, [r7, #48]	; 0x30
					}
				}
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 8007d1a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007d1c:	2b01      	cmp	r3, #1
 8007d1e:	d804      	bhi.n	8007d2a <f_read+0xca>
 8007d20:	68fb      	ldr	r3, [r7, #12]
 8007d22:	2202      	movs	r2, #2
 8007d24:	745a      	strb	r2, [r3, #17]
 8007d26:	2302      	movs	r3, #2
 8007d28:	e0c9      	b.n	8007ebe <f_read+0x25e>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8007d2a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007d2c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007d30:	d104      	bne.n	8007d3c <f_read+0xdc>
 8007d32:	68fb      	ldr	r3, [r7, #12]
 8007d34:	2201      	movs	r2, #1
 8007d36:	745a      	strb	r2, [r3, #17]
 8007d38:	2301      	movs	r3, #1
 8007d3a:	e0c0      	b.n	8007ebe <f_read+0x25e>
				fp->clust = clst;				/* Update current cluster */
 8007d3c:	68fb      	ldr	r3, [r7, #12]
 8007d3e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8007d40:	619a      	str	r2, [r3, #24]
			}
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
 8007d42:	697a      	ldr	r2, [r7, #20]
 8007d44:	68fb      	ldr	r3, [r7, #12]
 8007d46:	699b      	ldr	r3, [r3, #24]
 8007d48:	4619      	mov	r1, r3
 8007d4a:	4610      	mov	r0, r2
 8007d4c:	f7fd fd22 	bl	8005794 <clst2sect>
 8007d50:	61b8      	str	r0, [r7, #24]
			if (sect == 0) ABORT(fs, FR_INT_ERR);
 8007d52:	69bb      	ldr	r3, [r7, #24]
 8007d54:	2b00      	cmp	r3, #0
 8007d56:	d104      	bne.n	8007d62 <f_read+0x102>
 8007d58:	68fb      	ldr	r3, [r7, #12]
 8007d5a:	2202      	movs	r2, #2
 8007d5c:	745a      	strb	r2, [r3, #17]
 8007d5e:	2302      	movs	r3, #2
 8007d60:	e0ad      	b.n	8007ebe <f_read+0x25e>
			sect += csect;
 8007d62:	69ba      	ldr	r2, [r7, #24]
 8007d64:	69fb      	ldr	r3, [r7, #28]
 8007d66:	4413      	add	r3, r2
 8007d68:	61bb      	str	r3, [r7, #24]
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
 8007d6a:	687b      	ldr	r3, [r7, #4]
 8007d6c:	0a5b      	lsrs	r3, r3, #9
 8007d6e:	62bb      	str	r3, [r7, #40]	; 0x28
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
 8007d70:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007d72:	2b00      	cmp	r3, #0
 8007d74:	d039      	beq.n	8007dea <f_read+0x18a>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8007d76:	69fa      	ldr	r2, [r7, #28]
 8007d78:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007d7a:	4413      	add	r3, r2
 8007d7c:	697a      	ldr	r2, [r7, #20]
 8007d7e:	8952      	ldrh	r2, [r2, #10]
 8007d80:	4293      	cmp	r3, r2
 8007d82:	d905      	bls.n	8007d90 <f_read+0x130>
					cc = fs->csize - csect;
 8007d84:	697b      	ldr	r3, [r7, #20]
 8007d86:	895b      	ldrh	r3, [r3, #10]
 8007d88:	461a      	mov	r2, r3
 8007d8a:	69fb      	ldr	r3, [r7, #28]
 8007d8c:	1ad3      	subs	r3, r2, r3
 8007d8e:	62bb      	str	r3, [r7, #40]	; 0x28
				}
				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8007d90:	697b      	ldr	r3, [r7, #20]
 8007d92:	7858      	ldrb	r0, [r3, #1]
 8007d94:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007d96:	69ba      	ldr	r2, [r7, #24]
 8007d98:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8007d9a:	f7fd fa15 	bl	80051c8 <disk_read>
 8007d9e:	4603      	mov	r3, r0
 8007da0:	2b00      	cmp	r3, #0
 8007da2:	d004      	beq.n	8007dae <f_read+0x14e>
 8007da4:	68fb      	ldr	r3, [r7, #12]
 8007da6:	2201      	movs	r2, #1
 8007da8:	745a      	strb	r2, [r3, #17]
 8007daa:	2301      	movs	r3, #1
 8007dac:	e087      	b.n	8007ebe <f_read+0x25e>
#if FF_FS_TINY
				if (fs->wflag && fs->winsect - sect < cc) {
					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
				}
#else
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 8007dae:	68fb      	ldr	r3, [r7, #12]
 8007db0:	7c1b      	ldrb	r3, [r3, #16]
 8007db2:	b25b      	sxtb	r3, r3
 8007db4:	2b00      	cmp	r3, #0
 8007db6:	da14      	bge.n	8007de2 <f_read+0x182>
 8007db8:	68fb      	ldr	r3, [r7, #12]
 8007dba:	69da      	ldr	r2, [r3, #28]
 8007dbc:	69bb      	ldr	r3, [r7, #24]
 8007dbe:	1ad3      	subs	r3, r2, r3
 8007dc0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007dc2:	429a      	cmp	r2, r3
 8007dc4:	d90d      	bls.n	8007de2 <f_read+0x182>
					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 8007dc6:	68fb      	ldr	r3, [r7, #12]
 8007dc8:	69da      	ldr	r2, [r3, #28]
 8007dca:	69bb      	ldr	r3, [r7, #24]
 8007dcc:	1ad3      	subs	r3, r2, r3
 8007dce:	025b      	lsls	r3, r3, #9
 8007dd0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007dd2:	18d0      	adds	r0, r2, r3
 8007dd4:	68fb      	ldr	r3, [r7, #12]
 8007dd6:	3328      	adds	r3, #40	; 0x28
 8007dd8:	f44f 7200 	mov.w	r2, #512	; 0x200
 8007ddc:	4619      	mov	r1, r3
 8007dde:	f7fd fae5 	bl	80053ac <mem_cpy>
				}
#endif
#endif
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 8007de2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007de4:	025b      	lsls	r3, r3, #9
 8007de6:	62fb      	str	r3, [r7, #44]	; 0x2c
				continue;
 8007de8:	e050      	b.n	8007e8c <f_read+0x22c>
			}
#if !FF_FS_TINY
			if (fp->sect != sect) {			/* Load data sector if not in cache */
 8007dea:	68fb      	ldr	r3, [r7, #12]
 8007dec:	69db      	ldr	r3, [r3, #28]
 8007dee:	69ba      	ldr	r2, [r7, #24]
 8007df0:	429a      	cmp	r2, r3
 8007df2:	d02e      	beq.n	8007e52 <f_read+0x1f2>
#if !FF_FS_READONLY
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 8007df4:	68fb      	ldr	r3, [r7, #12]
 8007df6:	7c1b      	ldrb	r3, [r3, #16]
 8007df8:	b25b      	sxtb	r3, r3
 8007dfa:	2b00      	cmp	r3, #0
 8007dfc:	da18      	bge.n	8007e30 <f_read+0x1d0>
					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8007dfe:	697b      	ldr	r3, [r7, #20]
 8007e00:	7858      	ldrb	r0, [r3, #1]
 8007e02:	68fb      	ldr	r3, [r7, #12]
 8007e04:	f103 0128 	add.w	r1, r3, #40	; 0x28
 8007e08:	68fb      	ldr	r3, [r7, #12]
 8007e0a:	69da      	ldr	r2, [r3, #28]
 8007e0c:	2301      	movs	r3, #1
 8007e0e:	f7fd fa09 	bl	8005224 <disk_write>
 8007e12:	4603      	mov	r3, r0
 8007e14:	2b00      	cmp	r3, #0
 8007e16:	d004      	beq.n	8007e22 <f_read+0x1c2>
 8007e18:	68fb      	ldr	r3, [r7, #12]
 8007e1a:	2201      	movs	r2, #1
 8007e1c:	745a      	strb	r2, [r3, #17]
 8007e1e:	2301      	movs	r3, #1
 8007e20:	e04d      	b.n	8007ebe <f_read+0x25e>
					fp->flag &= (BYTE)~FA_DIRTY;
 8007e22:	68fb      	ldr	r3, [r7, #12]
 8007e24:	7c1b      	ldrb	r3, [r3, #16]
 8007e26:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8007e2a:	b2da      	uxtb	r2, r3
 8007e2c:	68fb      	ldr	r3, [r7, #12]
 8007e2e:	741a      	strb	r2, [r3, #16]
				}
#endif
				if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 8007e30:	697b      	ldr	r3, [r7, #20]
 8007e32:	7858      	ldrb	r0, [r3, #1]
 8007e34:	68fb      	ldr	r3, [r7, #12]
 8007e36:	f103 0128 	add.w	r1, r3, #40	; 0x28
 8007e3a:	2301      	movs	r3, #1
 8007e3c:	69ba      	ldr	r2, [r7, #24]
 8007e3e:	f7fd f9c3 	bl	80051c8 <disk_read>
 8007e42:	4603      	mov	r3, r0
 8007e44:	2b00      	cmp	r3, #0
 8007e46:	d004      	beq.n	8007e52 <f_read+0x1f2>
 8007e48:	68fb      	ldr	r3, [r7, #12]
 8007e4a:	2201      	movs	r2, #1
 8007e4c:	745a      	strb	r2, [r3, #17]
 8007e4e:	2301      	movs	r3, #1
 8007e50:	e035      	b.n	8007ebe <f_read+0x25e>
			}
#endif
			fp->sect = sect;
 8007e52:	68fb      	ldr	r3, [r7, #12]
 8007e54:	69ba      	ldr	r2, [r7, #24]
 8007e56:	61da      	str	r2, [r3, #28]
		}
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
 8007e58:	68fb      	ldr	r3, [r7, #12]
 8007e5a:	695b      	ldr	r3, [r3, #20]
 8007e5c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8007e60:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
 8007e64:	62fb      	str	r3, [r7, #44]	; 0x2c
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
 8007e66:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8007e68:	687b      	ldr	r3, [r7, #4]
 8007e6a:	429a      	cmp	r2, r3
 8007e6c:	d901      	bls.n	8007e72 <f_read+0x212>
 8007e6e:	687b      	ldr	r3, [r7, #4]
 8007e70:	62fb      	str	r3, [r7, #44]	; 0x2c
#if FF_FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#else
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 8007e72:	68fb      	ldr	r3, [r7, #12]
 8007e74:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8007e78:	68fb      	ldr	r3, [r7, #12]
 8007e7a:	695b      	ldr	r3, [r3, #20]
 8007e7c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8007e80:	4413      	add	r3, r2
 8007e82:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8007e84:	4619      	mov	r1, r3
 8007e86:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8007e88:	f7fd fa90 	bl	80053ac <mem_cpy>
		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
 8007e8c:	687a      	ldr	r2, [r7, #4]
 8007e8e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007e90:	1ad3      	subs	r3, r2, r3
 8007e92:	607b      	str	r3, [r7, #4]
 8007e94:	683b      	ldr	r3, [r7, #0]
 8007e96:	681a      	ldr	r2, [r3, #0]
 8007e98:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007e9a:	441a      	add	r2, r3
 8007e9c:	683b      	ldr	r3, [r7, #0]
 8007e9e:	601a      	str	r2, [r3, #0]
 8007ea0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007ea2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007ea4:	4413      	add	r3, r2
 8007ea6:	627b      	str	r3, [r7, #36]	; 0x24
 8007ea8:	68fb      	ldr	r3, [r7, #12]
 8007eaa:	695a      	ldr	r2, [r3, #20]
 8007eac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007eae:	441a      	add	r2, r3
 8007eb0:	68fb      	ldr	r3, [r7, #12]
 8007eb2:	615a      	str	r2, [r3, #20]
	for ( ;  btr;								/* Repeat until btr bytes read */
 8007eb4:	687b      	ldr	r3, [r7, #4]
 8007eb6:	2b00      	cmp	r3, #0
 8007eb8:	f47f af0d 	bne.w	8007cd6 <f_read+0x76>
#endif
	}

	LEAVE_FF(fs, FR_OK);
 8007ebc:	2300      	movs	r3, #0
}
 8007ebe:	4618      	mov	r0, r3
 8007ec0:	3738      	adds	r7, #56	; 0x38
 8007ec2:	46bd      	mov	sp, r7
 8007ec4:	bd80      	pop	{r7, pc}

08007ec6 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void* buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 8007ec6:	b580      	push	{r7, lr}
 8007ec8:	b08c      	sub	sp, #48	; 0x30
 8007eca:	af00      	add	r7, sp, #0
 8007ecc:	60f8      	str	r0, [r7, #12]
 8007ece:	60b9      	str	r1, [r7, #8]
 8007ed0:	607a      	str	r2, [r7, #4]
 8007ed2:	603b      	str	r3, [r7, #0]
	FRESULT res;
	FATFS *fs;
	DWORD clst;
	LBA_t sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;
 8007ed4:	68bb      	ldr	r3, [r7, #8]
 8007ed6:	61fb      	str	r3, [r7, #28]


	*bw = 0;	/* Clear write byte counter */
 8007ed8:	683b      	ldr	r3, [r7, #0]
 8007eda:	2200      	movs	r2, #0
 8007edc:	601a      	str	r2, [r3, #0]
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 8007ede:	68fb      	ldr	r3, [r7, #12]
 8007ee0:	f107 0210 	add.w	r2, r7, #16
 8007ee4:	4611      	mov	r1, r2
 8007ee6:	4618      	mov	r0, r3
 8007ee8:	f7ff fcba 	bl	8007860 <validate>
 8007eec:	4603      	mov	r3, r0
 8007eee:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8007ef2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8007ef6:	2b00      	cmp	r3, #0
 8007ef8:	d107      	bne.n	8007f0a <f_write+0x44>
 8007efa:	68fb      	ldr	r3, [r7, #12]
 8007efc:	7c5b      	ldrb	r3, [r3, #17]
 8007efe:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8007f02:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8007f06:	2b00      	cmp	r3, #0
 8007f08:	d002      	beq.n	8007f10 <f_write+0x4a>
 8007f0a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8007f0e:	e13f      	b.n	8008190 <f_write+0x2ca>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 8007f10:	68fb      	ldr	r3, [r7, #12]
 8007f12:	7c1b      	ldrb	r3, [r3, #16]
 8007f14:	f003 0302 	and.w	r3, r3, #2
 8007f18:	2b00      	cmp	r3, #0
 8007f1a:	d101      	bne.n	8007f20 <f_write+0x5a>
 8007f1c:	2307      	movs	r3, #7
 8007f1e:	e137      	b.n	8008190 <f_write+0x2ca>

	/* Check fptr wrap-around (file size cannot reach 4 GiB at FAT volume) */
	if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 8007f20:	68fb      	ldr	r3, [r7, #12]
 8007f22:	695a      	ldr	r2, [r3, #20]
 8007f24:	687b      	ldr	r3, [r7, #4]
 8007f26:	441a      	add	r2, r3
 8007f28:	68fb      	ldr	r3, [r7, #12]
 8007f2a:	695b      	ldr	r3, [r3, #20]
 8007f2c:	429a      	cmp	r2, r3
 8007f2e:	f080 8121 	bcs.w	8008174 <f_write+0x2ae>
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 8007f32:	68fb      	ldr	r3, [r7, #12]
 8007f34:	695b      	ldr	r3, [r3, #20]
 8007f36:	43db      	mvns	r3, r3
 8007f38:	607b      	str	r3, [r7, #4]
	}

	for ( ;  btw;							/* Repeat until all data written */
 8007f3a:	e11b      	b.n	8008174 <f_write+0x2ae>
		btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
 8007f3c:	68fb      	ldr	r3, [r7, #12]
 8007f3e:	695b      	ldr	r3, [r3, #20]
 8007f40:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8007f44:	2b00      	cmp	r3, #0
 8007f46:	f040 80d7 	bne.w	80080f8 <f_write+0x232>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 8007f4a:	68fb      	ldr	r3, [r7, #12]
 8007f4c:	695b      	ldr	r3, [r3, #20]
 8007f4e:	0a5b      	lsrs	r3, r3, #9
 8007f50:	693a      	ldr	r2, [r7, #16]
 8007f52:	8952      	ldrh	r2, [r2, #10]
 8007f54:	3a01      	subs	r2, #1
 8007f56:	4013      	ands	r3, r2
 8007f58:	61bb      	str	r3, [r7, #24]
			if (csect == 0) {				/* On the cluster boundary? */
 8007f5a:	69bb      	ldr	r3, [r7, #24]
 8007f5c:	2b00      	cmp	r3, #0
 8007f5e:	d137      	bne.n	8007fd0 <f_write+0x10a>
				if (fp->fptr == 0) {		/* On the top of the file? */
 8007f60:	68fb      	ldr	r3, [r7, #12]
 8007f62:	695b      	ldr	r3, [r3, #20]
 8007f64:	2b00      	cmp	r3, #0
 8007f66:	d10c      	bne.n	8007f82 <f_write+0xbc>
					clst = fp->obj.sclust;	/* Follow from the origin */
 8007f68:	68fb      	ldr	r3, [r7, #12]
 8007f6a:	689b      	ldr	r3, [r3, #8]
 8007f6c:	62bb      	str	r3, [r7, #40]	; 0x28
					if (clst == 0) {		/* If no cluster is allocated, */
 8007f6e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007f70:	2b00      	cmp	r3, #0
 8007f72:	d10e      	bne.n	8007f92 <f_write+0xcc>
						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
 8007f74:	68fb      	ldr	r3, [r7, #12]
 8007f76:	2100      	movs	r1, #0
 8007f78:	4618      	mov	r0, r3
 8007f7a:	f7fd fe23 	bl	8005bc4 <create_chain>
 8007f7e:	62b8      	str	r0, [r7, #40]	; 0x28
 8007f80:	e007      	b.n	8007f92 <f_write+0xcc>
					if (fp->cltbl) {
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					} else
#endif
					{
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 8007f82:	68fa      	ldr	r2, [r7, #12]
 8007f84:	68fb      	ldr	r3, [r7, #12]
 8007f86:	699b      	ldr	r3, [r3, #24]
 8007f88:	4619      	mov	r1, r3
 8007f8a:	4610      	mov	r0, r2
 8007f8c:	f7fd fe1a 	bl	8005bc4 <create_chain>
 8007f90:	62b8      	str	r0, [r7, #40]	; 0x28
					}
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8007f92:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007f94:	2b00      	cmp	r3, #0
 8007f96:	f000 80f2 	beq.w	800817e <f_write+0x2b8>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 8007f9a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007f9c:	2b01      	cmp	r3, #1
 8007f9e:	d104      	bne.n	8007faa <f_write+0xe4>
 8007fa0:	68fb      	ldr	r3, [r7, #12]
 8007fa2:	2202      	movs	r2, #2
 8007fa4:	745a      	strb	r2, [r3, #17]
 8007fa6:	2302      	movs	r3, #2
 8007fa8:	e0f2      	b.n	8008190 <f_write+0x2ca>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8007faa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007fac:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007fb0:	d104      	bne.n	8007fbc <f_write+0xf6>
 8007fb2:	68fb      	ldr	r3, [r7, #12]
 8007fb4:	2201      	movs	r2, #1
 8007fb6:	745a      	strb	r2, [r3, #17]
 8007fb8:	2301      	movs	r3, #1
 8007fba:	e0e9      	b.n	8008190 <f_write+0x2ca>
				fp->clust = clst;			/* Update current cluster */
 8007fbc:	68fb      	ldr	r3, [r7, #12]
 8007fbe:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007fc0:	619a      	str	r2, [r3, #24]
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 8007fc2:	68fb      	ldr	r3, [r7, #12]
 8007fc4:	689b      	ldr	r3, [r3, #8]
 8007fc6:	2b00      	cmp	r3, #0
 8007fc8:	d102      	bne.n	8007fd0 <f_write+0x10a>
 8007fca:	68fb      	ldr	r3, [r7, #12]
 8007fcc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007fce:	609a      	str	r2, [r3, #8]
			}
#if FF_FS_TINY
			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
#else
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
 8007fd0:	68fb      	ldr	r3, [r7, #12]
 8007fd2:	7c1b      	ldrb	r3, [r3, #16]
 8007fd4:	b25b      	sxtb	r3, r3
 8007fd6:	2b00      	cmp	r3, #0
 8007fd8:	da18      	bge.n	800800c <f_write+0x146>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8007fda:	693b      	ldr	r3, [r7, #16]
 8007fdc:	7858      	ldrb	r0, [r3, #1]
 8007fde:	68fb      	ldr	r3, [r7, #12]
 8007fe0:	f103 0128 	add.w	r1, r3, #40	; 0x28
 8007fe4:	68fb      	ldr	r3, [r7, #12]
 8007fe6:	69da      	ldr	r2, [r3, #28]
 8007fe8:	2301      	movs	r3, #1
 8007fea:	f7fd f91b 	bl	8005224 <disk_write>
 8007fee:	4603      	mov	r3, r0
 8007ff0:	2b00      	cmp	r3, #0
 8007ff2:	d004      	beq.n	8007ffe <f_write+0x138>
 8007ff4:	68fb      	ldr	r3, [r7, #12]
 8007ff6:	2201      	movs	r2, #1
 8007ff8:	745a      	strb	r2, [r3, #17]
 8007ffa:	2301      	movs	r3, #1
 8007ffc:	e0c8      	b.n	8008190 <f_write+0x2ca>
				fp->flag &= (BYTE)~FA_DIRTY;
 8007ffe:	68fb      	ldr	r3, [r7, #12]
 8008000:	7c1b      	ldrb	r3, [r3, #16]
 8008002:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8008006:	b2da      	uxtb	r2, r3
 8008008:	68fb      	ldr	r3, [r7, #12]
 800800a:	741a      	strb	r2, [r3, #16]
			}
#endif
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
 800800c:	693a      	ldr	r2, [r7, #16]
 800800e:	68fb      	ldr	r3, [r7, #12]
 8008010:	699b      	ldr	r3, [r3, #24]
 8008012:	4619      	mov	r1, r3
 8008014:	4610      	mov	r0, r2
 8008016:	f7fd fbbd 	bl	8005794 <clst2sect>
 800801a:	6178      	str	r0, [r7, #20]
			if (sect == 0) ABORT(fs, FR_INT_ERR);
 800801c:	697b      	ldr	r3, [r7, #20]
 800801e:	2b00      	cmp	r3, #0
 8008020:	d104      	bne.n	800802c <f_write+0x166>
 8008022:	68fb      	ldr	r3, [r7, #12]
 8008024:	2202      	movs	r2, #2
 8008026:	745a      	strb	r2, [r3, #17]
 8008028:	2302      	movs	r3, #2
 800802a:	e0b1      	b.n	8008190 <f_write+0x2ca>
			sect += csect;
 800802c:	697a      	ldr	r2, [r7, #20]
 800802e:	69bb      	ldr	r3, [r7, #24]
 8008030:	4413      	add	r3, r2
 8008032:	617b      	str	r3, [r7, #20]
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
 8008034:	687b      	ldr	r3, [r7, #4]
 8008036:	0a5b      	lsrs	r3, r3, #9
 8008038:	623b      	str	r3, [r7, #32]
			if (cc > 0) {					/* Write maximum contiguous sectors directly */
 800803a:	6a3b      	ldr	r3, [r7, #32]
 800803c:	2b00      	cmp	r3, #0
 800803e:	d03c      	beq.n	80080ba <f_write+0x1f4>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8008040:	69ba      	ldr	r2, [r7, #24]
 8008042:	6a3b      	ldr	r3, [r7, #32]
 8008044:	4413      	add	r3, r2
 8008046:	693a      	ldr	r2, [r7, #16]
 8008048:	8952      	ldrh	r2, [r2, #10]
 800804a:	4293      	cmp	r3, r2
 800804c:	d905      	bls.n	800805a <f_write+0x194>
					cc = fs->csize - csect;
 800804e:	693b      	ldr	r3, [r7, #16]
 8008050:	895b      	ldrh	r3, [r3, #10]
 8008052:	461a      	mov	r2, r3
 8008054:	69bb      	ldr	r3, [r7, #24]
 8008056:	1ad3      	subs	r3, r2, r3
 8008058:	623b      	str	r3, [r7, #32]
				}
				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800805a:	693b      	ldr	r3, [r7, #16]
 800805c:	7858      	ldrb	r0, [r3, #1]
 800805e:	6a3b      	ldr	r3, [r7, #32]
 8008060:	697a      	ldr	r2, [r7, #20]
 8008062:	69f9      	ldr	r1, [r7, #28]
 8008064:	f7fd f8de 	bl	8005224 <disk_write>
 8008068:	4603      	mov	r3, r0
 800806a:	2b00      	cmp	r3, #0
 800806c:	d004      	beq.n	8008078 <f_write+0x1b2>
 800806e:	68fb      	ldr	r3, [r7, #12]
 8008070:	2201      	movs	r2, #1
 8008072:	745a      	strb	r2, [r3, #17]
 8008074:	2301      	movs	r3, #1
 8008076:	e08b      	b.n	8008190 <f_write+0x2ca>
				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
					fs->wflag = 0;
				}
#else
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 8008078:	68fb      	ldr	r3, [r7, #12]
 800807a:	69da      	ldr	r2, [r3, #28]
 800807c:	697b      	ldr	r3, [r7, #20]
 800807e:	1ad3      	subs	r3, r2, r3
 8008080:	6a3a      	ldr	r2, [r7, #32]
 8008082:	429a      	cmp	r2, r3
 8008084:	d915      	bls.n	80080b2 <f_write+0x1ec>
					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
 8008086:	68fb      	ldr	r3, [r7, #12]
 8008088:	f103 0028 	add.w	r0, r3, #40	; 0x28
 800808c:	68fb      	ldr	r3, [r7, #12]
 800808e:	69da      	ldr	r2, [r3, #28]
 8008090:	697b      	ldr	r3, [r7, #20]
 8008092:	1ad3      	subs	r3, r2, r3
 8008094:	025b      	lsls	r3, r3, #9
 8008096:	69fa      	ldr	r2, [r7, #28]
 8008098:	4413      	add	r3, r2
 800809a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800809e:	4619      	mov	r1, r3
 80080a0:	f7fd f984 	bl	80053ac <mem_cpy>
					fp->flag &= (BYTE)~FA_DIRTY;
 80080a4:	68fb      	ldr	r3, [r7, #12]
 80080a6:	7c1b      	ldrb	r3, [r3, #16]
 80080a8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80080ac:	b2da      	uxtb	r2, r3
 80080ae:	68fb      	ldr	r3, [r7, #12]
 80080b0:	741a      	strb	r2, [r3, #16]
				}
#endif
#endif
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
 80080b2:	6a3b      	ldr	r3, [r7, #32]
 80080b4:	025b      	lsls	r3, r3, #9
 80080b6:	627b      	str	r3, [r7, #36]	; 0x24
				continue;
 80080b8:	e03f      	b.n	800813a <f_write+0x274>
			if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling on the growing edge */
				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
				fs->winsect = sect;
			}
#else
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 80080ba:	68fb      	ldr	r3, [r7, #12]
 80080bc:	69db      	ldr	r3, [r3, #28]
 80080be:	697a      	ldr	r2, [r7, #20]
 80080c0:	429a      	cmp	r2, r3
 80080c2:	d016      	beq.n	80080f2 <f_write+0x22c>
				fp->fptr < fp->obj.objsize &&
 80080c4:	68fb      	ldr	r3, [r7, #12]
 80080c6:	695a      	ldr	r2, [r3, #20]
 80080c8:	68fb      	ldr	r3, [r7, #12]
 80080ca:	68db      	ldr	r3, [r3, #12]
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 80080cc:	429a      	cmp	r2, r3
 80080ce:	d210      	bcs.n	80080f2 <f_write+0x22c>
				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
 80080d0:	693b      	ldr	r3, [r7, #16]
 80080d2:	7858      	ldrb	r0, [r3, #1]
 80080d4:	68fb      	ldr	r3, [r7, #12]
 80080d6:	f103 0128 	add.w	r1, r3, #40	; 0x28
 80080da:	2301      	movs	r3, #1
 80080dc:	697a      	ldr	r2, [r7, #20]
 80080de:	f7fd f873 	bl	80051c8 <disk_read>
 80080e2:	4603      	mov	r3, r0
				fp->fptr < fp->obj.objsize &&
 80080e4:	2b00      	cmp	r3, #0
 80080e6:	d004      	beq.n	80080f2 <f_write+0x22c>
					ABORT(fs, FR_DISK_ERR);
 80080e8:	68fb      	ldr	r3, [r7, #12]
 80080ea:	2201      	movs	r2, #1
 80080ec:	745a      	strb	r2, [r3, #17]
 80080ee:	2301      	movs	r3, #1
 80080f0:	e04e      	b.n	8008190 <f_write+0x2ca>
			}
#endif
			fp->sect = sect;
 80080f2:	68fb      	ldr	r3, [r7, #12]
 80080f4:	697a      	ldr	r2, [r7, #20]
 80080f6:	61da      	str	r2, [r3, #28]
		}
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
 80080f8:	68fb      	ldr	r3, [r7, #12]
 80080fa:	695b      	ldr	r3, [r3, #20]
 80080fc:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8008100:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
 8008104:	627b      	str	r3, [r7, #36]	; 0x24
		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
 8008106:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008108:	687b      	ldr	r3, [r7, #4]
 800810a:	429a      	cmp	r2, r3
 800810c:	d901      	bls.n	8008112 <f_write+0x24c>
 800810e:	687b      	ldr	r3, [r7, #4]
 8008110:	627b      	str	r3, [r7, #36]	; 0x24
#if FF_FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
		fs->wflag = 1;
#else
		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
 8008112:	68fb      	ldr	r3, [r7, #12]
 8008114:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8008118:	68fb      	ldr	r3, [r7, #12]
 800811a:	695b      	ldr	r3, [r3, #20]
 800811c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8008120:	4413      	add	r3, r2
 8008122:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008124:	69f9      	ldr	r1, [r7, #28]
 8008126:	4618      	mov	r0, r3
 8008128:	f7fd f940 	bl	80053ac <mem_cpy>
		fp->flag |= FA_DIRTY;
 800812c:	68fb      	ldr	r3, [r7, #12]
 800812e:	7c1b      	ldrb	r3, [r3, #16]
 8008130:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8008134:	b2da      	uxtb	r2, r3
 8008136:	68fb      	ldr	r3, [r7, #12]
 8008138:	741a      	strb	r2, [r3, #16]
		btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
 800813a:	687a      	ldr	r2, [r7, #4]
 800813c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800813e:	1ad3      	subs	r3, r2, r3
 8008140:	607b      	str	r3, [r7, #4]
 8008142:	683b      	ldr	r3, [r7, #0]
 8008144:	681a      	ldr	r2, [r3, #0]
 8008146:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008148:	441a      	add	r2, r3
 800814a:	683b      	ldr	r3, [r7, #0]
 800814c:	601a      	str	r2, [r3, #0]
 800814e:	69fa      	ldr	r2, [r7, #28]
 8008150:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008152:	4413      	add	r3, r2
 8008154:	61fb      	str	r3, [r7, #28]
 8008156:	68fb      	ldr	r3, [r7, #12]
 8008158:	695a      	ldr	r2, [r3, #20]
 800815a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800815c:	441a      	add	r2, r3
 800815e:	68fb      	ldr	r3, [r7, #12]
 8008160:	615a      	str	r2, [r3, #20]
 8008162:	68fb      	ldr	r3, [r7, #12]
 8008164:	68da      	ldr	r2, [r3, #12]
 8008166:	68fb      	ldr	r3, [r7, #12]
 8008168:	695b      	ldr	r3, [r3, #20]
 800816a:	429a      	cmp	r2, r3
 800816c:	bf38      	it	cc
 800816e:	461a      	movcc	r2, r3
 8008170:	68fb      	ldr	r3, [r7, #12]
 8008172:	60da      	str	r2, [r3, #12]
	for ( ;  btw;							/* Repeat until all data written */
 8008174:	687b      	ldr	r3, [r7, #4]
 8008176:	2b00      	cmp	r3, #0
 8008178:	f47f aee0 	bne.w	8007f3c <f_write+0x76>
 800817c:	e000      	b.n	8008180 <f_write+0x2ba>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 800817e:	bf00      	nop
#endif
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */
 8008180:	68fb      	ldr	r3, [r7, #12]
 8008182:	7c1b      	ldrb	r3, [r3, #16]
 8008184:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8008188:	b2da      	uxtb	r2, r3
 800818a:	68fb      	ldr	r3, [r7, #12]
 800818c:	741a      	strb	r2, [r3, #16]

	LEAVE_FF(fs, FR_OK);
 800818e:	2300      	movs	r3, #0
}
 8008190:	4618      	mov	r0, r3
 8008192:	3730      	adds	r7, #48	; 0x30
 8008194:	46bd      	mov	sp, r7
 8008196:	bd80      	pop	{r7, pc}

08008198 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
 8008198:	b580      	push	{r7, lr}
 800819a:	b086      	sub	sp, #24
 800819c:	af00      	add	r7, sp, #0
 800819e:	6078      	str	r0, [r7, #4]
	FATFS *fs;
	DWORD tm;
	BYTE *dir;


	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 80081a0:	687b      	ldr	r3, [r7, #4]
 80081a2:	f107 0208 	add.w	r2, r7, #8
 80081a6:	4611      	mov	r1, r2
 80081a8:	4618      	mov	r0, r3
 80081aa:	f7ff fb59 	bl	8007860 <validate>
 80081ae:	4603      	mov	r3, r0
 80081b0:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 80081b2:	7dfb      	ldrb	r3, [r7, #23]
 80081b4:	2b00      	cmp	r3, #0
 80081b6:	d167      	bne.n	8008288 <f_sync+0xf0>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 80081b8:	687b      	ldr	r3, [r7, #4]
 80081ba:	7c1b      	ldrb	r3, [r3, #16]
 80081bc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80081c0:	2b00      	cmp	r3, #0
 80081c2:	d061      	beq.n	8008288 <f_sync+0xf0>
#if !FF_FS_TINY
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 80081c4:	687b      	ldr	r3, [r7, #4]
 80081c6:	7c1b      	ldrb	r3, [r3, #16]
 80081c8:	b25b      	sxtb	r3, r3
 80081ca:	2b00      	cmp	r3, #0
 80081cc:	da15      	bge.n	80081fa <f_sync+0x62>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 80081ce:	68bb      	ldr	r3, [r7, #8]
 80081d0:	7858      	ldrb	r0, [r3, #1]
 80081d2:	687b      	ldr	r3, [r7, #4]
 80081d4:	f103 0128 	add.w	r1, r3, #40	; 0x28
 80081d8:	687b      	ldr	r3, [r7, #4]
 80081da:	69da      	ldr	r2, [r3, #28]
 80081dc:	2301      	movs	r3, #1
 80081de:	f7fd f821 	bl	8005224 <disk_write>
 80081e2:	4603      	mov	r3, r0
 80081e4:	2b00      	cmp	r3, #0
 80081e6:	d001      	beq.n	80081ec <f_sync+0x54>
 80081e8:	2301      	movs	r3, #1
 80081ea:	e04e      	b.n	800828a <f_sync+0xf2>
				fp->flag &= (BYTE)~FA_DIRTY;
 80081ec:	687b      	ldr	r3, [r7, #4]
 80081ee:	7c1b      	ldrb	r3, [r3, #16]
 80081f0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80081f4:	b2da      	uxtb	r2, r3
 80081f6:	687b      	ldr	r3, [r7, #4]
 80081f8:	741a      	strb	r2, [r3, #16]
			}
#endif
			/* Update the directory entry */
			tm = GET_FATTIME();				/* Modified time */
 80081fa:	4b26      	ldr	r3, [pc, #152]	; (8008294 <f_sync+0xfc>)
 80081fc:	613b      	str	r3, [r7, #16]
					FREE_NAMBUF();
				}
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
 80081fe:	68ba      	ldr	r2, [r7, #8]
 8008200:	687b      	ldr	r3, [r7, #4]
 8008202:	6a1b      	ldr	r3, [r3, #32]
 8008204:	4619      	mov	r1, r3
 8008206:	4610      	mov	r0, r2
 8008208:	f7fd fa29 	bl	800565e <move_window>
 800820c:	4603      	mov	r3, r0
 800820e:	75fb      	strb	r3, [r7, #23]
				if (res == FR_OK) {
 8008210:	7dfb      	ldrb	r3, [r7, #23]
 8008212:	2b00      	cmp	r3, #0
 8008214:	d138      	bne.n	8008288 <f_sync+0xf0>
					dir = fp->dir_ptr;
 8008216:	687b      	ldr	r3, [r7, #4]
 8008218:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800821a:	60fb      	str	r3, [r7, #12]
					dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been changed */
 800821c:	68fb      	ldr	r3, [r7, #12]
 800821e:	330b      	adds	r3, #11
 8008220:	781a      	ldrb	r2, [r3, #0]
 8008222:	68fb      	ldr	r3, [r7, #12]
 8008224:	330b      	adds	r3, #11
 8008226:	f042 0220 	orr.w	r2, r2, #32
 800822a:	b2d2      	uxtb	r2, r2
 800822c:	701a      	strb	r2, [r3, #0]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
 800822e:	687b      	ldr	r3, [r7, #4]
 8008230:	6818      	ldr	r0, [r3, #0]
 8008232:	687b      	ldr	r3, [r7, #4]
 8008234:	689b      	ldr	r3, [r3, #8]
 8008236:	461a      	mov	r2, r3
 8008238:	68f9      	ldr	r1, [r7, #12]
 800823a:	f7fd ff53 	bl	80060e4 <st_clust>
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 800823e:	68fb      	ldr	r3, [r7, #12]
 8008240:	f103 021c 	add.w	r2, r3, #28
 8008244:	687b      	ldr	r3, [r7, #4]
 8008246:	68db      	ldr	r3, [r3, #12]
 8008248:	4619      	mov	r1, r3
 800824a:	4610      	mov	r0, r2
 800824c:	f7fd f882 	bl	8005354 <st_dword>
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
 8008250:	68fb      	ldr	r3, [r7, #12]
 8008252:	3316      	adds	r3, #22
 8008254:	6939      	ldr	r1, [r7, #16]
 8008256:	4618      	mov	r0, r3
 8008258:	f7fd f87c 	bl	8005354 <st_dword>
					st_word(dir + DIR_LstAccDate, 0);
 800825c:	68fb      	ldr	r3, [r7, #12]
 800825e:	3312      	adds	r3, #18
 8008260:	2100      	movs	r1, #0
 8008262:	4618      	mov	r0, r3
 8008264:	f7fd f85b 	bl	800531e <st_word>
					fs->wflag = 1;
 8008268:	68bb      	ldr	r3, [r7, #8]
 800826a:	2201      	movs	r2, #1
 800826c:	70da      	strb	r2, [r3, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
 800826e:	68bb      	ldr	r3, [r7, #8]
 8008270:	4618      	mov	r0, r3
 8008272:	f7fd fa21 	bl	80056b8 <sync_fs>
 8008276:	4603      	mov	r3, r0
 8008278:	75fb      	strb	r3, [r7, #23]
					fp->flag &= (BYTE)~FA_MODIFIED;
 800827a:	687b      	ldr	r3, [r7, #4]
 800827c:	7c1b      	ldrb	r3, [r3, #16]
 800827e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8008282:	b2da      	uxtb	r2, r3
 8008284:	687b      	ldr	r3, [r7, #4]
 8008286:	741a      	strb	r2, [r3, #16]
				}
			}
		}
	}

	LEAVE_FF(fs, res);
 8008288:	7dfb      	ldrb	r3, [r7, #23]
}
 800828a:	4618      	mov	r0, r3
 800828c:	3718      	adds	r7, #24
 800828e:	46bd      	mov	sp, r7
 8008290:	bd80      	pop	{r7, pc}
 8008292:	bf00      	nop
 8008294:	52750000 	.word	0x52750000

08008298 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
 8008298:	b580      	push	{r7, lr}
 800829a:	b084      	sub	sp, #16
 800829c:	af00      	add	r7, sp, #0
 800829e:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs;

#if !FF_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 80082a0:	6878      	ldr	r0, [r7, #4]
 80082a2:	f7ff ff79 	bl	8008198 <f_sync>
 80082a6:	4603      	mov	r3, r0
 80082a8:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK)
 80082aa:	7bfb      	ldrb	r3, [r7, #15]
 80082ac:	2b00      	cmp	r3, #0
 80082ae:	d10e      	bne.n	80082ce <f_close+0x36>
#endif
	{
		res = validate(&fp->obj, &fs);	/* Lock volume */
 80082b0:	687b      	ldr	r3, [r7, #4]
 80082b2:	f107 0208 	add.w	r2, r7, #8
 80082b6:	4611      	mov	r1, r2
 80082b8:	4618      	mov	r0, r3
 80082ba:	f7ff fad1 	bl	8007860 <validate>
 80082be:	4603      	mov	r3, r0
 80082c0:	73fb      	strb	r3, [r7, #15]
		if (res == FR_OK) {
 80082c2:	7bfb      	ldrb	r3, [r7, #15]
 80082c4:	2b00      	cmp	r3, #0
 80082c6:	d102      	bne.n	80082ce <f_close+0x36>
#if FF_FS_LOCK != 0
			res = dec_lock(fp->obj.lockid);		/* Decrement file open counter */
			if (res == FR_OK) fp->obj.fs = 0;	/* Invalidate file object */
#else
			fp->obj.fs = 0;	/* Invalidate file object */
 80082c8:	687b      	ldr	r3, [r7, #4]
 80082ca:	2200      	movs	r2, #0
 80082cc:	601a      	str	r2, [r3, #0]
#if FF_FS_REENTRANT
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
 80082ce:	7bfb      	ldrb	r3, [r7, #15]
}
 80082d0:	4618      	mov	r0, r3
 80082d2:	3710      	adds	r7, #16
 80082d4:	46bd      	mov	sp, r7
 80082d6:	bd80      	pop	{r7, pc}

080082d8 <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
 80082d8:	b580      	push	{r7, lr}
 80082da:	b084      	sub	sp, #16
 80082dc:	af00      	add	r7, sp, #0
 80082de:	6078      	str	r0, [r7, #4]
 80082e0:	6039      	str	r1, [r7, #0]
	FRESULT res;
	FATFS *fs;
	DEF_NAMBUF


	if (!dp) return FR_INVALID_OBJECT;
 80082e2:	687b      	ldr	r3, [r7, #4]
 80082e4:	2b00      	cmp	r3, #0
 80082e6:	d101      	bne.n	80082ec <f_opendir+0x14>
 80082e8:	2309      	movs	r3, #9
 80082ea:	e04a      	b.n	8008382 <f_opendir+0xaa>

	/* Get logical drive */
	res = mount_volume(&path, &fs, 0);
 80082ec:	f107 0108 	add.w	r1, r7, #8
 80082f0:	463b      	mov	r3, r7
 80082f2:	2200      	movs	r2, #0
 80082f4:	4618      	mov	r0, r3
 80082f6:	f7ff f8af 	bl	8007458 <mount_volume>
 80082fa:	4603      	mov	r3, r0
 80082fc:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 80082fe:	7bfb      	ldrb	r3, [r7, #15]
 8008300:	2b00      	cmp	r3, #0
 8008302:	d137      	bne.n	8008374 <f_opendir+0x9c>
		dp->obj.fs = fs;
 8008304:	68ba      	ldr	r2, [r7, #8]
 8008306:	687b      	ldr	r3, [r7, #4]
 8008308:	601a      	str	r2, [r3, #0]
		INIT_NAMBUF(fs);
		res = follow_path(dp, path);			/* Follow the path to the directory */
 800830a:	683b      	ldr	r3, [r7, #0]
 800830c:	4619      	mov	r1, r3
 800830e:	6878      	ldr	r0, [r7, #4]
 8008310:	f7fe ff00 	bl	8007114 <follow_path>
 8008314:	4603      	mov	r3, r0
 8008316:	73fb      	strb	r3, [r7, #15]
		if (res == FR_OK) {						/* Follow completed */
 8008318:	7bfb      	ldrb	r3, [r7, #15]
 800831a:	2b00      	cmp	r3, #0
 800831c:	d125      	bne.n	800836a <f_opendir+0x92>
			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
 800831e:	687b      	ldr	r3, [r7, #4]
 8008320:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
 8008324:	b25b      	sxtb	r3, r3
 8008326:	2b00      	cmp	r3, #0
 8008328:	db12      	blt.n	8008350 <f_opendir+0x78>
				if (dp->obj.attr & AM_DIR) {		/* This object is a sub-directory */
 800832a:	687b      	ldr	r3, [r7, #4]
 800832c:	799b      	ldrb	r3, [r3, #6]
 800832e:	f003 0310 	and.w	r3, r3, #16
 8008332:	2b00      	cmp	r3, #0
 8008334:	d00a      	beq.n	800834c <f_opendir+0x74>
						dp->obj.c_ofs = dp->blk_ofs;
						init_alloc_info(fs, &dp->obj);	/* Get object allocation info */
					} else
#endif
					{
						dp->obj.sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 8008336:	68ba      	ldr	r2, [r7, #8]
 8008338:	687b      	ldr	r3, [r7, #4]
 800833a:	69db      	ldr	r3, [r3, #28]
 800833c:	4619      	mov	r1, r3
 800833e:	4610      	mov	r0, r2
 8008340:	f7fd feb1 	bl	80060a6 <ld_clust>
 8008344:	4602      	mov	r2, r0
 8008346:	687b      	ldr	r3, [r7, #4]
 8008348:	609a      	str	r2, [r3, #8]
 800834a:	e001      	b.n	8008350 <f_opendir+0x78>
					}
				} else {						/* This object is a file */
					res = FR_NO_PATH;
 800834c:	2305      	movs	r3, #5
 800834e:	73fb      	strb	r3, [r7, #15]
				}
			}
			if (res == FR_OK) {
 8008350:	7bfb      	ldrb	r3, [r7, #15]
 8008352:	2b00      	cmp	r3, #0
 8008354:	d109      	bne.n	800836a <f_opendir+0x92>
				dp->obj.id = fs->id;
 8008356:	68bb      	ldr	r3, [r7, #8]
 8008358:	88da      	ldrh	r2, [r3, #6]
 800835a:	687b      	ldr	r3, [r7, #4]
 800835c:	809a      	strh	r2, [r3, #4]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 800835e:	2100      	movs	r1, #0
 8008360:	6878      	ldr	r0, [r7, #4]
 8008362:	f7fd fd48 	bl	8005df6 <dir_sdi>
 8008366:	4603      	mov	r3, r0
 8008368:	73fb      	strb	r3, [r7, #15]
				}
#endif
			}
		}
		FREE_NAMBUF();
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 800836a:	7bfb      	ldrb	r3, [r7, #15]
 800836c:	2b04      	cmp	r3, #4
 800836e:	d101      	bne.n	8008374 <f_opendir+0x9c>
 8008370:	2305      	movs	r3, #5
 8008372:	73fb      	strb	r3, [r7, #15]
	}
	if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function faild */
 8008374:	7bfb      	ldrb	r3, [r7, #15]
 8008376:	2b00      	cmp	r3, #0
 8008378:	d002      	beq.n	8008380 <f_opendir+0xa8>
 800837a:	687b      	ldr	r3, [r7, #4]
 800837c:	2200      	movs	r2, #0
 800837e:	601a      	str	r2, [r3, #0]

	LEAVE_FF(fs, res);
 8008380:	7bfb      	ldrb	r3, [r7, #15]
}
 8008382:	4618      	mov	r0, r3
 8008384:	3710      	adds	r7, #16
 8008386:	46bd      	mov	sp, r7
 8008388:	bd80      	pop	{r7, pc}

0800838a <f_readdir>:

FRESULT f_readdir (
	DIR* dp,			/* Pointer to the open directory object */
	FILINFO* fno		/* Pointer to file information to return */
)
{
 800838a:	b580      	push	{r7, lr}
 800838c:	b084      	sub	sp, #16
 800838e:	af00      	add	r7, sp, #0
 8008390:	6078      	str	r0, [r7, #4]
 8008392:	6039      	str	r1, [r7, #0]
	FRESULT res;
	FATFS *fs;
	DEF_NAMBUF


	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
 8008394:	687b      	ldr	r3, [r7, #4]
 8008396:	f107 0208 	add.w	r2, r7, #8
 800839a:	4611      	mov	r1, r2
 800839c:	4618      	mov	r0, r3
 800839e:	f7ff fa5f 	bl	8007860 <validate>
 80083a2:	4603      	mov	r3, r0
 80083a4:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 80083a6:	7bfb      	ldrb	r3, [r7, #15]
 80083a8:	2b00      	cmp	r3, #0
 80083aa:	d126      	bne.n	80083fa <f_readdir+0x70>
		if (!fno) {
 80083ac:	683b      	ldr	r3, [r7, #0]
 80083ae:	2b00      	cmp	r3, #0
 80083b0:	d106      	bne.n	80083c0 <f_readdir+0x36>
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 80083b2:	2100      	movs	r1, #0
 80083b4:	6878      	ldr	r0, [r7, #4]
 80083b6:	f7fd fd1e 	bl	8005df6 <dir_sdi>
 80083ba:	4603      	mov	r3, r0
 80083bc:	73fb      	strb	r3, [r7, #15]
 80083be:	e01c      	b.n	80083fa <f_readdir+0x70>
		} else {
			INIT_NAMBUF(fs);
			res = DIR_READ_FILE(dp);		/* Read an item */
 80083c0:	2100      	movs	r1, #0
 80083c2:	6878      	ldr	r0, [r7, #4]
 80083c4:	f7fe f8af 	bl	8006526 <dir_read>
 80083c8:	4603      	mov	r3, r0
 80083ca:	73fb      	strb	r3, [r7, #15]
			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
 80083cc:	7bfb      	ldrb	r3, [r7, #15]
 80083ce:	2b04      	cmp	r3, #4
 80083d0:	d101      	bne.n	80083d6 <f_readdir+0x4c>
 80083d2:	2300      	movs	r3, #0
 80083d4:	73fb      	strb	r3, [r7, #15]
			if (res == FR_OK) {				/* A valid entry is found */
 80083d6:	7bfb      	ldrb	r3, [r7, #15]
 80083d8:	2b00      	cmp	r3, #0
 80083da:	d10e      	bne.n	80083fa <f_readdir+0x70>
				get_fileinfo(dp, fno);		/* Get the object information */
 80083dc:	6839      	ldr	r1, [r7, #0]
 80083de:	6878      	ldr	r0, [r7, #4]
 80083e0:	f7fe fb00 	bl	80069e4 <get_fileinfo>
				res = dir_next(dp, 0);		/* Increment index for next */
 80083e4:	2100      	movs	r1, #0
 80083e6:	6878      	ldr	r0, [r7, #4]
 80083e8:	f7fd fd80 	bl	8005eec <dir_next>
 80083ec:	4603      	mov	r3, r0
 80083ee:	73fb      	strb	r3, [r7, #15]
				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
 80083f0:	7bfb      	ldrb	r3, [r7, #15]
 80083f2:	2b04      	cmp	r3, #4
 80083f4:	d101      	bne.n	80083fa <f_readdir+0x70>
 80083f6:	2300      	movs	r3, #0
 80083f8:	73fb      	strb	r3, [r7, #15]
			}
			FREE_NAMBUF();
		}
	}
	LEAVE_FF(fs, res);
 80083fa:	7bfb      	ldrb	r3, [r7, #15]
}
 80083fc:	4618      	mov	r0, r3
 80083fe:	3710      	adds	r7, #16
 8008400:	46bd      	mov	sp, r7
 8008402:	bd80      	pop	{r7, pc}

08008404 <f_findnext>:

FRESULT f_findnext (
	DIR* dp,		/* Pointer to the open directory object */
	FILINFO* fno	/* Pointer to the file information structure */
)
{
 8008404:	b580      	push	{r7, lr}
 8008406:	b084      	sub	sp, #16
 8008408:	af00      	add	r7, sp, #0
 800840a:	6078      	str	r0, [r7, #4]
 800840c:	6039      	str	r1, [r7, #0]
	FRESULT res;


	for (;;) {
		res = f_readdir(dp, fno);		/* Get a directory item */
 800840e:	6839      	ldr	r1, [r7, #0]
 8008410:	6878      	ldr	r0, [r7, #4]
 8008412:	f7ff ffba 	bl	800838a <f_readdir>
 8008416:	4603      	mov	r3, r0
 8008418:	73fb      	strb	r3, [r7, #15]
		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
 800841a:	7bfb      	ldrb	r3, [r7, #15]
 800841c:	2b00      	cmp	r3, #0
 800841e:	d114      	bne.n	800844a <f_findnext+0x46>
 8008420:	683b      	ldr	r3, [r7, #0]
 8008422:	2b00      	cmp	r3, #0
 8008424:	d011      	beq.n	800844a <f_findnext+0x46>
 8008426:	683b      	ldr	r3, [r7, #0]
 8008428:	7d9b      	ldrb	r3, [r3, #22]
 800842a:	2b00      	cmp	r3, #0
 800842c:	d00d      	beq.n	800844a <f_findnext+0x46>
		if (pattern_match(dp->pat, fno->fname, 0, FIND_RECURS)) break;		/* Test for the file name */
 800842e:	687b      	ldr	r3, [r7, #4]
 8008430:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8008432:	683b      	ldr	r3, [r7, #0]
 8008434:	f103 0116 	add.w	r1, r3, #22
 8008438:	2304      	movs	r3, #4
 800843a:	2200      	movs	r2, #0
 800843c:	f7fe fc10 	bl	8006c60 <pattern_match>
 8008440:	4603      	mov	r3, r0
 8008442:	2b00      	cmp	r3, #0
 8008444:	d100      	bne.n	8008448 <f_findnext+0x44>
		res = f_readdir(dp, fno);		/* Get a directory item */
 8008446:	e7e2      	b.n	800840e <f_findnext+0xa>
		if (pattern_match(dp->pat, fno->fname, 0, FIND_RECURS)) break;		/* Test for the file name */
 8008448:	bf00      	nop
#if FF_USE_LFN && FF_USE_FIND == 2
		if (pattern_match(dp->pat, fno->altname, 0, FIND_RECURS)) break;	/* Test for alternative name if exist */
#endif
	}
	return res;
 800844a:	7bfb      	ldrb	r3, [r7, #15]
}
 800844c:	4618      	mov	r0, r3
 800844e:	3710      	adds	r7, #16
 8008450:	46bd      	mov	sp, r7
 8008452:	bd80      	pop	{r7, pc}

08008454 <f_findfirst>:
	DIR* dp,				/* Pointer to the blank directory object */
	FILINFO* fno,			/* Pointer to the file information structure */
	const TCHAR* path,		/* Pointer to the directory to open */
	const TCHAR* pattern	/* Pointer to the matching pattern */
)
{
 8008454:	b580      	push	{r7, lr}
 8008456:	b086      	sub	sp, #24
 8008458:	af00      	add	r7, sp, #0
 800845a:	60f8      	str	r0, [r7, #12]
 800845c:	60b9      	str	r1, [r7, #8]
 800845e:	607a      	str	r2, [r7, #4]
 8008460:	603b      	str	r3, [r7, #0]
	FRESULT res;


	dp->pat = pattern;		/* Save pointer to pattern string */
 8008462:	68fb      	ldr	r3, [r7, #12]
 8008464:	683a      	ldr	r2, [r7, #0]
 8008466:	631a      	str	r2, [r3, #48]	; 0x30
	res = f_opendir(dp, path);		/* Open the target directory */
 8008468:	6879      	ldr	r1, [r7, #4]
 800846a:	68f8      	ldr	r0, [r7, #12]
 800846c:	f7ff ff34 	bl	80082d8 <f_opendir>
 8008470:	4603      	mov	r3, r0
 8008472:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 8008474:	7dfb      	ldrb	r3, [r7, #23]
 8008476:	2b00      	cmp	r3, #0
 8008478:	d105      	bne.n	8008486 <f_findfirst+0x32>
		res = f_findnext(dp, fno);	/* Find the first item */
 800847a:	68b9      	ldr	r1, [r7, #8]
 800847c:	68f8      	ldr	r0, [r7, #12]
 800847e:	f7ff ffc1 	bl	8008404 <f_findnext>
 8008482:	4603      	mov	r3, r0
 8008484:	75fb      	strb	r3, [r7, #23]
	}
	return res;
 8008486:	7dfb      	ldrb	r3, [r7, #23]
}
 8008488:	4618      	mov	r0, r3
 800848a:	3718      	adds	r7, #24
 800848c:	46bd      	mov	sp, r7
 800848e:	bd80      	pop	{r7, pc}

08008490 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
 8008490:	b580      	push	{r7, lr}
 8008492:	b098      	sub	sp, #96	; 0x60
 8008494:	af00      	add	r7, sp, #0
 8008496:	6078      	str	r0, [r7, #4]
	FATFS *fs;
	DWORD dcl, pcl, tm;
	DEF_NAMBUF


	res = mount_volume(&path, &fs, FA_WRITE);	/* Get logical drive */
 8008498:	f107 0108 	add.w	r1, r7, #8
 800849c:	1d3b      	adds	r3, r7, #4
 800849e:	2202      	movs	r2, #2
 80084a0:	4618      	mov	r0, r3
 80084a2:	f7fe ffd9 	bl	8007458 <mount_volume>
 80084a6:	4603      	mov	r3, r0
 80084a8:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
	if (res == FR_OK) {
 80084ac:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 80084b0:	2b00      	cmp	r3, #0
 80084b2:	f040 80b3 	bne.w	800861c <f_mkdir+0x18c>
		dj.obj.fs = fs;
 80084b6:	68bb      	ldr	r3, [r7, #8]
 80084b8:	61fb      	str	r3, [r7, #28]
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);			/* Follow the file path */
 80084ba:	687a      	ldr	r2, [r7, #4]
 80084bc:	f107 031c 	add.w	r3, r7, #28
 80084c0:	4611      	mov	r1, r2
 80084c2:	4618      	mov	r0, r3
 80084c4:	f7fe fe26 	bl	8007114 <follow_path>
 80084c8:	4603      	mov	r3, r0
 80084ca:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
		if (res == FR_OK) res = FR_EXIST;		/* Name collision? */
 80084ce:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 80084d2:	2b00      	cmp	r3, #0
 80084d4:	d102      	bne.n	80084dc <f_mkdir+0x4c>
 80084d6:	2308      	movs	r3, #8
 80084d8:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
		if (FF_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {	/* Invalid name? */
			res = FR_INVALID_NAME;
		}
		if (res == FR_NO_FILE) {				/* It is clear to create a new directory */
 80084dc:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 80084e0:	2b04      	cmp	r3, #4
 80084e2:	f040 809b 	bne.w	800861c <f_mkdir+0x18c>
			sobj.fs = fs;						/* New object id to create a new chain */
 80084e6:	68bb      	ldr	r3, [r7, #8]
 80084e8:	60fb      	str	r3, [r7, #12]
			dcl = create_chain(&sobj, 0);		/* Allocate a cluster for the new directory */
 80084ea:	f107 030c 	add.w	r3, r7, #12
 80084ee:	2100      	movs	r1, #0
 80084f0:	4618      	mov	r0, r3
 80084f2:	f7fd fb67 	bl	8005bc4 <create_chain>
 80084f6:	65b8      	str	r0, [r7, #88]	; 0x58
			res = FR_OK;
 80084f8:	2300      	movs	r3, #0
 80084fa:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster? */
 80084fe:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8008500:	2b00      	cmp	r3, #0
 8008502:	d102      	bne.n	800850a <f_mkdir+0x7a>
 8008504:	2307      	movs	r3, #7
 8008506:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
			if (dcl == 1) res = FR_INT_ERR;		/* Any insanity? */
 800850a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800850c:	2b01      	cmp	r3, #1
 800850e:	d102      	bne.n	8008516 <f_mkdir+0x86>
 8008510:	2302      	movs	r3, #2
 8008512:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;	/* Disk error? */
 8008516:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8008518:	f1b3 3fff 	cmp.w	r3, #4294967295
 800851c:	d102      	bne.n	8008524 <f_mkdir+0x94>
 800851e:	2301      	movs	r3, #1
 8008520:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
			tm = GET_FATTIME();
 8008524:	4b40      	ldr	r3, [pc, #256]	; (8008628 <f_mkdir+0x198>)
 8008526:	657b      	str	r3, [r7, #84]	; 0x54
			if (res == FR_OK) {
 8008528:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800852c:	2b00      	cmp	r3, #0
 800852e:	d14b      	bne.n	80085c8 <f_mkdir+0x138>
				res = dir_clear(fs, dcl);		/* Clean up the new table */
 8008530:	68bb      	ldr	r3, [r7, #8]
 8008532:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8008534:	4618      	mov	r0, r3
 8008536:	f7fd fc16 	bl	8005d66 <dir_clear>
 800853a:	4603      	mov	r3, r0
 800853c:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
				if (res == FR_OK) {
 8008540:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 8008544:	2b00      	cmp	r3, #0
 8008546:	d13f      	bne.n	80085c8 <f_mkdir+0x138>
					if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* Create dot entries (FAT only) */
						mem_set(fs->win + DIR_Name, ' ', 11);	/* Create "." entry */
 8008548:	68bb      	ldr	r3, [r7, #8]
 800854a:	3334      	adds	r3, #52	; 0x34
 800854c:	220b      	movs	r2, #11
 800854e:	2120      	movs	r1, #32
 8008550:	4618      	mov	r0, r3
 8008552:	f7fc ff4c 	bl	80053ee <mem_set>
						fs->win[DIR_Name] = '.';
 8008556:	68bb      	ldr	r3, [r7, #8]
 8008558:	222e      	movs	r2, #46	; 0x2e
 800855a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
						fs->win[DIR_Attr] = AM_DIR;
 800855e:	68bb      	ldr	r3, [r7, #8]
 8008560:	2210      	movs	r2, #16
 8008562:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
						st_dword(fs->win + DIR_ModTime, tm);
 8008566:	68bb      	ldr	r3, [r7, #8]
 8008568:	3334      	adds	r3, #52	; 0x34
 800856a:	3316      	adds	r3, #22
 800856c:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800856e:	4618      	mov	r0, r3
 8008570:	f7fc fef0 	bl	8005354 <st_dword>
						st_clust(fs, fs->win, dcl);
 8008574:	68b8      	ldr	r0, [r7, #8]
 8008576:	68bb      	ldr	r3, [r7, #8]
 8008578:	3334      	adds	r3, #52	; 0x34
 800857a:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800857c:	4619      	mov	r1, r3
 800857e:	f7fd fdb1 	bl	80060e4 <st_clust>
						mem_cpy(fs->win + SZDIRE, fs->win, SZDIRE); /* Create ".." entry */
 8008582:	68bb      	ldr	r3, [r7, #8]
 8008584:	3334      	adds	r3, #52	; 0x34
 8008586:	f103 0020 	add.w	r0, r3, #32
 800858a:	68bb      	ldr	r3, [r7, #8]
 800858c:	3334      	adds	r3, #52	; 0x34
 800858e:	2220      	movs	r2, #32
 8008590:	4619      	mov	r1, r3
 8008592:	f7fc ff0b 	bl	80053ac <mem_cpy>
						fs->win[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
 8008596:	68bb      	ldr	r3, [r7, #8]
 8008598:	222e      	movs	r2, #46	; 0x2e
 800859a:	f883 2055 	strb.w	r2, [r3, #85]	; 0x55
 800859e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80085a0:	653b      	str	r3, [r7, #80]	; 0x50
						st_clust(fs, fs->win + SZDIRE, pcl);
 80085a2:	68b8      	ldr	r0, [r7, #8]
 80085a4:	68bb      	ldr	r3, [r7, #8]
 80085a6:	3334      	adds	r3, #52	; 0x34
 80085a8:	3320      	adds	r3, #32
 80085aa:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80085ac:	4619      	mov	r1, r3
 80085ae:	f7fd fd99 	bl	80060e4 <st_clust>
						fs->wflag = 1;
 80085b2:	68bb      	ldr	r3, [r7, #8]
 80085b4:	2201      	movs	r2, #1
 80085b6:	70da      	strb	r2, [r3, #3]
					}
					res = dir_register(&dj);	/* Register the object to the parent directoy */
 80085b8:	f107 031c 	add.w	r3, r7, #28
 80085bc:	4618      	mov	r0, r3
 80085be:	f7fe f919 	bl	80067f4 <dir_register>
 80085c2:	4603      	mov	r3, r0
 80085c4:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
				}
			}
			if (res == FR_OK) {
 80085c8:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 80085cc:	2b00      	cmp	r3, #0
 80085ce:	d11e      	bne.n	800860e <f_mkdir+0x17e>
					fs->dirbuf[XDIR_Attr] = AM_DIR;				/* Attribute */
					res = store_xdir(&dj);
				} else
#endif
				{
					st_dword(dj.dir + DIR_ModTime, tm);	/* Created time */
 80085d0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80085d2:	3316      	adds	r3, #22
 80085d4:	6d79      	ldr	r1, [r7, #84]	; 0x54
 80085d6:	4618      	mov	r0, r3
 80085d8:	f7fc febc 	bl	8005354 <st_dword>
					st_clust(fs, dj.dir, dcl);			/* Table start cluster */
 80085dc:	68bb      	ldr	r3, [r7, #8]
 80085de:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 80085e0:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80085e2:	4618      	mov	r0, r3
 80085e4:	f7fd fd7e 	bl	80060e4 <st_clust>
					dj.dir[DIR_Attr] = AM_DIR;			/* Attribute */
 80085e8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80085ea:	330b      	adds	r3, #11
 80085ec:	2210      	movs	r2, #16
 80085ee:	701a      	strb	r2, [r3, #0]
					fs->wflag = 1;
 80085f0:	68bb      	ldr	r3, [r7, #8]
 80085f2:	2201      	movs	r2, #1
 80085f4:	70da      	strb	r2, [r3, #3]
				}
				if (res == FR_OK) {
 80085f6:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 80085fa:	2b00      	cmp	r3, #0
 80085fc:	d10e      	bne.n	800861c <f_mkdir+0x18c>
					res = sync_fs(fs);
 80085fe:	68bb      	ldr	r3, [r7, #8]
 8008600:	4618      	mov	r0, r3
 8008602:	f7fd f859 	bl	80056b8 <sync_fs>
 8008606:	4603      	mov	r3, r0
 8008608:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
 800860c:	e006      	b.n	800861c <f_mkdir+0x18c>
				}
			} else {
				remove_chain(&sobj, dcl, 0);		/* Could not register, remove the allocated cluster */
 800860e:	f107 030c 	add.w	r3, r7, #12
 8008612:	2200      	movs	r2, #0
 8008614:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8008616:	4618      	mov	r0, r3
 8008618:	f7fd fa6f 	bl	8005afa <remove_chain>
			}
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
 800861c:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
}
 8008620:	4618      	mov	r0, r3
 8008622:	3760      	adds	r7, #96	; 0x60
 8008624:	46bd      	mov	sp, r7
 8008626:	bd80      	pop	{r7, pc}
 8008628:	52750000 	.word	0x52750000

0800862c <f_gets>:
TCHAR* f_gets (
	TCHAR* buff,	/* Pointer to the buffer to store read string */
	int len,		/* Size of string buffer (items) */
	FIL* fp			/* Pointer to the file object */
)
{
 800862c:	b580      	push	{r7, lr}
 800862e:	b08a      	sub	sp, #40	; 0x28
 8008630:	af00      	add	r7, sp, #0
 8008632:	60f8      	str	r0, [r7, #12]
 8008634:	60b9      	str	r1, [r7, #8]
 8008636:	607a      	str	r2, [r7, #4]
	int nc = 0;
 8008638:	2300      	movs	r3, #0
 800863a:	627b      	str	r3, [r7, #36]	; 0x24
	TCHAR *p = buff;
 800863c:	68fb      	ldr	r3, [r7, #12]
 800863e:	623b      	str	r3, [r7, #32]
		}
#endif
	}

#else			/* Byte-by-byte read without any conversion (ANSI/OEM API) */
	len -= 1;	/* Make a room for the terminator */
 8008640:	68bb      	ldr	r3, [r7, #8]
 8008642:	3b01      	subs	r3, #1
 8008644:	60bb      	str	r3, [r7, #8]
	while (nc < len) {
 8008646:	e01c      	b.n	8008682 <f_gets+0x56>
		f_read(fp, s, 1, &rc);	/* Get a byte */
 8008648:	f107 0314 	add.w	r3, r7, #20
 800864c:	f107 0118 	add.w	r1, r7, #24
 8008650:	2201      	movs	r2, #1
 8008652:	6878      	ldr	r0, [r7, #4]
 8008654:	f7ff fb04 	bl	8007c60 <f_read>
		if (rc != 1) break;		/* EOF? */
 8008658:	697b      	ldr	r3, [r7, #20]
 800865a:	2b01      	cmp	r3, #1
 800865c:	d116      	bne.n	800868c <f_gets+0x60>
		dc = s[0];
 800865e:	7e3b      	ldrb	r3, [r7, #24]
 8008660:	61fb      	str	r3, [r7, #28]
		if (FF_USE_STRFUNC == 2 && dc == '\r') continue;
 8008662:	69fb      	ldr	r3, [r7, #28]
 8008664:	2b0d      	cmp	r3, #13
 8008666:	d100      	bne.n	800866a <f_gets+0x3e>
 8008668:	e00b      	b.n	8008682 <f_gets+0x56>
		*p++ = (TCHAR)dc; nc++;
 800866a:	6a3b      	ldr	r3, [r7, #32]
 800866c:	1c5a      	adds	r2, r3, #1
 800866e:	623a      	str	r2, [r7, #32]
 8008670:	69fa      	ldr	r2, [r7, #28]
 8008672:	b2d2      	uxtb	r2, r2
 8008674:	701a      	strb	r2, [r3, #0]
 8008676:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008678:	3301      	adds	r3, #1
 800867a:	627b      	str	r3, [r7, #36]	; 0x24
		if (dc == '\n') break;
 800867c:	69fb      	ldr	r3, [r7, #28]
 800867e:	2b0a      	cmp	r3, #10
 8008680:	d006      	beq.n	8008690 <f_gets+0x64>
	while (nc < len) {
 8008682:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008684:	68bb      	ldr	r3, [r7, #8]
 8008686:	429a      	cmp	r2, r3
 8008688:	dbde      	blt.n	8008648 <f_gets+0x1c>
 800868a:	e002      	b.n	8008692 <f_gets+0x66>
		if (rc != 1) break;		/* EOF? */
 800868c:	bf00      	nop
 800868e:	e000      	b.n	8008692 <f_gets+0x66>
		if (dc == '\n') break;
 8008690:	bf00      	nop
	}
#endif

	*p = 0;		/* Terminate the string */
 8008692:	6a3b      	ldr	r3, [r7, #32]
 8008694:	2200      	movs	r2, #0
 8008696:	701a      	strb	r2, [r3, #0]
	return nc ? buff : 0;	/* When no data read due to EOF or error, return with error. */
 8008698:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800869a:	2b00      	cmp	r3, #0
 800869c:	d001      	beq.n	80086a2 <f_gets+0x76>
 800869e:	68fb      	ldr	r3, [r7, #12]
 80086a0:	e000      	b.n	80086a4 <f_gets+0x78>
 80086a2:	2300      	movs	r3, #0
}
 80086a4:	4618      	mov	r0, r3
 80086a6:	3728      	adds	r7, #40	; 0x28
 80086a8:	46bd      	mov	sp, r7
 80086aa:	bd80      	pop	{r7, pc}

080086ac <putc_bfd>:


/* Buffered write with code conversion */

static void putc_bfd (putbuff* pb, TCHAR c)
{
 80086ac:	b580      	push	{r7, lr}
 80086ae:	b086      	sub	sp, #24
 80086b0:	af00      	add	r7, sp, #0
 80086b2:	6078      	str	r0, [r7, #4]
 80086b4:	460b      	mov	r3, r1
 80086b6:	70fb      	strb	r3, [r7, #3]
	DWORD dc;
	const TCHAR *tp;
#endif
#endif

	if (FF_USE_STRFUNC == 2 && c == '\n') {	 /* LF -> CRLF conversion */
 80086b8:	78fb      	ldrb	r3, [r7, #3]
 80086ba:	2b0a      	cmp	r3, #10
 80086bc:	d103      	bne.n	80086c6 <putc_bfd+0x1a>
		putc_bfd(pb, '\r');
 80086be:	210d      	movs	r1, #13
 80086c0:	6878      	ldr	r0, [r7, #4]
 80086c2:	f7ff fff3 	bl	80086ac <putc_bfd>
	}

	i = pb->idx;			/* Write index of pb->buf[] */
 80086c6:	687b      	ldr	r3, [r7, #4]
 80086c8:	685b      	ldr	r3, [r3, #4]
 80086ca:	617b      	str	r3, [r7, #20]
	if (i < 0) return;
 80086cc:	697b      	ldr	r3, [r7, #20]
 80086ce:	2b00      	cmp	r3, #0
 80086d0:	db27      	blt.n	8008722 <putc_bfd+0x76>
	nc = pb->nchr;			/* Write unit counter */
 80086d2:	687b      	ldr	r3, [r7, #4]
 80086d4:	689b      	ldr	r3, [r3, #8]
 80086d6:	613b      	str	r3, [r7, #16]
	}
	pb->buf[i++] = (BYTE)wc;
#endif

#else									/* ANSI/OEM input (without re-encoding) */
	pb->buf[i++] = (BYTE)c;
 80086d8:	697b      	ldr	r3, [r7, #20]
 80086da:	1c5a      	adds	r2, r3, #1
 80086dc:	617a      	str	r2, [r7, #20]
 80086de:	687a      	ldr	r2, [r7, #4]
 80086e0:	4413      	add	r3, r2
 80086e2:	78fa      	ldrb	r2, [r7, #3]
 80086e4:	731a      	strb	r2, [r3, #12]
#endif

	if (i >= (int)(sizeof pb->buf) - 4) {	/* Write buffered characters to the file */
 80086e6:	697b      	ldr	r3, [r7, #20]
 80086e8:	2b3b      	cmp	r3, #59	; 0x3b
 80086ea:	dd12      	ble.n	8008712 <putc_bfd+0x66>
		f_write(pb->fp, pb->buf, (UINT)i, &n);
 80086ec:	687b      	ldr	r3, [r7, #4]
 80086ee:	6818      	ldr	r0, [r3, #0]
 80086f0:	687b      	ldr	r3, [r7, #4]
 80086f2:	f103 010c 	add.w	r1, r3, #12
 80086f6:	697a      	ldr	r2, [r7, #20]
 80086f8:	f107 030c 	add.w	r3, r7, #12
 80086fc:	f7ff fbe3 	bl	8007ec6 <f_write>
		i = (n == (UINT)i) ? 0 : -1;
 8008700:	68fa      	ldr	r2, [r7, #12]
 8008702:	697b      	ldr	r3, [r7, #20]
 8008704:	429a      	cmp	r2, r3
 8008706:	d101      	bne.n	800870c <putc_bfd+0x60>
 8008708:	2300      	movs	r3, #0
 800870a:	e001      	b.n	8008710 <putc_bfd+0x64>
 800870c:	f04f 33ff 	mov.w	r3, #4294967295
 8008710:	617b      	str	r3, [r7, #20]
	}
	pb->idx = i;
 8008712:	687b      	ldr	r3, [r7, #4]
 8008714:	697a      	ldr	r2, [r7, #20]
 8008716:	605a      	str	r2, [r3, #4]
	pb->nchr = nc + 1;
 8008718:	693b      	ldr	r3, [r7, #16]
 800871a:	1c5a      	adds	r2, r3, #1
 800871c:	687b      	ldr	r3, [r7, #4]
 800871e:	609a      	str	r2, [r3, #8]
 8008720:	e000      	b.n	8008724 <putc_bfd+0x78>
	if (i < 0) return;
 8008722:	bf00      	nop
}
 8008724:	3718      	adds	r7, #24
 8008726:	46bd      	mov	sp, r7
 8008728:	bd80      	pop	{r7, pc}

0800872a <putc_flush>:


/* Flush remaining characters in the buffer */

static int putc_flush (putbuff* pb)
{
 800872a:	b580      	push	{r7, lr}
 800872c:	b084      	sub	sp, #16
 800872e:	af00      	add	r7, sp, #0
 8008730:	6078      	str	r0, [r7, #4]
	UINT nw;

	if (   pb->idx >= 0	/* Flush buffered characters to the file */
 8008732:	687b      	ldr	r3, [r7, #4]
 8008734:	685b      	ldr	r3, [r3, #4]
 8008736:	2b00      	cmp	r3, #0
 8008738:	db16      	blt.n	8008768 <putc_flush+0x3e>
		&& f_write(pb->fp, pb->buf, (UINT)pb->idx, &nw) == FR_OK
 800873a:	687b      	ldr	r3, [r7, #4]
 800873c:	6818      	ldr	r0, [r3, #0]
 800873e:	687b      	ldr	r3, [r7, #4]
 8008740:	f103 010c 	add.w	r1, r3, #12
 8008744:	687b      	ldr	r3, [r7, #4]
 8008746:	685b      	ldr	r3, [r3, #4]
 8008748:	461a      	mov	r2, r3
 800874a:	f107 030c 	add.w	r3, r7, #12
 800874e:	f7ff fbba 	bl	8007ec6 <f_write>
 8008752:	4603      	mov	r3, r0
 8008754:	2b00      	cmp	r3, #0
 8008756:	d107      	bne.n	8008768 <putc_flush+0x3e>
		&& (UINT)pb->idx == nw) return pb->nchr;
 8008758:	687b      	ldr	r3, [r7, #4]
 800875a:	685b      	ldr	r3, [r3, #4]
 800875c:	68fa      	ldr	r2, [r7, #12]
 800875e:	4293      	cmp	r3, r2
 8008760:	d102      	bne.n	8008768 <putc_flush+0x3e>
 8008762:	687b      	ldr	r3, [r7, #4]
 8008764:	689b      	ldr	r3, [r3, #8]
 8008766:	e001      	b.n	800876c <putc_flush+0x42>
	return -1;
 8008768:	f04f 33ff 	mov.w	r3, #4294967295
}
 800876c:	4618      	mov	r0, r3
 800876e:	3710      	adds	r7, #16
 8008770:	46bd      	mov	sp, r7
 8008772:	bd80      	pop	{r7, pc}

08008774 <putc_init>:


/* Initialize write buffer */

static void putc_init (putbuff* pb, FIL* fp)
{
 8008774:	b580      	push	{r7, lr}
 8008776:	b082      	sub	sp, #8
 8008778:	af00      	add	r7, sp, #0
 800877a:	6078      	str	r0, [r7, #4]
 800877c:	6039      	str	r1, [r7, #0]
	mem_set(pb, 0, sizeof (putbuff));
 800877e:	224c      	movs	r2, #76	; 0x4c
 8008780:	2100      	movs	r1, #0
 8008782:	6878      	ldr	r0, [r7, #4]
 8008784:	f7fc fe33 	bl	80053ee <mem_set>
	pb->fp = fp;
 8008788:	687b      	ldr	r3, [r7, #4]
 800878a:	683a      	ldr	r2, [r7, #0]
 800878c:	601a      	str	r2, [r3, #0]
}
 800878e:	bf00      	nop
 8008790:	3708      	adds	r7, #8
 8008792:	46bd      	mov	sp, r7
 8008794:	bd80      	pop	{r7, pc}

08008796 <f_puts>:

int f_puts (
	const TCHAR* str,	/* Pointer to the string to be output */
	FIL* fp				/* Pointer to the file object */
)
{
 8008796:	b580      	push	{r7, lr}
 8008798:	b096      	sub	sp, #88	; 0x58
 800879a:	af00      	add	r7, sp, #0
 800879c:	6078      	str	r0, [r7, #4]
 800879e:	6039      	str	r1, [r7, #0]
	putbuff pb;


	putc_init(&pb, fp);
 80087a0:	f107 030c 	add.w	r3, r7, #12
 80087a4:	6839      	ldr	r1, [r7, #0]
 80087a6:	4618      	mov	r0, r3
 80087a8:	f7ff ffe4 	bl	8008774 <putc_init>
	while (*str) putc_bfd(&pb, *str++);		/* Put the string */
 80087ac:	e009      	b.n	80087c2 <f_puts+0x2c>
 80087ae:	687b      	ldr	r3, [r7, #4]
 80087b0:	1c5a      	adds	r2, r3, #1
 80087b2:	607a      	str	r2, [r7, #4]
 80087b4:	781a      	ldrb	r2, [r3, #0]
 80087b6:	f107 030c 	add.w	r3, r7, #12
 80087ba:	4611      	mov	r1, r2
 80087bc:	4618      	mov	r0, r3
 80087be:	f7ff ff75 	bl	80086ac <putc_bfd>
 80087c2:	687b      	ldr	r3, [r7, #4]
 80087c4:	781b      	ldrb	r3, [r3, #0]
 80087c6:	2b00      	cmp	r3, #0
 80087c8:	d1f1      	bne.n	80087ae <f_puts+0x18>
	return putc_flush(&pb);
 80087ca:	f107 030c 	add.w	r3, r7, #12
 80087ce:	4618      	mov	r0, r3
 80087d0:	f7ff ffab 	bl	800872a <putc_flush>
 80087d4:	4603      	mov	r3, r0
}
 80087d6:	4618      	mov	r0, r3
 80087d8:	3758      	adds	r7, #88	; 0x58
 80087da:	46bd      	mov	sp, r7
 80087dc:	bd80      	pop	{r7, pc}
	...

080087e0 <ff_uni2oem>:
#if FF_CODE_PAGE != 0 && FF_CODE_PAGE < 900
WCHAR ff_uni2oem (	/* Returns OEM code character, zero on error */
	DWORD	uni,	/* UTF-16 encoded character to be converted */
	WORD	cp		/* Code page for the conversion */
)
{
 80087e0:	b480      	push	{r7}
 80087e2:	b085      	sub	sp, #20
 80087e4:	af00      	add	r7, sp, #0
 80087e6:	6078      	str	r0, [r7, #4]
 80087e8:	460b      	mov	r3, r1
 80087ea:	807b      	strh	r3, [r7, #2]
	WCHAR c = 0;
 80087ec:	2300      	movs	r3, #0
 80087ee:	81fb      	strh	r3, [r7, #14]
	const WCHAR *p = CVTBL(uc, FF_CODE_PAGE);
 80087f0:	4b17      	ldr	r3, [pc, #92]	; (8008850 <ff_uni2oem+0x70>)
 80087f2:	60bb      	str	r3, [r7, #8]


	if (uni < 0x80) {	/* ASCII? */
 80087f4:	687b      	ldr	r3, [r7, #4]
 80087f6:	2b7f      	cmp	r3, #127	; 0x7f
 80087f8:	d802      	bhi.n	8008800 <ff_uni2oem+0x20>
		c = (WCHAR)uni;
 80087fa:	687b      	ldr	r3, [r7, #4]
 80087fc:	81fb      	strh	r3, [r7, #14]
 80087fe:	e01f      	b.n	8008840 <ff_uni2oem+0x60>

	} else {			/* Non-ASCII */
		if (uni < 0x10000 && cp == FF_CODE_PAGE) {	/* Is it in BMP and valid code page? */
 8008800:	687b      	ldr	r3, [r7, #4]
 8008802:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8008806:	d21b      	bcs.n	8008840 <ff_uni2oem+0x60>
 8008808:	887b      	ldrh	r3, [r7, #2]
 800880a:	f240 12b5 	movw	r2, #437	; 0x1b5
 800880e:	4293      	cmp	r3, r2
 8008810:	d116      	bne.n	8008840 <ff_uni2oem+0x60>
			for (c = 0; c < 0x80 && uni != p[c]; c++) ;
 8008812:	2300      	movs	r3, #0
 8008814:	81fb      	strh	r3, [r7, #14]
 8008816:	e002      	b.n	800881e <ff_uni2oem+0x3e>
 8008818:	89fb      	ldrh	r3, [r7, #14]
 800881a:	3301      	adds	r3, #1
 800881c:	81fb      	strh	r3, [r7, #14]
 800881e:	89fb      	ldrh	r3, [r7, #14]
 8008820:	2b7f      	cmp	r3, #127	; 0x7f
 8008822:	d808      	bhi.n	8008836 <ff_uni2oem+0x56>
 8008824:	89fb      	ldrh	r3, [r7, #14]
 8008826:	005b      	lsls	r3, r3, #1
 8008828:	68ba      	ldr	r2, [r7, #8]
 800882a:	4413      	add	r3, r2
 800882c:	881b      	ldrh	r3, [r3, #0]
 800882e:	461a      	mov	r2, r3
 8008830:	687b      	ldr	r3, [r7, #4]
 8008832:	4293      	cmp	r3, r2
 8008834:	d1f0      	bne.n	8008818 <ff_uni2oem+0x38>
			c = (c + 0x80) & 0xFF;
 8008836:	89fb      	ldrh	r3, [r7, #14]
 8008838:	3380      	adds	r3, #128	; 0x80
 800883a:	b29b      	uxth	r3, r3
 800883c:	b2db      	uxtb	r3, r3
 800883e:	81fb      	strh	r3, [r7, #14]
		}
	}

	return c;
 8008840:	89fb      	ldrh	r3, [r7, #14]
}
 8008842:	4618      	mov	r0, r3
 8008844:	3714      	adds	r7, #20
 8008846:	46bd      	mov	sp, r7
 8008848:	f85d 7b04 	ldr.w	r7, [sp], #4
 800884c:	4770      	bx	lr
 800884e:	bf00      	nop
 8008850:	08014e48 	.word	0x08014e48

08008854 <ff_oem2uni>:

WCHAR ff_oem2uni (	/* Returns Unicode character in UTF-16, zero on error */
	WCHAR	oem,	/* OEM code to be converted */
	WORD	cp		/* Code page for the conversion */
)
{
 8008854:	b480      	push	{r7}
 8008856:	b085      	sub	sp, #20
 8008858:	af00      	add	r7, sp, #0
 800885a:	4603      	mov	r3, r0
 800885c:	460a      	mov	r2, r1
 800885e:	80fb      	strh	r3, [r7, #6]
 8008860:	4613      	mov	r3, r2
 8008862:	80bb      	strh	r3, [r7, #4]
	WCHAR c = 0;
 8008864:	2300      	movs	r3, #0
 8008866:	81fb      	strh	r3, [r7, #14]
	const WCHAR *p = CVTBL(uc, FF_CODE_PAGE);
 8008868:	4b0f      	ldr	r3, [pc, #60]	; (80088a8 <ff_oem2uni+0x54>)
 800886a:	60bb      	str	r3, [r7, #8]


	if (oem < 0x80) {	/* ASCII? */
 800886c:	88fb      	ldrh	r3, [r7, #6]
 800886e:	2b7f      	cmp	r3, #127	; 0x7f
 8008870:	d802      	bhi.n	8008878 <ff_oem2uni+0x24>
		c = oem;
 8008872:	88fb      	ldrh	r3, [r7, #6]
 8008874:	81fb      	strh	r3, [r7, #14]
 8008876:	e010      	b.n	800889a <ff_oem2uni+0x46>

	} else {			/* Extended char */
		if (cp == FF_CODE_PAGE) {	/* Is it a valid code page? */
 8008878:	88bb      	ldrh	r3, [r7, #4]
 800887a:	f240 12b5 	movw	r2, #437	; 0x1b5
 800887e:	4293      	cmp	r3, r2
 8008880:	d10b      	bne.n	800889a <ff_oem2uni+0x46>
			if (oem < 0x100) c = p[oem - 0x80];
 8008882:	88fb      	ldrh	r3, [r7, #6]
 8008884:	2bff      	cmp	r3, #255	; 0xff
 8008886:	d808      	bhi.n	800889a <ff_oem2uni+0x46>
 8008888:	88fb      	ldrh	r3, [r7, #6]
 800888a:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 800888e:	3b80      	subs	r3, #128	; 0x80
 8008890:	005b      	lsls	r3, r3, #1
 8008892:	68ba      	ldr	r2, [r7, #8]
 8008894:	4413      	add	r3, r2
 8008896:	881b      	ldrh	r3, [r3, #0]
 8008898:	81fb      	strh	r3, [r7, #14]
		}
	}

	return c;
 800889a:	89fb      	ldrh	r3, [r7, #14]
}
 800889c:	4618      	mov	r0, r3
 800889e:	3714      	adds	r7, #20
 80088a0:	46bd      	mov	sp, r7
 80088a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80088a6:	4770      	bx	lr
 80088a8:	08014e48 	.word	0x08014e48

080088ac <ff_wtoupper>:
/*------------------------------------------------------------------------*/

DWORD ff_wtoupper (	/* Returns up-converted code point */
	DWORD uni		/* Unicode code point to be up-converted */
)
{
 80088ac:	b480      	push	{r7}
 80088ae:	b087      	sub	sp, #28
 80088b0:	af00      	add	r7, sp, #0
 80088b2:	6078      	str	r0, [r7, #4]

		0x0000	/* EOT */
	};


	if (uni < 0x10000) {	/* Is it in BMP? */
 80088b4:	687b      	ldr	r3, [r7, #4]
 80088b6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80088ba:	d27d      	bcs.n	80089b8 <ff_wtoupper+0x10c>
		uc = (WORD)uni;
 80088bc:	687b      	ldr	r3, [r7, #4]
 80088be:	827b      	strh	r3, [r7, #18]
		p = uc < 0x1000 ? cvt1 : cvt2;
 80088c0:	8a7b      	ldrh	r3, [r7, #18]
 80088c2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80088c6:	d201      	bcs.n	80088cc <ff_wtoupper+0x20>
 80088c8:	4b3f      	ldr	r3, [pc, #252]	; (80089c8 <ff_wtoupper+0x11c>)
 80088ca:	e000      	b.n	80088ce <ff_wtoupper+0x22>
 80088cc:	4b3f      	ldr	r3, [pc, #252]	; (80089cc <ff_wtoupper+0x120>)
 80088ce:	617b      	str	r3, [r7, #20]
		for (;;) {
			bc = *p++;								/* Get the block base */
 80088d0:	697b      	ldr	r3, [r7, #20]
 80088d2:	1c9a      	adds	r2, r3, #2
 80088d4:	617a      	str	r2, [r7, #20]
 80088d6:	881b      	ldrh	r3, [r3, #0]
 80088d8:	823b      	strh	r3, [r7, #16]
			if (bc == 0 || uc < bc) break;			/* Not matched? */
 80088da:	8a3b      	ldrh	r3, [r7, #16]
 80088dc:	2b00      	cmp	r3, #0
 80088de:	d069      	beq.n	80089b4 <ff_wtoupper+0x108>
 80088e0:	8a7a      	ldrh	r2, [r7, #18]
 80088e2:	8a3b      	ldrh	r3, [r7, #16]
 80088e4:	429a      	cmp	r2, r3
 80088e6:	d365      	bcc.n	80089b4 <ff_wtoupper+0x108>
			nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 80088e8:	697b      	ldr	r3, [r7, #20]
 80088ea:	1c9a      	adds	r2, r3, #2
 80088ec:	617a      	str	r2, [r7, #20]
 80088ee:	881b      	ldrh	r3, [r3, #0]
 80088f0:	81fb      	strh	r3, [r7, #14]
 80088f2:	89fb      	ldrh	r3, [r7, #14]
 80088f4:	0a1b      	lsrs	r3, r3, #8
 80088f6:	81bb      	strh	r3, [r7, #12]
 80088f8:	89fb      	ldrh	r3, [r7, #14]
 80088fa:	b2db      	uxtb	r3, r3
 80088fc:	81fb      	strh	r3, [r7, #14]
			if (uc < bc + nc) {	/* In the block? */
 80088fe:	8a7a      	ldrh	r2, [r7, #18]
 8008900:	8a39      	ldrh	r1, [r7, #16]
 8008902:	89fb      	ldrh	r3, [r7, #14]
 8008904:	440b      	add	r3, r1
 8008906:	429a      	cmp	r2, r3
 8008908:	da4a      	bge.n	80089a0 <ff_wtoupper+0xf4>
				switch (cmd) {
 800890a:	89bb      	ldrh	r3, [r7, #12]
 800890c:	2b08      	cmp	r3, #8
 800890e:	d850      	bhi.n	80089b2 <ff_wtoupper+0x106>
 8008910:	a201      	add	r2, pc, #4	; (adr r2, 8008918 <ff_wtoupper+0x6c>)
 8008912:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008916:	bf00      	nop
 8008918:	0800893d 	.word	0x0800893d
 800891c:	0800894f 	.word	0x0800894f
 8008920:	08008965 	.word	0x08008965
 8008924:	0800896d 	.word	0x0800896d
 8008928:	08008975 	.word	0x08008975
 800892c:	0800897d 	.word	0x0800897d
 8008930:	08008985 	.word	0x08008985
 8008934:	0800898d 	.word	0x0800898d
 8008938:	08008995 	.word	0x08008995
				case 0:	uc = p[uc - bc]; break;		/* Table conversion */
 800893c:	8a7a      	ldrh	r2, [r7, #18]
 800893e:	8a3b      	ldrh	r3, [r7, #16]
 8008940:	1ad3      	subs	r3, r2, r3
 8008942:	005b      	lsls	r3, r3, #1
 8008944:	697a      	ldr	r2, [r7, #20]
 8008946:	4413      	add	r3, r2
 8008948:	881b      	ldrh	r3, [r3, #0]
 800894a:	827b      	strh	r3, [r7, #18]
 800894c:	e027      	b.n	800899e <ff_wtoupper+0xf2>
				case 1:	uc -= (uc - bc) & 1; break;	/* Case pairs */
 800894e:	8a7a      	ldrh	r2, [r7, #18]
 8008950:	8a3b      	ldrh	r3, [r7, #16]
 8008952:	1ad3      	subs	r3, r2, r3
 8008954:	b29b      	uxth	r3, r3
 8008956:	f003 0301 	and.w	r3, r3, #1
 800895a:	b29b      	uxth	r3, r3
 800895c:	8a7a      	ldrh	r2, [r7, #18]
 800895e:	1ad3      	subs	r3, r2, r3
 8008960:	827b      	strh	r3, [r7, #18]
 8008962:	e01c      	b.n	800899e <ff_wtoupper+0xf2>
				case 2: uc -= 16; break;			/* Shift -16 */
 8008964:	8a7b      	ldrh	r3, [r7, #18]
 8008966:	3b10      	subs	r3, #16
 8008968:	827b      	strh	r3, [r7, #18]
 800896a:	e018      	b.n	800899e <ff_wtoupper+0xf2>
				case 3:	uc -= 32; break;			/* Shift -32 */
 800896c:	8a7b      	ldrh	r3, [r7, #18]
 800896e:	3b20      	subs	r3, #32
 8008970:	827b      	strh	r3, [r7, #18]
 8008972:	e014      	b.n	800899e <ff_wtoupper+0xf2>
				case 4:	uc -= 48; break;			/* Shift -48 */
 8008974:	8a7b      	ldrh	r3, [r7, #18]
 8008976:	3b30      	subs	r3, #48	; 0x30
 8008978:	827b      	strh	r3, [r7, #18]
 800897a:	e010      	b.n	800899e <ff_wtoupper+0xf2>
				case 5:	uc -= 26; break;			/* Shift -26 */
 800897c:	8a7b      	ldrh	r3, [r7, #18]
 800897e:	3b1a      	subs	r3, #26
 8008980:	827b      	strh	r3, [r7, #18]
 8008982:	e00c      	b.n	800899e <ff_wtoupper+0xf2>
				case 6:	uc += 8; break;				/* Shift +8 */
 8008984:	8a7b      	ldrh	r3, [r7, #18]
 8008986:	3308      	adds	r3, #8
 8008988:	827b      	strh	r3, [r7, #18]
 800898a:	e008      	b.n	800899e <ff_wtoupper+0xf2>
				case 7: uc -= 80; break;			/* Shift -80 */
 800898c:	8a7b      	ldrh	r3, [r7, #18]
 800898e:	3b50      	subs	r3, #80	; 0x50
 8008990:	827b      	strh	r3, [r7, #18]
 8008992:	e004      	b.n	800899e <ff_wtoupper+0xf2>
				case 8:	uc -= 0x1C60; break;		/* Shift -0x1C60 */
 8008994:	8a7b      	ldrh	r3, [r7, #18]
 8008996:	f5a3 53e3 	sub.w	r3, r3, #7264	; 0x1c60
 800899a:	827b      	strh	r3, [r7, #18]
 800899c:	bf00      	nop
				}
				break;
 800899e:	e008      	b.n	80089b2 <ff_wtoupper+0x106>
			}
			if (cmd == 0) p += nc;	/* Skip table if needed */
 80089a0:	89bb      	ldrh	r3, [r7, #12]
 80089a2:	2b00      	cmp	r3, #0
 80089a4:	d194      	bne.n	80088d0 <ff_wtoupper+0x24>
 80089a6:	89fb      	ldrh	r3, [r7, #14]
 80089a8:	005b      	lsls	r3, r3, #1
 80089aa:	697a      	ldr	r2, [r7, #20]
 80089ac:	4413      	add	r3, r2
 80089ae:	617b      	str	r3, [r7, #20]
			bc = *p++;								/* Get the block base */
 80089b0:	e78e      	b.n	80088d0 <ff_wtoupper+0x24>
				break;
 80089b2:	bf00      	nop
		}
		uni = uc;
 80089b4:	8a7b      	ldrh	r3, [r7, #18]
 80089b6:	607b      	str	r3, [r7, #4]
	}

	return uni;
 80089b8:	687b      	ldr	r3, [r7, #4]
}
 80089ba:	4618      	mov	r0, r3
 80089bc:	371c      	adds	r7, #28
 80089be:	46bd      	mov	sp, r7
 80089c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80089c4:	4770      	bx	lr
 80089c6:	bf00      	nop
 80089c8:	08014f48 	.word	0x08014f48
 80089cc:	0801513c 	.word	0x0801513c

080089d0 <SDCARD_ReadR1>:
     ||`----- 5th bit (c): error in the sequence of erase commands
     |`------ 6th bit (b): misaligned addres used in command
     `------- 7th bit (a): command argument outside allowed range
             (8th bit is always zero)
*/
/*static*/ uint8_t SDCARD_ReadR1() { // REPLACE WITH CHECKING MECHANIZM
 80089d0:	b580      	push	{r7, lr}
 80089d2:	b082      	sub	sp, #8
 80089d4:	af00      	add	r7, sp, #0
    uint8_t r1;
    // make sure FF is transmitted during receive
    uint8_t tx = 0xFF;
 80089d6:	23ff      	movs	r3, #255	; 0xff
 80089d8:	71bb      	strb	r3, [r7, #6]
		USER_ICP_ResetCondition();
 80089da:	f002 fe3b 	bl	800b654 <USER_ICP_ResetCondition>
    for(;USER_ICP_CheckCondition();) {
 80089de:	e00e      	b.n	80089fe <SDCARD_ReadR1+0x2e>
        if (USER_SPI_TransmitReceive(&tx, &r1, sizeof(r1)))
 80089e0:	1df9      	adds	r1, r7, #7
 80089e2:	1dbb      	adds	r3, r7, #6
 80089e4:	2201      	movs	r2, #1
 80089e6:	4618      	mov	r0, r3
 80089e8:	f002 fd40 	bl	800b46c <USER_SPI_TransmitReceive>
 80089ec:	4603      	mov	r3, r0
 80089ee:	2b00      	cmp	r3, #0
 80089f0:	d001      	beq.n	80089f6 <SDCARD_ReadR1+0x26>
					return 0xFF;
 80089f2:	23ff      	movs	r3, #255	; 0xff
 80089f4:	e012      	b.n	8008a1c <SDCARD_ReadR1+0x4c>
        if((r1 & 0x80) == 0) // 8th bit alwyas zero, r1 recevied
 80089f6:	79fb      	ldrb	r3, [r7, #7]
 80089f8:	b25b      	sxtb	r3, r3
 80089fa:	2b00      	cmp	r3, #0
 80089fc:	da05      	bge.n	8008a0a <SDCARD_ReadR1+0x3a>
    for(;USER_ICP_CheckCondition();) {
 80089fe:	f002 fe37 	bl	800b670 <USER_ICP_CheckCondition>
 8008a02:	4603      	mov	r3, r0
 8008a04:	2b00      	cmp	r3, #0
 8008a06:	d1eb      	bne.n	80089e0 <SDCARD_ReadR1+0x10>
 8008a08:	e000      	b.n	8008a0c <SDCARD_ReadR1+0x3c>
            break;
 8008a0a:	bf00      	nop
    }
		if (USER_ICP_ConditionValidation())
 8008a0c:	f002 fe3a 	bl	800b684 <USER_ICP_ConditionValidation>
 8008a10:	4603      	mov	r3, r0
 8008a12:	2b00      	cmp	r3, #0
 8008a14:	d001      	beq.n	8008a1a <SDCARD_ReadR1+0x4a>
			return 0xFF;
 8008a16:	23ff      	movs	r3, #255	; 0xff
 8008a18:	e000      	b.n	8008a1c <SDCARD_ReadR1+0x4c>
    return r1;
 8008a1a:	79fb      	ldrb	r3, [r7, #7]
}
 8008a1c:	4618      	mov	r0, r3
 8008a1e:	3708      	adds	r7, #8
 8008a20:	46bd      	mov	sp, r7
 8008a22:	bd80      	pop	{r7, pc}

08008a24 <SDCARD_WaitDataToken>:
#define DATA_TOKEN_CMD17 0xFE
#define DATA_TOKEN_CMD18 0xFE
#define DATA_TOKEN_CMD24 0xFE
#define DATA_TOKEN_CMD25 0xFC

/*static*/ int SDCARD_WaitDataToken(uint8_t token) { // REPLACE WITH CHECKING MECHANIZM
 8008a24:	b580      	push	{r7, lr}
 8008a26:	b084      	sub	sp, #16
 8008a28:	af00      	add	r7, sp, #0
 8008a2a:	4603      	mov	r3, r0
 8008a2c:	71fb      	strb	r3, [r7, #7]
    uint8_t fb;
    // make sure FF is transmitted during receive
    uint8_t tx = 0xFF;
 8008a2e:	23ff      	movs	r3, #255	; 0xff
 8008a30:	73bb      	strb	r3, [r7, #14]
		USER_ICP_ResetCondition();
 8008a32:	f002 fe0f 	bl	800b654 <USER_ICP_ResetCondition>
    for(;USER_ICP_CheckCondition();) {
 8008a36:	e017      	b.n	8008a68 <SDCARD_WaitDataToken+0x44>
        if (USER_SPI_TransmitReceive(&tx, &fb, sizeof(fb)))
 8008a38:	f107 010f 	add.w	r1, r7, #15
 8008a3c:	f107 030e 	add.w	r3, r7, #14
 8008a40:	2201      	movs	r2, #1
 8008a42:	4618      	mov	r0, r3
 8008a44:	f002 fd12 	bl	800b46c <USER_SPI_TransmitReceive>
 8008a48:	4603      	mov	r3, r0
 8008a4a:	2b00      	cmp	r3, #0
 8008a4c:	d002      	beq.n	8008a54 <SDCARD_WaitDataToken+0x30>
					return -1;
 8008a4e:	f04f 33ff 	mov.w	r3, #4294967295
 8008a52:	e019      	b.n	8008a88 <SDCARD_WaitDataToken+0x64>
        if(fb == token)
 8008a54:	7bfb      	ldrb	r3, [r7, #15]
 8008a56:	79fa      	ldrb	r2, [r7, #7]
 8008a58:	429a      	cmp	r2, r3
 8008a5a:	d00b      	beq.n	8008a74 <SDCARD_WaitDataToken+0x50>
            break;

        if(fb != 0xFF)
 8008a5c:	7bfb      	ldrb	r3, [r7, #15]
 8008a5e:	2bff      	cmp	r3, #255	; 0xff
 8008a60:	d002      	beq.n	8008a68 <SDCARD_WaitDataToken+0x44>
            return -1;
 8008a62:	f04f 33ff 	mov.w	r3, #4294967295
 8008a66:	e00f      	b.n	8008a88 <SDCARD_WaitDataToken+0x64>
    for(;USER_ICP_CheckCondition();) {
 8008a68:	f002 fe02 	bl	800b670 <USER_ICP_CheckCondition>
 8008a6c:	4603      	mov	r3, r0
 8008a6e:	2b00      	cmp	r3, #0
 8008a70:	d1e2      	bne.n	8008a38 <SDCARD_WaitDataToken+0x14>
 8008a72:	e000      	b.n	8008a76 <SDCARD_WaitDataToken+0x52>
            break;
 8008a74:	bf00      	nop
    }
		if (USER_ICP_ConditionValidation())
 8008a76:	f002 fe05 	bl	800b684 <USER_ICP_ConditionValidation>
 8008a7a:	4603      	mov	r3, r0
 8008a7c:	2b00      	cmp	r3, #0
 8008a7e:	d002      	beq.n	8008a86 <SDCARD_WaitDataToken+0x62>
			return -30;
 8008a80:	f06f 031d 	mvn.w	r3, #29
 8008a84:	e000      	b.n	8008a88 <SDCARD_WaitDataToken+0x64>
    return 0;
 8008a86:	2300      	movs	r3, #0
}
 8008a88:	4618      	mov	r0, r3
 8008a8a:	3710      	adds	r7, #16
 8008a8c:	46bd      	mov	sp, r7
 8008a8e:	bd80      	pop	{r7, pc}

08008a90 <SDCARD_ReadBytes>:

/*static*/ int SDCARD_ReadBytes(uint8_t* buff, uint16_t buff_size) { // REPLACE WITH CHECKING MECHANIZM
 8008a90:	b580      	push	{r7, lr}
 8008a92:	b084      	sub	sp, #16
 8008a94:	af00      	add	r7, sp, #0
 8008a96:	6078      	str	r0, [r7, #4]
 8008a98:	460b      	mov	r3, r1
 8008a9a:	807b      	strh	r3, [r7, #2]
    // make sure FF is transmitted during receive
    uint8_t tx = 0xFF;
 8008a9c:	23ff      	movs	r3, #255	; 0xff
 8008a9e:	73fb      	strb	r3, [r7, #15]
    while(buff_size > 0) {
 8008aa0:	e012      	b.n	8008ac8 <SDCARD_ReadBytes+0x38>
        if (USER_SPI_TransmitReceive(&tx, buff, 1))
 8008aa2:	f107 030f 	add.w	r3, r7, #15
 8008aa6:	2201      	movs	r2, #1
 8008aa8:	6879      	ldr	r1, [r7, #4]
 8008aaa:	4618      	mov	r0, r3
 8008aac:	f002 fcde 	bl	800b46c <USER_SPI_TransmitReceive>
 8008ab0:	4603      	mov	r3, r0
 8008ab2:	2b00      	cmp	r3, #0
 8008ab4:	d002      	beq.n	8008abc <SDCARD_ReadBytes+0x2c>
					return -1;
 8008ab6:	f04f 33ff 	mov.w	r3, #4294967295
 8008aba:	e009      	b.n	8008ad0 <SDCARD_ReadBytes+0x40>
        buff++;
 8008abc:	687b      	ldr	r3, [r7, #4]
 8008abe:	3301      	adds	r3, #1
 8008ac0:	607b      	str	r3, [r7, #4]
        buff_size--;
 8008ac2:	887b      	ldrh	r3, [r7, #2]
 8008ac4:	3b01      	subs	r3, #1
 8008ac6:	807b      	strh	r3, [r7, #2]
    while(buff_size > 0) {
 8008ac8:	887b      	ldrh	r3, [r7, #2]
 8008aca:	2b00      	cmp	r3, #0
 8008acc:	d1e9      	bne.n	8008aa2 <SDCARD_ReadBytes+0x12>
    }

    return 0;
 8008ace:	2300      	movs	r3, #0
}
 8008ad0:	4618      	mov	r0, r3
 8008ad2:	3710      	adds	r7, #16
 8008ad4:	46bd      	mov	sp, r7
 8008ad6:	bd80      	pop	{r7, pc}

08008ad8 <SDCARD_WaitNotBusy>:

/*static*/ int SDCARD_WaitNotBusy() { // REPLACE WITH CHECKING MECHANIZM
 8008ad8:	b580      	push	{r7, lr}
 8008ada:	b082      	sub	sp, #8
 8008adc:	af00      	add	r7, sp, #0
    uint8_t busy;
		USER_ICP_ResetCondition();
 8008ade:	f002 fdb9 	bl	800b654 <USER_ICP_ResetCondition>
    do {
        if(SDCARD_ReadBytes(&busy, sizeof(busy)) < 0) {
 8008ae2:	1dfb      	adds	r3, r7, #7
 8008ae4:	2101      	movs	r1, #1
 8008ae6:	4618      	mov	r0, r3
 8008ae8:	f7ff ffd2 	bl	8008a90 <SDCARD_ReadBytes>
 8008aec:	4603      	mov	r3, r0
 8008aee:	2b00      	cmp	r3, #0
 8008af0:	da02      	bge.n	8008af8 <SDCARD_WaitNotBusy+0x20>
            return -1;
 8008af2:	f04f 33ff 	mov.w	r3, #4294967295
 8008af6:	e010      	b.n	8008b1a <SDCARD_WaitNotBusy+0x42>
        }
    } while(busy != 0xFF && USER_ICP_CheckCondition() == 1);
 8008af8:	79fb      	ldrb	r3, [r7, #7]
 8008afa:	2bff      	cmp	r3, #255	; 0xff
 8008afc:	d004      	beq.n	8008b08 <SDCARD_WaitNotBusy+0x30>
 8008afe:	f002 fdb7 	bl	800b670 <USER_ICP_CheckCondition>
 8008b02:	4603      	mov	r3, r0
 8008b04:	2b01      	cmp	r3, #1
 8008b06:	d0ec      	beq.n	8008ae2 <SDCARD_WaitNotBusy+0xa>
		if (USER_ICP_ConditionValidation())
 8008b08:	f002 fdbc 	bl	800b684 <USER_ICP_ConditionValidation>
 8008b0c:	4603      	mov	r3, r0
 8008b0e:	2b00      	cmp	r3, #0
 8008b10:	d002      	beq.n	8008b18 <SDCARD_WaitNotBusy+0x40>
			return -30;
 8008b12:	f06f 031d 	mvn.w	r3, #29
 8008b16:	e000      	b.n	8008b1a <SDCARD_WaitNotBusy+0x42>
    return 0;
 8008b18:	2300      	movs	r3, #0
}
 8008b1a:	4618      	mov	r0, r3
 8008b1c:	3708      	adds	r7, #8
 8008b1e:	46bd      	mov	sp, r7
 8008b20:	bd80      	pop	{r7, pc}
	...

08008b24 <SDCARD_Init>:
 
int SDCARD_Init() {
 8008b24:	b580      	push	{r7, lr}
 8008b26:	b08e      	sub	sp, #56	; 0x38
 8008b28:	af00      	add	r7, sp, #0
    Set DI and CS high and apply 74 or more clock pulses to SCLK. Without this
    step under certain circumstances SD-card will not work. For instance, when
    multiple SPI devices are sharing the same bus (i.e. MISO, MOSI, CS).
    */
		//==========================
			if (!USER_SDCARD_isAvailable())
 8008b2a:	f002 fd67 	bl	800b5fc <USER_SDCARD_isAvailable>
 8008b2e:	4603      	mov	r3, r0
 8008b30:	2b00      	cmp	r3, #0
 8008b32:	d102      	bne.n	8008b3a <SDCARD_Init+0x16>
				return -29;
 8008b34:	f06f 031c 	mvn.w	r3, #28
 8008b38:	e101      	b.n	8008d3e <SDCARD_Init+0x21a>
		//==========================
			
    USER_SDCARD_Unselect();
 8008b3a:	f002 fd50 	bl	800b5de <USER_SDCARD_Unselect>

    uint8_t high = 0xFF;
 8008b3e:	23ff      	movs	r3, #255	; 0xff
 8008b40:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
    for(int i = 0; i < 10; i++) { // 80 clock pulses
 8008b44:	2300      	movs	r3, #0
 8008b46:	637b      	str	r3, [r7, #52]	; 0x34
 8008b48:	e008      	b.n	8008b5c <SDCARD_Init+0x38>
        USER_SPI_Transmit(&high, sizeof(high));
 8008b4a:	f107 0332 	add.w	r3, r7, #50	; 0x32
 8008b4e:	2101      	movs	r1, #1
 8008b50:	4618      	mov	r0, r3
 8008b52:	f002 fce3 	bl	800b51c <USER_SPI_Transmit>
    for(int i = 0; i < 10; i++) { // 80 clock pulses
 8008b56:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008b58:	3301      	adds	r3, #1
 8008b5a:	637b      	str	r3, [r7, #52]	; 0x34
 8008b5c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008b5e:	2b09      	cmp	r3, #9
 8008b60:	ddf3      	ble.n	8008b4a <SDCARD_Init+0x26>
    }

    USER_SDCARD_Select();
 8008b62:	f002 fd2d 	bl	800b5c0 <USER_SDCARD_Select>
    /*
    Step 2.
    
    Send CMD0 (GO_IDLE_STATE): Reset the SD card.
    */
    if(SDCARD_WaitNotBusy() < 0) { // keep this!
 8008b66:	f7ff ffb7 	bl	8008ad8 <SDCARD_WaitNotBusy>
 8008b6a:	4603      	mov	r3, r0
 8008b6c:	2b00      	cmp	r3, #0
 8008b6e:	da04      	bge.n	8008b7a <SDCARD_Init+0x56>
        USER_SDCARD_Unselect();
 8008b70:	f002 fd35 	bl	800b5de <USER_SDCARD_Unselect>
        return -1;
 8008b74:	f04f 33ff 	mov.w	r3, #4294967295
 8008b78:	e0e1      	b.n	8008d3e <SDCARD_Init+0x21a>
    }

    {
        /*static const*/ uint8_t cmd[] =
 8008b7a:	4a73      	ldr	r2, [pc, #460]	; (8008d48 <SDCARD_Init+0x224>)
 8008b7c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8008b80:	e892 0003 	ldmia.w	r2, {r0, r1}
 8008b84:	6018      	str	r0, [r3, #0]
 8008b86:	3304      	adds	r3, #4
 8008b88:	8019      	strh	r1, [r3, #0]
            { 0x40 | 0x00 /* CMD0 */, 0x00, 0x00, 0x00, 0x00 /* ARG = 0 */, (0x4A << 1) | 1 /* CRC7 + end bit */ };
        USER_SPI_Transmit((uint8_t*)cmd, sizeof(cmd));
 8008b8a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8008b8e:	2106      	movs	r1, #6
 8008b90:	4618      	mov	r0, r3
 8008b92:	f002 fcc3 	bl	800b51c <USER_SPI_Transmit>
    }

    if(SDCARD_ReadR1() != 0x01) {
 8008b96:	f7ff ff1b 	bl	80089d0 <SDCARD_ReadR1>
 8008b9a:	4603      	mov	r3, r0
 8008b9c:	2b01      	cmp	r3, #1
 8008b9e:	d004      	beq.n	8008baa <SDCARD_Init+0x86>
        USER_SDCARD_Unselect();
 8008ba0:	f002 fd1d 	bl	800b5de <USER_SDCARD_Unselect>
        return -1;
 8008ba4:	f04f 33ff 	mov.w	r3, #4294967295
 8008ba8:	e0c9      	b.n	8008d3e <SDCARD_Init+0x21a>
    MMC version 3. If accepted, R7 response (R1(0x01) + 32-bit return value)
    will be returned. The lower 12 bits in the return value 0x1AA means that
    the card is SDC version 2 and it can work at voltage range of 2.7 to 3.6
    volts. If not the case, the card should be rejected.
    */
    if(SDCARD_WaitNotBusy() < 0) { // keep this!
 8008baa:	f7ff ff95 	bl	8008ad8 <SDCARD_WaitNotBusy>
 8008bae:	4603      	mov	r3, r0
 8008bb0:	2b00      	cmp	r3, #0
 8008bb2:	da04      	bge.n	8008bbe <SDCARD_Init+0x9a>
        USER_SDCARD_Unselect();
 8008bb4:	f002 fd13 	bl	800b5de <USER_SDCARD_Unselect>
        return -1;
 8008bb8:	f04f 33ff 	mov.w	r3, #4294967295
 8008bbc:	e0bf      	b.n	8008d3e <SDCARD_Init+0x21a>
    }

    {
        /*static const*/ uint8_t cmd[] =
 8008bbe:	4a63      	ldr	r2, [pc, #396]	; (8008d4c <SDCARD_Init+0x228>)
 8008bc0:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8008bc4:	e892 0003 	ldmia.w	r2, {r0, r1}
 8008bc8:	6018      	str	r0, [r3, #0]
 8008bca:	3304      	adds	r3, #4
 8008bcc:	8019      	strh	r1, [r3, #0]
            { 0x40 | 0x08 /* CMD8 */, 0x00, 0x00, 0x01, 0xAA /* ARG */, (0x43 << 1) | 1 /* CRC7 + end bit */ };
        USER_SPI_Transmit((uint8_t*)cmd, sizeof(cmd));
 8008bce:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8008bd2:	2106      	movs	r1, #6
 8008bd4:	4618      	mov	r0, r3
 8008bd6:	f002 fca1 	bl	800b51c <USER_SPI_Transmit>
    }

    if(SDCARD_ReadR1() != 0x01) {
 8008bda:	f7ff fef9 	bl	80089d0 <SDCARD_ReadR1>
 8008bde:	4603      	mov	r3, r0
 8008be0:	2b01      	cmp	r3, #1
 8008be2:	d004      	beq.n	8008bee <SDCARD_Init+0xca>
        USER_SDCARD_Unselect();
 8008be4:	f002 fcfb 	bl	800b5de <USER_SDCARD_Unselect>
        return -2; // not an SDHC/SDXC card (i.e. SDSC, not supported)
 8008be8:	f06f 0301 	mvn.w	r3, #1
 8008bec:	e0a7      	b.n	8008d3e <SDCARD_Init+0x21a>
    }

    {
        uint8_t resp[4];
        if(SDCARD_ReadBytes(resp, sizeof(resp)) < 0) {
 8008bee:	f107 0320 	add.w	r3, r7, #32
 8008bf2:	2104      	movs	r1, #4
 8008bf4:	4618      	mov	r0, r3
 8008bf6:	f7ff ff4b 	bl	8008a90 <SDCARD_ReadBytes>
 8008bfa:	4603      	mov	r3, r0
 8008bfc:	2b00      	cmp	r3, #0
 8008bfe:	da04      	bge.n	8008c0a <SDCARD_Init+0xe6>
            USER_SDCARD_Unselect();
 8008c00:	f002 fced 	bl	800b5de <USER_SDCARD_Unselect>
            return -3;
 8008c04:	f06f 0302 	mvn.w	r3, #2
 8008c08:	e099      	b.n	8008d3e <SDCARD_Init+0x21a>
        }

        if(((resp[2] & 0x01) != 1) || (resp[3] != 0xAA)) {
 8008c0a:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8008c0e:	f003 0301 	and.w	r3, r3, #1
 8008c12:	2b00      	cmp	r3, #0
 8008c14:	d003      	beq.n	8008c1e <SDCARD_Init+0xfa>
 8008c16:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8008c1a:	2baa      	cmp	r3, #170	; 0xaa
 8008c1c:	d004      	beq.n	8008c28 <SDCARD_Init+0x104>
            USER_SDCARD_Unselect();
 8008c1e:	f002 fcde 	bl	800b5de <USER_SDCARD_Unselect>
            return -4;
 8008c22:	f06f 0303 	mvn.w	r3, #3
 8008c26:	e08a      	b.n	8008d3e <SDCARD_Init+0x21a>
    Step 4.
    And then initiate initialization with ACMD41 with HCS flag (bit 30).
    */
		/*USER_ICP_ResetCondition();*/
    for(;/*USER_ICP_CheckCondition()*/;) {
        if(SDCARD_WaitNotBusy() < 0) { // keep this!
 8008c28:	f7ff ff56 	bl	8008ad8 <SDCARD_WaitNotBusy>
 8008c2c:	4603      	mov	r3, r0
 8008c2e:	2b00      	cmp	r3, #0
 8008c30:	da04      	bge.n	8008c3c <SDCARD_Init+0x118>
            USER_SDCARD_Unselect();
 8008c32:	f002 fcd4 	bl	800b5de <USER_SDCARD_Unselect>
            return -1;
 8008c36:	f04f 33ff 	mov.w	r3, #4294967295
 8008c3a:	e080      	b.n	8008d3e <SDCARD_Init+0x21a>
        }

        {
            /*static const*/ uint8_t cmd[] =
 8008c3c:	4a44      	ldr	r2, [pc, #272]	; (8008d50 <SDCARD_Init+0x22c>)
 8008c3e:	f107 0318 	add.w	r3, r7, #24
 8008c42:	e892 0003 	ldmia.w	r2, {r0, r1}
 8008c46:	6018      	str	r0, [r3, #0]
 8008c48:	3304      	adds	r3, #4
 8008c4a:	8019      	strh	r1, [r3, #0]
                { 0x40 | 0x37 /* CMD55 */, 0x00, 0x00, 0x00, 0x00 /* ARG */, (0x7F << 1) | 1 /* CRC7 + end bit */ };
            USER_SPI_Transmit((uint8_t*)cmd, sizeof(cmd));
 8008c4c:	f107 0318 	add.w	r3, r7, #24
 8008c50:	2106      	movs	r1, #6
 8008c52:	4618      	mov	r0, r3
 8008c54:	f002 fc62 	bl	800b51c <USER_SPI_Transmit>
        }

        if(SDCARD_ReadR1() != 0x01) {
 8008c58:	f7ff feba 	bl	80089d0 <SDCARD_ReadR1>
 8008c5c:	4603      	mov	r3, r0
 8008c5e:	2b01      	cmp	r3, #1
 8008c60:	d004      	beq.n	8008c6c <SDCARD_Init+0x148>
            USER_SDCARD_Unselect();
 8008c62:	f002 fcbc 	bl	800b5de <USER_SDCARD_Unselect>
            return -5;
 8008c66:	f06f 0304 	mvn.w	r3, #4
 8008c6a:	e068      	b.n	8008d3e <SDCARD_Init+0x21a>
        }

        if(SDCARD_WaitNotBusy() < 0) { // keep this!
 8008c6c:	f7ff ff34 	bl	8008ad8 <SDCARD_WaitNotBusy>
 8008c70:	4603      	mov	r3, r0
 8008c72:	2b00      	cmp	r3, #0
 8008c74:	da04      	bge.n	8008c80 <SDCARD_Init+0x15c>
            USER_SDCARD_Unselect();
 8008c76:	f002 fcb2 	bl	800b5de <USER_SDCARD_Unselect>
            return -1;
 8008c7a:	f04f 33ff 	mov.w	r3, #4294967295
 8008c7e:	e05e      	b.n	8008d3e <SDCARD_Init+0x21a>
        }

        {
            /*static const*/ uint8_t cmd[] =
 8008c80:	4a34      	ldr	r2, [pc, #208]	; (8008d54 <SDCARD_Init+0x230>)
 8008c82:	f107 0310 	add.w	r3, r7, #16
 8008c86:	e892 0003 	ldmia.w	r2, {r0, r1}
 8008c8a:	6018      	str	r0, [r3, #0]
 8008c8c:	3304      	adds	r3, #4
 8008c8e:	8019      	strh	r1, [r3, #0]
                { 0x40 | 0x29 /* ACMD41 */, 0x40, 0x00, 0x00, 0x00 /* ARG */, (0x7F << 1) | 1 /* CRC7 + end bit */ };
            USER_SPI_Transmit((uint8_t*)cmd, sizeof(cmd));
 8008c90:	f107 0310 	add.w	r3, r7, #16
 8008c94:	2106      	movs	r1, #6
 8008c96:	4618      	mov	r0, r3
 8008c98:	f002 fc40 	bl	800b51c <USER_SPI_Transmit>
        }

        uint8_t r1 = SDCARD_ReadR1();
 8008c9c:	f7ff fe98 	bl	80089d0 <SDCARD_ReadR1>
 8008ca0:	4603      	mov	r3, r0
 8008ca2:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
        if(r1 == 0x00) {
 8008ca6:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8008caa:	2b00      	cmp	r3, #0
 8008cac:	d008      	beq.n	8008cc0 <SDCARD_Init+0x19c>
            break;
        }

        if(r1 != 0x01) {
 8008cae:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8008cb2:	2b01      	cmp	r3, #1
 8008cb4:	d0b8      	beq.n	8008c28 <SDCARD_Init+0x104>
            USER_SDCARD_Unselect();
 8008cb6:	f002 fc92 	bl	800b5de <USER_SDCARD_Unselect>
            return -6;
 8008cba:	f06f 0305 	mvn.w	r3, #5
 8008cbe:	e03e      	b.n	8008d3e <SDCARD_Init+0x21a>
            break;
 8008cc0:	bf00      	nop
    Step 5.
    After the initialization completed, read OCR register with CMD58 and check
    CCS flag (bit 30). When it is set, the card is a high-capacity card known
    as SDHC/SDXC.
    */
    if(SDCARD_WaitNotBusy() < 0) { // keep this!
 8008cc2:	f7ff ff09 	bl	8008ad8 <SDCARD_WaitNotBusy>
 8008cc6:	4603      	mov	r3, r0
 8008cc8:	2b00      	cmp	r3, #0
 8008cca:	da04      	bge.n	8008cd6 <SDCARD_Init+0x1b2>
        USER_SDCARD_Unselect();
 8008ccc:	f002 fc87 	bl	800b5de <USER_SDCARD_Unselect>
        return -1;
 8008cd0:	f04f 33ff 	mov.w	r3, #4294967295
 8008cd4:	e033      	b.n	8008d3e <SDCARD_Init+0x21a>
    }

    {
        /*static const*/ uint8_t cmd[] =
 8008cd6:	4a20      	ldr	r2, [pc, #128]	; (8008d58 <SDCARD_Init+0x234>)
 8008cd8:	f107 0308 	add.w	r3, r7, #8
 8008cdc:	e892 0003 	ldmia.w	r2, {r0, r1}
 8008ce0:	6018      	str	r0, [r3, #0]
 8008ce2:	3304      	adds	r3, #4
 8008ce4:	8019      	strh	r1, [r3, #0]
            { 0x40 | 0x3A /* CMD58 */, 0x00, 0x00, 0x00, 0x00 /* ARG */, (0x7F << 1) | 1 /* CRC7 + end bit */ };
        USER_SPI_Transmit((uint8_t*)cmd, sizeof(cmd));
 8008ce6:	f107 0308 	add.w	r3, r7, #8
 8008cea:	2106      	movs	r1, #6
 8008cec:	4618      	mov	r0, r3
 8008cee:	f002 fc15 	bl	800b51c <USER_SPI_Transmit>
    }

    if(SDCARD_ReadR1() != 0x00) {
 8008cf2:	f7ff fe6d 	bl	80089d0 <SDCARD_ReadR1>
 8008cf6:	4603      	mov	r3, r0
 8008cf8:	2b00      	cmp	r3, #0
 8008cfa:	d004      	beq.n	8008d06 <SDCARD_Init+0x1e2>
        USER_SDCARD_Unselect();
 8008cfc:	f002 fc6f 	bl	800b5de <USER_SDCARD_Unselect>
        return -7;
 8008d00:	f06f 0306 	mvn.w	r3, #6
 8008d04:	e01b      	b.n	8008d3e <SDCARD_Init+0x21a>
    }

    {
        uint8_t resp[4];
        if(SDCARD_ReadBytes(resp, sizeof(resp)) < 0) {
 8008d06:	1d3b      	adds	r3, r7, #4
 8008d08:	2104      	movs	r1, #4
 8008d0a:	4618      	mov	r0, r3
 8008d0c:	f7ff fec0 	bl	8008a90 <SDCARD_ReadBytes>
 8008d10:	4603      	mov	r3, r0
 8008d12:	2b00      	cmp	r3, #0
 8008d14:	da04      	bge.n	8008d20 <SDCARD_Init+0x1fc>
            USER_SDCARD_Unselect();
 8008d16:	f002 fc62 	bl	800b5de <USER_SDCARD_Unselect>
            return -8;
 8008d1a:	f06f 0307 	mvn.w	r3, #7
 8008d1e:	e00e      	b.n	8008d3e <SDCARD_Init+0x21a>
        }

        if((resp[0] & 0xC0) != 0xC0) {
 8008d20:	793b      	ldrb	r3, [r7, #4]
 8008d22:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8008d26:	2bc0      	cmp	r3, #192	; 0xc0
 8008d28:	d004      	beq.n	8008d34 <SDCARD_Init+0x210>
            USER_SDCARD_Unselect();
 8008d2a:	f002 fc58 	bl	800b5de <USER_SDCARD_Unselect>
            return -9;
 8008d2e:	f06f 0308 	mvn.w	r3, #8
 8008d32:	e004      	b.n	8008d3e <SDCARD_Init+0x21a>
        }
    }

    USER_SDCARD_Unselect();
 8008d34:	f002 fc53 	bl	800b5de <USER_SDCARD_Unselect>
		USER_SDCARD_isInitialisedCallback();
 8008d38:	f002 fc6a 	bl	800b610 <USER_SDCARD_isInitialisedCallback>
    return 0;
 8008d3c:	2300      	movs	r3, #0
}
 8008d3e:	4618      	mov	r0, r3
 8008d40:	3738      	adds	r7, #56	; 0x38
 8008d42:	46bd      	mov	sp, r7
 8008d44:	bd80      	pop	{r7, pc}
 8008d46:	bf00      	nop
 8008d48:	08014c18 	.word	0x08014c18
 8008d4c:	08014c20 	.word	0x08014c20
 8008d50:	08014c28 	.word	0x08014c28
 8008d54:	08014c30 	.word	0x08014c30
 8008d58:	08014c38 	.word	0x08014c38

08008d5c <SDCARD_ReadBegin>:

    USER_SDCARD_Unselect();
    return 0;
}

int SDCARD_ReadBegin(uint32_t blockNum) {
 8008d5c:	b580      	push	{r7, lr}
 8008d5e:	b084      	sub	sp, #16
 8008d60:	af00      	add	r7, sp, #0
 8008d62:	6078      	str	r0, [r7, #4]
		//==========================
			if (!USER_SDCARD_isAvailable())
 8008d64:	f002 fc4a 	bl	800b5fc <USER_SDCARD_isAvailable>
 8008d68:	4603      	mov	r3, r0
 8008d6a:	2b00      	cmp	r3, #0
 8008d6c:	d102      	bne.n	8008d74 <SDCARD_ReadBegin+0x18>
				return -29;
 8008d6e:	f06f 031c 	mvn.w	r3, #28
 8008d72:	e031      	b.n	8008dd8 <SDCARD_ReadBegin+0x7c>
		//==========================
    USER_SDCARD_Select();
 8008d74:	f002 fc24 	bl	800b5c0 <USER_SDCARD_Select>

    if(SDCARD_WaitNotBusy() < 0) { // keep this!
 8008d78:	f7ff feae 	bl	8008ad8 <SDCARD_WaitNotBusy>
 8008d7c:	4603      	mov	r3, r0
 8008d7e:	2b00      	cmp	r3, #0
 8008d80:	da04      	bge.n	8008d8c <SDCARD_ReadBegin+0x30>
        USER_SDCARD_Unselect();
 8008d82:	f002 fc2c 	bl	800b5de <USER_SDCARD_Unselect>
        return -1;
 8008d86:	f04f 33ff 	mov.w	r3, #4294967295
 8008d8a:	e025      	b.n	8008dd8 <SDCARD_ReadBegin+0x7c>
    }

    /* CMD18 (READ_MULTIPLE_BLOCK) command */
    uint8_t cmd[] = {
 8008d8c:	2352      	movs	r3, #82	; 0x52
 8008d8e:	723b      	strb	r3, [r7, #8]
        0x40 | 0x12 /* CMD18 */,
        (blockNum >> 24) & 0xFF, /* ARG */
 8008d90:	687b      	ldr	r3, [r7, #4]
 8008d92:	0e1b      	lsrs	r3, r3, #24
    uint8_t cmd[] = {
 8008d94:	b2db      	uxtb	r3, r3
 8008d96:	727b      	strb	r3, [r7, #9]
        (blockNum >> 16) & 0xFF,
 8008d98:	687b      	ldr	r3, [r7, #4]
 8008d9a:	0c1b      	lsrs	r3, r3, #16
    uint8_t cmd[] = {
 8008d9c:	b2db      	uxtb	r3, r3
 8008d9e:	72bb      	strb	r3, [r7, #10]
        (blockNum >> 8) & 0xFF,
 8008da0:	687b      	ldr	r3, [r7, #4]
 8008da2:	0a1b      	lsrs	r3, r3, #8
    uint8_t cmd[] = {
 8008da4:	b2db      	uxtb	r3, r3
 8008da6:	72fb      	strb	r3, [r7, #11]
 8008da8:	687b      	ldr	r3, [r7, #4]
 8008daa:	b2db      	uxtb	r3, r3
 8008dac:	733b      	strb	r3, [r7, #12]
 8008dae:	23ff      	movs	r3, #255	; 0xff
 8008db0:	737b      	strb	r3, [r7, #13]
        blockNum & 0xFF,
        (0x7F << 1) | 1 /* CRC7 + end bit */
    };
    USER_SPI_Transmit((uint8_t*)cmd, sizeof(cmd));
 8008db2:	f107 0308 	add.w	r3, r7, #8
 8008db6:	2106      	movs	r1, #6
 8008db8:	4618      	mov	r0, r3
 8008dba:	f002 fbaf 	bl	800b51c <USER_SPI_Transmit>

    if(SDCARD_ReadR1() != 0x00) {
 8008dbe:	f7ff fe07 	bl	80089d0 <SDCARD_ReadR1>
 8008dc2:	4603      	mov	r3, r0
 8008dc4:	2b00      	cmp	r3, #0
 8008dc6:	d004      	beq.n	8008dd2 <SDCARD_ReadBegin+0x76>
        USER_SDCARD_Unselect();
 8008dc8:	f002 fc09 	bl	800b5de <USER_SDCARD_Unselect>
        return -2;
 8008dcc:	f06f 0301 	mvn.w	r3, #1
 8008dd0:	e002      	b.n	8008dd8 <SDCARD_ReadBegin+0x7c>
    }

    USER_SDCARD_Unselect();
 8008dd2:	f002 fc04 	bl	800b5de <USER_SDCARD_Unselect>
    return 0;
 8008dd6:	2300      	movs	r3, #0
}
 8008dd8:	4618      	mov	r0, r3
 8008dda:	3710      	adds	r7, #16
 8008ddc:	46bd      	mov	sp, r7
 8008dde:	bd80      	pop	{r7, pc}

08008de0 <SDCARD_ReadData>:

int SDCARD_ReadData(uint8_t* buff) {
 8008de0:	b580      	push	{r7, lr}
 8008de2:	b084      	sub	sp, #16
 8008de4:	af00      	add	r7, sp, #0
 8008de6:	6078      	str	r0, [r7, #4]
		//==========================
			if (!USER_SDCARD_isAvailable())
 8008de8:	f002 fc08 	bl	800b5fc <USER_SDCARD_isAvailable>
 8008dec:	4603      	mov	r3, r0
 8008dee:	2b00      	cmp	r3, #0
 8008df0:	d102      	bne.n	8008df8 <SDCARD_ReadData+0x18>
				return -29;
 8008df2:	f06f 031c 	mvn.w	r3, #28
 8008df6:	e02a      	b.n	8008e4e <SDCARD_ReadData+0x6e>
		//==========================
    uint8_t crc[2];
    USER_SDCARD_Select();
 8008df8:	f002 fbe2 	bl	800b5c0 <USER_SDCARD_Select>

    if(SDCARD_WaitDataToken(DATA_TOKEN_CMD18) < 0) {
 8008dfc:	20fe      	movs	r0, #254	; 0xfe
 8008dfe:	f7ff fe11 	bl	8008a24 <SDCARD_WaitDataToken>
 8008e02:	4603      	mov	r3, r0
 8008e04:	2b00      	cmp	r3, #0
 8008e06:	da04      	bge.n	8008e12 <SDCARD_ReadData+0x32>
        USER_SDCARD_Unselect();
 8008e08:	f002 fbe9 	bl	800b5de <USER_SDCARD_Unselect>
        return -1;
 8008e0c:	f04f 33ff 	mov.w	r3, #4294967295
 8008e10:	e01d      	b.n	8008e4e <SDCARD_ReadData+0x6e>
    }

    if(SDCARD_ReadBytes(buff, 512) < 0) {
 8008e12:	f44f 7100 	mov.w	r1, #512	; 0x200
 8008e16:	6878      	ldr	r0, [r7, #4]
 8008e18:	f7ff fe3a 	bl	8008a90 <SDCARD_ReadBytes>
 8008e1c:	4603      	mov	r3, r0
 8008e1e:	2b00      	cmp	r3, #0
 8008e20:	da04      	bge.n	8008e2c <SDCARD_ReadData+0x4c>
        USER_SDCARD_Unselect();
 8008e22:	f002 fbdc 	bl	800b5de <USER_SDCARD_Unselect>
        return -2;
 8008e26:	f06f 0301 	mvn.w	r3, #1
 8008e2a:	e010      	b.n	8008e4e <SDCARD_ReadData+0x6e>
    }

    if(SDCARD_ReadBytes(crc, 2) < 0) {
 8008e2c:	f107 030c 	add.w	r3, r7, #12
 8008e30:	2102      	movs	r1, #2
 8008e32:	4618      	mov	r0, r3
 8008e34:	f7ff fe2c 	bl	8008a90 <SDCARD_ReadBytes>
 8008e38:	4603      	mov	r3, r0
 8008e3a:	2b00      	cmp	r3, #0
 8008e3c:	da04      	bge.n	8008e48 <SDCARD_ReadData+0x68>
        USER_SDCARD_Unselect();
 8008e3e:	f002 fbce 	bl	800b5de <USER_SDCARD_Unselect>
        return -3;
 8008e42:	f06f 0302 	mvn.w	r3, #2
 8008e46:	e002      	b.n	8008e4e <SDCARD_ReadData+0x6e>
    }

    USER_SDCARD_Unselect();
 8008e48:	f002 fbc9 	bl	800b5de <USER_SDCARD_Unselect>
    return 0;
 8008e4c:	2300      	movs	r3, #0

}
 8008e4e:	4618      	mov	r0, r3
 8008e50:	3710      	adds	r7, #16
 8008e52:	46bd      	mov	sp, r7
 8008e54:	bd80      	pop	{r7, pc}
	...

08008e58 <SDCARD_ReadEnd>:

int SDCARD_ReadEnd() {
 8008e58:	b580      	push	{r7, lr}
 8008e5a:	b082      	sub	sp, #8
 8008e5c:	af00      	add	r7, sp, #0
		//==========================
			if (!USER_SDCARD_isAvailable())
 8008e5e:	f002 fbcd 	bl	800b5fc <USER_SDCARD_isAvailable>
 8008e62:	4603      	mov	r3, r0
 8008e64:	2b00      	cmp	r3, #0
 8008e66:	d102      	bne.n	8008e6e <SDCARD_ReadEnd+0x16>
				return -29;
 8008e68:	f06f 031c 	mvn.w	r3, #28
 8008e6c:	e027      	b.n	8008ebe <SDCARD_ReadEnd+0x66>
		//==========================
    USER_SDCARD_Select();
 8008e6e:	f002 fba7 	bl	800b5c0 <USER_SDCARD_Select>

    /* CMD12 (STOP_TRANSMISSION) */
    {
        /*static const*/ uint8_t cmd[] = { 0x40 | 0x0C /* CMD12 */, 0x00, 0x00, 0x00, 0x00 /* ARG */, (0x7F << 1) | 1 };
 8008e72:	4a15      	ldr	r2, [pc, #84]	; (8008ec8 <SDCARD_ReadEnd+0x70>)
 8008e74:	463b      	mov	r3, r7
 8008e76:	e892 0003 	ldmia.w	r2, {r0, r1}
 8008e7a:	6018      	str	r0, [r3, #0]
 8008e7c:	3304      	adds	r3, #4
 8008e7e:	8019      	strh	r1, [r3, #0]
        USER_SPI_Transmit((uint8_t*)cmd, sizeof(cmd));
 8008e80:	463b      	mov	r3, r7
 8008e82:	2106      	movs	r1, #6
 8008e84:	4618      	mov	r0, r3
 8008e86:	f002 fb49 	bl	800b51c <USER_SPI_Transmit>
    /*
    The received byte immediataly following CMD12 is a stuff byte, it should be
    discarded before receive the response of the CMD12
    */
    uint8_t stuffByte;
    if(SDCARD_ReadBytes(&stuffByte, sizeof(stuffByte)) < 0) {
 8008e8a:	1dfb      	adds	r3, r7, #7
 8008e8c:	2101      	movs	r1, #1
 8008e8e:	4618      	mov	r0, r3
 8008e90:	f7ff fdfe 	bl	8008a90 <SDCARD_ReadBytes>
 8008e94:	4603      	mov	r3, r0
 8008e96:	2b00      	cmp	r3, #0
 8008e98:	da04      	bge.n	8008ea4 <SDCARD_ReadEnd+0x4c>
        USER_SDCARD_Unselect();
 8008e9a:	f002 fba0 	bl	800b5de <USER_SDCARD_Unselect>
        return -1;
 8008e9e:	f04f 33ff 	mov.w	r3, #4294967295
 8008ea2:	e00c      	b.n	8008ebe <SDCARD_ReadEnd+0x66>
    }

    if(SDCARD_ReadR1() != 0x00) {
 8008ea4:	f7ff fd94 	bl	80089d0 <SDCARD_ReadR1>
 8008ea8:	4603      	mov	r3, r0
 8008eaa:	2b00      	cmp	r3, #0
 8008eac:	d004      	beq.n	8008eb8 <SDCARD_ReadEnd+0x60>
        USER_SDCARD_Unselect();
 8008eae:	f002 fb96 	bl	800b5de <USER_SDCARD_Unselect>
        return -2;
 8008eb2:	f06f 0301 	mvn.w	r3, #1
 8008eb6:	e002      	b.n	8008ebe <SDCARD_ReadEnd+0x66>
    }
    
    USER_SDCARD_Unselect();
 8008eb8:	f002 fb91 	bl	800b5de <USER_SDCARD_Unselect>
    return 0;
 8008ebc:	2300      	movs	r3, #0
}
 8008ebe:	4618      	mov	r0, r3
 8008ec0:	3708      	adds	r7, #8
 8008ec2:	46bd      	mov	sp, r7
 8008ec4:	bd80      	pop	{r7, pc}
 8008ec6:	bf00      	nop
 8008ec8:	08014c48 	.word	0x08014c48

08008ecc <SDCARD_WriteBegin>:


int SDCARD_WriteBegin(uint32_t blockNum) {
 8008ecc:	b580      	push	{r7, lr}
 8008ece:	b084      	sub	sp, #16
 8008ed0:	af00      	add	r7, sp, #0
 8008ed2:	6078      	str	r0, [r7, #4]
		//==========================
			if (!USER_SDCARD_isAvailable())
 8008ed4:	f002 fb92 	bl	800b5fc <USER_SDCARD_isAvailable>
 8008ed8:	4603      	mov	r3, r0
 8008eda:	2b00      	cmp	r3, #0
 8008edc:	d102      	bne.n	8008ee4 <SDCARD_WriteBegin+0x18>
				return -29;
 8008ede:	f06f 031c 	mvn.w	r3, #28
 8008ee2:	e031      	b.n	8008f48 <SDCARD_WriteBegin+0x7c>
		//==========================
    USER_SDCARD_Select();
 8008ee4:	f002 fb6c 	bl	800b5c0 <USER_SDCARD_Select>

    if(SDCARD_WaitNotBusy() < 0) { // keep this!
 8008ee8:	f7ff fdf6 	bl	8008ad8 <SDCARD_WaitNotBusy>
 8008eec:	4603      	mov	r3, r0
 8008eee:	2b00      	cmp	r3, #0
 8008ef0:	da04      	bge.n	8008efc <SDCARD_WriteBegin+0x30>
        USER_SDCARD_Unselect();
 8008ef2:	f002 fb74 	bl	800b5de <USER_SDCARD_Unselect>
        return -1;
 8008ef6:	f04f 33ff 	mov.w	r3, #4294967295
 8008efa:	e025      	b.n	8008f48 <SDCARD_WriteBegin+0x7c>
    }

    /* CMD25 (WRITE_MULTIPLE_BLOCK) command */
    uint8_t cmd[] = {
 8008efc:	2359      	movs	r3, #89	; 0x59
 8008efe:	723b      	strb	r3, [r7, #8]
        0x40 | 0x19 /* CMD25 */,
        (blockNum >> 24) & 0xFF, /* ARG */
 8008f00:	687b      	ldr	r3, [r7, #4]
 8008f02:	0e1b      	lsrs	r3, r3, #24
    uint8_t cmd[] = {
 8008f04:	b2db      	uxtb	r3, r3
 8008f06:	727b      	strb	r3, [r7, #9]
        (blockNum >> 16) & 0xFF,
 8008f08:	687b      	ldr	r3, [r7, #4]
 8008f0a:	0c1b      	lsrs	r3, r3, #16
    uint8_t cmd[] = {
 8008f0c:	b2db      	uxtb	r3, r3
 8008f0e:	72bb      	strb	r3, [r7, #10]
        (blockNum >> 8) & 0xFF,
 8008f10:	687b      	ldr	r3, [r7, #4]
 8008f12:	0a1b      	lsrs	r3, r3, #8
    uint8_t cmd[] = {
 8008f14:	b2db      	uxtb	r3, r3
 8008f16:	72fb      	strb	r3, [r7, #11]
 8008f18:	687b      	ldr	r3, [r7, #4]
 8008f1a:	b2db      	uxtb	r3, r3
 8008f1c:	733b      	strb	r3, [r7, #12]
 8008f1e:	23ff      	movs	r3, #255	; 0xff
 8008f20:	737b      	strb	r3, [r7, #13]
        blockNum & 0xFF,
        (0x7F << 1) | 1 /* CRC7 + end bit */
    };
    USER_SPI_Transmit((uint8_t*)cmd, sizeof(cmd));
 8008f22:	f107 0308 	add.w	r3, r7, #8
 8008f26:	2106      	movs	r1, #6
 8008f28:	4618      	mov	r0, r3
 8008f2a:	f002 faf7 	bl	800b51c <USER_SPI_Transmit>

    if(SDCARD_ReadR1() != 0x00) {
 8008f2e:	f7ff fd4f 	bl	80089d0 <SDCARD_ReadR1>
 8008f32:	4603      	mov	r3, r0
 8008f34:	2b00      	cmp	r3, #0
 8008f36:	d004      	beq.n	8008f42 <SDCARD_WriteBegin+0x76>
        USER_SDCARD_Unselect();
 8008f38:	f002 fb51 	bl	800b5de <USER_SDCARD_Unselect>
        return -2;
 8008f3c:	f06f 0301 	mvn.w	r3, #1
 8008f40:	e002      	b.n	8008f48 <SDCARD_WriteBegin+0x7c>
    }

    USER_SDCARD_Unselect();
 8008f42:	f002 fb4c 	bl	800b5de <USER_SDCARD_Unselect>
    return 0;
 8008f46:	2300      	movs	r3, #0
}
 8008f48:	4618      	mov	r0, r3
 8008f4a:	3710      	adds	r7, #16
 8008f4c:	46bd      	mov	sp, r7
 8008f4e:	bd80      	pop	{r7, pc}

08008f50 <SDCARD_WriteData>:

int SDCARD_WriteData(const uint8_t* buff) {
 8008f50:	b580      	push	{r7, lr}
 8008f52:	b084      	sub	sp, #16
 8008f54:	af00      	add	r7, sp, #0
 8008f56:	6078      	str	r0, [r7, #4]
		//==========================
			if (!USER_SDCARD_isAvailable())
 8008f58:	f002 fb50 	bl	800b5fc <USER_SDCARD_isAvailable>
 8008f5c:	4603      	mov	r3, r0
 8008f5e:	2b00      	cmp	r3, #0
 8008f60:	d102      	bne.n	8008f68 <SDCARD_WriteData+0x18>
				return -29;
 8008f62:	f06f 031c 	mvn.w	r3, #28
 8008f66:	e034      	b.n	8008fd2 <SDCARD_WriteData+0x82>
		//==========================
    USER_SDCARD_Select();
 8008f68:	f002 fb2a 	bl	800b5c0 <USER_SDCARD_Select>

    uint8_t dataToken = DATA_TOKEN_CMD25;
 8008f6c:	23fc      	movs	r3, #252	; 0xfc
 8008f6e:	73fb      	strb	r3, [r7, #15]
    uint8_t crc[2] = { 0xFF, 0xFF };
 8008f70:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8008f74:	81bb      	strh	r3, [r7, #12]
    USER_SPI_Transmit(&dataToken, sizeof(dataToken));
 8008f76:	f107 030f 	add.w	r3, r7, #15
 8008f7a:	2101      	movs	r1, #1
 8008f7c:	4618      	mov	r0, r3
 8008f7e:	f002 facd 	bl	800b51c <USER_SPI_Transmit>
    USER_SPI_Transmit((uint8_t*)buff, 512);
 8008f82:	f44f 7100 	mov.w	r1, #512	; 0x200
 8008f86:	6878      	ldr	r0, [r7, #4]
 8008f88:	f002 fac8 	bl	800b51c <USER_SPI_Transmit>
    USER_SPI_Transmit(crc, sizeof(crc));
 8008f8c:	f107 030c 	add.w	r3, r7, #12
 8008f90:	2102      	movs	r1, #2
 8008f92:	4618      	mov	r0, r3
 8008f94:	f002 fac2 	bl	800b51c <USER_SPI_Transmit>
            010 - Data accepted
            101 - Data rejected due to CRC error
            110 - Data rejected due to write error
    */
    uint8_t dataResp;
    SDCARD_ReadBytes(&dataResp, sizeof(dataResp));
 8008f98:	f107 030b 	add.w	r3, r7, #11
 8008f9c:	2101      	movs	r1, #1
 8008f9e:	4618      	mov	r0, r3
 8008fa0:	f7ff fd76 	bl	8008a90 <SDCARD_ReadBytes>
    if((dataResp & 0x1F) != 0x05) { // data rejected
 8008fa4:	7afb      	ldrb	r3, [r7, #11]
 8008fa6:	f003 031f 	and.w	r3, r3, #31
 8008faa:	2b05      	cmp	r3, #5
 8008fac:	d004      	beq.n	8008fb8 <SDCARD_WriteData+0x68>
        USER_SDCARD_Unselect();
 8008fae:	f002 fb16 	bl	800b5de <USER_SDCARD_Unselect>
        return -1;
 8008fb2:	f04f 33ff 	mov.w	r3, #4294967295
 8008fb6:	e00c      	b.n	8008fd2 <SDCARD_WriteData+0x82>
    }

    if(SDCARD_WaitNotBusy() < 0) {
 8008fb8:	f7ff fd8e 	bl	8008ad8 <SDCARD_WaitNotBusy>
 8008fbc:	4603      	mov	r3, r0
 8008fbe:	2b00      	cmp	r3, #0
 8008fc0:	da04      	bge.n	8008fcc <SDCARD_WriteData+0x7c>
        USER_SDCARD_Unselect();
 8008fc2:	f002 fb0c 	bl	800b5de <USER_SDCARD_Unselect>
        return -2;
 8008fc6:	f06f 0301 	mvn.w	r3, #1
 8008fca:	e002      	b.n	8008fd2 <SDCARD_WriteData+0x82>
    }

    USER_SDCARD_Unselect();
 8008fcc:	f002 fb07 	bl	800b5de <USER_SDCARD_Unselect>
    return 0;
 8008fd0:	2300      	movs	r3, #0
}
 8008fd2:	4618      	mov	r0, r3
 8008fd4:	3710      	adds	r7, #16
 8008fd6:	46bd      	mov	sp, r7
 8008fd8:	bd80      	pop	{r7, pc}

08008fda <SDCARD_WriteEnd>:

int SDCARD_WriteEnd() {
 8008fda:	b580      	push	{r7, lr}
 8008fdc:	b082      	sub	sp, #8
 8008fde:	af00      	add	r7, sp, #0
		//==========================
			if (!USER_SDCARD_isAvailable())
 8008fe0:	f002 fb0c 	bl	800b5fc <USER_SDCARD_isAvailable>
 8008fe4:	4603      	mov	r3, r0
 8008fe6:	2b00      	cmp	r3, #0
 8008fe8:	d102      	bne.n	8008ff0 <SDCARD_WriteEnd+0x16>
				return -29;
 8008fea:	f06f 031c 	mvn.w	r3, #28
 8008fee:	e01a      	b.n	8009026 <SDCARD_WriteEnd+0x4c>
		//==========================
    USER_SDCARD_Select();
 8008ff0:	f002 fae6 	bl	800b5c0 <USER_SDCARD_Select>

    uint8_t stopTran = 0xFD; // stop transaction token for CMD25
 8008ff4:	23fd      	movs	r3, #253	; 0xfd
 8008ff6:	71fb      	strb	r3, [r7, #7]
    USER_SPI_Transmit(&stopTran, sizeof(stopTran));
 8008ff8:	1dfb      	adds	r3, r7, #7
 8008ffa:	2101      	movs	r1, #1
 8008ffc:	4618      	mov	r0, r3
 8008ffe:	f002 fa8d 	bl	800b51c <USER_SPI_Transmit>

    // skip one byte before readyng "busy"
    // this is required by the spec and is necessary for some real SD-cards!
    uint8_t skipByte;
    SDCARD_ReadBytes(&skipByte, sizeof(skipByte));
 8009002:	1dbb      	adds	r3, r7, #6
 8009004:	2101      	movs	r1, #1
 8009006:	4618      	mov	r0, r3
 8009008:	f7ff fd42 	bl	8008a90 <SDCARD_ReadBytes>

    if(SDCARD_WaitNotBusy() < 0) {
 800900c:	f7ff fd64 	bl	8008ad8 <SDCARD_WaitNotBusy>
 8009010:	4603      	mov	r3, r0
 8009012:	2b00      	cmp	r3, #0
 8009014:	da04      	bge.n	8009020 <SDCARD_WriteEnd+0x46>
        USER_SDCARD_Unselect();
 8009016:	f002 fae2 	bl	800b5de <USER_SDCARD_Unselect>
        return -1;
 800901a:	f04f 33ff 	mov.w	r3, #4294967295
 800901e:	e002      	b.n	8009026 <SDCARD_WriteEnd+0x4c>
    }

    USER_SDCARD_Unselect();
 8009020:	f002 fadd 	bl	800b5de <USER_SDCARD_Unselect>
    return 0;
 8009024:	2300      	movs	r3, #0
}
 8009026:	4618      	mov	r0, r3
 8009028:	3708      	adds	r7, #8
 800902a:	46bd      	mov	sp, r7
 800902c:	bd80      	pop	{r7, pc}
	...

08009030 <ResponceCmd>:
#include "SequencerTasks.h"

extern uint8_t ad_data[];

static void ResponceCmd(uint16_t cmd, uint8_t cmdResp)
{
 8009030:	b580      	push	{r7, lr}
 8009032:	b084      	sub	sp, #16
 8009034:	af00      	add	r7, sp, #0
 8009036:	4603      	mov	r3, r0
 8009038:	460a      	mov	r2, r1
 800903a:	80fb      	strh	r3, [r7, #6]
 800903c:	4613      	mov	r3, r2
 800903e:	717b      	strb	r3, [r7, #5]
	tBleStatus status;
	if (!sys.rf.isConnected)
 8009040:	4b23      	ldr	r3, [pc, #140]	; (80090d0 <ResponceCmd+0xa0>)
 8009042:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 8009046:	3325      	adds	r3, #37	; 0x25
 8009048:	781b      	ldrb	r3, [r3, #0]
 800904a:	2b00      	cmp	r3, #0
 800904c:	d03b      	beq.n	80090c6 <ResponceCmd+0x96>
		return;
	sys.rf.mcu_p_spcb[0] = cmdResp;
 800904e:	4b20      	ldr	r3, [pc, #128]	; (80090d0 <ResponceCmd+0xa0>)
 8009050:	f503 4384 	add.w	r3, r3, #16896	; 0x4200
 8009054:	3343      	adds	r3, #67	; 0x43
 8009056:	797a      	ldrb	r2, [r7, #5]
 8009058:	701a      	strb	r2, [r3, #0]
	sys.rf.mcu_p_spcb[1] = (uint8_t)((uint16_t)cmd >> 8);
 800905a:	88fb      	ldrh	r3, [r7, #6]
 800905c:	0a1b      	lsrs	r3, r3, #8
 800905e:	b29b      	uxth	r3, r3
 8009060:	b2da      	uxtb	r2, r3
 8009062:	4b1b      	ldr	r3, [pc, #108]	; (80090d0 <ResponceCmd+0xa0>)
 8009064:	f503 4384 	add.w	r3, r3, #16896	; 0x4200
 8009068:	3344      	adds	r3, #68	; 0x44
 800906a:	701a      	strb	r2, [r3, #0]
	sys.rf.mcu_p_spcb[2] = cmd;
 800906c:	88fb      	ldrh	r3, [r7, #6]
 800906e:	b2da      	uxtb	r2, r3
 8009070:	4b17      	ldr	r3, [pc, #92]	; (80090d0 <ResponceCmd+0xa0>)
 8009072:	f503 4384 	add.w	r3, r3, #16896	; 0x4200
 8009076:	3345      	adds	r3, #69	; 0x45
 8009078:	701a      	strb	r2, [r3, #0]
	status = Custom_STM_App_Update_Char(CUSTOM_STM_MCU_P_SPCB, sys.rf.mcu_p_spcb);
 800907a:	4916      	ldr	r1, [pc, #88]	; (80090d4 <ResponceCmd+0xa4>)
 800907c:	2004      	movs	r0, #4
 800907e:	f00b f853 	bl	8014128 <Custom_STM_App_Update_Char>
 8009082:	4603      	mov	r3, r0
 8009084:	73fb      	strb	r3, [r7, #15]
	if (status)
 8009086:	7bfb      	ldrb	r3, [r7, #15]
 8009088:	2b00      	cmp	r3, #0
 800908a:	d01d      	beq.n	80090c8 <ResponceCmd+0x98>
	{
		sys.rf.ErrStatuses[sys.rf.ErrStatusesLen] = status;
 800908c:	4b10      	ldr	r3, [pc, #64]	; (80090d0 <ResponceCmd+0xa0>)
 800908e:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 8009092:	3324      	adds	r3, #36	; 0x24
 8009094:	781b      	ldrb	r3, [r3, #0]
 8009096:	461a      	mov	r2, r3
 8009098:	4b0d      	ldr	r3, [pc, #52]	; (80090d0 <ResponceCmd+0xa0>)
 800909a:	4413      	add	r3, r2
 800909c:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 80090a0:	3325      	adds	r3, #37	; 0x25
 80090a2:	7bfa      	ldrb	r2, [r7, #15]
 80090a4:	701a      	strb	r2, [r3, #0]
		sys.rf.ErrStatusesLen = (sys.rf.ErrStatusesLen + 1) % _RF_ER_STATUSES_MAX_LEN;
 80090a6:	4b0a      	ldr	r3, [pc, #40]	; (80090d0 <ResponceCmd+0xa0>)
 80090a8:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 80090ac:	3324      	adds	r3, #36	; 0x24
 80090ae:	781b      	ldrb	r3, [r3, #0]
 80090b0:	3301      	adds	r3, #1
 80090b2:	b2db      	uxtb	r3, r3
 80090b4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80090b8:	b2da      	uxtb	r2, r3
 80090ba:	4b05      	ldr	r3, [pc, #20]	; (80090d0 <ResponceCmd+0xa0>)
 80090bc:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 80090c0:	3324      	adds	r3, #36	; 0x24
 80090c2:	701a      	strb	r2, [r3, #0]
 80090c4:	e000      	b.n	80090c8 <ResponceCmd+0x98>
		return;
 80090c6:	bf00      	nop
	}
}
 80090c8:	3710      	adds	r7, #16
 80090ca:	46bd      	mov	sp, r7
 80090cc:	bd80      	pop	{r7, pc}
 80090ce:	bf00      	nop
 80090d0:	20001020 	.word	0x20001020
 80090d4:	20005263 	.word	0x20005263

080090d8 <ResponceData>:

static void ResponceData(uint16_t cmd, uint8_t cmdResp)
{
 80090d8:	b580      	push	{r7, lr}
 80090da:	b084      	sub	sp, #16
 80090dc:	af00      	add	r7, sp, #0
 80090de:	4603      	mov	r3, r0
 80090e0:	460a      	mov	r2, r1
 80090e2:	80fb      	strh	r3, [r7, #6]
 80090e4:	4613      	mov	r3, r2
 80090e6:	717b      	strb	r3, [r7, #5]
	tBleStatus status;
	if (!sys.rf.isConnected)
 80090e8:	4b23      	ldr	r3, [pc, #140]	; (8009178 <ResponceData+0xa0>)
 80090ea:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 80090ee:	3325      	adds	r3, #37	; 0x25
 80090f0:	781b      	ldrb	r3, [r3, #0]
 80090f2:	2b00      	cmp	r3, #0
 80090f4:	d03b      	beq.n	800916e <ResponceData+0x96>
		return;
	sys.rf.mcu_p_data[0] = cmdResp;
 80090f6:	4b20      	ldr	r3, [pc, #128]	; (8009178 <ResponceData+0xa0>)
 80090f8:	f503 4384 	add.w	r3, r3, #16896	; 0x4200
 80090fc:	3358      	adds	r3, #88	; 0x58
 80090fe:	797a      	ldrb	r2, [r7, #5]
 8009100:	701a      	strb	r2, [r3, #0]
	sys.rf.mcu_p_data[1] = (uint8_t)((uint16_t)cmd >> 8);
 8009102:	88fb      	ldrh	r3, [r7, #6]
 8009104:	0a1b      	lsrs	r3, r3, #8
 8009106:	b29b      	uxth	r3, r3
 8009108:	b2da      	uxtb	r2, r3
 800910a:	4b1b      	ldr	r3, [pc, #108]	; (8009178 <ResponceData+0xa0>)
 800910c:	f503 4384 	add.w	r3, r3, #16896	; 0x4200
 8009110:	3359      	adds	r3, #89	; 0x59
 8009112:	701a      	strb	r2, [r3, #0]
	sys.rf.mcu_p_data[2] = cmd;
 8009114:	88fb      	ldrh	r3, [r7, #6]
 8009116:	b2da      	uxtb	r2, r3
 8009118:	4b17      	ldr	r3, [pc, #92]	; (8009178 <ResponceData+0xa0>)
 800911a:	f503 4384 	add.w	r3, r3, #16896	; 0x4200
 800911e:	335a      	adds	r3, #90	; 0x5a
 8009120:	701a      	strb	r2, [r3, #0]
	status = Custom_STM_App_Update_Char(CUSTOM_STM_MCU_P_DATA, sys.rf.mcu_p_data);
 8009122:	4916      	ldr	r1, [pc, #88]	; (800917c <ResponceData+0xa4>)
 8009124:	2003      	movs	r0, #3
 8009126:	f00a ffff 	bl	8014128 <Custom_STM_App_Update_Char>
 800912a:	4603      	mov	r3, r0
 800912c:	73fb      	strb	r3, [r7, #15]
	if (status)
 800912e:	7bfb      	ldrb	r3, [r7, #15]
 8009130:	2b00      	cmp	r3, #0
 8009132:	d01d      	beq.n	8009170 <ResponceData+0x98>
	{
		sys.rf.ErrStatuses[sys.rf.ErrStatusesLen] = status;
 8009134:	4b10      	ldr	r3, [pc, #64]	; (8009178 <ResponceData+0xa0>)
 8009136:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 800913a:	3324      	adds	r3, #36	; 0x24
 800913c:	781b      	ldrb	r3, [r3, #0]
 800913e:	461a      	mov	r2, r3
 8009140:	4b0d      	ldr	r3, [pc, #52]	; (8009178 <ResponceData+0xa0>)
 8009142:	4413      	add	r3, r2
 8009144:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 8009148:	3325      	adds	r3, #37	; 0x25
 800914a:	7bfa      	ldrb	r2, [r7, #15]
 800914c:	701a      	strb	r2, [r3, #0]
		sys.rf.ErrStatusesLen = (sys.rf.ErrStatusesLen + 1) % _RF_ER_STATUSES_MAX_LEN;
 800914e:	4b0a      	ldr	r3, [pc, #40]	; (8009178 <ResponceData+0xa0>)
 8009150:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 8009154:	3324      	adds	r3, #36	; 0x24
 8009156:	781b      	ldrb	r3, [r3, #0]
 8009158:	3301      	adds	r3, #1
 800915a:	b2db      	uxtb	r3, r3
 800915c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8009160:	b2da      	uxtb	r2, r3
 8009162:	4b05      	ldr	r3, [pc, #20]	; (8009178 <ResponceData+0xa0>)
 8009164:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 8009168:	3324      	adds	r3, #36	; 0x24
 800916a:	701a      	strb	r2, [r3, #0]
 800916c:	e000      	b.n	8009170 <ResponceData+0x98>
		return;
 800916e:	bf00      	nop
	}
}
 8009170:	3710      	adds	r7, #16
 8009172:	46bd      	mov	sp, r7
 8009174:	bd80      	pop	{r7, pc}
 8009176:	bf00      	nop
 8009178:	20001020 	.word	0x20001020
 800917c:	20005278 	.word	0x20005278

08009180 <isAcceptableCharValue>:

static uint8_t isAcceptableCharValue(char value)
{
 8009180:	b480      	push	{r7}
 8009182:	b083      	sub	sp, #12
 8009184:	af00      	add	r7, sp, #0
 8009186:	4603      	mov	r3, r0
 8009188:	71fb      	strb	r3, [r7, #7]
	if ((value >= 'a' && value <= 'z') || value == '.')
 800918a:	79fb      	ldrb	r3, [r7, #7]
 800918c:	2b60      	cmp	r3, #96	; 0x60
 800918e:	d902      	bls.n	8009196 <isAcceptableCharValue+0x16>
 8009190:	79fb      	ldrb	r3, [r7, #7]
 8009192:	2b7a      	cmp	r3, #122	; 0x7a
 8009194:	d902      	bls.n	800919c <isAcceptableCharValue+0x1c>
 8009196:	79fb      	ldrb	r3, [r7, #7]
 8009198:	2b2e      	cmp	r3, #46	; 0x2e
 800919a:	d101      	bne.n	80091a0 <isAcceptableCharValue+0x20>
		return 1;
 800919c:	2301      	movs	r3, #1
 800919e:	e018      	b.n	80091d2 <isAcceptableCharValue+0x52>
	if (value >= '0' && value <= '9')
 80091a0:	79fb      	ldrb	r3, [r7, #7]
 80091a2:	2b2f      	cmp	r3, #47	; 0x2f
 80091a4:	d904      	bls.n	80091b0 <isAcceptableCharValue+0x30>
 80091a6:	79fb      	ldrb	r3, [r7, #7]
 80091a8:	2b39      	cmp	r3, #57	; 0x39
 80091aa:	d801      	bhi.n	80091b0 <isAcceptableCharValue+0x30>
		return 1;
 80091ac:	2301      	movs	r3, #1
 80091ae:	e010      	b.n	80091d2 <isAcceptableCharValue+0x52>
	if (value >= 'A' && value <= 'Z')
 80091b0:	79fb      	ldrb	r3, [r7, #7]
 80091b2:	2b40      	cmp	r3, #64	; 0x40
 80091b4:	d904      	bls.n	80091c0 <isAcceptableCharValue+0x40>
 80091b6:	79fb      	ldrb	r3, [r7, #7]
 80091b8:	2b5a      	cmp	r3, #90	; 0x5a
 80091ba:	d801      	bhi.n	80091c0 <isAcceptableCharValue+0x40>
		return 1;
 80091bc:	2301      	movs	r3, #1
 80091be:	e008      	b.n	80091d2 <isAcceptableCharValue+0x52>
	if (value == '_' || value == '-')
 80091c0:	79fb      	ldrb	r3, [r7, #7]
 80091c2:	2b5f      	cmp	r3, #95	; 0x5f
 80091c4:	d002      	beq.n	80091cc <isAcceptableCharValue+0x4c>
 80091c6:	79fb      	ldrb	r3, [r7, #7]
 80091c8:	2b2d      	cmp	r3, #45	; 0x2d
 80091ca:	d101      	bne.n	80091d0 <isAcceptableCharValue+0x50>
		return 1;
 80091cc:	2301      	movs	r3, #1
 80091ce:	e000      	b.n	80091d2 <isAcceptableCharValue+0x52>
	return 0;
 80091d0:	2300      	movs	r3, #0
}
 80091d2:	4618      	mov	r0, r3
 80091d4:	370c      	adds	r7, #12
 80091d6:	46bd      	mov	sp, r7
 80091d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80091dc:	4770      	bx	lr
	...

080091e0 <ST_rf_ProcessFirstCharWrite>:



void ST_rf_ProcessFirstCharWrite (void) // p_mcu_cmd
{
 80091e0:	b580      	push	{r7, lr}
 80091e2:	b08a      	sub	sp, #40	; 0x28
 80091e4:	af00      	add	r7, sp, #0
	if (!sys.rf.isConnected)
 80091e6:	4b90      	ldr	r3, [pc, #576]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 80091e8:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 80091ec:	3325      	adds	r3, #37	; 0x25
 80091ee:	781b      	ldrb	r3, [r3, #0]
 80091f0:	2b00      	cmp	r3, #0
 80091f2:	f000 83e4 	beq.w	80099be <ST_rf_ProcessFirstCharWrite+0x7de>
		return;
	if (sys.rf.p_mcu_cmd_dat[0] != 0xCA && sys.rf.p_mcu_cmd_dat[3] != 0xFE)
 80091f6:	4b8c      	ldr	r3, [pc, #560]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 80091f8:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 80091fc:	3327      	adds	r3, #39	; 0x27
 80091fe:	781b      	ldrb	r3, [r3, #0]
 8009200:	2bca      	cmp	r3, #202	; 0xca
 8009202:	d007      	beq.n	8009214 <ST_rf_ProcessFirstCharWrite+0x34>
 8009204:	4b88      	ldr	r3, [pc, #544]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 8009206:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 800920a:	332a      	adds	r3, #42	; 0x2a
 800920c:	781b      	ldrb	r3, [r3, #0]
 800920e:	2bfe      	cmp	r3, #254	; 0xfe
 8009210:	f040 83d7 	bne.w	80099c2 <ST_rf_ProcessFirstCharWrite+0x7e2>
		return;
	uint16_t cmd = (sys.rf.p_mcu_cmd_dat[1] << 8) + sys.rf.p_mcu_cmd_dat[2];
 8009214:	4b84      	ldr	r3, [pc, #528]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 8009216:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 800921a:	3328      	adds	r3, #40	; 0x28
 800921c:	781b      	ldrb	r3, [r3, #0]
 800921e:	b29b      	uxth	r3, r3
 8009220:	021b      	lsls	r3, r3, #8
 8009222:	b29a      	uxth	r2, r3
 8009224:	4b80      	ldr	r3, [pc, #512]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 8009226:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 800922a:	3329      	adds	r3, #41	; 0x29
 800922c:	781b      	ldrb	r3, [r3, #0]
 800922e:	b29b      	uxth	r3, r3
 8009230:	4413      	add	r3, r2
 8009232:	83fb      	strh	r3, [r7, #30]
	uint16_t i, additionalData, helper;
	switch(cmd)
 8009234:	8bfb      	ldrh	r3, [r7, #30]
 8009236:	3b01      	subs	r3, #1
 8009238:	2b10      	cmp	r3, #16
 800923a:	f200 83ba 	bhi.w	80099b2 <ST_rf_ProcessFirstCharWrite+0x7d2>
 800923e:	a201      	add	r2, pc, #4	; (adr r2, 8009244 <ST_rf_ProcessFirstCharWrite+0x64>)
 8009240:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009244:	08009289 	.word	0x08009289
 8009248:	0800929f 	.word	0x0800929f
 800924c:	080092b5 	.word	0x080092b5
 8009250:	08009309 	.word	0x08009309
 8009254:	08009319 	.word	0x08009319
 8009258:	08009329 	.word	0x08009329
 800925c:	08009377 	.word	0x08009377
 8009260:	0800938d 	.word	0x0800938d
 8009264:	080094e9 	.word	0x080094e9
 8009268:	08009515 	.word	0x08009515
 800926c:	080099b3 	.word	0x080099b3
 8009270:	0800955d 	.word	0x0800955d
 8009274:	080095d1 	.word	0x080095d1
 8009278:	080096af 	.word	0x080096af
 800927c:	0800973b 	.word	0x0800973b
 8009280:	0800979d 	.word	0x0800979d
 8009284:	080097ff 	.word	0x080097ff
	{
	case 0x0001: // start impulse processing
		sys.rad.startComp();
 8009288:	4b67      	ldr	r3, [pc, #412]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 800928a:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 800928e:	3314      	adds	r3, #20
 8009290:	681b      	ldr	r3, [r3, #0]
 8009292:	4798      	blx	r3
		ResponceCmd(0x0001, 0x00);
 8009294:	2100      	movs	r1, #0
 8009296:	2001      	movs	r0, #1
 8009298:	f7ff feca 	bl	8009030 <ResponceCmd>
		break;
 800929c:	e392      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
	case 0x0002: // stop impulse processing
		sys.rad.stopComp();
 800929e:	4b62      	ldr	r3, [pc, #392]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 80092a0:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 80092a4:	3318      	adds	r3, #24
 80092a6:	681b      	ldr	r3, [r3, #0]
 80092a8:	4798      	blx	r3
		ResponceCmd(0x0002, 0x00);
 80092aa:	2100      	movs	r1, #0
 80092ac:	2002      	movs	r0, #2
 80092ae:	f7ff febf 	bl	8009030 <ResponceCmd>
		break;
 80092b2:	e387      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
	case 0x0003: // save spectrogram on uSD
		if (sys.fs._isInitialized)
 80092b4:	4b5c      	ldr	r3, [pc, #368]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 80092b6:	781b      	ldrb	r3, [r3, #0]
 80092b8:	2b00      	cmp	r3, #0
 80092ba:	d00b      	beq.n	80092d4 <ST_rf_ProcessFirstCharWrite+0xf4>
		{
			sys.fs.saveRadInfo_csv("test.csv", sys.rad._spectrogram, 4096);
 80092bc:	4b5a      	ldr	r3, [pc, #360]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 80092be:	68db      	ldr	r3, [r3, #12]
 80092c0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80092c4:	4959      	ldr	r1, [pc, #356]	; (800942c <ST_rf_ProcessFirstCharWrite+0x24c>)
 80092c6:	485a      	ldr	r0, [pc, #360]	; (8009430 <ST_rf_ProcessFirstCharWrite+0x250>)
 80092c8:	4798      	blx	r3
			ResponceCmd(0x0003, 0x00);
 80092ca:	2100      	movs	r1, #0
 80092cc:	2003      	movs	r0, #3
 80092ce:	f7ff feaf 	bl	8009030 <ResponceCmd>
			}
			else
				ResponceCmd(0x0003, 0x01);
		}

		break;
 80092d2:	e377      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
			sys.fs.initialize("", 0);
 80092d4:	4b54      	ldr	r3, [pc, #336]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 80092d6:	689b      	ldr	r3, [r3, #8]
 80092d8:	2100      	movs	r1, #0
 80092da:	4856      	ldr	r0, [pc, #344]	; (8009434 <ST_rf_ProcessFirstCharWrite+0x254>)
 80092dc:	4798      	blx	r3
			if (sys.fs._isInitialized)
 80092de:	4b52      	ldr	r3, [pc, #328]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 80092e0:	781b      	ldrb	r3, [r3, #0]
 80092e2:	2b00      	cmp	r3, #0
 80092e4:	d00b      	beq.n	80092fe <ST_rf_ProcessFirstCharWrite+0x11e>
				sys.fs.saveRadInfo_csv("test.csv", sys.rad._spectrogram, 4096);
 80092e6:	4b50      	ldr	r3, [pc, #320]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 80092e8:	68db      	ldr	r3, [r3, #12]
 80092ea:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80092ee:	494f      	ldr	r1, [pc, #316]	; (800942c <ST_rf_ProcessFirstCharWrite+0x24c>)
 80092f0:	484f      	ldr	r0, [pc, #316]	; (8009430 <ST_rf_ProcessFirstCharWrite+0x250>)
 80092f2:	4798      	blx	r3
				ResponceCmd(0x0003, 0x00);
 80092f4:	2100      	movs	r1, #0
 80092f6:	2003      	movs	r0, #3
 80092f8:	f7ff fe9a 	bl	8009030 <ResponceCmd>
		break;
 80092fc:	e362      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
				ResponceCmd(0x0003, 0x01);
 80092fe:	2101      	movs	r1, #1
 8009300:	2003      	movs	r0, #3
 8009302:	f7ff fe95 	bl	8009030 <ResponceCmd>
		break;
 8009306:	e35d      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
	case 0x0004: // start sending CPS value
		sys.tim2.turnOn();
 8009308:	4b47      	ldr	r3, [pc, #284]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 800930a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800930c:	4798      	blx	r3
		ResponceCmd(0x0004, 0x00);
 800930e:	2100      	movs	r1, #0
 8009310:	2004      	movs	r0, #4
 8009312:	f7ff fe8d 	bl	8009030 <ResponceCmd>
		break;
 8009316:	e355      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
	case 0x0005: // stop sending CPS value
		sys.tim2.turnOff();
 8009318:	4b43      	ldr	r3, [pc, #268]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 800931a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800931c:	4798      	blx	r3
		ResponceCmd(0x0005, 0x00);
 800931e:	2100      	movs	r1, #0
 8009320:	2005      	movs	r0, #5
 8009322:	f7ff fe85 	bl	8009030 <ResponceCmd>
		break;
 8009326:	e34d      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
	case 0x0006: // fs initialization
		if (sys.uSD.isAvailable())
 8009328:	4b3f      	ldr	r3, [pc, #252]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 800932a:	699b      	ldr	r3, [r3, #24]
 800932c:	4798      	blx	r3
 800932e:	4603      	mov	r3, r0
 8009330:	2b00      	cmp	r3, #0
 8009332:	d01b      	beq.n	800936c <ST_rf_ProcessFirstCharWrite+0x18c>
		{
			if (!sys.fs._isInitialized)
 8009334:	4b3c      	ldr	r3, [pc, #240]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 8009336:	781b      	ldrb	r3, [r3, #0]
 8009338:	2b00      	cmp	r3, #0
 800933a:	d112      	bne.n	8009362 <ST_rf_ProcessFirstCharWrite+0x182>
			{
				sys.fs.initialize("", 0);
 800933c:	4b3a      	ldr	r3, [pc, #232]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 800933e:	689b      	ldr	r3, [r3, #8]
 8009340:	2100      	movs	r1, #0
 8009342:	483c      	ldr	r0, [pc, #240]	; (8009434 <ST_rf_ProcessFirstCharWrite+0x254>)
 8009344:	4798      	blx	r3
				if (sys.fs._isInitialized)
 8009346:	4b38      	ldr	r3, [pc, #224]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 8009348:	781b      	ldrb	r3, [r3, #0]
 800934a:	2b00      	cmp	r3, #0
 800934c:	d004      	beq.n	8009358 <ST_rf_ProcessFirstCharWrite+0x178>
					ResponceCmd(0x0006, 0x00);
 800934e:	2100      	movs	r1, #0
 8009350:	2006      	movs	r0, #6
 8009352:	f7ff fe6d 	bl	8009030 <ResponceCmd>
			else
				ResponceCmd(0x0006, 0x02);
		}
		else
			ResponceCmd(0x0006, 0x01);
		break;
 8009356:	e335      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
					ResponceCmd(0x0006, 0x03);
 8009358:	2103      	movs	r1, #3
 800935a:	2006      	movs	r0, #6
 800935c:	f7ff fe68 	bl	8009030 <ResponceCmd>
		break;
 8009360:	e330      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
				ResponceCmd(0x0006, 0x02);
 8009362:	2102      	movs	r1, #2
 8009364:	2006      	movs	r0, #6
 8009366:	f7ff fe63 	bl	8009030 <ResponceCmd>
		break;
 800936a:	e32b      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
			ResponceCmd(0x0006, 0x01);
 800936c:	2101      	movs	r1, #1
 800936e:	2006      	movs	r0, #6
 8009370:	f7ff fe5e 	bl	8009030 <ResponceCmd>
		break;
 8009374:	e326      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
	case 0x0007:
		GPIOB->ODR ^= GPIO_ODR_OD1;
 8009376:	4b30      	ldr	r3, [pc, #192]	; (8009438 <ST_rf_ProcessFirstCharWrite+0x258>)
 8009378:	695b      	ldr	r3, [r3, #20]
 800937a:	4a2f      	ldr	r2, [pc, #188]	; (8009438 <ST_rf_ProcessFirstCharWrite+0x258>)
 800937c:	f083 0302 	eor.w	r3, r3, #2
 8009380:	6153      	str	r3, [r2, #20]
		ResponceCmd(0x0007, 0x00);
 8009382:	2100      	movs	r1, #0
 8009384:	2007      	movs	r0, #7
 8009386:	f7ff fe53 	bl	8009030 <ResponceCmd>
		break;
 800938a:	e31b      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
	case 0x0008: // get 20 values from spectrogram
		additionalData = (sys.rf.p_mcu_cmd_dat[4] << 8) + sys.rf.p_mcu_cmd_dat[5];
 800938c:	4b26      	ldr	r3, [pc, #152]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 800938e:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 8009392:	332b      	adds	r3, #43	; 0x2b
 8009394:	781b      	ldrb	r3, [r3, #0]
 8009396:	b29b      	uxth	r3, r3
 8009398:	021b      	lsls	r3, r3, #8
 800939a:	b29a      	uxth	r2, r3
 800939c:	4b22      	ldr	r3, [pc, #136]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 800939e:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 80093a2:	332c      	adds	r3, #44	; 0x2c
 80093a4:	781b      	ldrb	r3, [r3, #0]
 80093a6:	b29b      	uxth	r3, r3
 80093a8:	4413      	add	r3, r2
 80093aa:	80fb      	strh	r3, [r7, #6]

		if (additionalData > 4095)
 80093ac:	88fb      	ldrh	r3, [r7, #6]
 80093ae:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80093b2:	d304      	bcc.n	80093be <ST_rf_ProcessFirstCharWrite+0x1de>
		{
			ResponceData(0x0008, 0x01);
 80093b4:	2101      	movs	r1, #1
 80093b6:	2008      	movs	r0, #8
 80093b8:	f7ff fe8e 	bl	80090d8 <ResponceData>
			break;
 80093bc:	e302      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
		}
		helper = additionalData + 20;
 80093be:	88fb      	ldrh	r3, [r7, #6]
 80093c0:	3314      	adds	r3, #20
 80093c2:	84bb      	strh	r3, [r7, #36]	; 0x24
		if (helper > 4096)
 80093c4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80093c6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80093ca:	d902      	bls.n	80093d2 <ST_rf_ProcessFirstCharWrite+0x1f2>
			helper = 4096;
 80093cc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80093d0:	84bb      	strh	r3, [r7, #36]	; 0x24

		sys.rf.mcu_p_data[3] = ((uint16_t)additionalData >> 8);
 80093d2:	88fb      	ldrh	r3, [r7, #6]
 80093d4:	0a1b      	lsrs	r3, r3, #8
 80093d6:	b29b      	uxth	r3, r3
 80093d8:	b2da      	uxtb	r2, r3
 80093da:	4b13      	ldr	r3, [pc, #76]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 80093dc:	f503 4384 	add.w	r3, r3, #16896	; 0x4200
 80093e0:	335b      	adds	r3, #91	; 0x5b
 80093e2:	701a      	strb	r2, [r3, #0]
		sys.rf.mcu_p_data[4] = additionalData;
 80093e4:	88fb      	ldrh	r3, [r7, #6]
 80093e6:	b2da      	uxtb	r2, r3
 80093e8:	4b0f      	ldr	r3, [pc, #60]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 80093ea:	f503 4384 	add.w	r3, r3, #16896	; 0x4200
 80093ee:	335c      	adds	r3, #92	; 0x5c
 80093f0:	701a      	strb	r2, [r3, #0]
		sys.rf.mcu_p_data[5] = ((uint16_t)(helper - additionalData) >> 8);
 80093f2:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 80093f4:	88fb      	ldrh	r3, [r7, #6]
 80093f6:	1ad3      	subs	r3, r2, r3
 80093f8:	b29b      	uxth	r3, r3
 80093fa:	0a1b      	lsrs	r3, r3, #8
 80093fc:	b29b      	uxth	r3, r3
 80093fe:	b2da      	uxtb	r2, r3
 8009400:	4b09      	ldr	r3, [pc, #36]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 8009402:	f503 4384 	add.w	r3, r3, #16896	; 0x4200
 8009406:	335d      	adds	r3, #93	; 0x5d
 8009408:	701a      	strb	r2, [r3, #0]
		sys.rf.mcu_p_data[6] = ((uint16_t)(helper - additionalData));
 800940a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800940c:	b2da      	uxtb	r2, r3
 800940e:	88fb      	ldrh	r3, [r7, #6]
 8009410:	b2db      	uxtb	r3, r3
 8009412:	1ad3      	subs	r3, r2, r3
 8009414:	b2da      	uxtb	r2, r3
 8009416:	4b04      	ldr	r3, [pc, #16]	; (8009428 <ST_rf_ProcessFirstCharWrite+0x248>)
 8009418:	f503 4384 	add.w	r3, r3, #16896	; 0x4200
 800941c:	335e      	adds	r3, #94	; 0x5e
 800941e:	701a      	strb	r2, [r3, #0]

		for (i = additionalData; i < helper; i++)
 8009420:	88fb      	ldrh	r3, [r7, #6]
 8009422:	84fb      	strh	r3, [r7, #38]	; 0x26
 8009424:	e057      	b.n	80094d6 <ST_rf_ProcessFirstCharWrite+0x2f6>
 8009426:	bf00      	nop
 8009428:	20001020 	.word	0x20001020
 800942c:	200010ac 	.word	0x200010ac
 8009430:	08014c50 	.word	0x08014c50
 8009434:	08014c5c 	.word	0x08014c5c
 8009438:	48000400 	.word	0x48000400
		{
			uint16_t j = 7 + (i - additionalData) * 4;
 800943c:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800943e:	88fb      	ldrh	r3, [r7, #6]
 8009440:	1ad3      	subs	r3, r2, r3
 8009442:	b29b      	uxth	r3, r3
 8009444:	009b      	lsls	r3, r3, #2
 8009446:	b29b      	uxth	r3, r3
 8009448:	3307      	adds	r3, #7
 800944a:	80bb      	strh	r3, [r7, #4]
			sys.rf.mcu_p_data[j] = (sys.rad._spectrogram[i] >> 24);
 800944c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800944e:	4aa6      	ldr	r2, [pc, #664]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 8009450:	3322      	adds	r3, #34	; 0x22
 8009452:	009b      	lsls	r3, r3, #2
 8009454:	4413      	add	r3, r2
 8009456:	685b      	ldr	r3, [r3, #4]
 8009458:	0e1a      	lsrs	r2, r3, #24
 800945a:	88bb      	ldrh	r3, [r7, #4]
 800945c:	b2d1      	uxtb	r1, r2
 800945e:	4aa2      	ldr	r2, [pc, #648]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 8009460:	4413      	add	r3, r2
 8009462:	f503 4384 	add.w	r3, r3, #16896	; 0x4200
 8009466:	3358      	adds	r3, #88	; 0x58
 8009468:	460a      	mov	r2, r1
 800946a:	701a      	strb	r2, [r3, #0]
			sys.rf.mcu_p_data[j + 1] = (sys.rad._spectrogram[i] >> 16);
 800946c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800946e:	4a9e      	ldr	r2, [pc, #632]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 8009470:	3322      	adds	r3, #34	; 0x22
 8009472:	009b      	lsls	r3, r3, #2
 8009474:	4413      	add	r3, r2
 8009476:	685b      	ldr	r3, [r3, #4]
 8009478:	0c1a      	lsrs	r2, r3, #16
 800947a:	88bb      	ldrh	r3, [r7, #4]
 800947c:	3301      	adds	r3, #1
 800947e:	b2d1      	uxtb	r1, r2
 8009480:	4a99      	ldr	r2, [pc, #612]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 8009482:	4413      	add	r3, r2
 8009484:	f503 4384 	add.w	r3, r3, #16896	; 0x4200
 8009488:	3358      	adds	r3, #88	; 0x58
 800948a:	460a      	mov	r2, r1
 800948c:	701a      	strb	r2, [r3, #0]
			sys.rf.mcu_p_data[j + 2] = (sys.rad._spectrogram[i] >> 8);
 800948e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8009490:	4a95      	ldr	r2, [pc, #596]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 8009492:	3322      	adds	r3, #34	; 0x22
 8009494:	009b      	lsls	r3, r3, #2
 8009496:	4413      	add	r3, r2
 8009498:	685b      	ldr	r3, [r3, #4]
 800949a:	0a1a      	lsrs	r2, r3, #8
 800949c:	88bb      	ldrh	r3, [r7, #4]
 800949e:	3302      	adds	r3, #2
 80094a0:	b2d1      	uxtb	r1, r2
 80094a2:	4a91      	ldr	r2, [pc, #580]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 80094a4:	4413      	add	r3, r2
 80094a6:	f503 4384 	add.w	r3, r3, #16896	; 0x4200
 80094aa:	3358      	adds	r3, #88	; 0x58
 80094ac:	460a      	mov	r2, r1
 80094ae:	701a      	strb	r2, [r3, #0]
			sys.rf.mcu_p_data[j + 3] = sys.rad._spectrogram[i];
 80094b0:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80094b2:	4a8d      	ldr	r2, [pc, #564]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 80094b4:	3322      	adds	r3, #34	; 0x22
 80094b6:	009b      	lsls	r3, r3, #2
 80094b8:	4413      	add	r3, r2
 80094ba:	685a      	ldr	r2, [r3, #4]
 80094bc:	88bb      	ldrh	r3, [r7, #4]
 80094be:	3303      	adds	r3, #3
 80094c0:	b2d1      	uxtb	r1, r2
 80094c2:	4a89      	ldr	r2, [pc, #548]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 80094c4:	4413      	add	r3, r2
 80094c6:	f503 4384 	add.w	r3, r3, #16896	; 0x4200
 80094ca:	3358      	adds	r3, #88	; 0x58
 80094cc:	460a      	mov	r2, r1
 80094ce:	701a      	strb	r2, [r3, #0]
		for (i = additionalData; i < helper; i++)
 80094d0:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80094d2:	3301      	adds	r3, #1
 80094d4:	84fb      	strh	r3, [r7, #38]	; 0x26
 80094d6:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 80094d8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80094da:	429a      	cmp	r2, r3
 80094dc:	d3ae      	bcc.n	800943c <ST_rf_ProcessFirstCharWrite+0x25c>
		}
		ResponceData(0x0008, 0x00);
 80094de:	2100      	movs	r1, #0
 80094e0:	2008      	movs	r0, #8
 80094e2:	f7ff fdf9 	bl	80090d8 <ResponceData>
		break;
 80094e6:	e26d      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
	case 0x0009: // clear spectrogram
		for (i = 0; i < 4096; i++)
 80094e8:	2300      	movs	r3, #0
 80094ea:	84fb      	strh	r3, [r7, #38]	; 0x26
 80094ec:	e009      	b.n	8009502 <ST_rf_ProcessFirstCharWrite+0x322>
			sys.rad._spectrogram[i] = 0;
 80094ee:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80094f0:	4a7d      	ldr	r2, [pc, #500]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 80094f2:	3322      	adds	r3, #34	; 0x22
 80094f4:	009b      	lsls	r3, r3, #2
 80094f6:	4413      	add	r3, r2
 80094f8:	2200      	movs	r2, #0
 80094fa:	605a      	str	r2, [r3, #4]
		for (i = 0; i < 4096; i++)
 80094fc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80094fe:	3301      	adds	r3, #1
 8009500:	84fb      	strh	r3, [r7, #38]	; 0x26
 8009502:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8009504:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8009508:	d3f1      	bcc.n	80094ee <ST_rf_ProcessFirstCharWrite+0x30e>
		ResponceCmd(0x0009, 0x00);
 800950a:	2100      	movs	r1, #0
 800950c:	2009      	movs	r0, #9
 800950e:	f7ff fd8f 	bl	8009030 <ResponceCmd>
		break;
 8009512:	e257      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
	case 0x000A: // set time between cps writings
		helper = (sys.rf.p_mcu_cmd_dat[4] << 8) + sys.rf.p_mcu_cmd_dat[5];
 8009514:	4b74      	ldr	r3, [pc, #464]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 8009516:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 800951a:	332b      	adds	r3, #43	; 0x2b
 800951c:	781b      	ldrb	r3, [r3, #0]
 800951e:	b29b      	uxth	r3, r3
 8009520:	021b      	lsls	r3, r3, #8
 8009522:	b29a      	uxth	r2, r3
 8009524:	4b70      	ldr	r3, [pc, #448]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 8009526:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 800952a:	332c      	adds	r3, #44	; 0x2c
 800952c:	781b      	ldrb	r3, [r3, #0]
 800952e:	b29b      	uxth	r3, r3
 8009530:	4413      	add	r3, r2
 8009532:	84bb      	strh	r3, [r7, #36]	; 0x24
		if (helper < 50)
 8009534:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8009536:	2b31      	cmp	r3, #49	; 0x31
 8009538:	d806      	bhi.n	8009548 <ST_rf_ProcessFirstCharWrite+0x368>
		{
			helper = 50;
 800953a:	2332      	movs	r3, #50	; 0x32
 800953c:	84bb      	strh	r3, [r7, #36]	; 0x24
			ResponceCmd(0x000A, 0x01);
 800953e:	2101      	movs	r1, #1
 8009540:	200a      	movs	r0, #10
 8009542:	f7ff fd75 	bl	8009030 <ResponceCmd>
 8009546:	e003      	b.n	8009550 <ST_rf_ProcessFirstCharWrite+0x370>
		}
		else
			ResponceCmd(0x000A, 0x00);
 8009548:	2100      	movs	r1, #0
 800954a:	200a      	movs	r0, #10
 800954c:	f7ff fd70 	bl	8009030 <ResponceCmd>
		sys.tim2.setTime(helper);
 8009550:	4b65      	ldr	r3, [pc, #404]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 8009552:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009554:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8009556:	4610      	mov	r0, r2
 8009558:	4798      	blx	r3
		break;
 800955a:	e233      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
	case 0x000C: // set measurement time in minutes
		{
			uint32_t measurementTime = ((uint32_t)sys.rf.p_mcu_cmd_dat[4] << 24) + ((uint32_t)sys.rf.p_mcu_cmd_dat[5] << 16) +
 800955c:	4b62      	ldr	r3, [pc, #392]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 800955e:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 8009562:	332b      	adds	r3, #43	; 0x2b
 8009564:	781b      	ldrb	r3, [r3, #0]
 8009566:	061a      	lsls	r2, r3, #24
 8009568:	4b5f      	ldr	r3, [pc, #380]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 800956a:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 800956e:	332c      	adds	r3, #44	; 0x2c
 8009570:	781b      	ldrb	r3, [r3, #0]
 8009572:	041b      	lsls	r3, r3, #16
 8009574:	441a      	add	r2, r3
					((uint32_t)sys.rf.p_mcu_cmd_dat[6] << 8) + sys.rf.p_mcu_cmd_dat[7];
 8009576:	4b5c      	ldr	r3, [pc, #368]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 8009578:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 800957c:	332d      	adds	r3, #45	; 0x2d
 800957e:	781b      	ldrb	r3, [r3, #0]
 8009580:	021b      	lsls	r3, r3, #8
			uint32_t measurementTime = ((uint32_t)sys.rf.p_mcu_cmd_dat[4] << 24) + ((uint32_t)sys.rf.p_mcu_cmd_dat[5] << 16) +
 8009582:	441a      	add	r2, r3
					((uint32_t)sys.rf.p_mcu_cmd_dat[6] << 8) + sys.rf.p_mcu_cmd_dat[7];
 8009584:	4b58      	ldr	r3, [pc, #352]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 8009586:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 800958a:	332e      	adds	r3, #46	; 0x2e
 800958c:	781b      	ldrb	r3, [r3, #0]
			uint32_t measurementTime = ((uint32_t)sys.rf.p_mcu_cmd_dat[4] << 24) + ((uint32_t)sys.rf.p_mcu_cmd_dat[5] << 16) +
 800958e:	4413      	add	r3, r2
 8009590:	60bb      	str	r3, [r7, #8]
			measurementTime *= 60;
 8009592:	68ba      	ldr	r2, [r7, #8]
 8009594:	4613      	mov	r3, r2
 8009596:	011b      	lsls	r3, r3, #4
 8009598:	1a9b      	subs	r3, r3, r2
 800959a:	009b      	lsls	r3, r3, #2
 800959c:	60bb      	str	r3, [r7, #8]
			if (measurementTime == 0)
 800959e:	68bb      	ldr	r3, [r7, #8]
 80095a0:	2b00      	cmp	r3, #0
 80095a2:	d107      	bne.n	80095b4 <ST_rf_ProcessFirstCharWrite+0x3d4>
				sys.rad._saveTime = 0xFFFFFFFF;
 80095a4:	4b50      	ldr	r3, [pc, #320]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 80095a6:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 80095aa:	3310      	adds	r3, #16
 80095ac:	f04f 32ff 	mov.w	r2, #4294967295
 80095b0:	601a      	str	r2, [r3, #0]
 80095b2:	e008      	b.n	80095c6 <ST_rf_ProcessFirstCharWrite+0x3e6>
			else
				sys.rad._saveTime = sys.tim17.globalSystemTimeSec + measurementTime;
 80095b4:	4b4c      	ldr	r3, [pc, #304]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 80095b6:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80095b8:	68bb      	ldr	r3, [r7, #8]
 80095ba:	441a      	add	r2, r3
 80095bc:	4b4a      	ldr	r3, [pc, #296]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 80095be:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 80095c2:	3310      	adds	r3, #16
 80095c4:	601a      	str	r2, [r3, #0]
			ResponceCmd(0x000C, 0x00);
 80095c6:	2100      	movs	r1, #0
 80095c8:	200c      	movs	r0, #12
 80095ca:	f7ff fd31 	bl	8009030 <ResponceCmd>
		}
		break;
 80095ce:	e1f9      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
	case 0x000D: // set device number
		{
			char c1 = sys.rf.p_mcu_cmd_dat[4];
 80095d0:	4b45      	ldr	r3, [pc, #276]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 80095d2:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 80095d6:	332b      	adds	r3, #43	; 0x2b
 80095d8:	781b      	ldrb	r3, [r3, #0]
 80095da:	737b      	strb	r3, [r7, #13]
			char c2 = sys.rf.p_mcu_cmd_dat[5];
 80095dc:	4b42      	ldr	r3, [pc, #264]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 80095de:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 80095e2:	332c      	adds	r3, #44	; 0x2c
 80095e4:	781b      	ldrb	r3, [r3, #0]
 80095e6:	733b      	strb	r3, [r7, #12]
			if (!((c1 >= '0' && c1 <= '9') || (c1 >= 'a' && c1 <= 'z') || (c1 >= 'A' && c1 <= 'Z')))
 80095e8:	7b7b      	ldrb	r3, [r7, #13]
 80095ea:	2b2f      	cmp	r3, #47	; 0x2f
 80095ec:	d902      	bls.n	80095f4 <ST_rf_ProcessFirstCharWrite+0x414>
 80095ee:	7b7b      	ldrb	r3, [r7, #13]
 80095f0:	2b39      	cmp	r3, #57	; 0x39
 80095f2:	d910      	bls.n	8009616 <ST_rf_ProcessFirstCharWrite+0x436>
 80095f4:	7b7b      	ldrb	r3, [r7, #13]
 80095f6:	2b60      	cmp	r3, #96	; 0x60
 80095f8:	d902      	bls.n	8009600 <ST_rf_ProcessFirstCharWrite+0x420>
 80095fa:	7b7b      	ldrb	r3, [r7, #13]
 80095fc:	2b7a      	cmp	r3, #122	; 0x7a
 80095fe:	d90a      	bls.n	8009616 <ST_rf_ProcessFirstCharWrite+0x436>
 8009600:	7b7b      	ldrb	r3, [r7, #13]
 8009602:	2b40      	cmp	r3, #64	; 0x40
 8009604:	d902      	bls.n	800960c <ST_rf_ProcessFirstCharWrite+0x42c>
 8009606:	7b7b      	ldrb	r3, [r7, #13]
 8009608:	2b5a      	cmp	r3, #90	; 0x5a
 800960a:	d904      	bls.n	8009616 <ST_rf_ProcessFirstCharWrite+0x436>
			{
				ResponceCmd(0x000D, 0x01);
 800960c:	2101      	movs	r1, #1
 800960e:	200d      	movs	r0, #13
 8009610:	f7ff fd0e 	bl	8009030 <ResponceCmd>
				return;
 8009614:	e1d6      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
			}
			if (!((c2 >= '0' && c2 <= '9') || (c2 >= 'a' && c2 <= 'z') || (c2 >= 'A' && c2 <= 'Z')))
 8009616:	7b3b      	ldrb	r3, [r7, #12]
 8009618:	2b2f      	cmp	r3, #47	; 0x2f
 800961a:	d902      	bls.n	8009622 <ST_rf_ProcessFirstCharWrite+0x442>
 800961c:	7b3b      	ldrb	r3, [r7, #12]
 800961e:	2b39      	cmp	r3, #57	; 0x39
 8009620:	d910      	bls.n	8009644 <ST_rf_ProcessFirstCharWrite+0x464>
 8009622:	7b3b      	ldrb	r3, [r7, #12]
 8009624:	2b60      	cmp	r3, #96	; 0x60
 8009626:	d902      	bls.n	800962e <ST_rf_ProcessFirstCharWrite+0x44e>
 8009628:	7b3b      	ldrb	r3, [r7, #12]
 800962a:	2b7a      	cmp	r3, #122	; 0x7a
 800962c:	d90a      	bls.n	8009644 <ST_rf_ProcessFirstCharWrite+0x464>
 800962e:	7b3b      	ldrb	r3, [r7, #12]
 8009630:	2b40      	cmp	r3, #64	; 0x40
 8009632:	d902      	bls.n	800963a <ST_rf_ProcessFirstCharWrite+0x45a>
 8009634:	7b3b      	ldrb	r3, [r7, #12]
 8009636:	2b5a      	cmp	r3, #90	; 0x5a
 8009638:	d904      	bls.n	8009644 <ST_rf_ProcessFirstCharWrite+0x464>
			{
				ResponceCmd(0x000D, 0x01);
 800963a:	2101      	movs	r1, #1
 800963c:	200d      	movs	r0, #13
 800963e:	f7ff fcf7 	bl	8009030 <ResponceCmd>
				return;
 8009642:	e1bf      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
			}
			ad_data[8] = sys.settings.deviceNumber[0] = c1;
 8009644:	4b28      	ldr	r3, [pc, #160]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 8009646:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 800964a:	3364      	adds	r3, #100	; 0x64
 800964c:	7b7a      	ldrb	r2, [r7, #13]
 800964e:	701a      	strb	r2, [r3, #0]
 8009650:	4b25      	ldr	r3, [pc, #148]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 8009652:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 8009656:	3364      	adds	r3, #100	; 0x64
 8009658:	781a      	ldrb	r2, [r3, #0]
 800965a:	4b24      	ldr	r3, [pc, #144]	; (80096ec <ST_rf_ProcessFirstCharWrite+0x50c>)
 800965c:	721a      	strb	r2, [r3, #8]
			ad_data[9] = sys.settings.deviceNumber[1] = c2;
 800965e:	4b22      	ldr	r3, [pc, #136]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 8009660:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 8009664:	3365      	adds	r3, #101	; 0x65
 8009666:	7b3a      	ldrb	r2, [r7, #12]
 8009668:	701a      	strb	r2, [r3, #0]
 800966a:	4b1f      	ldr	r3, [pc, #124]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 800966c:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 8009670:	3365      	adds	r3, #101	; 0x65
 8009672:	781a      	ldrb	r2, [r3, #0]
 8009674:	4b1d      	ldr	r3, [pc, #116]	; (80096ec <ST_rf_ProcessFirstCharWrite+0x50c>)
 8009676:	725a      	strb	r2, [r3, #9]
			if (!sys.fs._isInitialized)
 8009678:	4b1b      	ldr	r3, [pc, #108]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 800967a:	781b      	ldrb	r3, [r3, #0]
 800967c:	2b00      	cmp	r3, #0
 800967e:	d104      	bne.n	800968a <ST_rf_ProcessFirstCharWrite+0x4aa>
				sys.fs.initialize("", 0);
 8009680:	4b19      	ldr	r3, [pc, #100]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 8009682:	689b      	ldr	r3, [r3, #8]
 8009684:	2100      	movs	r1, #0
 8009686:	481a      	ldr	r0, [pc, #104]	; (80096f0 <ST_rf_ProcessFirstCharWrite+0x510>)
 8009688:	4798      	blx	r3
			if (sys.fs._isInitialized)
 800968a:	4b17      	ldr	r3, [pc, #92]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 800968c:	781b      	ldrb	r3, [r3, #0]
 800968e:	2b00      	cmp	r3, #0
 8009690:	d008      	beq.n	80096a4 <ST_rf_ProcessFirstCharWrite+0x4c4>
			{
				sys.fs.saveSystemSettingsInfo(&sys.settings);
 8009692:	4b15      	ldr	r3, [pc, #84]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 8009694:	695b      	ldr	r3, [r3, #20]
 8009696:	4817      	ldr	r0, [pc, #92]	; (80096f4 <ST_rf_ProcessFirstCharWrite+0x514>)
 8009698:	4798      	blx	r3
				ResponceCmd(0x000D, 0x00);
 800969a:	2100      	movs	r1, #0
 800969c:	200d      	movs	r0, #13
 800969e:	f7ff fcc7 	bl	8009030 <ResponceCmd>
			}
			else
				ResponceCmd(0x000D, 0x02);

		}
		break;
 80096a2:	e18f      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
				ResponceCmd(0x000D, 0x02);
 80096a4:	2102      	movs	r1, #2
 80096a6:	200d      	movs	r0, #13
 80096a8:	f7ff fcc2 	bl	8009030 <ResponceCmd>
		break;
 80096ac:	e18a      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
	case 0x000E:
		{ // set dma buffer size
			uint16_t val = ((uint16_t)sys.rf.p_mcu_cmd_dat[4] << 8) + sys.rf.p_mcu_cmd_dat[5];
 80096ae:	4b0e      	ldr	r3, [pc, #56]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 80096b0:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 80096b4:	332b      	adds	r3, #43	; 0x2b
 80096b6:	781b      	ldrb	r3, [r3, #0]
 80096b8:	b29b      	uxth	r3, r3
 80096ba:	021b      	lsls	r3, r3, #8
 80096bc:	b29a      	uxth	r2, r3
 80096be:	4b0a      	ldr	r3, [pc, #40]	; (80096e8 <ST_rf_ProcessFirstCharWrite+0x508>)
 80096c0:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 80096c4:	332c      	adds	r3, #44	; 0x2c
 80096c6:	781b      	ldrb	r3, [r3, #0]
 80096c8:	b29b      	uxth	r3, r3
 80096ca:	4413      	add	r3, r2
 80096cc:	81fb      	strh	r3, [r7, #14]
			if (val < 5 || val > 1000)
 80096ce:	89fb      	ldrh	r3, [r7, #14]
 80096d0:	2b04      	cmp	r3, #4
 80096d2:	d903      	bls.n	80096dc <ST_rf_ProcessFirstCharWrite+0x4fc>
 80096d4:	89fb      	ldrh	r3, [r7, #14]
 80096d6:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80096da:	d90d      	bls.n	80096f8 <ST_rf_ProcessFirstCharWrite+0x518>
			{
				ResponceCmd(0x000E, 0x01);
 80096dc:	2101      	movs	r1, #1
 80096de:	200e      	movs	r0, #14
 80096e0:	f7ff fca6 	bl	8009030 <ResponceCmd>
				return;
 80096e4:	e16e      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
 80096e6:	bf00      	nop
 80096e8:	20001020 	.word	0x20001020
 80096ec:	20000010 	.word	0x20000010
 80096f0:	08014c5c 	.word	0x08014c5c
 80096f4:	20005384 	.word	0x20005384
			}
			if (!sys.fs._isInitialized)
 80096f8:	4b6f      	ldr	r3, [pc, #444]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 80096fa:	781b      	ldrb	r3, [r3, #0]
 80096fc:	2b00      	cmp	r3, #0
 80096fe:	d104      	bne.n	800970a <ST_rf_ProcessFirstCharWrite+0x52a>
				sys.fs.initialize("", 0);
 8009700:	4b6d      	ldr	r3, [pc, #436]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 8009702:	689b      	ldr	r3, [r3, #8]
 8009704:	2100      	movs	r1, #0
 8009706:	486d      	ldr	r0, [pc, #436]	; (80098bc <ST_rf_ProcessFirstCharWrite+0x6dc>)
 8009708:	4798      	blx	r3
			if (sys.fs._isInitialized)
 800970a:	4b6b      	ldr	r3, [pc, #428]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 800970c:	781b      	ldrb	r3, [r3, #0]
 800970e:	2b00      	cmp	r3, #0
 8009710:	d00e      	beq.n	8009730 <ST_rf_ProcessFirstCharWrite+0x550>
			{
				sys.settings.countsToDma = val;
 8009712:	4b69      	ldr	r3, [pc, #420]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 8009714:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 8009718:	3366      	adds	r3, #102	; 0x66
 800971a:	89fa      	ldrh	r2, [r7, #14]
 800971c:	801a      	strh	r2, [r3, #0]
				sys.fs.saveSystemSettingsInfo(&sys.settings);
 800971e:	4b66      	ldr	r3, [pc, #408]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 8009720:	695b      	ldr	r3, [r3, #20]
 8009722:	4867      	ldr	r0, [pc, #412]	; (80098c0 <ST_rf_ProcessFirstCharWrite+0x6e0>)
 8009724:	4798      	blx	r3
				ResponceCmd(0x000E, 0x00);
 8009726:	2100      	movs	r1, #0
 8009728:	200e      	movs	r0, #14
 800972a:	f7ff fc81 	bl	8009030 <ResponceCmd>
			}
			else
				ResponceCmd(0x000E, 0x02);
		}
		break;
 800972e:	e149      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
				ResponceCmd(0x000E, 0x02);
 8009730:	2102      	movs	r1, #2
 8009732:	200e      	movs	r0, #14
 8009734:	f7ff fc7c 	bl	8009030 <ResponceCmd>
		break;
 8009738:	e144      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
	case 0x000F:
		{ // set min filtration value
			uint16_t val = ((uint16_t)sys.rf.p_mcu_cmd_dat[4] << 8) + sys.rf.p_mcu_cmd_dat[5];
 800973a:	4b5f      	ldr	r3, [pc, #380]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 800973c:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 8009740:	332b      	adds	r3, #43	; 0x2b
 8009742:	781b      	ldrb	r3, [r3, #0]
 8009744:	b29b      	uxth	r3, r3
 8009746:	021b      	lsls	r3, r3, #8
 8009748:	b29a      	uxth	r2, r3
 800974a:	4b5b      	ldr	r3, [pc, #364]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 800974c:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 8009750:	332c      	adds	r3, #44	; 0x2c
 8009752:	781b      	ldrb	r3, [r3, #0]
 8009754:	b29b      	uxth	r3, r3
 8009756:	4413      	add	r3, r2
 8009758:	823b      	strh	r3, [r7, #16]
			sys.settings.minValueFiltration = val;
 800975a:	4b57      	ldr	r3, [pc, #348]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 800975c:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 8009760:	3368      	adds	r3, #104	; 0x68
 8009762:	8a3a      	ldrh	r2, [r7, #16]
 8009764:	801a      	strh	r2, [r3, #0]
			if (!sys.fs._isInitialized)
 8009766:	4b54      	ldr	r3, [pc, #336]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 8009768:	781b      	ldrb	r3, [r3, #0]
 800976a:	2b00      	cmp	r3, #0
 800976c:	d104      	bne.n	8009778 <ST_rf_ProcessFirstCharWrite+0x598>
				sys.fs.initialize("", 0);
 800976e:	4b52      	ldr	r3, [pc, #328]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 8009770:	689b      	ldr	r3, [r3, #8]
 8009772:	2100      	movs	r1, #0
 8009774:	4851      	ldr	r0, [pc, #324]	; (80098bc <ST_rf_ProcessFirstCharWrite+0x6dc>)
 8009776:	4798      	blx	r3
			if (sys.fs._isInitialized)
 8009778:	4b4f      	ldr	r3, [pc, #316]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 800977a:	781b      	ldrb	r3, [r3, #0]
 800977c:	2b00      	cmp	r3, #0
 800977e:	d008      	beq.n	8009792 <ST_rf_ProcessFirstCharWrite+0x5b2>
			{
				sys.fs.saveSystemSettingsInfo(&sys.settings);
 8009780:	4b4d      	ldr	r3, [pc, #308]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 8009782:	695b      	ldr	r3, [r3, #20]
 8009784:	484e      	ldr	r0, [pc, #312]	; (80098c0 <ST_rf_ProcessFirstCharWrite+0x6e0>)
 8009786:	4798      	blx	r3
				ResponceCmd(0x000F, 0x00);
 8009788:	2100      	movs	r1, #0
 800978a:	200f      	movs	r0, #15
 800978c:	f7ff fc50 	bl	8009030 <ResponceCmd>
			}
			else
				ResponceCmd(0x000F, 0x01);
		}
		break;
 8009790:	e118      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
				ResponceCmd(0x000F, 0x01);
 8009792:	2101      	movs	r1, #1
 8009794:	200f      	movs	r0, #15
 8009796:	f7ff fc4b 	bl	8009030 <ResponceCmd>
		break;
 800979a:	e113      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
	case 0x0010:
		{ // set max filtration value
			uint16_t val = ((uint16_t)sys.rf.p_mcu_cmd_dat[4] << 8) + sys.rf.p_mcu_cmd_dat[5];
 800979c:	4b46      	ldr	r3, [pc, #280]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 800979e:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 80097a2:	332b      	adds	r3, #43	; 0x2b
 80097a4:	781b      	ldrb	r3, [r3, #0]
 80097a6:	b29b      	uxth	r3, r3
 80097a8:	021b      	lsls	r3, r3, #8
 80097aa:	b29a      	uxth	r2, r3
 80097ac:	4b42      	ldr	r3, [pc, #264]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 80097ae:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 80097b2:	332c      	adds	r3, #44	; 0x2c
 80097b4:	781b      	ldrb	r3, [r3, #0]
 80097b6:	b29b      	uxth	r3, r3
 80097b8:	4413      	add	r3, r2
 80097ba:	827b      	strh	r3, [r7, #18]
			sys.settings.maxValueFiltration = val;
 80097bc:	4b3e      	ldr	r3, [pc, #248]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 80097be:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 80097c2:	336a      	adds	r3, #106	; 0x6a
 80097c4:	8a7a      	ldrh	r2, [r7, #18]
 80097c6:	801a      	strh	r2, [r3, #0]
			if (!sys.fs._isInitialized)
 80097c8:	4b3b      	ldr	r3, [pc, #236]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 80097ca:	781b      	ldrb	r3, [r3, #0]
 80097cc:	2b00      	cmp	r3, #0
 80097ce:	d104      	bne.n	80097da <ST_rf_ProcessFirstCharWrite+0x5fa>
				sys.fs.initialize("", 0);
 80097d0:	4b39      	ldr	r3, [pc, #228]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 80097d2:	689b      	ldr	r3, [r3, #8]
 80097d4:	2100      	movs	r1, #0
 80097d6:	4839      	ldr	r0, [pc, #228]	; (80098bc <ST_rf_ProcessFirstCharWrite+0x6dc>)
 80097d8:	4798      	blx	r3
			if (sys.fs._isInitialized)
 80097da:	4b37      	ldr	r3, [pc, #220]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 80097dc:	781b      	ldrb	r3, [r3, #0]
 80097de:	2b00      	cmp	r3, #0
 80097e0:	d008      	beq.n	80097f4 <ST_rf_ProcessFirstCharWrite+0x614>
			{
				sys.fs.saveSystemSettingsInfo(&sys.settings);
 80097e2:	4b35      	ldr	r3, [pc, #212]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 80097e4:	695b      	ldr	r3, [r3, #20]
 80097e6:	4836      	ldr	r0, [pc, #216]	; (80098c0 <ST_rf_ProcessFirstCharWrite+0x6e0>)
 80097e8:	4798      	blx	r3
				ResponceCmd(0x0010, 0x00);
 80097ea:	2100      	movs	r1, #0
 80097ec:	2010      	movs	r0, #16
 80097ee:	f7ff fc1f 	bl	8009030 <ResponceCmd>
			}
			else
				ResponceCmd(0x0010, 0x01);
		}
		break;
 80097f2:	e0e7      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
				ResponceCmd(0x0010, 0x01);
 80097f4:	2101      	movs	r1, #1
 80097f6:	2010      	movs	r0, #16
 80097f8:	f7ff fc1a 	bl	8009030 <ResponceCmd>
		break;
 80097fc:	e0e2      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
	case 0x0011:
		{ // get device status
			uint32_t flags = 0;
 80097fe:	2300      	movs	r3, #0
 8009800:	623b      	str	r3, [r7, #32]
			if (COMP2->CSR & COMP_CSR_EN) // if impulse processing
 8009802:	4b30      	ldr	r3, [pc, #192]	; (80098c4 <ST_rf_ProcessFirstCharWrite+0x6e4>)
 8009804:	681b      	ldr	r3, [r3, #0]
 8009806:	f003 0301 	and.w	r3, r3, #1
 800980a:	2b00      	cmp	r3, #0
 800980c:	d003      	beq.n	8009816 <ST_rf_ProcessFirstCharWrite+0x636>
				flags |= ((uint32_t)1 << 0);
 800980e:	6a3b      	ldr	r3, [r7, #32]
 8009810:	f043 0301 	orr.w	r3, r3, #1
 8009814:	623b      	str	r3, [r7, #32]
			if (TIM2->CR1 & TIM_CR1_CEN) // if CPS sending
 8009816:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800981a:	681b      	ldr	r3, [r3, #0]
 800981c:	f003 0301 	and.w	r3, r3, #1
 8009820:	2b00      	cmp	r3, #0
 8009822:	d003      	beq.n	800982c <ST_rf_ProcessFirstCharWrite+0x64c>
				flags |= ((uint32_t)1 << 1);
 8009824:	6a3b      	ldr	r3, [r7, #32]
 8009826:	f043 0302 	orr.w	r3, r3, #2
 800982a:	623b      	str	r3, [r7, #32]
			if (sys.uSD.isAvailable()) // if uSD is available
 800982c:	4b22      	ldr	r3, [pc, #136]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 800982e:	699b      	ldr	r3, [r3, #24]
 8009830:	4798      	blx	r3
 8009832:	4603      	mov	r3, r0
 8009834:	2b00      	cmp	r3, #0
 8009836:	d003      	beq.n	8009840 <ST_rf_ProcessFirstCharWrite+0x660>
				flags |= ((uint32_t)1 << 2);
 8009838:	6a3b      	ldr	r3, [r7, #32]
 800983a:	f043 0304 	orr.w	r3, r3, #4
 800983e:	623b      	str	r3, [r7, #32]
			if (sys.fs._isInitialized) // if filesystem is initialized
 8009840:	4b1d      	ldr	r3, [pc, #116]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 8009842:	781b      	ldrb	r3, [r3, #0]
 8009844:	2b00      	cmp	r3, #0
 8009846:	d003      	beq.n	8009850 <ST_rf_ProcessFirstCharWrite+0x670>
				flags |= ((uint32_t)1 << 3);
 8009848:	6a3b      	ldr	r3, [r7, #32]
 800984a:	f043 0308 	orr.w	r3, r3, #8
 800984e:	623b      	str	r3, [r7, #32]
			if (sys.rf.ErrStatusesLen) // if ble has error statuses
 8009850:	4b19      	ldr	r3, [pc, #100]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 8009852:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 8009856:	3324      	adds	r3, #36	; 0x24
 8009858:	781b      	ldrb	r3, [r3, #0]
 800985a:	2b00      	cmp	r3, #0
 800985c:	d003      	beq.n	8009866 <ST_rf_ProcessFirstCharWrite+0x686>
				flags |= ((uint32_t)1 << 4);
 800985e:	6a3b      	ldr	r3, [r7, #32]
 8009860:	f043 0310 	orr.w	r3, r3, #16
 8009864:	623b      	str	r3, [r7, #32]
			if (sys.rad._saveTime != 0xFFFFFFFF) // if timer is set
 8009866:	4b14      	ldr	r3, [pc, #80]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 8009868:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 800986c:	3310      	adds	r3, #16
 800986e:	681b      	ldr	r3, [r3, #0]
 8009870:	f1b3 3fff 	cmp.w	r3, #4294967295
 8009874:	d003      	beq.n	800987e <ST_rf_ProcessFirstCharWrite+0x69e>
				flags |= ((uint32_t)1 << 5);
 8009876:	6a3b      	ldr	r3, [r7, #32]
 8009878:	f043 0320 	orr.w	r3, r3, #32
 800987c:	623b      	str	r3, [r7, #32]
			if (COMP2->CSR & COMP_CSR_VALUE) // comparator value
 800987e:	4b11      	ldr	r3, [pc, #68]	; (80098c4 <ST_rf_ProcessFirstCharWrite+0x6e4>)
 8009880:	681b      	ldr	r3, [r3, #0]
 8009882:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8009886:	2b00      	cmp	r3, #0
 8009888:	d003      	beq.n	8009892 <ST_rf_ProcessFirstCharWrite+0x6b2>
				flags |= ((uint32_t)1 << 6);
 800988a:	6a3b      	ldr	r3, [r7, #32]
 800988c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009890:	623b      	str	r3, [r7, #32]

			uint32_t remainingTime = (flags & (1 << 5))? (sys.rad._saveTime-sys.tim17.globalSystemTimeSec) / 60 : 0; // in minutes
 8009892:	6a3b      	ldr	r3, [r7, #32]
 8009894:	f003 0320 	and.w	r3, r3, #32
 8009898:	2b00      	cmp	r3, #0
 800989a:	d017      	beq.n	80098cc <ST_rf_ProcessFirstCharWrite+0x6ec>
 800989c:	4b06      	ldr	r3, [pc, #24]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 800989e:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 80098a2:	3310      	adds	r3, #16
 80098a4:	681a      	ldr	r2, [r3, #0]
 80098a6:	4b04      	ldr	r3, [pc, #16]	; (80098b8 <ST_rf_ProcessFirstCharWrite+0x6d8>)
 80098a8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80098aa:	1ad3      	subs	r3, r2, r3
 80098ac:	4a06      	ldr	r2, [pc, #24]	; (80098c8 <ST_rf_ProcessFirstCharWrite+0x6e8>)
 80098ae:	fba2 2303 	umull	r2, r3, r2, r3
 80098b2:	095b      	lsrs	r3, r3, #5
 80098b4:	e00b      	b.n	80098ce <ST_rf_ProcessFirstCharWrite+0x6ee>
 80098b6:	bf00      	nop
 80098b8:	20001020 	.word	0x20001020
 80098bc:	08014c5c 	.word	0x08014c5c
 80098c0:	20005384 	.word	0x20005384
 80098c4:	40010204 	.word	0x40010204
 80098c8:	88888889 	.word	0x88888889
 80098cc:	2300      	movs	r3, #0
 80098ce:	61bb      	str	r3, [r7, #24]
			uint8_t *mask = sys.rf.mcu_p_spcb;
 80098d0:	4b3e      	ldr	r3, [pc, #248]	; (80099cc <ST_rf_ProcessFirstCharWrite+0x7ec>)
 80098d2:	617b      	str	r3, [r7, #20]
			mask[3] = ((uint32_t)flags >> 24);
 80098d4:	6a3b      	ldr	r3, [r7, #32]
 80098d6:	0e1a      	lsrs	r2, r3, #24
 80098d8:	697b      	ldr	r3, [r7, #20]
 80098da:	3303      	adds	r3, #3
 80098dc:	b2d2      	uxtb	r2, r2
 80098de:	701a      	strb	r2, [r3, #0]
			mask[4] = ((uint32_t)flags >> 16);
 80098e0:	6a3b      	ldr	r3, [r7, #32]
 80098e2:	0c1a      	lsrs	r2, r3, #16
 80098e4:	697b      	ldr	r3, [r7, #20]
 80098e6:	3304      	adds	r3, #4
 80098e8:	b2d2      	uxtb	r2, r2
 80098ea:	701a      	strb	r2, [r3, #0]
			mask[5] = ((uint32_t)flags >> 8);
 80098ec:	6a3b      	ldr	r3, [r7, #32]
 80098ee:	0a1a      	lsrs	r2, r3, #8
 80098f0:	697b      	ldr	r3, [r7, #20]
 80098f2:	3305      	adds	r3, #5
 80098f4:	b2d2      	uxtb	r2, r2
 80098f6:	701a      	strb	r2, [r3, #0]
			mask[6] = flags;
 80098f8:	697b      	ldr	r3, [r7, #20]
 80098fa:	3306      	adds	r3, #6
 80098fc:	6a3a      	ldr	r2, [r7, #32]
 80098fe:	b2d2      	uxtb	r2, r2
 8009900:	701a      	strb	r2, [r3, #0]
			mask[7] = ((uint32_t)remainingTime >> 24);
 8009902:	69bb      	ldr	r3, [r7, #24]
 8009904:	0e1a      	lsrs	r2, r3, #24
 8009906:	697b      	ldr	r3, [r7, #20]
 8009908:	3307      	adds	r3, #7
 800990a:	b2d2      	uxtb	r2, r2
 800990c:	701a      	strb	r2, [r3, #0]
			mask[8] = ((uint32_t)remainingTime >> 16);
 800990e:	69bb      	ldr	r3, [r7, #24]
 8009910:	0c1a      	lsrs	r2, r3, #16
 8009912:	697b      	ldr	r3, [r7, #20]
 8009914:	3308      	adds	r3, #8
 8009916:	b2d2      	uxtb	r2, r2
 8009918:	701a      	strb	r2, [r3, #0]
			mask[9] = ((uint32_t)remainingTime >> 8);
 800991a:	69bb      	ldr	r3, [r7, #24]
 800991c:	0a1a      	lsrs	r2, r3, #8
 800991e:	697b      	ldr	r3, [r7, #20]
 8009920:	3309      	adds	r3, #9
 8009922:	b2d2      	uxtb	r2, r2
 8009924:	701a      	strb	r2, [r3, #0]
			mask[10] = remainingTime;
 8009926:	697b      	ldr	r3, [r7, #20]
 8009928:	330a      	adds	r3, #10
 800992a:	69ba      	ldr	r2, [r7, #24]
 800992c:	b2d2      	uxtb	r2, r2
 800992e:	701a      	strb	r2, [r3, #0]

			mask[11] = ((uint16_t)sys.settings.countsToDma >> 8);
 8009930:	4b27      	ldr	r3, [pc, #156]	; (80099d0 <ST_rf_ProcessFirstCharWrite+0x7f0>)
 8009932:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 8009936:	3366      	adds	r3, #102	; 0x66
 8009938:	881b      	ldrh	r3, [r3, #0]
 800993a:	0a1b      	lsrs	r3, r3, #8
 800993c:	b29a      	uxth	r2, r3
 800993e:	697b      	ldr	r3, [r7, #20]
 8009940:	330b      	adds	r3, #11
 8009942:	b2d2      	uxtb	r2, r2
 8009944:	701a      	strb	r2, [r3, #0]
			mask[12] = sys.settings.countsToDma;
 8009946:	4b22      	ldr	r3, [pc, #136]	; (80099d0 <ST_rf_ProcessFirstCharWrite+0x7f0>)
 8009948:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 800994c:	3366      	adds	r3, #102	; 0x66
 800994e:	881a      	ldrh	r2, [r3, #0]
 8009950:	697b      	ldr	r3, [r7, #20]
 8009952:	330c      	adds	r3, #12
 8009954:	b2d2      	uxtb	r2, r2
 8009956:	701a      	strb	r2, [r3, #0]

			mask[13] = ((uint16_t)sys.settings.minValueFiltration >> 8);
 8009958:	4b1d      	ldr	r3, [pc, #116]	; (80099d0 <ST_rf_ProcessFirstCharWrite+0x7f0>)
 800995a:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 800995e:	3368      	adds	r3, #104	; 0x68
 8009960:	881b      	ldrh	r3, [r3, #0]
 8009962:	0a1b      	lsrs	r3, r3, #8
 8009964:	b29a      	uxth	r2, r3
 8009966:	697b      	ldr	r3, [r7, #20]
 8009968:	330d      	adds	r3, #13
 800996a:	b2d2      	uxtb	r2, r2
 800996c:	701a      	strb	r2, [r3, #0]
			mask[14] = sys.settings.minValueFiltration;
 800996e:	4b18      	ldr	r3, [pc, #96]	; (80099d0 <ST_rf_ProcessFirstCharWrite+0x7f0>)
 8009970:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 8009974:	3368      	adds	r3, #104	; 0x68
 8009976:	881a      	ldrh	r2, [r3, #0]
 8009978:	697b      	ldr	r3, [r7, #20]
 800997a:	330e      	adds	r3, #14
 800997c:	b2d2      	uxtb	r2, r2
 800997e:	701a      	strb	r2, [r3, #0]

			mask[15] = ((uint16_t)sys.settings.maxValueFiltration >> 8);
 8009980:	4b13      	ldr	r3, [pc, #76]	; (80099d0 <ST_rf_ProcessFirstCharWrite+0x7f0>)
 8009982:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 8009986:	336a      	adds	r3, #106	; 0x6a
 8009988:	881b      	ldrh	r3, [r3, #0]
 800998a:	0a1b      	lsrs	r3, r3, #8
 800998c:	b29a      	uxth	r2, r3
 800998e:	697b      	ldr	r3, [r7, #20]
 8009990:	330f      	adds	r3, #15
 8009992:	b2d2      	uxtb	r2, r2
 8009994:	701a      	strb	r2, [r3, #0]
			mask[16] = sys.settings.maxValueFiltration;
 8009996:	4b0e      	ldr	r3, [pc, #56]	; (80099d0 <ST_rf_ProcessFirstCharWrite+0x7f0>)
 8009998:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 800999c:	336a      	adds	r3, #106	; 0x6a
 800999e:	881a      	ldrh	r2, [r3, #0]
 80099a0:	697b      	ldr	r3, [r7, #20]
 80099a2:	3310      	adds	r3, #16
 80099a4:	b2d2      	uxtb	r2, r2
 80099a6:	701a      	strb	r2, [r3, #0]
			ResponceCmd(0x0011, 0x00);
 80099a8:	2100      	movs	r1, #0
 80099aa:	2011      	movs	r0, #17
 80099ac:	f7ff fb40 	bl	8009030 <ResponceCmd>
		}
		break;
 80099b0:	e008      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
	default:
		ResponceCmd(0xFFFF, 0xAA);
 80099b2:	21aa      	movs	r1, #170	; 0xaa
 80099b4:	f64f 70ff 	movw	r0, #65535	; 0xffff
 80099b8:	f7ff fb3a 	bl	8009030 <ResponceCmd>
 80099bc:	e002      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
		return;
 80099be:	bf00      	nop
 80099c0:	e000      	b.n	80099c4 <ST_rf_ProcessFirstCharWrite+0x7e4>
		return;
 80099c2:	bf00      	nop

	}


	//GPIOB->ODR ^= GPIO_ODR_OD1;
}
 80099c4:	3728      	adds	r7, #40	; 0x28
 80099c6:	46bd      	mov	sp, r7
 80099c8:	bd80      	pop	{r7, pc}
 80099ca:	bf00      	nop
 80099cc:	20005263 	.word	0x20005263
 80099d0:	20001020 	.word	0x20001020

080099d4 <ST_rf_ProcessSecondCharWrite>:

void ST_rf_ProcessSecondCharWrite (void) // p_mcu_data
{
 80099d4:	b580      	push	{r7, lr}
 80099d6:	b082      	sub	sp, #8
 80099d8:	af00      	add	r7, sp, #0
	if (!sys.rf.isConnected)
 80099da:	4b57      	ldr	r3, [pc, #348]	; (8009b38 <ST_rf_ProcessSecondCharWrite+0x164>)
 80099dc:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 80099e0:	3325      	adds	r3, #37	; 0x25
 80099e2:	781b      	ldrb	r3, [r3, #0]
 80099e4:	2b00      	cmp	r3, #0
 80099e6:	f000 80a0 	beq.w	8009b2a <ST_rf_ProcessSecondCharWrite+0x156>
		return;
	if (sys.rf.p_mcu_data_dat[0] != 0xCA && sys.rf.p_mcu_data_dat[3] != 0xFE)
 80099ea:	4b53      	ldr	r3, [pc, #332]	; (8009b38 <ST_rf_ProcessSecondCharWrite+0x164>)
 80099ec:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 80099f0:	333d      	adds	r3, #61	; 0x3d
 80099f2:	781b      	ldrb	r3, [r3, #0]
 80099f4:	2bca      	cmp	r3, #202	; 0xca
 80099f6:	d007      	beq.n	8009a08 <ST_rf_ProcessSecondCharWrite+0x34>
 80099f8:	4b4f      	ldr	r3, [pc, #316]	; (8009b38 <ST_rf_ProcessSecondCharWrite+0x164>)
 80099fa:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 80099fe:	3340      	adds	r3, #64	; 0x40
 8009a00:	781b      	ldrb	r3, [r3, #0]
 8009a02:	2bfe      	cmp	r3, #254	; 0xfe
 8009a04:	f040 8093 	bne.w	8009b2e <ST_rf_ProcessSecondCharWrite+0x15a>
		return;
	uint16_t cmd = (sys.rf.p_mcu_data_dat[1] << 8) + sys.rf.p_mcu_data_dat[2];
 8009a08:	4b4b      	ldr	r3, [pc, #300]	; (8009b38 <ST_rf_ProcessSecondCharWrite+0x164>)
 8009a0a:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 8009a0e:	333e      	adds	r3, #62	; 0x3e
 8009a10:	781b      	ldrb	r3, [r3, #0]
 8009a12:	b29b      	uxth	r3, r3
 8009a14:	021b      	lsls	r3, r3, #8
 8009a16:	b29a      	uxth	r2, r3
 8009a18:	4b47      	ldr	r3, [pc, #284]	; (8009b38 <ST_rf_ProcessSecondCharWrite+0x164>)
 8009a1a:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 8009a1e:	333f      	adds	r3, #63	; 0x3f
 8009a20:	781b      	ldrb	r3, [r3, #0]
 8009a22:	b29b      	uxth	r3, r3
 8009a24:	4413      	add	r3, r2
 8009a26:	80bb      	strh	r3, [r7, #4]
	switch (cmd)
 8009a28:	88bb      	ldrh	r3, [r7, #4]
 8009a2a:	2b0b      	cmp	r3, #11
 8009a2c:	d177      	bne.n	8009b1e <ST_rf_ProcessSecondCharWrite+0x14a>
	{
	case 0x000B:
		{
			uint16_t len = sys.rf.p_mcu_data_dat[4];
 8009a2e:	4b42      	ldr	r3, [pc, #264]	; (8009b38 <ST_rf_ProcessSecondCharWrite+0x164>)
 8009a30:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 8009a34:	3341      	adds	r3, #65	; 0x41
 8009a36:	781b      	ldrb	r3, [r3, #0]
 8009a38:	807b      	strh	r3, [r7, #2]
			static char fileName[70];
			uint16_t i;
			if (len < 5 || len > 64)
 8009a3a:	887b      	ldrh	r3, [r7, #2]
 8009a3c:	2b04      	cmp	r3, #4
 8009a3e:	d902      	bls.n	8009a46 <ST_rf_ProcessSecondCharWrite+0x72>
 8009a40:	887b      	ldrh	r3, [r7, #2]
 8009a42:	2b40      	cmp	r3, #64	; 0x40
 8009a44:	d904      	bls.n	8009a50 <ST_rf_ProcessSecondCharWrite+0x7c>
			{
				ResponceCmd(0x000B, 0x01);
 8009a46:	2101      	movs	r1, #1
 8009a48:	200b      	movs	r0, #11
 8009a4a:	f7ff faf1 	bl	8009030 <ResponceCmd>
				return;
 8009a4e:	e06f      	b.n	8009b30 <ST_rf_ProcessSecondCharWrite+0x15c>
			}
			if (sys.rf.p_mcu_data_dat[5] != '#' && sys.rf.p_mcu_data_dat[6 + len] != '#')
 8009a50:	4b39      	ldr	r3, [pc, #228]	; (8009b38 <ST_rf_ProcessSecondCharWrite+0x164>)
 8009a52:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 8009a56:	3342      	adds	r3, #66	; 0x42
 8009a58:	781b      	ldrb	r3, [r3, #0]
 8009a5a:	2b23      	cmp	r3, #35	; 0x23
 8009a5c:	d00e      	beq.n	8009a7c <ST_rf_ProcessSecondCharWrite+0xa8>
 8009a5e:	887b      	ldrh	r3, [r7, #2]
 8009a60:	3306      	adds	r3, #6
 8009a62:	4a35      	ldr	r2, [pc, #212]	; (8009b38 <ST_rf_ProcessSecondCharWrite+0x164>)
 8009a64:	4413      	add	r3, r2
 8009a66:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 8009a6a:	333d      	adds	r3, #61	; 0x3d
 8009a6c:	781b      	ldrb	r3, [r3, #0]
 8009a6e:	2b23      	cmp	r3, #35	; 0x23
 8009a70:	d004      	beq.n	8009a7c <ST_rf_ProcessSecondCharWrite+0xa8>
			{
				ResponceCmd(0x000B, 0x02);
 8009a72:	2102      	movs	r1, #2
 8009a74:	200b      	movs	r0, #11
 8009a76:	f7ff fadb 	bl	8009030 <ResponceCmd>
				return;
 8009a7a:	e059      	b.n	8009b30 <ST_rf_ProcessSecondCharWrite+0x15c>
			}
			for (i = 0; i < len; i++)
 8009a7c:	2300      	movs	r3, #0
 8009a7e:	80fb      	strh	r3, [r7, #6]
 8009a80:	e01b      	b.n	8009aba <ST_rf_ProcessSecondCharWrite+0xe6>
			{
				fileName[i] = sys.rf.p_mcu_data_dat[6 + i];
 8009a82:	88fb      	ldrh	r3, [r7, #6]
 8009a84:	3306      	adds	r3, #6
 8009a86:	88fa      	ldrh	r2, [r7, #6]
 8009a88:	492b      	ldr	r1, [pc, #172]	; (8009b38 <ST_rf_ProcessSecondCharWrite+0x164>)
 8009a8a:	440b      	add	r3, r1
 8009a8c:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 8009a90:	333d      	adds	r3, #61	; 0x3d
 8009a92:	7819      	ldrb	r1, [r3, #0]
 8009a94:	4b29      	ldr	r3, [pc, #164]	; (8009b3c <ST_rf_ProcessSecondCharWrite+0x168>)
 8009a96:	5499      	strb	r1, [r3, r2]
				if (!isAcceptableCharValue(fileName[i]))
 8009a98:	88fb      	ldrh	r3, [r7, #6]
 8009a9a:	4a28      	ldr	r2, [pc, #160]	; (8009b3c <ST_rf_ProcessSecondCharWrite+0x168>)
 8009a9c:	5cd3      	ldrb	r3, [r2, r3]
 8009a9e:	4618      	mov	r0, r3
 8009aa0:	f7ff fb6e 	bl	8009180 <isAcceptableCharValue>
 8009aa4:	4603      	mov	r3, r0
 8009aa6:	2b00      	cmp	r3, #0
 8009aa8:	d104      	bne.n	8009ab4 <ST_rf_ProcessSecondCharWrite+0xe0>
				{
					ResponceCmd(0x000B, 0x03);
 8009aaa:	2103      	movs	r1, #3
 8009aac:	200b      	movs	r0, #11
 8009aae:	f7ff fabf 	bl	8009030 <ResponceCmd>
					return;
 8009ab2:	e03d      	b.n	8009b30 <ST_rf_ProcessSecondCharWrite+0x15c>
			for (i = 0; i < len; i++)
 8009ab4:	88fb      	ldrh	r3, [r7, #6]
 8009ab6:	3301      	adds	r3, #1
 8009ab8:	80fb      	strh	r3, [r7, #6]
 8009aba:	88fa      	ldrh	r2, [r7, #6]
 8009abc:	887b      	ldrh	r3, [r7, #2]
 8009abe:	429a      	cmp	r2, r3
 8009ac0:	d3df      	bcc.n	8009a82 <ST_rf_ProcessSecondCharWrite+0xae>
				}
			}
			fileName[len] = 0;
 8009ac2:	887b      	ldrh	r3, [r7, #2]
 8009ac4:	4a1d      	ldr	r2, [pc, #116]	; (8009b3c <ST_rf_ProcessSecondCharWrite+0x168>)
 8009ac6:	2100      	movs	r1, #0
 8009ac8:	54d1      	strb	r1, [r2, r3]
			if (sys.fs._isInitialized)
 8009aca:	4b1b      	ldr	r3, [pc, #108]	; (8009b38 <ST_rf_ProcessSecondCharWrite+0x164>)
 8009acc:	781b      	ldrb	r3, [r3, #0]
 8009ace:	2b00      	cmp	r3, #0
 8009ad0:	d00b      	beq.n	8009aea <ST_rf_ProcessSecondCharWrite+0x116>
			{
				sys.fs.saveRadInfo_csv(fileName, sys.rad._spectrogram, 4096);
 8009ad2:	4b19      	ldr	r3, [pc, #100]	; (8009b38 <ST_rf_ProcessSecondCharWrite+0x164>)
 8009ad4:	68db      	ldr	r3, [r3, #12]
 8009ad6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8009ada:	4919      	ldr	r1, [pc, #100]	; (8009b40 <ST_rf_ProcessSecondCharWrite+0x16c>)
 8009adc:	4817      	ldr	r0, [pc, #92]	; (8009b3c <ST_rf_ProcessSecondCharWrite+0x168>)
 8009ade:	4798      	blx	r3
				ResponceCmd(0x000B, 0x00);
 8009ae0:	2100      	movs	r1, #0
 8009ae2:	200b      	movs	r0, #11
 8009ae4:	f7ff faa4 	bl	8009030 <ResponceCmd>
				}
				else
					ResponceCmd(0x000B, 0x04);
			}
		}
		break;
 8009ae8:	e022      	b.n	8009b30 <ST_rf_ProcessSecondCharWrite+0x15c>
				sys.fs.initialize("", 0);
 8009aea:	4b13      	ldr	r3, [pc, #76]	; (8009b38 <ST_rf_ProcessSecondCharWrite+0x164>)
 8009aec:	689b      	ldr	r3, [r3, #8]
 8009aee:	2100      	movs	r1, #0
 8009af0:	4814      	ldr	r0, [pc, #80]	; (8009b44 <ST_rf_ProcessSecondCharWrite+0x170>)
 8009af2:	4798      	blx	r3
				if (sys.fs._isInitialized)
 8009af4:	4b10      	ldr	r3, [pc, #64]	; (8009b38 <ST_rf_ProcessSecondCharWrite+0x164>)
 8009af6:	781b      	ldrb	r3, [r3, #0]
 8009af8:	2b00      	cmp	r3, #0
 8009afa:	d00b      	beq.n	8009b14 <ST_rf_ProcessSecondCharWrite+0x140>
					sys.fs.saveRadInfo_csv(fileName, sys.rad._spectrogram, 4096);
 8009afc:	4b0e      	ldr	r3, [pc, #56]	; (8009b38 <ST_rf_ProcessSecondCharWrite+0x164>)
 8009afe:	68db      	ldr	r3, [r3, #12]
 8009b00:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8009b04:	490e      	ldr	r1, [pc, #56]	; (8009b40 <ST_rf_ProcessSecondCharWrite+0x16c>)
 8009b06:	480d      	ldr	r0, [pc, #52]	; (8009b3c <ST_rf_ProcessSecondCharWrite+0x168>)
 8009b08:	4798      	blx	r3
					ResponceCmd(0x000B, 0x00);
 8009b0a:	2100      	movs	r1, #0
 8009b0c:	200b      	movs	r0, #11
 8009b0e:	f7ff fa8f 	bl	8009030 <ResponceCmd>
		break;
 8009b12:	e00d      	b.n	8009b30 <ST_rf_ProcessSecondCharWrite+0x15c>
					ResponceCmd(0x000B, 0x04);
 8009b14:	2104      	movs	r1, #4
 8009b16:	200b      	movs	r0, #11
 8009b18:	f7ff fa8a 	bl	8009030 <ResponceCmd>
		break;
 8009b1c:	e008      	b.n	8009b30 <ST_rf_ProcessSecondCharWrite+0x15c>

	default:
		ResponceCmd(0xFFFF, 0xAA);
 8009b1e:	21aa      	movs	r1, #170	; 0xaa
 8009b20:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8009b24:	f7ff fa84 	bl	8009030 <ResponceCmd>
 8009b28:	e002      	b.n	8009b30 <ST_rf_ProcessSecondCharWrite+0x15c>
		return;
 8009b2a:	bf00      	nop
 8009b2c:	e000      	b.n	8009b30 <ST_rf_ProcessSecondCharWrite+0x15c>
		return;
 8009b2e:	bf00      	nop
	}

	//GPIOB->ODR ^= GPIO_ODR_OD1;
}
 8009b30:	3708      	adds	r7, #8
 8009b32:	46bd      	mov	sp, r7
 8009b34:	bd80      	pop	{r7, pc}
 8009b36:	bf00      	nop
 8009b38:	20001020 	.word	0x20001020
 8009b3c:	200003c4 	.word	0x200003c4
 8009b40:	200010ac 	.word	0x200010ac
 8009b44:	08014c5c 	.word	0x08014c5c

08009b48 <ST_rf_UpdateCPS>:

void ST_rf_UpdateCPS (void) // mcu_p_cps
{
 8009b48:	b580      	push	{r7, lr}
 8009b4a:	b082      	sub	sp, #8
 8009b4c:	af00      	add	r7, sp, #0
	tBleStatus status;
	if (!sys.rf.isConnected)
 8009b4e:	4b18      	ldr	r3, [pc, #96]	; (8009bb0 <ST_rf_UpdateCPS+0x68>)
 8009b50:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 8009b54:	3325      	adds	r3, #37	; 0x25
 8009b56:	781b      	ldrb	r3, [r3, #0]
 8009b58:	2b00      	cmp	r3, #0
 8009b5a:	d025      	beq.n	8009ba8 <ST_rf_UpdateCPS+0x60>
		return;
	status = Custom_STM_App_Update_Char(CUSTOM_STM_MCU_P_CPS, sys.rf.mcu_p_CPS_dat);
 8009b5c:	4915      	ldr	r1, [pc, #84]	; (8009bb4 <ST_rf_UpdateCPS+0x6c>)
 8009b5e:	2002      	movs	r0, #2
 8009b60:	f00a fae2 	bl	8014128 <Custom_STM_App_Update_Char>
 8009b64:	4603      	mov	r3, r0
 8009b66:	71fb      	strb	r3, [r7, #7]
	if (status)
 8009b68:	79fb      	ldrb	r3, [r7, #7]
 8009b6a:	2b00      	cmp	r3, #0
 8009b6c:	d01d      	beq.n	8009baa <ST_rf_UpdateCPS+0x62>
	{
		sys.rf.ErrStatuses[sys.rf.ErrStatusesLen] = status;
 8009b6e:	4b10      	ldr	r3, [pc, #64]	; (8009bb0 <ST_rf_UpdateCPS+0x68>)
 8009b70:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 8009b74:	3324      	adds	r3, #36	; 0x24
 8009b76:	781b      	ldrb	r3, [r3, #0]
 8009b78:	461a      	mov	r2, r3
 8009b7a:	4b0d      	ldr	r3, [pc, #52]	; (8009bb0 <ST_rf_UpdateCPS+0x68>)
 8009b7c:	4413      	add	r3, r2
 8009b7e:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 8009b82:	3325      	adds	r3, #37	; 0x25
 8009b84:	79fa      	ldrb	r2, [r7, #7]
 8009b86:	701a      	strb	r2, [r3, #0]
		sys.rf.ErrStatusesLen = (sys.rf.ErrStatusesLen + 1) % _RF_ER_STATUSES_MAX_LEN;
 8009b88:	4b09      	ldr	r3, [pc, #36]	; (8009bb0 <ST_rf_UpdateCPS+0x68>)
 8009b8a:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 8009b8e:	3324      	adds	r3, #36	; 0x24
 8009b90:	781b      	ldrb	r3, [r3, #0]
 8009b92:	3301      	adds	r3, #1
 8009b94:	b2db      	uxtb	r3, r3
 8009b96:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8009b9a:	b2da      	uxtb	r2, r3
 8009b9c:	4b04      	ldr	r3, [pc, #16]	; (8009bb0 <ST_rf_UpdateCPS+0x68>)
 8009b9e:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 8009ba2:	3324      	adds	r3, #36	; 0x24
 8009ba4:	701a      	strb	r2, [r3, #0]
 8009ba6:	e000      	b.n	8009baa <ST_rf_UpdateCPS+0x62>
		return;
 8009ba8:	bf00      	nop
	}
}
 8009baa:	3708      	adds	r7, #8
 8009bac:	46bd      	mov	sp, r7
 8009bae:	bd80      	pop	{r7, pc}
 8009bb0:	20001020 	.word	0x20001020
 8009bb4:	20005252 	.word	0x20005252

08009bb8 <ST_fs_Initialize>:

void ST_fs_Initialize (void)
{
 8009bb8:	b580      	push	{r7, lr}
 8009bba:	af00      	add	r7, sp, #0
	//GPIOB->ODR ^= GPIO_ODR_OD1;
	if (sys.uSD.isAvailable())
 8009bbc:	4b06      	ldr	r3, [pc, #24]	; (8009bd8 <ST_fs_Initialize+0x20>)
 8009bbe:	699b      	ldr	r3, [r3, #24]
 8009bc0:	4798      	blx	r3
 8009bc2:	4603      	mov	r3, r0
 8009bc4:	2b00      	cmp	r3, #0
 8009bc6:	d004      	beq.n	8009bd2 <ST_fs_Initialize+0x1a>
		sys.fs.initialize("", 0);
 8009bc8:	4b03      	ldr	r3, [pc, #12]	; (8009bd8 <ST_fs_Initialize+0x20>)
 8009bca:	689b      	ldr	r3, [r3, #8]
 8009bcc:	2100      	movs	r1, #0
 8009bce:	4803      	ldr	r0, [pc, #12]	; (8009bdc <ST_fs_Initialize+0x24>)
 8009bd0:	4798      	blx	r3
}
 8009bd2:	bf00      	nop
 8009bd4:	bd80      	pop	{r7, pc}
 8009bd6:	bf00      	nop
 8009bd8:	20001020 	.word	0x20001020
 8009bdc:	08014c5c 	.word	0x08014c5c

08009be0 <ST_fs_SaveSpectrPostDelayed>:

void ST_fs_SaveSpectrPostDelayed (void)
{
 8009be0:	b580      	push	{r7, lr}
 8009be2:	af00      	add	r7, sp, #0

	if (sys.uSD.isAvailable())
 8009be4:	4b0d      	ldr	r3, [pc, #52]	; (8009c1c <ST_fs_SaveSpectrPostDelayed+0x3c>)
 8009be6:	699b      	ldr	r3, [r3, #24]
 8009be8:	4798      	blx	r3
 8009bea:	4603      	mov	r3, r0
 8009bec:	2b00      	cmp	r3, #0
 8009bee:	d013      	beq.n	8009c18 <ST_fs_SaveSpectrPostDelayed+0x38>
	{
		if (!sys.fs._isInitialized)
 8009bf0:	4b0a      	ldr	r3, [pc, #40]	; (8009c1c <ST_fs_SaveSpectrPostDelayed+0x3c>)
 8009bf2:	781b      	ldrb	r3, [r3, #0]
 8009bf4:	2b00      	cmp	r3, #0
 8009bf6:	d104      	bne.n	8009c02 <ST_fs_SaveSpectrPostDelayed+0x22>
			sys.fs.initialize("", 0);
 8009bf8:	4b08      	ldr	r3, [pc, #32]	; (8009c1c <ST_fs_SaveSpectrPostDelayed+0x3c>)
 8009bfa:	689b      	ldr	r3, [r3, #8]
 8009bfc:	2100      	movs	r1, #0
 8009bfe:	4808      	ldr	r0, [pc, #32]	; (8009c20 <ST_fs_SaveSpectrPostDelayed+0x40>)
 8009c00:	4798      	blx	r3
		if (sys.fs._isInitialized)
 8009c02:	4b06      	ldr	r3, [pc, #24]	; (8009c1c <ST_fs_SaveSpectrPostDelayed+0x3c>)
 8009c04:	781b      	ldrb	r3, [r3, #0]
 8009c06:	2b00      	cmp	r3, #0
 8009c08:	d006      	beq.n	8009c18 <ST_fs_SaveSpectrPostDelayed+0x38>
			sys.fs.saveRadInfo_csv("post_delayed.csv", sys.rad._spectrogram, 4096);
 8009c0a:	4b04      	ldr	r3, [pc, #16]	; (8009c1c <ST_fs_SaveSpectrPostDelayed+0x3c>)
 8009c0c:	68db      	ldr	r3, [r3, #12]
 8009c0e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8009c12:	4904      	ldr	r1, [pc, #16]	; (8009c24 <ST_fs_SaveSpectrPostDelayed+0x44>)
 8009c14:	4804      	ldr	r0, [pc, #16]	; (8009c28 <ST_fs_SaveSpectrPostDelayed+0x48>)
 8009c16:	4798      	blx	r3
	}
}
 8009c18:	bf00      	nop
 8009c1a:	bd80      	pop	{r7, pc}
 8009c1c:	20001020 	.word	0x20001020
 8009c20:	08014c5c 	.word	0x08014c5c
 8009c24:	200010ac 	.word	0x200010ac
 8009c28:	08014c60 	.word	0x08014c60

08009c2c <_adc_dummyDelay>:
#include "main.h"

static uint8_t _adc_dumm = 0;

static void _adc_dummyDelay(void)
{
 8009c2c:	b480      	push	{r7}
 8009c2e:	af00      	add	r7, sp, #0
	++_adc_dumm;
 8009c30:	4b05      	ldr	r3, [pc, #20]	; (8009c48 <_adc_dummyDelay+0x1c>)
 8009c32:	781b      	ldrb	r3, [r3, #0]
 8009c34:	3301      	adds	r3, #1
 8009c36:	b2da      	uxtb	r2, r3
 8009c38:	4b03      	ldr	r3, [pc, #12]	; (8009c48 <_adc_dummyDelay+0x1c>)
 8009c3a:	701a      	strb	r2, [r3, #0]
}
 8009c3c:	bf00      	nop
 8009c3e:	46bd      	mov	sp, r7
 8009c40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009c44:	4770      	bx	lr
 8009c46:	bf00      	nop
 8009c48:	2000040a 	.word	0x2000040a

08009c4c <_adc_enable_adc>:

static void _adc_enable_adc(void)
{
 8009c4c:	b480      	push	{r7}
 8009c4e:	af00      	add	r7, sp, #0
	ADC1->ISR |= ADC_ISR_ADRDY;
 8009c50:	4b0e      	ldr	r3, [pc, #56]	; (8009c8c <_adc_enable_adc+0x40>)
 8009c52:	681b      	ldr	r3, [r3, #0]
 8009c54:	4a0d      	ldr	r2, [pc, #52]	; (8009c8c <_adc_enable_adc+0x40>)
 8009c56:	f043 0301 	orr.w	r3, r3, #1
 8009c5a:	6013      	str	r3, [r2, #0]
	ADC1->CR |= ADC_CR_ADEN;
 8009c5c:	4b0b      	ldr	r3, [pc, #44]	; (8009c8c <_adc_enable_adc+0x40>)
 8009c5e:	689b      	ldr	r3, [r3, #8]
 8009c60:	4a0a      	ldr	r2, [pc, #40]	; (8009c8c <_adc_enable_adc+0x40>)
 8009c62:	f043 0301 	orr.w	r3, r3, #1
 8009c66:	6093      	str	r3, [r2, #8]
	while(!(ADC1->ISR & ADC_ISR_ADRDY));
 8009c68:	bf00      	nop
 8009c6a:	4b08      	ldr	r3, [pc, #32]	; (8009c8c <_adc_enable_adc+0x40>)
 8009c6c:	681b      	ldr	r3, [r3, #0]
 8009c6e:	f003 0301 	and.w	r3, r3, #1
 8009c72:	2b00      	cmp	r3, #0
 8009c74:	d0f9      	beq.n	8009c6a <_adc_enable_adc+0x1e>
	ADC1->ISR |= ADC_ISR_ADRDY;
 8009c76:	4b05      	ldr	r3, [pc, #20]	; (8009c8c <_adc_enable_adc+0x40>)
 8009c78:	681b      	ldr	r3, [r3, #0]
 8009c7a:	4a04      	ldr	r2, [pc, #16]	; (8009c8c <_adc_enable_adc+0x40>)
 8009c7c:	f043 0301 	orr.w	r3, r3, #1
 8009c80:	6013      	str	r3, [r2, #0]
}
 8009c82:	bf00      	nop
 8009c84:	46bd      	mov	sp, r7
 8009c86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009c8a:	4770      	bx	lr
 8009c8c:	50040000 	.word	0x50040000

08009c90 <_adc_disable_adc>:

static void _adc_disable_adc(void)
{
 8009c90:	b480      	push	{r7}
 8009c92:	af00      	add	r7, sp, #0
	while(ADC1->CR & (ADC_CR_ADSTART | ADC_CR_JADSTART));
 8009c94:	bf00      	nop
 8009c96:	4b0c      	ldr	r3, [pc, #48]	; (8009cc8 <_adc_disable_adc+0x38>)
 8009c98:	689b      	ldr	r3, [r3, #8]
 8009c9a:	f003 030c 	and.w	r3, r3, #12
 8009c9e:	2b00      	cmp	r3, #0
 8009ca0:	d1f9      	bne.n	8009c96 <_adc_disable_adc+0x6>
	ADC1->CR |= ADC_CR_ADDIS;
 8009ca2:	4b09      	ldr	r3, [pc, #36]	; (8009cc8 <_adc_disable_adc+0x38>)
 8009ca4:	689b      	ldr	r3, [r3, #8]
 8009ca6:	4a08      	ldr	r2, [pc, #32]	; (8009cc8 <_adc_disable_adc+0x38>)
 8009ca8:	f043 0302 	orr.w	r3, r3, #2
 8009cac:	6093      	str	r3, [r2, #8]
	while(ADC1->CR & ADC_CR_ADEN);
 8009cae:	bf00      	nop
 8009cb0:	4b05      	ldr	r3, [pc, #20]	; (8009cc8 <_adc_disable_adc+0x38>)
 8009cb2:	689b      	ldr	r3, [r3, #8]
 8009cb4:	f003 0301 	and.w	r3, r3, #1
 8009cb8:	2b00      	cmp	r3, #0
 8009cba:	d1f9      	bne.n	8009cb0 <_adc_disable_adc+0x20>
}
 8009cbc:	bf00      	nop
 8009cbe:	bf00      	nop
 8009cc0:	46bd      	mov	sp, r7
 8009cc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009cc6:	4770      	bx	lr
 8009cc8:	50040000 	.word	0x50040000

08009ccc <__adc_calibrateAndReinit>:


void __adc_calibrateAndReinit (void)
{
 8009ccc:	b580      	push	{r7, lr}
 8009cce:	af00      	add	r7, sp, #0
	ADC1_COMMON->CCR &= ~ADC_CCR_CKMODE;
 8009cd0:	4b1e      	ldr	r3, [pc, #120]	; (8009d4c <__adc_calibrateAndReinit+0x80>)
 8009cd2:	689b      	ldr	r3, [r3, #8]
 8009cd4:	4a1d      	ldr	r2, [pc, #116]	; (8009d4c <__adc_calibrateAndReinit+0x80>)
 8009cd6:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8009cda:	6093      	str	r3, [r2, #8]
	ADC1_COMMON->CCR |= ADC_CCR_CKMODE_0;
 8009cdc:	4b1b      	ldr	r3, [pc, #108]	; (8009d4c <__adc_calibrateAndReinit+0x80>)
 8009cde:	689b      	ldr	r3, [r3, #8]
 8009ce0:	4a1a      	ldr	r2, [pc, #104]	; (8009d4c <__adc_calibrateAndReinit+0x80>)
 8009ce2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8009ce6:	6093      	str	r3, [r2, #8]
	
	ADC1->CFGR |= ADC_CFGR_DMAEN;
 8009ce8:	4b19      	ldr	r3, [pc, #100]	; (8009d50 <__adc_calibrateAndReinit+0x84>)
 8009cea:	68db      	ldr	r3, [r3, #12]
 8009cec:	4a18      	ldr	r2, [pc, #96]	; (8009d50 <__adc_calibrateAndReinit+0x84>)
 8009cee:	f043 0301 	orr.w	r3, r3, #1
 8009cf2:	60d3      	str	r3, [r2, #12]
	ADC1->CFGR |= ADC_CFGR_CONT;
 8009cf4:	4b16      	ldr	r3, [pc, #88]	; (8009d50 <__adc_calibrateAndReinit+0x84>)
 8009cf6:	68db      	ldr	r3, [r3, #12]
 8009cf8:	4a15      	ldr	r2, [pc, #84]	; (8009d50 <__adc_calibrateAndReinit+0x84>)
 8009cfa:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8009cfe:	60d3      	str	r3, [r2, #12]
	
	if ((ADC1->CR & ADC_CR_DEEPPWD) || !(ADC1->CR & ADC_CR_ADVREGEN) || (ADC1->CR & ADC_CR_ADEN))
 8009d00:	4b13      	ldr	r3, [pc, #76]	; (8009d50 <__adc_calibrateAndReinit+0x84>)
 8009d02:	689b      	ldr	r3, [r3, #8]
 8009d04:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8009d08:	2b00      	cmp	r3, #0
 8009d0a:	d10b      	bne.n	8009d24 <__adc_calibrateAndReinit+0x58>
 8009d0c:	4b10      	ldr	r3, [pc, #64]	; (8009d50 <__adc_calibrateAndReinit+0x84>)
 8009d0e:	689b      	ldr	r3, [r3, #8]
 8009d10:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8009d14:	2b00      	cmp	r3, #0
 8009d16:	d005      	beq.n	8009d24 <__adc_calibrateAndReinit+0x58>
 8009d18:	4b0d      	ldr	r3, [pc, #52]	; (8009d50 <__adc_calibrateAndReinit+0x84>)
 8009d1a:	689b      	ldr	r3, [r3, #8]
 8009d1c:	f003 0301 	and.w	r3, r3, #1
 8009d20:	2b00      	cmp	r3, #0
 8009d22:	d001      	beq.n	8009d28 <__adc_calibrateAndReinit+0x5c>
		Error_Handler(); // !!!!!!!!!!!!!!!!
 8009d24:	f002 ff32 	bl	800cb8c <Error_Handler>
	ADC1->CR |= ADC_CR_ADCAL;
 8009d28:	4b09      	ldr	r3, [pc, #36]	; (8009d50 <__adc_calibrateAndReinit+0x84>)
 8009d2a:	689b      	ldr	r3, [r3, #8]
 8009d2c:	4a08      	ldr	r2, [pc, #32]	; (8009d50 <__adc_calibrateAndReinit+0x84>)
 8009d2e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8009d32:	6093      	str	r3, [r2, #8]
	while(ADC1->CR & ADC_CR_ADCAL);
 8009d34:	bf00      	nop
 8009d36:	4b06      	ldr	r3, [pc, #24]	; (8009d50 <__adc_calibrateAndReinit+0x84>)
 8009d38:	689b      	ldr	r3, [r3, #8]
 8009d3a:	2b00      	cmp	r3, #0
 8009d3c:	dbfb      	blt.n	8009d36 <__adc_calibrateAndReinit+0x6a>
	_adc_dummyDelay();
 8009d3e:	f7ff ff75 	bl	8009c2c <_adc_dummyDelay>
	_adc_enable_adc();
 8009d42:	f7ff ff83 	bl	8009c4c <_adc_enable_adc>
}
 8009d46:	bf00      	nop
 8009d48:	bd80      	pop	{r7, pc}
 8009d4a:	bf00      	nop
 8009d4c:	50040300 	.word	0x50040300
 8009d50:	50040000 	.word	0x50040000

08009d54 <__adc_startBatConversion>:

void __adc_startBatConversion (void)
{
 8009d54:	b480      	push	{r7}
 8009d56:	af00      	add	r7, sp, #0
	ADC1->CR |= ADC_CR_JADSTART;
 8009d58:	4b05      	ldr	r3, [pc, #20]	; (8009d70 <__adc_startBatConversion+0x1c>)
 8009d5a:	689b      	ldr	r3, [r3, #8]
 8009d5c:	4a04      	ldr	r2, [pc, #16]	; (8009d70 <__adc_startBatConversion+0x1c>)
 8009d5e:	f043 0308 	orr.w	r3, r3, #8
 8009d62:	6093      	str	r3, [r2, #8]
}
 8009d64:	bf00      	nop
 8009d66:	46bd      	mov	sp, r7
 8009d68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d6c:	4770      	bx	lr
 8009d6e:	bf00      	nop
 8009d70:	50040000 	.word	0x50040000

08009d74 <__adc_startSigConversion>:

void __adc_startSigConversion (void)
{
 8009d74:	b480      	push	{r7}
 8009d76:	af00      	add	r7, sp, #0
	ADC1->CR |= ADC_CR_ADSTART;
 8009d78:	4b05      	ldr	r3, [pc, #20]	; (8009d90 <__adc_startSigConversion+0x1c>)
 8009d7a:	689b      	ldr	r3, [r3, #8]
 8009d7c:	4a04      	ldr	r2, [pc, #16]	; (8009d90 <__adc_startSigConversion+0x1c>)
 8009d7e:	f043 0304 	orr.w	r3, r3, #4
 8009d82:	6093      	str	r3, [r2, #8]
}
 8009d84:	bf00      	nop
 8009d86:	46bd      	mov	sp, r7
 8009d88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d8c:	4770      	bx	lr
 8009d8e:	bf00      	nop
 8009d90:	50040000 	.word	0x50040000

08009d94 <__adc_isBatDataAvailable>:

uint8_t __adc_isBatDataAvailable (void) // optimise ?
{
 8009d94:	b480      	push	{r7}
 8009d96:	b083      	sub	sp, #12
 8009d98:	af00      	add	r7, sp, #0
	uint8_t retval = (ADC1->ISR & ADC_ISR_JEOS)?0x01:0x00;
 8009d9a:	4b0d      	ldr	r3, [pc, #52]	; (8009dd0 <__adc_isBatDataAvailable+0x3c>)
 8009d9c:	681b      	ldr	r3, [r3, #0]
 8009d9e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009da2:	2b00      	cmp	r3, #0
 8009da4:	bf14      	ite	ne
 8009da6:	2301      	movne	r3, #1
 8009da8:	2300      	moveq	r3, #0
 8009daa:	b2db      	uxtb	r3, r3
 8009dac:	71fb      	strb	r3, [r7, #7]
	if (retval)
 8009dae:	79fb      	ldrb	r3, [r7, #7]
 8009db0:	2b00      	cmp	r3, #0
 8009db2:	d005      	beq.n	8009dc0 <__adc_isBatDataAvailable+0x2c>
		ADC1->ISR |= ADC_ISR_JEOS;
 8009db4:	4b06      	ldr	r3, [pc, #24]	; (8009dd0 <__adc_isBatDataAvailable+0x3c>)
 8009db6:	681b      	ldr	r3, [r3, #0]
 8009db8:	4a05      	ldr	r2, [pc, #20]	; (8009dd0 <__adc_isBatDataAvailable+0x3c>)
 8009dba:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009dbe:	6013      	str	r3, [r2, #0]
	return retval;
 8009dc0:	79fb      	ldrb	r3, [r7, #7]
}
 8009dc2:	4618      	mov	r0, r3
 8009dc4:	370c      	adds	r7, #12
 8009dc6:	46bd      	mov	sp, r7
 8009dc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009dcc:	4770      	bx	lr
 8009dce:	bf00      	nop
 8009dd0:	50040000 	.word	0x50040000

08009dd4 <__adc_isSigDataAvailable>:

uint8_t __adc_isSigDataAvailable (void)
{
 8009dd4:	b480      	push	{r7}
 8009dd6:	b083      	sub	sp, #12
 8009dd8:	af00      	add	r7, sp, #0
	uint8_t retval = (ADC1->ISR & ADC_ISR_EOS)?0x01:0x00;
 8009dda:	4b0d      	ldr	r3, [pc, #52]	; (8009e10 <__adc_isSigDataAvailable+0x3c>)
 8009ddc:	681b      	ldr	r3, [r3, #0]
 8009dde:	f003 0308 	and.w	r3, r3, #8
 8009de2:	2b00      	cmp	r3, #0
 8009de4:	bf14      	ite	ne
 8009de6:	2301      	movne	r3, #1
 8009de8:	2300      	moveq	r3, #0
 8009dea:	b2db      	uxtb	r3, r3
 8009dec:	71fb      	strb	r3, [r7, #7]
	if (retval)
 8009dee:	79fb      	ldrb	r3, [r7, #7]
 8009df0:	2b00      	cmp	r3, #0
 8009df2:	d005      	beq.n	8009e00 <__adc_isSigDataAvailable+0x2c>
		ADC1->ISR |= ADC_ISR_EOS;
 8009df4:	4b06      	ldr	r3, [pc, #24]	; (8009e10 <__adc_isSigDataAvailable+0x3c>)
 8009df6:	681b      	ldr	r3, [r3, #0]
 8009df8:	4a05      	ldr	r2, [pc, #20]	; (8009e10 <__adc_isSigDataAvailable+0x3c>)
 8009dfa:	f043 0308 	orr.w	r3, r3, #8
 8009dfe:	6013      	str	r3, [r2, #0]
	return retval;
 8009e00:	79fb      	ldrb	r3, [r7, #7]
}
 8009e02:	4618      	mov	r0, r3
 8009e04:	370c      	adds	r7, #12
 8009e06:	46bd      	mov	sp, r7
 8009e08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e0c:	4770      	bx	lr
 8009e0e:	bf00      	nop
 8009e10:	50040000 	.word	0x50040000

08009e14 <__adc_getSigData>:

uint16_t __adc_getSigData (void)
{
 8009e14:	b480      	push	{r7}
 8009e16:	af00      	add	r7, sp, #0
	return ADC1->DR;
 8009e18:	4b03      	ldr	r3, [pc, #12]	; (8009e28 <__adc_getSigData+0x14>)
 8009e1a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009e1c:	b29b      	uxth	r3, r3
}
 8009e1e:	4618      	mov	r0, r3
 8009e20:	46bd      	mov	sp, r7
 8009e22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e26:	4770      	bx	lr
 8009e28:	50040000 	.word	0x50040000

08009e2c <__adc_getBatData>:

uint16_t __adc_getBatData (void)
{
 8009e2c:	b480      	push	{r7}
 8009e2e:	af00      	add	r7, sp, #0
	return ADC1->JDR1;
 8009e30:	4b04      	ldr	r3, [pc, #16]	; (8009e44 <__adc_getBatData+0x18>)
 8009e32:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8009e36:	b29b      	uxth	r3, r3
}
 8009e38:	4618      	mov	r0, r3
 8009e3a:	46bd      	mov	sp, r7
 8009e3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e40:	4770      	bx	lr
 8009e42:	bf00      	nop
 8009e44:	50040000 	.word	0x50040000

08009e48 <__adc_reCalibrate>:

void __adc_reCalibrate (void)
{
 8009e48:	b580      	push	{r7, lr}
 8009e4a:	af00      	add	r7, sp, #0
	_adc_disable_adc();
 8009e4c:	f7ff ff20 	bl	8009c90 <_adc_disable_adc>
	ADC1->CR |= ADC_CR_ADCAL;
 8009e50:	4b07      	ldr	r3, [pc, #28]	; (8009e70 <__adc_reCalibrate+0x28>)
 8009e52:	689b      	ldr	r3, [r3, #8]
 8009e54:	4a06      	ldr	r2, [pc, #24]	; (8009e70 <__adc_reCalibrate+0x28>)
 8009e56:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8009e5a:	6093      	str	r3, [r2, #8]
	while(ADC1->CR & ADC_CR_ADCAL);
 8009e5c:	bf00      	nop
 8009e5e:	4b04      	ldr	r3, [pc, #16]	; (8009e70 <__adc_reCalibrate+0x28>)
 8009e60:	689b      	ldr	r3, [r3, #8]
 8009e62:	2b00      	cmp	r3, #0
 8009e64:	dbfb      	blt.n	8009e5e <__adc_reCalibrate+0x16>
	_adc_enable_adc();
 8009e66:	f7ff fef1 	bl	8009c4c <_adc_enable_adc>
}
 8009e6a:	bf00      	nop
 8009e6c:	bd80      	pop	{r7, pc}
 8009e6e:	bf00      	nop
 8009e70:	50040000 	.word	0x50040000

08009e74 <_init_adc_subsystem>:


void _init_adc_subsystem(struct _adc *adc)
{
 8009e74:	b480      	push	{r7}
 8009e76:	b083      	sub	sp, #12
 8009e78:	af00      	add	r7, sp, #0
 8009e7a:	6078      	str	r0, [r7, #4]
	_adc_dumm = 0;
 8009e7c:	4b10      	ldr	r3, [pc, #64]	; (8009ec0 <_init_adc_subsystem+0x4c>)
 8009e7e:	2200      	movs	r2, #0
 8009e80:	701a      	strb	r2, [r3, #0]
	adc->calibrateAndReinit = __adc_calibrateAndReinit;
 8009e82:	687b      	ldr	r3, [r7, #4]
 8009e84:	4a0f      	ldr	r2, [pc, #60]	; (8009ec4 <_init_adc_subsystem+0x50>)
 8009e86:	601a      	str	r2, [r3, #0]
	adc->startBatConversion = __adc_startBatConversion;
 8009e88:	687b      	ldr	r3, [r7, #4]
 8009e8a:	4a0f      	ldr	r2, [pc, #60]	; (8009ec8 <_init_adc_subsystem+0x54>)
 8009e8c:	605a      	str	r2, [r3, #4]
	adc->startSigConversion = __adc_startSigConversion;
 8009e8e:	687b      	ldr	r3, [r7, #4]
 8009e90:	4a0e      	ldr	r2, [pc, #56]	; (8009ecc <_init_adc_subsystem+0x58>)
 8009e92:	609a      	str	r2, [r3, #8]
	adc->isBatDataAvailable = __adc_isBatDataAvailable;
 8009e94:	687b      	ldr	r3, [r7, #4]
 8009e96:	4a0e      	ldr	r2, [pc, #56]	; (8009ed0 <_init_adc_subsystem+0x5c>)
 8009e98:	60da      	str	r2, [r3, #12]
	adc->isSigDataAvailable = __adc_isSigDataAvailable;
 8009e9a:	687b      	ldr	r3, [r7, #4]
 8009e9c:	4a0d      	ldr	r2, [pc, #52]	; (8009ed4 <_init_adc_subsystem+0x60>)
 8009e9e:	611a      	str	r2, [r3, #16]
	adc->getSigData = __adc_getSigData;
 8009ea0:	687b      	ldr	r3, [r7, #4]
 8009ea2:	4a0d      	ldr	r2, [pc, #52]	; (8009ed8 <_init_adc_subsystem+0x64>)
 8009ea4:	615a      	str	r2, [r3, #20]
	adc->getBatData = __adc_getBatData;
 8009ea6:	687b      	ldr	r3, [r7, #4]
 8009ea8:	4a0c      	ldr	r2, [pc, #48]	; (8009edc <_init_adc_subsystem+0x68>)
 8009eaa:	619a      	str	r2, [r3, #24]
	adc->reCalibrate = __adc_reCalibrate;
 8009eac:	687b      	ldr	r3, [r7, #4]
 8009eae:	4a0c      	ldr	r2, [pc, #48]	; (8009ee0 <_init_adc_subsystem+0x6c>)
 8009eb0:	61da      	str	r2, [r3, #28]
}
 8009eb2:	bf00      	nop
 8009eb4:	370c      	adds	r7, #12
 8009eb6:	46bd      	mov	sp, r7
 8009eb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009ebc:	4770      	bx	lr
 8009ebe:	bf00      	nop
 8009ec0:	2000040a 	.word	0x2000040a
 8009ec4:	08009ccd 	.word	0x08009ccd
 8009ec8:	08009d55 	.word	0x08009d55
 8009ecc:	08009d75 	.word	0x08009d75
 8009ed0:	08009d95 	.word	0x08009d95
 8009ed4:	08009dd5 	.word	0x08009dd5
 8009ed8:	08009e15 	.word	0x08009e15
 8009edc:	08009e2d 	.word	0x08009e2d
 8009ee0:	08009e49 	.word	0x08009e49

08009ee4 <__dma_initialize>:
static uint16_t _dma_data_buffer[1024];
static uint16_t _dma_data_counts;


void __dma_initialize (uint16_t dataCounts)
{
 8009ee4:	b480      	push	{r7}
 8009ee6:	b083      	sub	sp, #12
 8009ee8:	af00      	add	r7, sp, #0
 8009eea:	4603      	mov	r3, r0
 8009eec:	80fb      	strh	r3, [r7, #6]
	DMA1_Channel1->CPAR = (uint32_t)&(ADC1->DR);
 8009eee:	4b0f      	ldr	r3, [pc, #60]	; (8009f2c <__dma_initialize+0x48>)
 8009ef0:	4a0f      	ldr	r2, [pc, #60]	; (8009f30 <__dma_initialize+0x4c>)
 8009ef2:	609a      	str	r2, [r3, #8]
	DMA1_Channel1->CMAR = (uint32_t)_dma_data_buffer;
 8009ef4:	4b0d      	ldr	r3, [pc, #52]	; (8009f2c <__dma_initialize+0x48>)
 8009ef6:	4a0f      	ldr	r2, [pc, #60]	; (8009f34 <__dma_initialize+0x50>)
 8009ef8:	60da      	str	r2, [r3, #12]
	DMA1_Channel1->CNDTR = dataCounts;
 8009efa:	4a0c      	ldr	r2, [pc, #48]	; (8009f2c <__dma_initialize+0x48>)
 8009efc:	88fb      	ldrh	r3, [r7, #6]
 8009efe:	6053      	str	r3, [r2, #4]
	_dma_data_counts = dataCounts;
 8009f00:	4a0d      	ldr	r2, [pc, #52]	; (8009f38 <__dma_initialize+0x54>)
 8009f02:	88fb      	ldrh	r3, [r7, #6]
 8009f04:	8013      	strh	r3, [r2, #0]
	DMA1_Channel1->CCR |= DMA_CCR_TCIE;
 8009f06:	4b09      	ldr	r3, [pc, #36]	; (8009f2c <__dma_initialize+0x48>)
 8009f08:	681b      	ldr	r3, [r3, #0]
 8009f0a:	4a08      	ldr	r2, [pc, #32]	; (8009f2c <__dma_initialize+0x48>)
 8009f0c:	f043 0302 	orr.w	r3, r3, #2
 8009f10:	6013      	str	r3, [r2, #0]
	DMA1_Channel1->CCR |= DMA_CCR_EN;
 8009f12:	4b06      	ldr	r3, [pc, #24]	; (8009f2c <__dma_initialize+0x48>)
 8009f14:	681b      	ldr	r3, [r3, #0]
 8009f16:	4a05      	ldr	r2, [pc, #20]	; (8009f2c <__dma_initialize+0x48>)
 8009f18:	f043 0301 	orr.w	r3, r3, #1
 8009f1c:	6013      	str	r3, [r2, #0]
}
 8009f1e:	bf00      	nop
 8009f20:	370c      	adds	r7, #12
 8009f22:	46bd      	mov	sp, r7
 8009f24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f28:	4770      	bx	lr
 8009f2a:	bf00      	nop
 8009f2c:	40020008 	.word	0x40020008
 8009f30:	50040040 	.word	0x50040040
 8009f34:	2000040c 	.word	0x2000040c
 8009f38:	20000c0c 	.word	0x20000c0c

08009f3c <__dma_returnDataInfo>:


void __dma_returnDataInfo (uint16_t **dataBuffer, uint16_t *dataCounts)
{
 8009f3c:	b480      	push	{r7}
 8009f3e:	b083      	sub	sp, #12
 8009f40:	af00      	add	r7, sp, #0
 8009f42:	6078      	str	r0, [r7, #4]
 8009f44:	6039      	str	r1, [r7, #0]
	*dataBuffer = _dma_data_buffer;
 8009f46:	687b      	ldr	r3, [r7, #4]
 8009f48:	4a05      	ldr	r2, [pc, #20]	; (8009f60 <__dma_returnDataInfo+0x24>)
 8009f4a:	601a      	str	r2, [r3, #0]
	*dataCounts = _dma_data_counts;
 8009f4c:	4b05      	ldr	r3, [pc, #20]	; (8009f64 <__dma_returnDataInfo+0x28>)
 8009f4e:	881a      	ldrh	r2, [r3, #0]
 8009f50:	683b      	ldr	r3, [r7, #0]
 8009f52:	801a      	strh	r2, [r3, #0]
}
 8009f54:	bf00      	nop
 8009f56:	370c      	adds	r7, #12
 8009f58:	46bd      	mov	sp, r7
 8009f5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f5e:	4770      	bx	lr
 8009f60:	2000040c 	.word	0x2000040c
 8009f64:	20000c0c 	.word	0x20000c0c

08009f68 <_init_dma_dubsystem>:


void _init_dma_dubsystem(struct _dma *dma)
{
 8009f68:	b480      	push	{r7}
 8009f6a:	b083      	sub	sp, #12
 8009f6c:	af00      	add	r7, sp, #0
 8009f6e:	6078      	str	r0, [r7, #4]
	_dma_data_counts = 0;
 8009f70:	4b07      	ldr	r3, [pc, #28]	; (8009f90 <_init_dma_dubsystem+0x28>)
 8009f72:	2200      	movs	r2, #0
 8009f74:	801a      	strh	r2, [r3, #0]
	dma->initialize = __dma_initialize;
 8009f76:	687b      	ldr	r3, [r7, #4]
 8009f78:	4a06      	ldr	r2, [pc, #24]	; (8009f94 <_init_dma_dubsystem+0x2c>)
 8009f7a:	601a      	str	r2, [r3, #0]
	dma->returnDataInfo = __dma_returnDataInfo;
 8009f7c:	687b      	ldr	r3, [r7, #4]
 8009f7e:	4a06      	ldr	r2, [pc, #24]	; (8009f98 <_init_dma_dubsystem+0x30>)
 8009f80:	605a      	str	r2, [r3, #4]
}
 8009f82:	bf00      	nop
 8009f84:	370c      	adds	r7, #12
 8009f86:	46bd      	mov	sp, r7
 8009f88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f8c:	4770      	bx	lr
 8009f8e:	bf00      	nop
 8009f90:	20000c0c 	.word	0x20000c0c
 8009f94:	08009ee5 	.word	0x08009ee5
 8009f98:	08009f3d 	.word	0x08009f3d

08009f9c <_fs_strLen>:

static FATFS _fs;
static struct _FS *_SFS;

/*static*/ uint16_t _fs_strLen(char *str)
{
 8009f9c:	b580      	push	{r7, lr}
 8009f9e:	b084      	sub	sp, #16
 8009fa0:	af00      	add	r7, sp, #0
 8009fa2:	6078      	str	r0, [r7, #4]
	uint16_t len = 0;
 8009fa4:	2300      	movs	r3, #0
 8009fa6:	81fb      	strh	r3, [r7, #14]
	while(str[len++] != 0 && len != 0xFFFF);
 8009fa8:	bf00      	nop
 8009faa:	89fb      	ldrh	r3, [r7, #14]
 8009fac:	1c5a      	adds	r2, r3, #1
 8009fae:	81fa      	strh	r2, [r7, #14]
 8009fb0:	461a      	mov	r2, r3
 8009fb2:	687b      	ldr	r3, [r7, #4]
 8009fb4:	4413      	add	r3, r2
 8009fb6:	781b      	ldrb	r3, [r3, #0]
 8009fb8:	2b00      	cmp	r3, #0
 8009fba:	d004      	beq.n	8009fc6 <_fs_strLen+0x2a>
 8009fbc:	89fb      	ldrh	r3, [r7, #14]
 8009fbe:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8009fc2:	4293      	cmp	r3, r2
 8009fc4:	d1f1      	bne.n	8009faa <_fs_strLen+0xe>
	if (len == 0xFFFF)
 8009fc6:	89fb      	ldrh	r3, [r7, #14]
 8009fc8:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8009fcc:	4293      	cmp	r3, r2
 8009fce:	d101      	bne.n	8009fd4 <_fs_strLen+0x38>
		Error_Handler(); // @error_state !!!!
 8009fd0:	f002 fddc 	bl	800cb8c <Error_Handler>
	return len - 1;
 8009fd4:	89fb      	ldrh	r3, [r7, #14]
 8009fd6:	3b01      	subs	r3, #1
 8009fd8:	b29b      	uxth	r3, r3
}
 8009fda:	4618      	mov	r0, r3
 8009fdc:	3710      	adds	r7, #16
 8009fde:	46bd      	mov	sp, r7
 8009fe0:	bd80      	pop	{r7, pc}

08009fe2 <_fs_attachStrings>:

/*static*/ void _fs_attachStrings(char* str1, char* str2, char *result, uint16_t maxLen)
{
 8009fe2:	b580      	push	{r7, lr}
 8009fe4:	b086      	sub	sp, #24
 8009fe6:	af00      	add	r7, sp, #0
 8009fe8:	60f8      	str	r0, [r7, #12]
 8009fea:	60b9      	str	r1, [r7, #8]
 8009fec:	607a      	str	r2, [r7, #4]
 8009fee:	807b      	strh	r3, [r7, #2]
	uint16_t len1 = _fs_strLen(str1);
 8009ff0:	68f8      	ldr	r0, [r7, #12]
 8009ff2:	f7ff ffd3 	bl	8009f9c <_fs_strLen>
 8009ff6:	4603      	mov	r3, r0
 8009ff8:	82bb      	strh	r3, [r7, #20]
	uint16_t len2 = _fs_strLen(str2);
 8009ffa:	68b8      	ldr	r0, [r7, #8]
 8009ffc:	f7ff ffce 	bl	8009f9c <_fs_strLen>
 800a000:	4603      	mov	r3, r0
 800a002:	827b      	strh	r3, [r7, #18]
	uint16_t i, resLen = len1 + len2;
 800a004:	8aba      	ldrh	r2, [r7, #20]
 800a006:	8a7b      	ldrh	r3, [r7, #18]
 800a008:	4413      	add	r3, r2
 800a00a:	823b      	strh	r3, [r7, #16]
	if (len1 + len2 > maxLen)
 800a00c:	8aba      	ldrh	r2, [r7, #20]
 800a00e:	8a7b      	ldrh	r3, [r7, #18]
 800a010:	441a      	add	r2, r3
 800a012:	887b      	ldrh	r3, [r7, #2]
 800a014:	429a      	cmp	r2, r3
 800a016:	dd01      	ble.n	800a01c <_fs_attachStrings+0x3a>
		Error_Handler();
 800a018:	f002 fdb8 	bl	800cb8c <Error_Handler>
	
	for (i = 0; i < len1; i++)
 800a01c:	2300      	movs	r3, #0
 800a01e:	82fb      	strh	r3, [r7, #22]
 800a020:	e00a      	b.n	800a038 <_fs_attachStrings+0x56>
		result[i] = str1[i];
 800a022:	8afb      	ldrh	r3, [r7, #22]
 800a024:	68fa      	ldr	r2, [r7, #12]
 800a026:	441a      	add	r2, r3
 800a028:	8afb      	ldrh	r3, [r7, #22]
 800a02a:	6879      	ldr	r1, [r7, #4]
 800a02c:	440b      	add	r3, r1
 800a02e:	7812      	ldrb	r2, [r2, #0]
 800a030:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < len1; i++)
 800a032:	8afb      	ldrh	r3, [r7, #22]
 800a034:	3301      	adds	r3, #1
 800a036:	82fb      	strh	r3, [r7, #22]
 800a038:	8afa      	ldrh	r2, [r7, #22]
 800a03a:	8abb      	ldrh	r3, [r7, #20]
 800a03c:	429a      	cmp	r2, r3
 800a03e:	d3f0      	bcc.n	800a022 <_fs_attachStrings+0x40>
	for (i = len1; i <= resLen; i++)
 800a040:	8abb      	ldrh	r3, [r7, #20]
 800a042:	82fb      	strh	r3, [r7, #22]
 800a044:	e00d      	b.n	800a062 <_fs_attachStrings+0x80>
		result[i] = str2[i - len1];
 800a046:	8afa      	ldrh	r2, [r7, #22]
 800a048:	8abb      	ldrh	r3, [r7, #20]
 800a04a:	1ad3      	subs	r3, r2, r3
 800a04c:	461a      	mov	r2, r3
 800a04e:	68bb      	ldr	r3, [r7, #8]
 800a050:	441a      	add	r2, r3
 800a052:	8afb      	ldrh	r3, [r7, #22]
 800a054:	6879      	ldr	r1, [r7, #4]
 800a056:	440b      	add	r3, r1
 800a058:	7812      	ldrb	r2, [r2, #0]
 800a05a:	701a      	strb	r2, [r3, #0]
	for (i = len1; i <= resLen; i++)
 800a05c:	8afb      	ldrh	r3, [r7, #22]
 800a05e:	3301      	adds	r3, #1
 800a060:	82fb      	strh	r3, [r7, #22]
 800a062:	8afa      	ldrh	r2, [r7, #22]
 800a064:	8a3b      	ldrh	r3, [r7, #16]
 800a066:	429a      	cmp	r2, r3
 800a068:	d9ed      	bls.n	800a046 <_fs_attachStrings+0x64>
}
 800a06a:	bf00      	nop
 800a06c:	bf00      	nop
 800a06e:	3718      	adds	r7, #24
 800a070:	46bd      	mov	sp, r7
 800a072:	bd80      	pop	{r7, pc}

0800a074 <_fs_convertSpectValToStr>:

/*static*/ void _fs_convertSpectValToStr(uint32_t data, uint32_t index, char *buf, uint16_t bufsize)
{
 800a074:	b580      	push	{r7, lr}
 800a076:	b088      	sub	sp, #32
 800a078:	af00      	add	r7, sp, #0
 800a07a:	60f8      	str	r0, [r7, #12]
 800a07c:	60b9      	str	r1, [r7, #8]
 800a07e:	607a      	str	r2, [r7, #4]
 800a080:	807b      	strh	r3, [r7, #2]
	uint8_t d_len = 0, i_len = 0;
 800a082:	2300      	movs	r3, #0
 800a084:	77fb      	strb	r3, [r7, #31]
 800a086:	2300      	movs	r3, #0
 800a088:	77bb      	strb	r3, [r7, #30]
	uint32_t c_data = data, c_index = index;
 800a08a:	68fb      	ldr	r3, [r7, #12]
 800a08c:	61bb      	str	r3, [r7, #24]
 800a08e:	68bb      	ldr	r3, [r7, #8]
 800a090:	617b      	str	r3, [r7, #20]
	while(c_index)
 800a092:	e008      	b.n	800a0a6 <_fs_convertSpectValToStr+0x32>
	{
		++i_len;
 800a094:	7fbb      	ldrb	r3, [r7, #30]
 800a096:	3301      	adds	r3, #1
 800a098:	77bb      	strb	r3, [r7, #30]
		c_index /= 10;
 800a09a:	697b      	ldr	r3, [r7, #20]
 800a09c:	4a42      	ldr	r2, [pc, #264]	; (800a1a8 <_fs_convertSpectValToStr+0x134>)
 800a09e:	fba2 2303 	umull	r2, r3, r2, r3
 800a0a2:	08db      	lsrs	r3, r3, #3
 800a0a4:	617b      	str	r3, [r7, #20]
	while(c_index)
 800a0a6:	697b      	ldr	r3, [r7, #20]
 800a0a8:	2b00      	cmp	r3, #0
 800a0aa:	d1f3      	bne.n	800a094 <_fs_convertSpectValToStr+0x20>
	}
	while(c_data)
 800a0ac:	e008      	b.n	800a0c0 <_fs_convertSpectValToStr+0x4c>
	{
		++d_len;
 800a0ae:	7ffb      	ldrb	r3, [r7, #31]
 800a0b0:	3301      	adds	r3, #1
 800a0b2:	77fb      	strb	r3, [r7, #31]
		c_data /= 10;
 800a0b4:	69bb      	ldr	r3, [r7, #24]
 800a0b6:	4a3c      	ldr	r2, [pc, #240]	; (800a1a8 <_fs_convertSpectValToStr+0x134>)
 800a0b8:	fba2 2303 	umull	r2, r3, r2, r3
 800a0bc:	08db      	lsrs	r3, r3, #3
 800a0be:	61bb      	str	r3, [r7, #24]
	while(c_data)
 800a0c0:	69bb      	ldr	r3, [r7, #24]
 800a0c2:	2b00      	cmp	r3, #0
 800a0c4:	d1f3      	bne.n	800a0ae <_fs_convertSpectValToStr+0x3a>
	}
	if (!d_len)
 800a0c6:	7ffb      	ldrb	r3, [r7, #31]
 800a0c8:	2b00      	cmp	r3, #0
 800a0ca:	d101      	bne.n	800a0d0 <_fs_convertSpectValToStr+0x5c>
		d_len = 1;
 800a0cc:	2301      	movs	r3, #1
 800a0ce:	77fb      	strb	r3, [r7, #31]
	if (!i_len)
 800a0d0:	7fbb      	ldrb	r3, [r7, #30]
 800a0d2:	2b00      	cmp	r3, #0
 800a0d4:	d101      	bne.n	800a0da <_fs_convertSpectValToStr+0x66>
		i_len = 1;
 800a0d6:	2301      	movs	r3, #1
 800a0d8:	77bb      	strb	r3, [r7, #30]
	
	if (i_len + c_data + 3 > bufsize)
 800a0da:	7fba      	ldrb	r2, [r7, #30]
 800a0dc:	69bb      	ldr	r3, [r7, #24]
 800a0de:	4413      	add	r3, r2
 800a0e0:	1cda      	adds	r2, r3, #3
 800a0e2:	887b      	ldrh	r3, [r7, #2]
 800a0e4:	429a      	cmp	r2, r3
 800a0e6:	d901      	bls.n	800a0ec <_fs_convertSpectValToStr+0x78>
		Error_Handler();
 800a0e8:	f002 fd50 	bl	800cb8c <Error_Handler>
	c_data = d_len;
 800a0ec:	7ffb      	ldrb	r3, [r7, #31]
 800a0ee:	61bb      	str	r3, [r7, #24]
	c_index = i_len;
 800a0f0:	7fbb      	ldrb	r3, [r7, #30]
 800a0f2:	617b      	str	r3, [r7, #20]
	while(c_index)
 800a0f4:	e01b      	b.n	800a12e <_fs_convertSpectValToStr+0xba>
	{
		uint8_t ost = index % 10 + 48;
 800a0f6:	68b9      	ldr	r1, [r7, #8]
 800a0f8:	4b2b      	ldr	r3, [pc, #172]	; (800a1a8 <_fs_convertSpectValToStr+0x134>)
 800a0fa:	fba3 2301 	umull	r2, r3, r3, r1
 800a0fe:	08da      	lsrs	r2, r3, #3
 800a100:	4613      	mov	r3, r2
 800a102:	009b      	lsls	r3, r3, #2
 800a104:	4413      	add	r3, r2
 800a106:	005b      	lsls	r3, r3, #1
 800a108:	1aca      	subs	r2, r1, r3
 800a10a:	b2d3      	uxtb	r3, r2
 800a10c:	3330      	adds	r3, #48	; 0x30
 800a10e:	74bb      	strb	r3, [r7, #18]
		buf[c_index - 1] = ost;
 800a110:	697b      	ldr	r3, [r7, #20]
 800a112:	3b01      	subs	r3, #1
 800a114:	687a      	ldr	r2, [r7, #4]
 800a116:	4413      	add	r3, r2
 800a118:	7cba      	ldrb	r2, [r7, #18]
 800a11a:	701a      	strb	r2, [r3, #0]
		--c_index;
 800a11c:	697b      	ldr	r3, [r7, #20]
 800a11e:	3b01      	subs	r3, #1
 800a120:	617b      	str	r3, [r7, #20]
		index /= 10;
 800a122:	68bb      	ldr	r3, [r7, #8]
 800a124:	4a20      	ldr	r2, [pc, #128]	; (800a1a8 <_fs_convertSpectValToStr+0x134>)
 800a126:	fba2 2303 	umull	r2, r3, r2, r3
 800a12a:	08db      	lsrs	r3, r3, #3
 800a12c:	60bb      	str	r3, [r7, #8]
	while(c_index)
 800a12e:	697b      	ldr	r3, [r7, #20]
 800a130:	2b00      	cmp	r3, #0
 800a132:	d1e0      	bne.n	800a0f6 <_fs_convertSpectValToStr+0x82>
	}
	buf[i_len] = ',';
 800a134:	7fbb      	ldrb	r3, [r7, #30]
 800a136:	687a      	ldr	r2, [r7, #4]
 800a138:	4413      	add	r3, r2
 800a13a:	222c      	movs	r2, #44	; 0x2c
 800a13c:	701a      	strb	r2, [r3, #0]
	while(c_data)
 800a13e:	e01c      	b.n	800a17a <_fs_convertSpectValToStr+0x106>
	{
		uint8_t ost = data % 10 + 48;
 800a140:	68f9      	ldr	r1, [r7, #12]
 800a142:	4b19      	ldr	r3, [pc, #100]	; (800a1a8 <_fs_convertSpectValToStr+0x134>)
 800a144:	fba3 2301 	umull	r2, r3, r3, r1
 800a148:	08da      	lsrs	r2, r3, #3
 800a14a:	4613      	mov	r3, r2
 800a14c:	009b      	lsls	r3, r3, #2
 800a14e:	4413      	add	r3, r2
 800a150:	005b      	lsls	r3, r3, #1
 800a152:	1aca      	subs	r2, r1, r3
 800a154:	b2d3      	uxtb	r3, r2
 800a156:	3330      	adds	r3, #48	; 0x30
 800a158:	74fb      	strb	r3, [r7, #19]
		buf[i_len + c_data] = ost;
 800a15a:	7fba      	ldrb	r2, [r7, #30]
 800a15c:	69bb      	ldr	r3, [r7, #24]
 800a15e:	4413      	add	r3, r2
 800a160:	687a      	ldr	r2, [r7, #4]
 800a162:	4413      	add	r3, r2
 800a164:	7cfa      	ldrb	r2, [r7, #19]
 800a166:	701a      	strb	r2, [r3, #0]
		--c_data;
 800a168:	69bb      	ldr	r3, [r7, #24]
 800a16a:	3b01      	subs	r3, #1
 800a16c:	61bb      	str	r3, [r7, #24]
		data /= 10;
 800a16e:	68fb      	ldr	r3, [r7, #12]
 800a170:	4a0d      	ldr	r2, [pc, #52]	; (800a1a8 <_fs_convertSpectValToStr+0x134>)
 800a172:	fba2 2303 	umull	r2, r3, r2, r3
 800a176:	08db      	lsrs	r3, r3, #3
 800a178:	60fb      	str	r3, [r7, #12]
	while(c_data)
 800a17a:	69bb      	ldr	r3, [r7, #24]
 800a17c:	2b00      	cmp	r3, #0
 800a17e:	d1df      	bne.n	800a140 <_fs_convertSpectValToStr+0xcc>
	}
	buf[i_len + d_len + 1] = '\n';
 800a180:	7fba      	ldrb	r2, [r7, #30]
 800a182:	7ffb      	ldrb	r3, [r7, #31]
 800a184:	4413      	add	r3, r2
 800a186:	3301      	adds	r3, #1
 800a188:	687a      	ldr	r2, [r7, #4]
 800a18a:	4413      	add	r3, r2
 800a18c:	220a      	movs	r2, #10
 800a18e:	701a      	strb	r2, [r3, #0]
	buf[i_len + d_len + 2] = 0;
 800a190:	7fba      	ldrb	r2, [r7, #30]
 800a192:	7ffb      	ldrb	r3, [r7, #31]
 800a194:	4413      	add	r3, r2
 800a196:	3302      	adds	r3, #2
 800a198:	687a      	ldr	r2, [r7, #4]
 800a19a:	4413      	add	r3, r2
 800a19c:	2200      	movs	r2, #0
 800a19e:	701a      	strb	r2, [r3, #0]
}
 800a1a0:	bf00      	nop
 800a1a2:	3720      	adds	r7, #32
 800a1a4:	46bd      	mov	sp, r7
 800a1a6:	bd80      	pop	{r7, pc}
 800a1a8:	cccccccd 	.word	0xcccccccd

0800a1ac <__FS_saveFmwInfoAndInitFilStruct>:

/*static*/ void __FS_saveFmwInfoAndInitFilStruct (char *str, uint8_t firstLoad)
{
 800a1ac:	b580      	push	{r7, lr}
 800a1ae:	f5ad 7d62 	sub.w	sp, sp, #904	; 0x388
 800a1b2:	af00      	add	r7, sp, #0
 800a1b4:	1d3b      	adds	r3, r7, #4
 800a1b6:	6018      	str	r0, [r3, #0]
 800a1b8:	460a      	mov	r2, r1
 800a1ba:	1cfb      	adds	r3, r7, #3
 800a1bc:	701a      	strb	r2, [r3, #0]
	if (!_SFS->_isInitialized || str == NULL)
 800a1be:	4b20      	ldr	r3, [pc, #128]	; (800a240 <__FS_saveFmwInfoAndInitFilStruct+0x94>)
 800a1c0:	681b      	ldr	r3, [r3, #0]
 800a1c2:	781b      	ldrb	r3, [r3, #0]
 800a1c4:	2b00      	cmp	r3, #0
 800a1c6:	d035      	beq.n	800a234 <__FS_saveFmwInfoAndInitFilStruct+0x88>
 800a1c8:	1d3b      	adds	r3, r7, #4
 800a1ca:	681b      	ldr	r3, [r3, #0]
 800a1cc:	2b00      	cmp	r3, #0
 800a1ce:	d031      	beq.n	800a234 <__FS_saveFmwInfoAndInitFilStruct+0x88>
		return;
	
	FILINFO fno;
	DIR dr;
	if (firstLoad)
 800a1d0:	1cfb      	adds	r3, r7, #3
 800a1d2:	781b      	ldrb	r3, [r3, #0]
 800a1d4:	2b00      	cmp	r3, #0
 800a1d6:	d029      	beq.n	800a22c <__FS_saveFmwInfoAndInitFilStruct+0x80>
	{
		f_findfirst(&dr, &fno, "/", "fmw_info.txt");
 800a1d8:	f507 711b 	add.w	r1, r7, #620	; 0x26c
 800a1dc:	f507 700e 	add.w	r0, r7, #568	; 0x238
 800a1e0:	4b18      	ldr	r3, [pc, #96]	; (800a244 <__FS_saveFmwInfoAndInitFilStruct+0x98>)
 800a1e2:	4a19      	ldr	r2, [pc, #100]	; (800a248 <__FS_saveFmwInfoAndInitFilStruct+0x9c>)
 800a1e4:	f7fe f936 	bl	8008454 <f_findfirst>
		if (fno.fname[0] == 0)
 800a1e8:	f507 731b 	add.w	r3, r7, #620	; 0x26c
 800a1ec:	7d9b      	ldrb	r3, [r3, #22]
 800a1ee:	2b00      	cmp	r3, #0
 800a1f0:	d11c      	bne.n	800a22c <__FS_saveFmwInfoAndInitFilStruct+0x80>
		{
			FIL file;
			f_open(&file, "fmw_info.txt", FA_WRITE | FA_CREATE_ALWAYS);
 800a1f2:	f107 030c 	add.w	r3, r7, #12
 800a1f6:	220a      	movs	r2, #10
 800a1f8:	4912      	ldr	r1, [pc, #72]	; (800a244 <__FS_saveFmwInfoAndInitFilStruct+0x98>)
 800a1fa:	4618      	mov	r0, r3
 800a1fc:	f7fd fba6 	bl	800794c <f_open>
			uint16_t len = _fs_strLen(str);
 800a200:	1d3b      	adds	r3, r7, #4
 800a202:	6818      	ldr	r0, [r3, #0]
 800a204:	f7ff feca 	bl	8009f9c <_fs_strLen>
 800a208:	4603      	mov	r3, r0
 800a20a:	f8a7 3386 	strh.w	r3, [r7, #902]	; 0x386
			UINT bwr;
			f_write(&file, str, len, &bwr);
 800a20e:	f8b7 2386 	ldrh.w	r2, [r7, #902]	; 0x386
 800a212:	f507 730d 	add.w	r3, r7, #564	; 0x234
 800a216:	1d39      	adds	r1, r7, #4
 800a218:	f107 000c 	add.w	r0, r7, #12
 800a21c:	6809      	ldr	r1, [r1, #0]
 800a21e:	f7fd fe52 	bl	8007ec6 <f_write>
			f_close(&file);
 800a222:	f107 030c 	add.w	r3, r7, #12
 800a226:	4618      	mov	r0, r3
 800a228:	f7fe f836 	bl	8008298 <f_close>
		}
	}
	
	f_mkdir(CSV_DATA_FOLDER);
 800a22c:	4807      	ldr	r0, [pc, #28]	; (800a24c <__FS_saveFmwInfoAndInitFilStruct+0xa0>)
 800a22e:	f7fe f92f 	bl	8008490 <f_mkdir>
 800a232:	e000      	b.n	800a236 <__FS_saveFmwInfoAndInitFilStruct+0x8a>
		return;
 800a234:	bf00      	nop
}
 800a236:	f507 7762 	add.w	r7, r7, #904	; 0x388
 800a23a:	46bd      	mov	sp, r7
 800a23c:	bd80      	pop	{r7, pc}
 800a23e:	bf00      	nop
 800a240:	20000e44 	.word	0x20000e44
 800a244:	08014c74 	.word	0x08014c74
 800a248:	08014c84 	.word	0x08014c84
 800a24c:	08014c88 	.word	0x08014c88

0800a250 <__FS_initialize>:

// STATIC FUNCTIONS END


void __FS_initialize (char *info, uint8_t firstLoad)
{
 800a250:	b580      	push	{r7, lr}
 800a252:	b084      	sub	sp, #16
 800a254:	af00      	add	r7, sp, #0
 800a256:	6078      	str	r0, [r7, #4]
 800a258:	460b      	mov	r3, r1
 800a25a:	70fb      	strb	r3, [r7, #3]
	if (_SFS->_isInitialized) // @@@
 800a25c:	4b12      	ldr	r3, [pc, #72]	; (800a2a8 <__FS_initialize+0x58>)
 800a25e:	681b      	ldr	r3, [r3, #0]
 800a260:	781b      	ldrb	r3, [r3, #0]
 800a262:	2b00      	cmp	r3, #0
 800a264:	d11b      	bne.n	800a29e <__FS_initialize+0x4e>
		return;
	FRESULT res;
	res = f_mount(&_fs, "", 1);
 800a266:	2201      	movs	r2, #1
 800a268:	4910      	ldr	r1, [pc, #64]	; (800a2ac <__FS_initialize+0x5c>)
 800a26a:	4811      	ldr	r0, [pc, #68]	; (800a2b0 <__FS_initialize+0x60>)
 800a26c:	f7fd fb2e 	bl	80078cc <f_mount>
 800a270:	4603      	mov	r3, r0
 800a272:	73fb      	strb	r3, [r7, #15]
	if (res != FR_OK)
 800a274:	7bfb      	ldrb	r3, [r7, #15]
 800a276:	2b00      	cmp	r3, #0
 800a278:	d004      	beq.n	800a284 <__FS_initialize+0x34>
		_SFS->_isInitialized = 0;
 800a27a:	4b0b      	ldr	r3, [pc, #44]	; (800a2a8 <__FS_initialize+0x58>)
 800a27c:	681b      	ldr	r3, [r3, #0]
 800a27e:	2200      	movs	r2, #0
 800a280:	701a      	strb	r2, [r3, #0]
 800a282:	e00d      	b.n	800a2a0 <__FS_initialize+0x50>
	else
	{
		_SFS->_isInitialized = 1;
 800a284:	4b08      	ldr	r3, [pc, #32]	; (800a2a8 <__FS_initialize+0x58>)
 800a286:	681b      	ldr	r3, [r3, #0]
 800a288:	2201      	movs	r2, #1
 800a28a:	701a      	strb	r2, [r3, #0]
		if (firstLoad)
 800a28c:	78fb      	ldrb	r3, [r7, #3]
 800a28e:	2b00      	cmp	r3, #0
 800a290:	d006      	beq.n	800a2a0 <__FS_initialize+0x50>
			__FS_saveFmwInfoAndInitFilStruct(info, firstLoad);
 800a292:	78fb      	ldrb	r3, [r7, #3]
 800a294:	4619      	mov	r1, r3
 800a296:	6878      	ldr	r0, [r7, #4]
 800a298:	f7ff ff88 	bl	800a1ac <__FS_saveFmwInfoAndInitFilStruct>
 800a29c:	e000      	b.n	800a2a0 <__FS_initialize+0x50>
		return;
 800a29e:	bf00      	nop
	}
}
 800a2a0:	3710      	adds	r7, #16
 800a2a2:	46bd      	mov	sp, r7
 800a2a4:	bd80      	pop	{r7, pc}
 800a2a6:	bf00      	nop
 800a2a8:	20000e44 	.word	0x20000e44
 800a2ac:	08014c94 	.word	0x08014c94
 800a2b0:	20000c10 	.word	0x20000c10

0800a2b4 <__FS_saveRadInfo_csv>:

void __FS_saveRadInfo_csv (char *file_name, uint32_t *mas, uint16_t size)
{
 800a2b4:	b580      	push	{r7, lr}
 800a2b6:	f5ad 7d20 	sub.w	sp, sp, #640	; 0x280
 800a2ba:	af00      	add	r7, sp, #0
 800a2bc:	f107 030c 	add.w	r3, r7, #12
 800a2c0:	6018      	str	r0, [r3, #0]
 800a2c2:	f107 0308 	add.w	r3, r7, #8
 800a2c6:	6019      	str	r1, [r3, #0]
 800a2c8:	1dbb      	adds	r3, r7, #6
 800a2ca:	801a      	strh	r2, [r3, #0]
	if (!_SFS->_isInitialized)
 800a2cc:	4b29      	ldr	r3, [pc, #164]	; (800a374 <__FS_saveRadInfo_csv+0xc0>)
 800a2ce:	681b      	ldr	r3, [r3, #0]
 800a2d0:	781b      	ldrb	r3, [r3, #0]
 800a2d2:	2b00      	cmp	r3, #0
 800a2d4:	d046      	beq.n	800a364 <__FS_saveRadInfo_csv+0xb0>
	
	FIL file;
	FRESULT res;
	static char fullPath[88];
	static char namePath[64];
	_fs_attachStrings("/", file_name, namePath, 64);
 800a2d6:	f107 010c 	add.w	r1, r7, #12
 800a2da:	2340      	movs	r3, #64	; 0x40
 800a2dc:	4a26      	ldr	r2, [pc, #152]	; (800a378 <__FS_saveRadInfo_csv+0xc4>)
 800a2de:	6809      	ldr	r1, [r1, #0]
 800a2e0:	4826      	ldr	r0, [pc, #152]	; (800a37c <__FS_saveRadInfo_csv+0xc8>)
 800a2e2:	f7ff fe7e 	bl	8009fe2 <_fs_attachStrings>
	_fs_attachStrings(CSV_DATA_FOLDER, namePath, fullPath, 88);
 800a2e6:	2358      	movs	r3, #88	; 0x58
 800a2e8:	4a25      	ldr	r2, [pc, #148]	; (800a380 <__FS_saveRadInfo_csv+0xcc>)
 800a2ea:	4923      	ldr	r1, [pc, #140]	; (800a378 <__FS_saveRadInfo_csv+0xc4>)
 800a2ec:	4825      	ldr	r0, [pc, #148]	; (800a384 <__FS_saveRadInfo_csv+0xd0>)
 800a2ee:	f7ff fe78 	bl	8009fe2 <_fs_attachStrings>
	
	res = f_open(&file, fullPath, FA_WRITE | FA_CREATE_ALWAYS);
 800a2f2:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800a2f6:	220a      	movs	r2, #10
 800a2f8:	4921      	ldr	r1, [pc, #132]	; (800a380 <__FS_saveRadInfo_csv+0xcc>)
 800a2fa:	4618      	mov	r0, r3
 800a2fc:	f7fd fb26 	bl	800794c <f_open>
 800a300:	4603      	mov	r3, r0
 800a302:	f887 327b 	strb.w	r3, [r7, #635]	; 0x27b
	if (res != FR_OK)
 800a306:	f897 327b 	ldrb.w	r3, [r7, #635]	; 0x27b
 800a30a:	2b00      	cmp	r3, #0
 800a30c:	d12c      	bne.n	800a368 <__FS_saveRadInfo_csv+0xb4>
		return;
	char str_buf[64];
	for (uint32_t i = 0; i < 4096; i++)
 800a30e:	2300      	movs	r3, #0
 800a310:	f8c7 327c 	str.w	r3, [r7, #636]	; 0x27c
 800a314:	e01b      	b.n	800a34e <__FS_saveRadInfo_csv+0x9a>
	{
		_fs_convertSpectValToStr(mas[i], i, str_buf, 64);
 800a316:	f8d7 327c 	ldr.w	r3, [r7, #636]	; 0x27c
 800a31a:	009b      	lsls	r3, r3, #2
 800a31c:	f107 0208 	add.w	r2, r7, #8
 800a320:	6812      	ldr	r2, [r2, #0]
 800a322:	4413      	add	r3, r2
 800a324:	6818      	ldr	r0, [r3, #0]
 800a326:	f107 0210 	add.w	r2, r7, #16
 800a32a:	2340      	movs	r3, #64	; 0x40
 800a32c:	f8d7 127c 	ldr.w	r1, [r7, #636]	; 0x27c
 800a330:	f7ff fea0 	bl	800a074 <_fs_convertSpectValToStr>
		f_puts(str_buf, &file);
 800a334:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800a338:	f107 0310 	add.w	r3, r7, #16
 800a33c:	4611      	mov	r1, r2
 800a33e:	4618      	mov	r0, r3
 800a340:	f7fe fa29 	bl	8008796 <f_puts>
	for (uint32_t i = 0; i < 4096; i++)
 800a344:	f8d7 327c 	ldr.w	r3, [r7, #636]	; 0x27c
 800a348:	3301      	adds	r3, #1
 800a34a:	f8c7 327c 	str.w	r3, [r7, #636]	; 0x27c
 800a34e:	f8d7 327c 	ldr.w	r3, [r7, #636]	; 0x27c
 800a352:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800a356:	d3de      	bcc.n	800a316 <__FS_saveRadInfo_csv+0x62>
	}	
	f_close(&file);
 800a358:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800a35c:	4618      	mov	r0, r3
 800a35e:	f7fd ff9b 	bl	8008298 <f_close>
 800a362:	e002      	b.n	800a36a <__FS_saveRadInfo_csv+0xb6>
		return;
 800a364:	bf00      	nop
 800a366:	e000      	b.n	800a36a <__FS_saveRadInfo_csv+0xb6>
		return;
 800a368:	bf00      	nop
}
 800a36a:	f507 7720 	add.w	r7, r7, #640	; 0x280
 800a36e:	46bd      	mov	sp, r7
 800a370:	bd80      	pop	{r7, pc}
 800a372:	bf00      	nop
 800a374:	20000e44 	.word	0x20000e44
 800a378:	20000e48 	.word	0x20000e48
 800a37c:	08014c84 	.word	0x08014c84
 800a380:	20000e88 	.word	0x20000e88
 800a384:	08014c88 	.word	0x08014c88

0800a388 <_fs_getHexAsChar>:

static char _fs_getHexAsChar(uint8_t val)
{
 800a388:	b480      	push	{r7}
 800a38a:	b083      	sub	sp, #12
 800a38c:	af00      	add	r7, sp, #0
 800a38e:	4603      	mov	r3, r0
 800a390:	71fb      	strb	r3, [r7, #7]
	val = val & 0x0F;
 800a392:	79fb      	ldrb	r3, [r7, #7]
 800a394:	f003 030f 	and.w	r3, r3, #15
 800a398:	71fb      	strb	r3, [r7, #7]
	if (val > 9)
 800a39a:	79fb      	ldrb	r3, [r7, #7]
 800a39c:	2b09      	cmp	r3, #9
 800a39e:	d903      	bls.n	800a3a8 <_fs_getHexAsChar+0x20>
		return val + 55;
 800a3a0:	79fb      	ldrb	r3, [r7, #7]
 800a3a2:	3337      	adds	r3, #55	; 0x37
 800a3a4:	b2db      	uxtb	r3, r3
 800a3a6:	e002      	b.n	800a3ae <_fs_getHexAsChar+0x26>
	else
		return val + 48;
 800a3a8:	79fb      	ldrb	r3, [r7, #7]
 800a3aa:	3330      	adds	r3, #48	; 0x30
 800a3ac:	b2db      	uxtb	r3, r3
}
 800a3ae:	4618      	mov	r0, r3
 800a3b0:	370c      	adds	r7, #12
 800a3b2:	46bd      	mov	sp, r7
 800a3b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a3b8:	4770      	bx	lr

0800a3ba <_fs_prepareSysSetStr>:

static void _fs_prepareSysSetStr(char *str, uint8_t cmd, uint8_t dataLen)
{
 800a3ba:	b590      	push	{r4, r7, lr}
 800a3bc:	b083      	sub	sp, #12
 800a3be:	af00      	add	r7, sp, #0
 800a3c0:	6078      	str	r0, [r7, #4]
 800a3c2:	460b      	mov	r3, r1
 800a3c4:	70fb      	strb	r3, [r7, #3]
 800a3c6:	4613      	mov	r3, r2
 800a3c8:	70bb      	strb	r3, [r7, #2]
	str[0] = '#';
 800a3ca:	687b      	ldr	r3, [r7, #4]
 800a3cc:	2223      	movs	r2, #35	; 0x23
 800a3ce:	701a      	strb	r2, [r3, #0]

	str[1] = _fs_getHexAsChar(cmd >> 4);
 800a3d0:	78fb      	ldrb	r3, [r7, #3]
 800a3d2:	091b      	lsrs	r3, r3, #4
 800a3d4:	b2da      	uxtb	r2, r3
 800a3d6:	687b      	ldr	r3, [r7, #4]
 800a3d8:	1c5c      	adds	r4, r3, #1
 800a3da:	4610      	mov	r0, r2
 800a3dc:	f7ff ffd4 	bl	800a388 <_fs_getHexAsChar>
 800a3e0:	4603      	mov	r3, r0
 800a3e2:	7023      	strb	r3, [r4, #0]
	str[2] = _fs_getHexAsChar(cmd & 0x0F);
 800a3e4:	78fb      	ldrb	r3, [r7, #3]
 800a3e6:	f003 030f 	and.w	r3, r3, #15
 800a3ea:	b2da      	uxtb	r2, r3
 800a3ec:	687b      	ldr	r3, [r7, #4]
 800a3ee:	1c9c      	adds	r4, r3, #2
 800a3f0:	4610      	mov	r0, r2
 800a3f2:	f7ff ffc9 	bl	800a388 <_fs_getHexAsChar>
 800a3f6:	4603      	mov	r3, r0
 800a3f8:	7023      	strb	r3, [r4, #0]
	str[3] = _fs_getHexAsChar(dataLen >> 4);
 800a3fa:	78bb      	ldrb	r3, [r7, #2]
 800a3fc:	091b      	lsrs	r3, r3, #4
 800a3fe:	b2da      	uxtb	r2, r3
 800a400:	687b      	ldr	r3, [r7, #4]
 800a402:	1cdc      	adds	r4, r3, #3
 800a404:	4610      	mov	r0, r2
 800a406:	f7ff ffbf 	bl	800a388 <_fs_getHexAsChar>
 800a40a:	4603      	mov	r3, r0
 800a40c:	7023      	strb	r3, [r4, #0]
	str[4] = _fs_getHexAsChar(dataLen & 0x0F);
 800a40e:	78bb      	ldrb	r3, [r7, #2]
 800a410:	f003 030f 	and.w	r3, r3, #15
 800a414:	b2da      	uxtb	r2, r3
 800a416:	687b      	ldr	r3, [r7, #4]
 800a418:	1d1c      	adds	r4, r3, #4
 800a41a:	4610      	mov	r0, r2
 800a41c:	f7ff ffb4 	bl	800a388 <_fs_getHexAsChar>
 800a420:	4603      	mov	r3, r0
 800a422:	7023      	strb	r3, [r4, #0]
	str[5] = '#';
 800a424:	687b      	ldr	r3, [r7, #4]
 800a426:	3305      	adds	r3, #5
 800a428:	2223      	movs	r2, #35	; 0x23
 800a42a:	701a      	strb	r2, [r3, #0]
	str[6 + dataLen] = '#';
 800a42c:	78bb      	ldrb	r3, [r7, #2]
 800a42e:	3306      	adds	r3, #6
 800a430:	461a      	mov	r2, r3
 800a432:	687b      	ldr	r3, [r7, #4]
 800a434:	4413      	add	r3, r2
 800a436:	2223      	movs	r2, #35	; 0x23
 800a438:	701a      	strb	r2, [r3, #0]
	str[7 + dataLen] = 0;
 800a43a:	78bb      	ldrb	r3, [r7, #2]
 800a43c:	3307      	adds	r3, #7
 800a43e:	461a      	mov	r2, r3
 800a440:	687b      	ldr	r3, [r7, #4]
 800a442:	4413      	add	r3, r2
 800a444:	2200      	movs	r2, #0
 800a446:	701a      	strb	r2, [r3, #0]
}
 800a448:	bf00      	nop
 800a44a:	370c      	adds	r7, #12
 800a44c:	46bd      	mov	sp, r7
 800a44e:	bd90      	pop	{r4, r7, pc}

0800a450 <_fs_convertUint32ToChar>:

static uint8_t _fs_convertUint32ToChar(uint32_t val, char *buff)
{
 800a450:	b480      	push	{r7}
 800a452:	b087      	sub	sp, #28
 800a454:	af00      	add	r7, sp, #0
 800a456:	6078      	str	r0, [r7, #4]
 800a458:	6039      	str	r1, [r7, #0]
	uint8_t len;
	uint32_t copy = val;
 800a45a:	687b      	ldr	r3, [r7, #4]
 800a45c:	613b      	str	r3, [r7, #16]
	uint8_t res;
	while(copy)
 800a45e:	e008      	b.n	800a472 <_fs_convertUint32ToChar+0x22>
	{
		len++;
 800a460:	7dfb      	ldrb	r3, [r7, #23]
 800a462:	3301      	adds	r3, #1
 800a464:	75fb      	strb	r3, [r7, #23]
		copy /= 10;
 800a466:	693b      	ldr	r3, [r7, #16]
 800a468:	4a1d      	ldr	r2, [pc, #116]	; (800a4e0 <_fs_convertUint32ToChar+0x90>)
 800a46a:	fba2 2303 	umull	r2, r3, r2, r3
 800a46e:	08db      	lsrs	r3, r3, #3
 800a470:	613b      	str	r3, [r7, #16]
	while(copy)
 800a472:	693b      	ldr	r3, [r7, #16]
 800a474:	2b00      	cmp	r3, #0
 800a476:	d1f3      	bne.n	800a460 <_fs_convertUint32ToChar+0x10>
	}
	if (!len)
 800a478:	7dfb      	ldrb	r3, [r7, #23]
 800a47a:	2b00      	cmp	r3, #0
 800a47c:	d101      	bne.n	800a482 <_fs_convertUint32ToChar+0x32>
		len = 1;
 800a47e:	2301      	movs	r3, #1
 800a480:	75fb      	strb	r3, [r7, #23]
	res = len;
 800a482:	7dfb      	ldrb	r3, [r7, #23]
 800a484:	73fb      	strb	r3, [r7, #15]
	buff[len] = 0;
 800a486:	7dfb      	ldrb	r3, [r7, #23]
 800a488:	683a      	ldr	r2, [r7, #0]
 800a48a:	4413      	add	r3, r2
 800a48c:	2200      	movs	r2, #0
 800a48e:	701a      	strb	r2, [r3, #0]
	while(len)
 800a490:	e01b      	b.n	800a4ca <_fs_convertUint32ToChar+0x7a>
	{
		--len;
 800a492:	7dfb      	ldrb	r3, [r7, #23]
 800a494:	3b01      	subs	r3, #1
 800a496:	75fb      	strb	r3, [r7, #23]
		uint8_t ost = val % 10;
 800a498:	6879      	ldr	r1, [r7, #4]
 800a49a:	4b11      	ldr	r3, [pc, #68]	; (800a4e0 <_fs_convertUint32ToChar+0x90>)
 800a49c:	fba3 2301 	umull	r2, r3, r3, r1
 800a4a0:	08da      	lsrs	r2, r3, #3
 800a4a2:	4613      	mov	r3, r2
 800a4a4:	009b      	lsls	r3, r3, #2
 800a4a6:	4413      	add	r3, r2
 800a4a8:	005b      	lsls	r3, r3, #1
 800a4aa:	1aca      	subs	r2, r1, r3
 800a4ac:	4613      	mov	r3, r2
 800a4ae:	73bb      	strb	r3, [r7, #14]
		buff[len] = ost + 48;
 800a4b0:	7dfb      	ldrb	r3, [r7, #23]
 800a4b2:	683a      	ldr	r2, [r7, #0]
 800a4b4:	4413      	add	r3, r2
 800a4b6:	7bba      	ldrb	r2, [r7, #14]
 800a4b8:	3230      	adds	r2, #48	; 0x30
 800a4ba:	b2d2      	uxtb	r2, r2
 800a4bc:	701a      	strb	r2, [r3, #0]
		val /= 10;
 800a4be:	687b      	ldr	r3, [r7, #4]
 800a4c0:	4a07      	ldr	r2, [pc, #28]	; (800a4e0 <_fs_convertUint32ToChar+0x90>)
 800a4c2:	fba2 2303 	umull	r2, r3, r2, r3
 800a4c6:	08db      	lsrs	r3, r3, #3
 800a4c8:	607b      	str	r3, [r7, #4]
	while(len)
 800a4ca:	7dfb      	ldrb	r3, [r7, #23]
 800a4cc:	2b00      	cmp	r3, #0
 800a4ce:	d1e0      	bne.n	800a492 <_fs_convertUint32ToChar+0x42>
	}
	return res;
 800a4d0:	7bfb      	ldrb	r3, [r7, #15]
}
 800a4d2:	4618      	mov	r0, r3
 800a4d4:	371c      	adds	r7, #28
 800a4d6:	46bd      	mov	sp, r7
 800a4d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a4dc:	4770      	bx	lr
 800a4de:	bf00      	nop
 800a4e0:	cccccccd 	.word	0xcccccccd

0800a4e4 <__FS_saveSystemSettingsInfo>:

void __FS_saveSystemSettingsInfo (struct SystemSettings* settings)
{
 800a4e4:	b580      	push	{r7, lr}
 800a4e6:	f5ad 7d5c 	sub.w	sp, sp, #880	; 0x370
 800a4ea:	af00      	add	r7, sp, #0
 800a4ec:	1d3b      	adds	r3, r7, #4
 800a4ee:	6018      	str	r0, [r3, #0]
	if (!_SFS->_isInitialized)
 800a4f0:	4b82      	ldr	r3, [pc, #520]	; (800a6fc <__FS_saveSystemSettingsInfo+0x218>)
 800a4f2:	681b      	ldr	r3, [r3, #0]
 800a4f4:	781b      	ldrb	r3, [r3, #0]
 800a4f6:	2b00      	cmp	r3, #0
 800a4f8:	f000 80f8 	beq.w	800a6ec <__FS_saveSystemSettingsInfo+0x208>

	FIL file;
	FRESULT res;
	char str[256];

	res = f_open(&file, "cfgr.txt", FA_WRITE | FA_CREATE_ALWAYS);
 800a4fc:	f507 739e 	add.w	r3, r7, #316	; 0x13c
 800a500:	220a      	movs	r2, #10
 800a502:	497f      	ldr	r1, [pc, #508]	; (800a700 <__FS_saveSystemSettingsInfo+0x21c>)
 800a504:	4618      	mov	r0, r3
 800a506:	f7fd fa21 	bl	800794c <f_open>
 800a50a:	4603      	mov	r3, r0
 800a50c:	f887 3369 	strb.w	r3, [r7, #873]	; 0x369
	if (res != FR_OK)
 800a510:	f897 3369 	ldrb.w	r3, [r7, #873]	; 0x369
 800a514:	2b00      	cmp	r3, #0
 800a516:	f040 80eb 	bne.w	800a6f0 <__FS_saveSystemSettingsInfo+0x20c>
		return;
	{ // saving device name
		str[6] = settings->deviceNumber[0];
 800a51a:	1d3b      	adds	r3, r7, #4
 800a51c:	681b      	ldr	r3, [r3, #0]
 800a51e:	781a      	ldrb	r2, [r3, #0]
 800a520:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800a524:	719a      	strb	r2, [r3, #6]
		str[7] = settings->deviceNumber[1];
 800a526:	1d3b      	adds	r3, r7, #4
 800a528:	681b      	ldr	r3, [r3, #0]
 800a52a:	785a      	ldrb	r2, [r3, #1]
 800a52c:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800a530:	71da      	strb	r2, [r3, #7]
		_fs_prepareSysSetStr(str, 1, 2);
 800a532:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800a536:	2202      	movs	r2, #2
 800a538:	2101      	movs	r1, #1
 800a53a:	4618      	mov	r0, r3
 800a53c:	f7ff ff3d 	bl	800a3ba <_fs_prepareSysSetStr>
		_fs_attachStrings(str, " @device name numbers\n", str, 240);
 800a540:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 800a544:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 800a548:	23f0      	movs	r3, #240	; 0xf0
 800a54a:	496e      	ldr	r1, [pc, #440]	; (800a704 <__FS_saveSystemSettingsInfo+0x220>)
 800a54c:	f7ff fd49 	bl	8009fe2 <_fs_attachStrings>
		f_puts(str, &file);
 800a550:	f507 729e 	add.w	r2, r7, #316	; 0x13c
 800a554:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800a558:	4611      	mov	r1, r2
 800a55a:	4618      	mov	r0, r3
 800a55c:	f7fe f91b 	bl	8008796 <f_puts>
	}
	{ // saving dma impulse counts
		char valBuffer[16];
		uint16_t i;
		uint8_t valueLen = _fs_convertUint32ToChar(settings->countsToDma, valBuffer);
 800a560:	1d3b      	adds	r3, r7, #4
 800a562:	681b      	ldr	r3, [r3, #0]
 800a564:	885b      	ldrh	r3, [r3, #2]
 800a566:	461a      	mov	r2, r3
 800a568:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800a56c:	4619      	mov	r1, r3
 800a56e:	4610      	mov	r0, r2
 800a570:	f7ff ff6e 	bl	800a450 <_fs_convertUint32ToChar>
 800a574:	4603      	mov	r3, r0
 800a576:	f887 3368 	strb.w	r3, [r7, #872]	; 0x368
		for (i = 0; i < valueLen; i++)
 800a57a:	2300      	movs	r3, #0
 800a57c:	f8a7 336e 	strh.w	r3, [r7, #878]	; 0x36e
 800a580:	e00f      	b.n	800a5a2 <__FS_saveSystemSettingsInfo+0xbe>
			str[6 + i] = valBuffer[i];
 800a582:	f8b7 236e 	ldrh.w	r2, [r7, #878]	; 0x36e
 800a586:	f8b7 336e 	ldrh.w	r3, [r7, #878]	; 0x36e
 800a58a:	3306      	adds	r3, #6
 800a58c:	f107 012c 	add.w	r1, r7, #44	; 0x2c
 800a590:	5c89      	ldrb	r1, [r1, r2]
 800a592:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 800a596:	54d1      	strb	r1, [r2, r3]
		for (i = 0; i < valueLen; i++)
 800a598:	f8b7 336e 	ldrh.w	r3, [r7, #878]	; 0x36e
 800a59c:	3301      	adds	r3, #1
 800a59e:	f8a7 336e 	strh.w	r3, [r7, #878]	; 0x36e
 800a5a2:	f897 3368 	ldrb.w	r3, [r7, #872]	; 0x368
 800a5a6:	b29b      	uxth	r3, r3
 800a5a8:	f8b7 236e 	ldrh.w	r2, [r7, #878]	; 0x36e
 800a5ac:	429a      	cmp	r2, r3
 800a5ae:	d3e8      	bcc.n	800a582 <__FS_saveSystemSettingsInfo+0x9e>
		_fs_prepareSysSetStr(str, 2, valueLen);
 800a5b0:	f897 2368 	ldrb.w	r2, [r7, #872]	; 0x368
 800a5b4:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800a5b8:	2102      	movs	r1, #2
 800a5ba:	4618      	mov	r0, r3
 800a5bc:	f7ff fefd 	bl	800a3ba <_fs_prepareSysSetStr>
		_fs_attachStrings(str, " @ADC counts on one impulse\n", str, 240);
 800a5c0:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 800a5c4:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 800a5c8:	23f0      	movs	r3, #240	; 0xf0
 800a5ca:	494f      	ldr	r1, [pc, #316]	; (800a708 <__FS_saveSystemSettingsInfo+0x224>)
 800a5cc:	f7ff fd09 	bl	8009fe2 <_fs_attachStrings>
		f_puts(str, &file);
 800a5d0:	f507 729e 	add.w	r2, r7, #316	; 0x13c
 800a5d4:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800a5d8:	4611      	mov	r1, r2
 800a5da:	4618      	mov	r0, r3
 800a5dc:	f7fe f8db 	bl	8008796 <f_puts>
	}
	{ // saving min filtration value
		char valBuffer[16];
		uint16_t i;
		uint8_t valueLen = _fs_convertUint32ToChar(settings->minValueFiltration, valBuffer);
 800a5e0:	1d3b      	adds	r3, r7, #4
 800a5e2:	681b      	ldr	r3, [r3, #0]
 800a5e4:	889b      	ldrh	r3, [r3, #4]
 800a5e6:	461a      	mov	r2, r3
 800a5e8:	f107 031c 	add.w	r3, r7, #28
 800a5ec:	4619      	mov	r1, r3
 800a5ee:	4610      	mov	r0, r2
 800a5f0:	f7ff ff2e 	bl	800a450 <_fs_convertUint32ToChar>
 800a5f4:	4603      	mov	r3, r0
 800a5f6:	f887 3367 	strb.w	r3, [r7, #871]	; 0x367
		for (i = 0; i < valueLen; i++)
 800a5fa:	2300      	movs	r3, #0
 800a5fc:	f8a7 336c 	strh.w	r3, [r7, #876]	; 0x36c
 800a600:	e00f      	b.n	800a622 <__FS_saveSystemSettingsInfo+0x13e>
			str[6 + i] = valBuffer[i];
 800a602:	f8b7 236c 	ldrh.w	r2, [r7, #876]	; 0x36c
 800a606:	f8b7 336c 	ldrh.w	r3, [r7, #876]	; 0x36c
 800a60a:	3306      	adds	r3, #6
 800a60c:	f107 011c 	add.w	r1, r7, #28
 800a610:	5c89      	ldrb	r1, [r1, r2]
 800a612:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 800a616:	54d1      	strb	r1, [r2, r3]
		for (i = 0; i < valueLen; i++)
 800a618:	f8b7 336c 	ldrh.w	r3, [r7, #876]	; 0x36c
 800a61c:	3301      	adds	r3, #1
 800a61e:	f8a7 336c 	strh.w	r3, [r7, #876]	; 0x36c
 800a622:	f897 3367 	ldrb.w	r3, [r7, #871]	; 0x367
 800a626:	b29b      	uxth	r3, r3
 800a628:	f8b7 236c 	ldrh.w	r2, [r7, #876]	; 0x36c
 800a62c:	429a      	cmp	r2, r3
 800a62e:	d3e8      	bcc.n	800a602 <__FS_saveSystemSettingsInfo+0x11e>
		_fs_prepareSysSetStr(str, 3, valueLen);
 800a630:	f897 2367 	ldrb.w	r2, [r7, #871]	; 0x367
 800a634:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800a638:	2103      	movs	r1, #3
 800a63a:	4618      	mov	r0, r3
 800a63c:	f7ff febd 	bl	800a3ba <_fs_prepareSysSetStr>
		_fs_attachStrings(str, " @min filtration value\n", str, 240);
 800a640:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 800a644:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 800a648:	23f0      	movs	r3, #240	; 0xf0
 800a64a:	4930      	ldr	r1, [pc, #192]	; (800a70c <__FS_saveSystemSettingsInfo+0x228>)
 800a64c:	f7ff fcc9 	bl	8009fe2 <_fs_attachStrings>
		f_puts(str, &file);
 800a650:	f507 729e 	add.w	r2, r7, #316	; 0x13c
 800a654:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800a658:	4611      	mov	r1, r2
 800a65a:	4618      	mov	r0, r3
 800a65c:	f7fe f89b 	bl	8008796 <f_puts>
	}
	{ // saving max filtration value
		char valBuffer[16];
		uint16_t i;
		uint8_t valueLen = _fs_convertUint32ToChar(settings->maxValueFiltration, valBuffer);
 800a660:	1d3b      	adds	r3, r7, #4
 800a662:	681b      	ldr	r3, [r3, #0]
 800a664:	88db      	ldrh	r3, [r3, #6]
 800a666:	461a      	mov	r2, r3
 800a668:	f107 030c 	add.w	r3, r7, #12
 800a66c:	4619      	mov	r1, r3
 800a66e:	4610      	mov	r0, r2
 800a670:	f7ff feee 	bl	800a450 <_fs_convertUint32ToChar>
 800a674:	4603      	mov	r3, r0
 800a676:	f887 3366 	strb.w	r3, [r7, #870]	; 0x366
		for (i = 0; i < valueLen; i++)
 800a67a:	2300      	movs	r3, #0
 800a67c:	f8a7 336a 	strh.w	r3, [r7, #874]	; 0x36a
 800a680:	e00f      	b.n	800a6a2 <__FS_saveSystemSettingsInfo+0x1be>
			str[6 + i] = valBuffer[i];
 800a682:	f8b7 236a 	ldrh.w	r2, [r7, #874]	; 0x36a
 800a686:	f8b7 336a 	ldrh.w	r3, [r7, #874]	; 0x36a
 800a68a:	3306      	adds	r3, #6
 800a68c:	f107 010c 	add.w	r1, r7, #12
 800a690:	5c89      	ldrb	r1, [r1, r2]
 800a692:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 800a696:	54d1      	strb	r1, [r2, r3]
		for (i = 0; i < valueLen; i++)
 800a698:	f8b7 336a 	ldrh.w	r3, [r7, #874]	; 0x36a
 800a69c:	3301      	adds	r3, #1
 800a69e:	f8a7 336a 	strh.w	r3, [r7, #874]	; 0x36a
 800a6a2:	f897 3366 	ldrb.w	r3, [r7, #870]	; 0x366
 800a6a6:	b29b      	uxth	r3, r3
 800a6a8:	f8b7 236a 	ldrh.w	r2, [r7, #874]	; 0x36a
 800a6ac:	429a      	cmp	r2, r3
 800a6ae:	d3e8      	bcc.n	800a682 <__FS_saveSystemSettingsInfo+0x19e>
		_fs_prepareSysSetStr(str, 4, valueLen);
 800a6b0:	f897 2366 	ldrb.w	r2, [r7, #870]	; 0x366
 800a6b4:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800a6b8:	2104      	movs	r1, #4
 800a6ba:	4618      	mov	r0, r3
 800a6bc:	f7ff fe7d 	bl	800a3ba <_fs_prepareSysSetStr>
		_fs_attachStrings(str, " @max filtration value\n", str, 240);
 800a6c0:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 800a6c4:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 800a6c8:	23f0      	movs	r3, #240	; 0xf0
 800a6ca:	4911      	ldr	r1, [pc, #68]	; (800a710 <__FS_saveSystemSettingsInfo+0x22c>)
 800a6cc:	f7ff fc89 	bl	8009fe2 <_fs_attachStrings>
		f_puts(str, &file);
 800a6d0:	f507 729e 	add.w	r2, r7, #316	; 0x13c
 800a6d4:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800a6d8:	4611      	mov	r1, r2
 800a6da:	4618      	mov	r0, r3
 800a6dc:	f7fe f85b 	bl	8008796 <f_puts>
	}
	f_close(&file);
 800a6e0:	f507 739e 	add.w	r3, r7, #316	; 0x13c
 800a6e4:	4618      	mov	r0, r3
 800a6e6:	f7fd fdd7 	bl	8008298 <f_close>
 800a6ea:	e002      	b.n	800a6f2 <__FS_saveSystemSettingsInfo+0x20e>
		return;
 800a6ec:	bf00      	nop
 800a6ee:	e000      	b.n	800a6f2 <__FS_saveSystemSettingsInfo+0x20e>
		return;
 800a6f0:	bf00      	nop
}
 800a6f2:	f507 775c 	add.w	r7, r7, #880	; 0x370
 800a6f6:	46bd      	mov	sp, r7
 800a6f8:	bd80      	pop	{r7, pc}
 800a6fa:	bf00      	nop
 800a6fc:	20000e44 	.word	0x20000e44
 800a700:	08014c98 	.word	0x08014c98
 800a704:	08014ca4 	.word	0x08014ca4
 800a708:	08014cbc 	.word	0x08014cbc
 800a70c:	08014cdc 	.word	0x08014cdc
 800a710:	08014cf4 	.word	0x08014cf4

0800a714 <_fs_fromCharToUint8_t>:

static uint8_t _fs_fromCharToUint8_t (char c)
{
 800a714:	b480      	push	{r7}
 800a716:	b083      	sub	sp, #12
 800a718:	af00      	add	r7, sp, #0
 800a71a:	4603      	mov	r3, r0
 800a71c:	71fb      	strb	r3, [r7, #7]
	if (c >= '0' && c <= '9')
 800a71e:	79fb      	ldrb	r3, [r7, #7]
 800a720:	2b2f      	cmp	r3, #47	; 0x2f
 800a722:	d907      	bls.n	800a734 <_fs_fromCharToUint8_t+0x20>
 800a724:	79fb      	ldrb	r3, [r7, #7]
 800a726:	2b39      	cmp	r3, #57	; 0x39
 800a728:	d804      	bhi.n	800a734 <_fs_fromCharToUint8_t+0x20>
		return (c - 48) & 0x0F;
 800a72a:	79fb      	ldrb	r3, [r7, #7]
 800a72c:	f003 030f 	and.w	r3, r3, #15
 800a730:	b2db      	uxtb	r3, r3
 800a732:	e01a      	b.n	800a76a <_fs_fromCharToUint8_t+0x56>
	if (c >= 'a' && c <= 'z')
 800a734:	79fb      	ldrb	r3, [r7, #7]
 800a736:	2b60      	cmp	r3, #96	; 0x60
 800a738:	d909      	bls.n	800a74e <_fs_fromCharToUint8_t+0x3a>
 800a73a:	79fb      	ldrb	r3, [r7, #7]
 800a73c:	2b7a      	cmp	r3, #122	; 0x7a
 800a73e:	d806      	bhi.n	800a74e <_fs_fromCharToUint8_t+0x3a>
		return (c - 97 + 10) & 0x0F;
 800a740:	79fb      	ldrb	r3, [r7, #7]
 800a742:	3b57      	subs	r3, #87	; 0x57
 800a744:	b2db      	uxtb	r3, r3
 800a746:	f003 030f 	and.w	r3, r3, #15
 800a74a:	b2db      	uxtb	r3, r3
 800a74c:	e00d      	b.n	800a76a <_fs_fromCharToUint8_t+0x56>
	if (c >= 'A' && c <= 'Z')
 800a74e:	79fb      	ldrb	r3, [r7, #7]
 800a750:	2b40      	cmp	r3, #64	; 0x40
 800a752:	d909      	bls.n	800a768 <_fs_fromCharToUint8_t+0x54>
 800a754:	79fb      	ldrb	r3, [r7, #7]
 800a756:	2b5a      	cmp	r3, #90	; 0x5a
 800a758:	d806      	bhi.n	800a768 <_fs_fromCharToUint8_t+0x54>
		return (c - 65 + 10) & 0x0F;
 800a75a:	79fb      	ldrb	r3, [r7, #7]
 800a75c:	3b37      	subs	r3, #55	; 0x37
 800a75e:	b2db      	uxtb	r3, r3
 800a760:	f003 030f 	and.w	r3, r3, #15
 800a764:	b2db      	uxtb	r3, r3
 800a766:	e000      	b.n	800a76a <_fs_fromCharToUint8_t+0x56>
	return 0;
 800a768:	2300      	movs	r3, #0
}
 800a76a:	4618      	mov	r0, r3
 800a76c:	370c      	adds	r7, #12
 800a76e:	46bd      	mov	sp, r7
 800a770:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a774:	4770      	bx	lr

0800a776 <_fs_processCfgrDataString>:

static uint8_t _fs_processCfgrDataString(char *str, uint8_t *cmd, uint8_t *dataLen) // return value true - error, false - OK occured
{
 800a776:	b590      	push	{r4, r7, lr}
 800a778:	b087      	sub	sp, #28
 800a77a:	af00      	add	r7, sp, #0
 800a77c:	60f8      	str	r0, [r7, #12]
 800a77e:	60b9      	str	r1, [r7, #8]
 800a780:	607a      	str	r2, [r7, #4]
	uint16_t strLen = _fs_strLen(str);
 800a782:	68f8      	ldr	r0, [r7, #12]
 800a784:	f7ff fc0a 	bl	8009f9c <_fs_strLen>
 800a788:	4603      	mov	r3, r0
 800a78a:	82fb      	strh	r3, [r7, #22]
	if (strLen < 6)
 800a78c:	8afb      	ldrh	r3, [r7, #22]
 800a78e:	2b05      	cmp	r3, #5
 800a790:	d801      	bhi.n	800a796 <_fs_processCfgrDataString+0x20>
		return 1;
 800a792:	2301      	movs	r3, #1
 800a794:	e03e      	b.n	800a814 <_fs_processCfgrDataString+0x9e>
	if (str[0] != '#' || str[5] != '#')
 800a796:	68fb      	ldr	r3, [r7, #12]
 800a798:	781b      	ldrb	r3, [r3, #0]
 800a79a:	2b23      	cmp	r3, #35	; 0x23
 800a79c:	d104      	bne.n	800a7a8 <_fs_processCfgrDataString+0x32>
 800a79e:	68fb      	ldr	r3, [r7, #12]
 800a7a0:	3305      	adds	r3, #5
 800a7a2:	781b      	ldrb	r3, [r3, #0]
 800a7a4:	2b23      	cmp	r3, #35	; 0x23
 800a7a6:	d001      	beq.n	800a7ac <_fs_processCfgrDataString+0x36>
		return 1;
 800a7a8:	2301      	movs	r3, #1
 800a7aa:	e033      	b.n	800a814 <_fs_processCfgrDataString+0x9e>
	*cmd = (_fs_fromCharToUint8_t(str[1]) << 4) + _fs_fromCharToUint8_t(str[2]);
 800a7ac:	68fb      	ldr	r3, [r7, #12]
 800a7ae:	3301      	adds	r3, #1
 800a7b0:	781b      	ldrb	r3, [r3, #0]
 800a7b2:	4618      	mov	r0, r3
 800a7b4:	f7ff ffae 	bl	800a714 <_fs_fromCharToUint8_t>
 800a7b8:	4603      	mov	r3, r0
 800a7ba:	011b      	lsls	r3, r3, #4
 800a7bc:	b2dc      	uxtb	r4, r3
 800a7be:	68fb      	ldr	r3, [r7, #12]
 800a7c0:	3302      	adds	r3, #2
 800a7c2:	781b      	ldrb	r3, [r3, #0]
 800a7c4:	4618      	mov	r0, r3
 800a7c6:	f7ff ffa5 	bl	800a714 <_fs_fromCharToUint8_t>
 800a7ca:	4603      	mov	r3, r0
 800a7cc:	4423      	add	r3, r4
 800a7ce:	b2da      	uxtb	r2, r3
 800a7d0:	68bb      	ldr	r3, [r7, #8]
 800a7d2:	701a      	strb	r2, [r3, #0]
	*dataLen = (_fs_fromCharToUint8_t(str[3]) << 4) + _fs_fromCharToUint8_t(str[4]);
 800a7d4:	68fb      	ldr	r3, [r7, #12]
 800a7d6:	3303      	adds	r3, #3
 800a7d8:	781b      	ldrb	r3, [r3, #0]
 800a7da:	4618      	mov	r0, r3
 800a7dc:	f7ff ff9a 	bl	800a714 <_fs_fromCharToUint8_t>
 800a7e0:	4603      	mov	r3, r0
 800a7e2:	011b      	lsls	r3, r3, #4
 800a7e4:	b2dc      	uxtb	r4, r3
 800a7e6:	68fb      	ldr	r3, [r7, #12]
 800a7e8:	3304      	adds	r3, #4
 800a7ea:	781b      	ldrb	r3, [r3, #0]
 800a7ec:	4618      	mov	r0, r3
 800a7ee:	f7ff ff91 	bl	800a714 <_fs_fromCharToUint8_t>
 800a7f2:	4603      	mov	r3, r0
 800a7f4:	4423      	add	r3, r4
 800a7f6:	b2da      	uxtb	r2, r3
 800a7f8:	687b      	ldr	r3, [r7, #4]
 800a7fa:	701a      	strb	r2, [r3, #0]
	if (str[6 + (*dataLen)] != '#')
 800a7fc:	687b      	ldr	r3, [r7, #4]
 800a7fe:	781b      	ldrb	r3, [r3, #0]
 800a800:	3306      	adds	r3, #6
 800a802:	461a      	mov	r2, r3
 800a804:	68fb      	ldr	r3, [r7, #12]
 800a806:	4413      	add	r3, r2
 800a808:	781b      	ldrb	r3, [r3, #0]
 800a80a:	2b23      	cmp	r3, #35	; 0x23
 800a80c:	d001      	beq.n	800a812 <_fs_processCfgrDataString+0x9c>
		return 1;
 800a80e:	2301      	movs	r3, #1
 800a810:	e000      	b.n	800a814 <_fs_processCfgrDataString+0x9e>
	return 0;
 800a812:	2300      	movs	r3, #0
}
 800a814:	4618      	mov	r0, r3
 800a816:	371c      	adds	r7, #28
 800a818:	46bd      	mov	sp, r7
 800a81a:	bd90      	pop	{r4, r7, pc}

0800a81c <_fs_getUint32FromChar>:

static uint32_t _fs_getUint32FromChar(uint32_t defaultValue, char *buff)
{
 800a81c:	b480      	push	{r7}
 800a81e:	b085      	sub	sp, #20
 800a820:	af00      	add	r7, sp, #0
 800a822:	6078      	str	r0, [r7, #4]
 800a824:	6039      	str	r1, [r7, #0]
	uint32_t retValue = 0;
 800a826:	2300      	movs	r3, #0
 800a828:	60fb      	str	r3, [r7, #12]
	uint8_t i = 0;
 800a82a:	2300      	movs	r3, #0
 800a82c:	72fb      	strb	r3, [r7, #11]
	while(buff[i] >= '0' && buff[i] <= '9' && i < 10)
 800a82e:	e011      	b.n	800a854 <_fs_getUint32FromChar+0x38>
	{
		uint8_t actualValue = buff[i] - 48;
 800a830:	7afb      	ldrb	r3, [r7, #11]
 800a832:	683a      	ldr	r2, [r7, #0]
 800a834:	4413      	add	r3, r2
 800a836:	781b      	ldrb	r3, [r3, #0]
 800a838:	3b30      	subs	r3, #48	; 0x30
 800a83a:	72bb      	strb	r3, [r7, #10]
		retValue = retValue * 10 + actualValue;
 800a83c:	68fa      	ldr	r2, [r7, #12]
 800a83e:	4613      	mov	r3, r2
 800a840:	009b      	lsls	r3, r3, #2
 800a842:	4413      	add	r3, r2
 800a844:	005b      	lsls	r3, r3, #1
 800a846:	461a      	mov	r2, r3
 800a848:	7abb      	ldrb	r3, [r7, #10]
 800a84a:	4413      	add	r3, r2
 800a84c:	60fb      	str	r3, [r7, #12]
		++i;
 800a84e:	7afb      	ldrb	r3, [r7, #11]
 800a850:	3301      	adds	r3, #1
 800a852:	72fb      	strb	r3, [r7, #11]
	while(buff[i] >= '0' && buff[i] <= '9' && i < 10)
 800a854:	7afb      	ldrb	r3, [r7, #11]
 800a856:	683a      	ldr	r2, [r7, #0]
 800a858:	4413      	add	r3, r2
 800a85a:	781b      	ldrb	r3, [r3, #0]
 800a85c:	2b2f      	cmp	r3, #47	; 0x2f
 800a85e:	d908      	bls.n	800a872 <_fs_getUint32FromChar+0x56>
 800a860:	7afb      	ldrb	r3, [r7, #11]
 800a862:	683a      	ldr	r2, [r7, #0]
 800a864:	4413      	add	r3, r2
 800a866:	781b      	ldrb	r3, [r3, #0]
 800a868:	2b39      	cmp	r3, #57	; 0x39
 800a86a:	d802      	bhi.n	800a872 <_fs_getUint32FromChar+0x56>
 800a86c:	7afb      	ldrb	r3, [r7, #11]
 800a86e:	2b09      	cmp	r3, #9
 800a870:	d9de      	bls.n	800a830 <_fs_getUint32FromChar+0x14>
	}
	if (i == 10)
 800a872:	7afb      	ldrb	r3, [r7, #11]
 800a874:	2b0a      	cmp	r3, #10
 800a876:	d101      	bne.n	800a87c <_fs_getUint32FromChar+0x60>
		retValue = defaultValue;
 800a878:	687b      	ldr	r3, [r7, #4]
 800a87a:	60fb      	str	r3, [r7, #12]
	return retValue;
 800a87c:	68fb      	ldr	r3, [r7, #12]
}
 800a87e:	4618      	mov	r0, r3
 800a880:	3714      	adds	r7, #20
 800a882:	46bd      	mov	sp, r7
 800a884:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a888:	4770      	bx	lr
	...

0800a88c <__FS_downloadSystemSettingsInfo>:

void __FS_downloadSystemSettingsInfo (struct SystemSettings* settings)
{
 800a88c:	b580      	push	{r7, lr}
 800a88e:	f5ad 6d92 	sub.w	sp, sp, #1168	; 0x490
 800a892:	af00      	add	r7, sp, #0
 800a894:	1d3b      	adds	r3, r7, #4
 800a896:	6018      	str	r0, [r3, #0]
	if (!_SFS->_isInitialized)
 800a898:	4b7c      	ldr	r3, [pc, #496]	; (800aa8c <__FS_downloadSystemSettingsInfo+0x200>)
 800a89a:	681b      	ldr	r3, [r3, #0]
 800a89c:	781b      	ldrb	r3, [r3, #0]
 800a89e:	2b00      	cmp	r3, #0
 800a8a0:	f000 80ec 	beq.w	800aa7c <__FS_downloadSystemSettingsInfo+0x1f0>
		return;

	FILINFO fno;
	DIR dr;

	f_findfirst(&dr, &fno, "/", "cfgr.txt");
 800a8a4:	f507 715a 	add.w	r1, r7, #872	; 0x368
 800a8a8:	f507 704d 	add.w	r0, r7, #820	; 0x334
 800a8ac:	4b78      	ldr	r3, [pc, #480]	; (800aa90 <__FS_downloadSystemSettingsInfo+0x204>)
 800a8ae:	4a79      	ldr	r2, [pc, #484]	; (800aa94 <__FS_downloadSystemSettingsInfo+0x208>)
 800a8b0:	f7fd fdd0 	bl	8008454 <f_findfirst>
	if (fno.fname[0] == 0)
 800a8b4:	f507 735a 	add.w	r3, r7, #872	; 0x368
 800a8b8:	7d9b      	ldrb	r3, [r3, #22]
 800a8ba:	2b00      	cmp	r3, #0
 800a8bc:	d104      	bne.n	800a8c8 <__FS_downloadSystemSettingsInfo+0x3c>
	{
		__FS_saveSystemSettingsInfo(settings);
 800a8be:	1d3b      	adds	r3, r7, #4
 800a8c0:	6818      	ldr	r0, [r3, #0]
 800a8c2:	f7ff fe0f 	bl	800a4e4 <__FS_saveSystemSettingsInfo>
 800a8c6:	e0dc      	b.n	800aa82 <__FS_downloadSystemSettingsInfo+0x1f6>
	else
	{
		FIL file;
		char buff[256], *retValue;
		uint8_t cmd, dataLen;
		FRESULT res = f_open(&file, "cfgr.txt", FA_READ | FA_OPEN_EXISTING);
 800a8c8:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800a8cc:	2201      	movs	r2, #1
 800a8ce:	4970      	ldr	r1, [pc, #448]	; (800aa90 <__FS_downloadSystemSettingsInfo+0x204>)
 800a8d0:	4618      	mov	r0, r3
 800a8d2:	f7fd f83b 	bl	800794c <f_open>
 800a8d6:	4603      	mov	r3, r0
 800a8d8:	f887 348f 	strb.w	r3, [r7, #1167]	; 0x48f
		if (res != FR_OK)
 800a8dc:	f897 348f 	ldrb.w	r3, [r7, #1167]	; 0x48f
 800a8e0:	2b00      	cmp	r3, #0
 800a8e2:	f040 80cd 	bne.w	800aa80 <__FS_downloadSystemSettingsInfo+0x1f4>
			return;

		do
		{
			retValue = f_gets(buff, 250, &file);
 800a8e6:	f507 7284 	add.w	r2, r7, #264	; 0x108
 800a8ea:	f107 0308 	add.w	r3, r7, #8
 800a8ee:	21fa      	movs	r1, #250	; 0xfa
 800a8f0:	4618      	mov	r0, r3
 800a8f2:	f7fd fe9b 	bl	800862c <f_gets>
 800a8f6:	f8c7 0488 	str.w	r0, [r7, #1160]	; 0x488
			if (!retValue)
 800a8fa:	f8d7 3488 	ldr.w	r3, [r7, #1160]	; 0x488
 800a8fe:	2b00      	cmp	r3, #0
 800a900:	f000 80b5 	beq.w	800aa6e <__FS_downloadSystemSettingsInfo+0x1e2>
				break;
			if (!_fs_processCfgrDataString(buff, &cmd, &dataLen))
 800a904:	f207 3232 	addw	r2, r7, #818	; 0x332
 800a908:	f207 3133 	addw	r1, r7, #819	; 0x333
 800a90c:	f107 0308 	add.w	r3, r7, #8
 800a910:	4618      	mov	r0, r3
 800a912:	f7ff ff30 	bl	800a776 <_fs_processCfgrDataString>
 800a916:	4603      	mov	r3, r0
 800a918:	2b00      	cmp	r3, #0
 800a91a:	f040 8097 	bne.w	800aa4c <__FS_downloadSystemSettingsInfo+0x1c0>
			{
				switch (cmd)
 800a91e:	f207 3333 	addw	r3, r7, #819	; 0x333
 800a922:	781b      	ldrb	r3, [r3, #0]
 800a924:	3b01      	subs	r3, #1
 800a926:	2b03      	cmp	r3, #3
 800a928:	f200 8092 	bhi.w	800aa50 <__FS_downloadSystemSettingsInfo+0x1c4>
 800a92c:	a201      	add	r2, pc, #4	; (adr r2, 800a934 <__FS_downloadSystemSettingsInfo+0xa8>)
 800a92e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a932:	bf00      	nop
 800a934:	0800a945 	.word	0x0800a945
 800a938:	0800a9db 	.word	0x0800a9db
 800a93c:	0800aa0d 	.word	0x0800aa0d
 800a940:	0800aa2d 	.word	0x0800aa2d
				{
				case 1: // setting device name
					{
						if (dataLen != 2)
 800a944:	f207 3332 	addw	r3, r7, #818	; 0x332
 800a948:	781b      	ldrb	r3, [r3, #0]
 800a94a:	2b02      	cmp	r3, #2
 800a94c:	f040 8082 	bne.w	800aa54 <__FS_downloadSystemSettingsInfo+0x1c8>
							continue;
						char c1 = buff[6];
 800a950:	f107 0308 	add.w	r3, r7, #8
 800a954:	799b      	ldrb	r3, [r3, #6]
 800a956:	f887 3481 	strb.w	r3, [r7, #1153]	; 0x481
						char c2 = buff[7];
 800a95a:	f107 0308 	add.w	r3, r7, #8
 800a95e:	79db      	ldrb	r3, [r3, #7]
 800a960:	f887 3480 	strb.w	r3, [r7, #1152]	; 0x480
						if (!((c1 >= '0' && c1 <= '9') || (c1 >= 'a' && c1 <= 'z') || (c1 >= 'A' && c1 <= 'Z')))
 800a964:	f897 3481 	ldrb.w	r3, [r7, #1153]	; 0x481
 800a968:	2b2f      	cmp	r3, #47	; 0x2f
 800a96a:	d903      	bls.n	800a974 <__FS_downloadSystemSettingsInfo+0xe8>
 800a96c:	f897 3481 	ldrb.w	r3, [r7, #1153]	; 0x481
 800a970:	2b39      	cmp	r3, #57	; 0x39
 800a972:	d90f      	bls.n	800a994 <__FS_downloadSystemSettingsInfo+0x108>
 800a974:	f897 3481 	ldrb.w	r3, [r7, #1153]	; 0x481
 800a978:	2b60      	cmp	r3, #96	; 0x60
 800a97a:	d903      	bls.n	800a984 <__FS_downloadSystemSettingsInfo+0xf8>
 800a97c:	f897 3481 	ldrb.w	r3, [r7, #1153]	; 0x481
 800a980:	2b7a      	cmp	r3, #122	; 0x7a
 800a982:	d907      	bls.n	800a994 <__FS_downloadSystemSettingsInfo+0x108>
 800a984:	f897 3481 	ldrb.w	r3, [r7, #1153]	; 0x481
 800a988:	2b40      	cmp	r3, #64	; 0x40
 800a98a:	d965      	bls.n	800aa58 <__FS_downloadSystemSettingsInfo+0x1cc>
 800a98c:	f897 3481 	ldrb.w	r3, [r7, #1153]	; 0x481
 800a990:	2b5a      	cmp	r3, #90	; 0x5a
 800a992:	d861      	bhi.n	800aa58 <__FS_downloadSystemSettingsInfo+0x1cc>
							continue;
						if (!((c2 >= '0' && c2 <= '9') || (c2 >= 'a' && c2 <= 'z') || (c2 >= 'A' && c2 <= 'Z')))
 800a994:	f897 3480 	ldrb.w	r3, [r7, #1152]	; 0x480
 800a998:	2b2f      	cmp	r3, #47	; 0x2f
 800a99a:	d903      	bls.n	800a9a4 <__FS_downloadSystemSettingsInfo+0x118>
 800a99c:	f897 3480 	ldrb.w	r3, [r7, #1152]	; 0x480
 800a9a0:	2b39      	cmp	r3, #57	; 0x39
 800a9a2:	d90f      	bls.n	800a9c4 <__FS_downloadSystemSettingsInfo+0x138>
 800a9a4:	f897 3480 	ldrb.w	r3, [r7, #1152]	; 0x480
 800a9a8:	2b60      	cmp	r3, #96	; 0x60
 800a9aa:	d903      	bls.n	800a9b4 <__FS_downloadSystemSettingsInfo+0x128>
 800a9ac:	f897 3480 	ldrb.w	r3, [r7, #1152]	; 0x480
 800a9b0:	2b7a      	cmp	r3, #122	; 0x7a
 800a9b2:	d907      	bls.n	800a9c4 <__FS_downloadSystemSettingsInfo+0x138>
 800a9b4:	f897 3480 	ldrb.w	r3, [r7, #1152]	; 0x480
 800a9b8:	2b40      	cmp	r3, #64	; 0x40
 800a9ba:	d94f      	bls.n	800aa5c <__FS_downloadSystemSettingsInfo+0x1d0>
 800a9bc:	f897 3480 	ldrb.w	r3, [r7, #1152]	; 0x480
 800a9c0:	2b5a      	cmp	r3, #90	; 0x5a
 800a9c2:	d84b      	bhi.n	800aa5c <__FS_downloadSystemSettingsInfo+0x1d0>
							continue;
						settings->deviceNumber[0] = c1;
 800a9c4:	1d3b      	adds	r3, r7, #4
 800a9c6:	681b      	ldr	r3, [r3, #0]
 800a9c8:	f897 2481 	ldrb.w	r2, [r7, #1153]	; 0x481
 800a9cc:	701a      	strb	r2, [r3, #0]
						settings->deviceNumber[1] = c2;
 800a9ce:	1d3b      	adds	r3, r7, #4
 800a9d0:	681b      	ldr	r3, [r3, #0]
 800a9d2:	f897 2480 	ldrb.w	r2, [r7, #1152]	; 0x480
 800a9d6:	705a      	strb	r2, [r3, #1]
					}
					break;
 800a9d8:	e043      	b.n	800aa62 <__FS_downloadSystemSettingsInfo+0x1d6>
				case 2: // setting dma impulse counts
					{
						uint16_t dma_counts = _fs_getUint32FromChar(128, &buff[6]);
 800a9da:	f107 0308 	add.w	r3, r7, #8
 800a9de:	3306      	adds	r3, #6
 800a9e0:	4619      	mov	r1, r3
 800a9e2:	2080      	movs	r0, #128	; 0x80
 800a9e4:	f7ff ff1a 	bl	800a81c <_fs_getUint32FromChar>
 800a9e8:	4603      	mov	r3, r0
 800a9ea:	f8a7 3482 	strh.w	r3, [r7, #1154]	; 0x482
						if (dma_counts < 5 || dma_counts > 1000)
 800a9ee:	f8b7 3482 	ldrh.w	r3, [r7, #1154]	; 0x482
 800a9f2:	2b04      	cmp	r3, #4
 800a9f4:	d934      	bls.n	800aa60 <__FS_downloadSystemSettingsInfo+0x1d4>
 800a9f6:	f8b7 3482 	ldrh.w	r3, [r7, #1154]	; 0x482
 800a9fa:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800a9fe:	d82f      	bhi.n	800aa60 <__FS_downloadSystemSettingsInfo+0x1d4>
							continue;
						settings->countsToDma = dma_counts;
 800aa00:	1d3b      	adds	r3, r7, #4
 800aa02:	681b      	ldr	r3, [r3, #0]
 800aa04:	f8b7 2482 	ldrh.w	r2, [r7, #1154]	; 0x482
 800aa08:	805a      	strh	r2, [r3, #2]
					}
					break;
 800aa0a:	e02a      	b.n	800aa62 <__FS_downloadSystemSettingsInfo+0x1d6>
				case 3: // setting min filtration value
					{
						uint16_t val = _fs_getUint32FromChar(0, &buff[6]);
 800aa0c:	f107 0308 	add.w	r3, r7, #8
 800aa10:	3306      	adds	r3, #6
 800aa12:	4619      	mov	r1, r3
 800aa14:	2000      	movs	r0, #0
 800aa16:	f7ff ff01 	bl	800a81c <_fs_getUint32FromChar>
 800aa1a:	4603      	mov	r3, r0
 800aa1c:	f8a7 3484 	strh.w	r3, [r7, #1156]	; 0x484
						settings->minValueFiltration = val;
 800aa20:	1d3b      	adds	r3, r7, #4
 800aa22:	681b      	ldr	r3, [r3, #0]
 800aa24:	f8b7 2484 	ldrh.w	r2, [r7, #1156]	; 0x484
 800aa28:	809a      	strh	r2, [r3, #4]
					}
					break;
 800aa2a:	e01a      	b.n	800aa62 <__FS_downloadSystemSettingsInfo+0x1d6>
				case 4: // setting max filtration value
					{
						uint16_t val = _fs_getUint32FromChar(0, &buff[6]);
 800aa2c:	f107 0308 	add.w	r3, r7, #8
 800aa30:	3306      	adds	r3, #6
 800aa32:	4619      	mov	r1, r3
 800aa34:	2000      	movs	r0, #0
 800aa36:	f7ff fef1 	bl	800a81c <_fs_getUint32FromChar>
 800aa3a:	4603      	mov	r3, r0
 800aa3c:	f8a7 3486 	strh.w	r3, [r7, #1158]	; 0x486
						settings->maxValueFiltration = val;
 800aa40:	1d3b      	adds	r3, r7, #4
 800aa42:	681b      	ldr	r3, [r3, #0]
 800aa44:	f8b7 2486 	ldrh.w	r2, [r7, #1158]	; 0x486
 800aa48:	80da      	strh	r2, [r3, #6]
					}
					break;
 800aa4a:	e00a      	b.n	800aa62 <__FS_downloadSystemSettingsInfo+0x1d6>
				default:
					continue;
					break;
				}
			}
 800aa4c:	bf00      	nop
 800aa4e:	e008      	b.n	800aa62 <__FS_downloadSystemSettingsInfo+0x1d6>
					continue;
 800aa50:	bf00      	nop
 800aa52:	e006      	b.n	800aa62 <__FS_downloadSystemSettingsInfo+0x1d6>
							continue;
 800aa54:	bf00      	nop
 800aa56:	e004      	b.n	800aa62 <__FS_downloadSystemSettingsInfo+0x1d6>
							continue;
 800aa58:	bf00      	nop
 800aa5a:	e002      	b.n	800aa62 <__FS_downloadSystemSettingsInfo+0x1d6>
							continue;
 800aa5c:	bf00      	nop
 800aa5e:	e000      	b.n	800aa62 <__FS_downloadSystemSettingsInfo+0x1d6>
							continue;
 800aa60:	bf00      	nop
		} while(retValue);
 800aa62:	f8d7 3488 	ldr.w	r3, [r7, #1160]	; 0x488
 800aa66:	2b00      	cmp	r3, #0
 800aa68:	f47f af3d 	bne.w	800a8e6 <__FS_downloadSystemSettingsInfo+0x5a>
 800aa6c:	e000      	b.n	800aa70 <__FS_downloadSystemSettingsInfo+0x1e4>
				break;
 800aa6e:	bf00      	nop

		f_close(&file);
 800aa70:	f507 7384 	add.w	r3, r7, #264	; 0x108
 800aa74:	4618      	mov	r0, r3
 800aa76:	f7fd fc0f 	bl	8008298 <f_close>
 800aa7a:	e002      	b.n	800aa82 <__FS_downloadSystemSettingsInfo+0x1f6>
		return;
 800aa7c:	bf00      	nop
 800aa7e:	e000      	b.n	800aa82 <__FS_downloadSystemSettingsInfo+0x1f6>
			return;
 800aa80:	bf00      	nop
	}

}
 800aa82:	f507 6792 	add.w	r7, r7, #1168	; 0x490
 800aa86:	46bd      	mov	sp, r7
 800aa88:	bd80      	pop	{r7, pc}
 800aa8a:	bf00      	nop
 800aa8c:	20000e44 	.word	0x20000e44
 800aa90:	08014c98 	.word	0x08014c98
 800aa94:	08014c84 	.word	0x08014c84

0800aa98 <_init_fs_subsystem>:


void _init_fs_subsystem(struct _FS* fs)
{
 800aa98:	b480      	push	{r7}
 800aa9a:	b083      	sub	sp, #12
 800aa9c:	af00      	add	r7, sp, #0
 800aa9e:	6078      	str	r0, [r7, #4]
	_SFS = fs;
 800aaa0:	4a0e      	ldr	r2, [pc, #56]	; (800aadc <_init_fs_subsystem+0x44>)
 800aaa2:	687b      	ldr	r3, [r7, #4]
 800aaa4:	6013      	str	r3, [r2, #0]
	_SFS->_isInitialized = 0;
 800aaa6:	4b0d      	ldr	r3, [pc, #52]	; (800aadc <_init_fs_subsystem+0x44>)
 800aaa8:	681b      	ldr	r3, [r3, #0]
 800aaaa:	2200      	movs	r2, #0
 800aaac:	701a      	strb	r2, [r3, #0]
	_SFS->_initializationTime = 0xFFFFFFFF;
 800aaae:	4b0b      	ldr	r3, [pc, #44]	; (800aadc <_init_fs_subsystem+0x44>)
 800aab0:	681b      	ldr	r3, [r3, #0]
 800aab2:	f04f 32ff 	mov.w	r2, #4294967295
 800aab6:	605a      	str	r2, [r3, #4]
	fs->initialize = __FS_initialize;
 800aab8:	687b      	ldr	r3, [r7, #4]
 800aaba:	4a09      	ldr	r2, [pc, #36]	; (800aae0 <_init_fs_subsystem+0x48>)
 800aabc:	609a      	str	r2, [r3, #8]
	fs->saveRadInfo_csv = __FS_saveRadInfo_csv;
 800aabe:	687b      	ldr	r3, [r7, #4]
 800aac0:	4a08      	ldr	r2, [pc, #32]	; (800aae4 <_init_fs_subsystem+0x4c>)
 800aac2:	60da      	str	r2, [r3, #12]
	fs->saveSystemSettingsInfo = __FS_saveSystemSettingsInfo;
 800aac4:	687b      	ldr	r3, [r7, #4]
 800aac6:	4a08      	ldr	r2, [pc, #32]	; (800aae8 <_init_fs_subsystem+0x50>)
 800aac8:	615a      	str	r2, [r3, #20]
	fs->downloadSystemSettingsInfo = __FS_downloadSystemSettingsInfo;
 800aaca:	687b      	ldr	r3, [r7, #4]
 800aacc:	4a07      	ldr	r2, [pc, #28]	; (800aaec <_init_fs_subsystem+0x54>)
 800aace:	611a      	str	r2, [r3, #16]
}
 800aad0:	bf00      	nop
 800aad2:	370c      	adds	r7, #12
 800aad4:	46bd      	mov	sp, r7
 800aad6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aada:	4770      	bx	lr
 800aadc:	20000e44 	.word	0x20000e44
 800aae0:	0800a251 	.word	0x0800a251
 800aae4:	0800a2b5 	.word	0x0800a2b5
 800aae8:	0800a4e5 	.word	0x0800a4e5
 800aaec:	0800a88d 	.word	0x0800a88d

0800aaf0 <__rf_setConnected>:

struct _rf *RFS;


void __rf_setConnected (uint8_t connStatus)
{
 800aaf0:	b480      	push	{r7}
 800aaf2:	b083      	sub	sp, #12
 800aaf4:	af00      	add	r7, sp, #0
 800aaf6:	4603      	mov	r3, r0
 800aaf8:	71fb      	strb	r3, [r7, #7]
	RFS->isConnected = connStatus;
 800aafa:	4b05      	ldr	r3, [pc, #20]	; (800ab10 <__rf_setConnected+0x20>)
 800aafc:	681b      	ldr	r3, [r3, #0]
 800aafe:	79fa      	ldrb	r2, [r7, #7]
 800ab00:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81
	//GPIOB->ODR ^= GPIO_ODR_OD1;
	// PROCESS DISCONNECTION !!!!!!!!!
}
 800ab04:	bf00      	nop
 800ab06:	370c      	adds	r7, #12
 800ab08:	46bd      	mov	sp, r7
 800ab0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ab0e:	4770      	bx	lr
 800ab10:	2000101c 	.word	0x2000101c

0800ab14 <__rf_processFirstCharWrite>:


void __rf_processFirstCharWrite (uint8_t* data, uint16_t dataLength) // finished
{
 800ab14:	b580      	push	{r7, lr}
 800ab16:	b084      	sub	sp, #16
 800ab18:	af00      	add	r7, sp, #0
 800ab1a:	6078      	str	r0, [r7, #4]
 800ab1c:	460b      	mov	r3, r1
 800ab1e:	807b      	strh	r3, [r7, #2]
	uint8_t i;
	if (dataLength > 20)
 800ab20:	887b      	ldrh	r3, [r7, #2]
 800ab22:	2b14      	cmp	r3, #20
 800ab24:	d901      	bls.n	800ab2a <__rf_processFirstCharWrite+0x16>
		dataLength = 20;
 800ab26:	2314      	movs	r3, #20
 800ab28:	807b      	strh	r3, [r7, #2]
	for (i = 0; i < dataLength; i++)
 800ab2a:	2300      	movs	r3, #0
 800ab2c:	73fb      	strb	r3, [r7, #15]
 800ab2e:	e00d      	b.n	800ab4c <__rf_processFirstCharWrite+0x38>
		RFS->p_mcu_cmd_dat[i] = data[i];
 800ab30:	7bfb      	ldrb	r3, [r7, #15]
 800ab32:	687a      	ldr	r2, [r7, #4]
 800ab34:	18d1      	adds	r1, r2, r3
 800ab36:	4b0f      	ldr	r3, [pc, #60]	; (800ab74 <__rf_processFirstCharWrite+0x60>)
 800ab38:	681a      	ldr	r2, [r3, #0]
 800ab3a:	7bfb      	ldrb	r3, [r7, #15]
 800ab3c:	7809      	ldrb	r1, [r1, #0]
 800ab3e:	4413      	add	r3, r2
 800ab40:	460a      	mov	r2, r1
 800ab42:	f883 2083 	strb.w	r2, [r3, #131]	; 0x83
	for (i = 0; i < dataLength; i++)
 800ab46:	7bfb      	ldrb	r3, [r7, #15]
 800ab48:	3301      	adds	r3, #1
 800ab4a:	73fb      	strb	r3, [r7, #15]
 800ab4c:	7bfb      	ldrb	r3, [r7, #15]
 800ab4e:	b29b      	uxth	r3, r3
 800ab50:	887a      	ldrh	r2, [r7, #2]
 800ab52:	429a      	cmp	r2, r3
 800ab54:	d8ec      	bhi.n	800ab30 <__rf_processFirstCharWrite+0x1c>
	RFS->p_mcu_cmd_len = dataLength;
 800ab56:	4b07      	ldr	r3, [pc, #28]	; (800ab74 <__rf_processFirstCharWrite+0x60>)
 800ab58:	681b      	ldr	r3, [r3, #0]
 800ab5a:	887a      	ldrh	r2, [r7, #2]
 800ab5c:	b2d2      	uxtb	r2, r2
 800ab5e:	f883 2082 	strb.w	r2, [r3, #130]	; 0x82
	UTIL_SEQ_SetTask(1 << USER_TASK_PROCESS_FCW, CFG_SCH_PRIO_0);
 800ab62:	2100      	movs	r1, #0
 800ab64:	2010      	movs	r0, #16
 800ab66:	f009 feeb 	bl	8014940 <UTIL_SEQ_SetTask>
}
 800ab6a:	bf00      	nop
 800ab6c:	3710      	adds	r7, #16
 800ab6e:	46bd      	mov	sp, r7
 800ab70:	bd80      	pop	{r7, pc}
 800ab72:	bf00      	nop
 800ab74:	2000101c 	.word	0x2000101c

0800ab78 <__rf_processSecondCharWrite>:

void __rf_processSecondCharWrite (uint8_t* data, uint16_t dataLength) // finished
{
 800ab78:	b580      	push	{r7, lr}
 800ab7a:	b084      	sub	sp, #16
 800ab7c:	af00      	add	r7, sp, #0
 800ab7e:	6078      	str	r0, [r7, #4]
 800ab80:	460b      	mov	r3, r1
 800ab82:	807b      	strh	r3, [r7, #2]
	uint8_t i;
	if (dataLength > 240)
 800ab84:	887b      	ldrh	r3, [r7, #2]
 800ab86:	2bf0      	cmp	r3, #240	; 0xf0
 800ab88:	d901      	bls.n	800ab8e <__rf_processSecondCharWrite+0x16>
		dataLength = 240;
 800ab8a:	23f0      	movs	r3, #240	; 0xf0
 800ab8c:	807b      	strh	r3, [r7, #2]
	for (i = 0; i < dataLength; i++)
 800ab8e:	2300      	movs	r3, #0
 800ab90:	73fb      	strb	r3, [r7, #15]
 800ab92:	e00d      	b.n	800abb0 <__rf_processSecondCharWrite+0x38>
		RFS->p_mcu_data_dat[i] = data[i];
 800ab94:	7bfb      	ldrb	r3, [r7, #15]
 800ab96:	687a      	ldr	r2, [r7, #4]
 800ab98:	18d1      	adds	r1, r2, r3
 800ab9a:	4b0f      	ldr	r3, [pc, #60]	; (800abd8 <__rf_processSecondCharWrite+0x60>)
 800ab9c:	681a      	ldr	r2, [r3, #0]
 800ab9e:	7bfb      	ldrb	r3, [r7, #15]
 800aba0:	7809      	ldrb	r1, [r1, #0]
 800aba2:	4413      	add	r3, r2
 800aba4:	460a      	mov	r2, r1
 800aba6:	f883 2099 	strb.w	r2, [r3, #153]	; 0x99
	for (i = 0; i < dataLength; i++)
 800abaa:	7bfb      	ldrb	r3, [r7, #15]
 800abac:	3301      	adds	r3, #1
 800abae:	73fb      	strb	r3, [r7, #15]
 800abb0:	7bfb      	ldrb	r3, [r7, #15]
 800abb2:	b29b      	uxth	r3, r3
 800abb4:	887a      	ldrh	r2, [r7, #2]
 800abb6:	429a      	cmp	r2, r3
 800abb8:	d8ec      	bhi.n	800ab94 <__rf_processSecondCharWrite+0x1c>
	RFS->p_mcu_data_len = dataLength;
 800abba:	4b07      	ldr	r3, [pc, #28]	; (800abd8 <__rf_processSecondCharWrite+0x60>)
 800abbc:	681b      	ldr	r3, [r3, #0]
 800abbe:	887a      	ldrh	r2, [r7, #2]
 800abc0:	b2d2      	uxtb	r2, r2
 800abc2:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
	UTIL_SEQ_SetTask(1 << USER_TASK_PROCESS_SCW, CFG_SCH_PRIO_0);
 800abc6:	2100      	movs	r1, #0
 800abc8:	2020      	movs	r0, #32
 800abca:	f009 feb9 	bl	8014940 <UTIL_SEQ_SetTask>
}
 800abce:	bf00      	nop
 800abd0:	3710      	adds	r7, #16
 800abd2:	46bd      	mov	sp, r7
 800abd4:	bd80      	pop	{r7, pc}
 800abd6:	bf00      	nop
 800abd8:	2000101c 	.word	0x2000101c

0800abdc <__rf_processNotification>:

void __rf_processNotification (enum NotificationChar charNotification, uint8_t isEnabled)
{
 800abdc:	b480      	push	{r7}
 800abde:	b083      	sub	sp, #12
 800abe0:	af00      	add	r7, sp, #0
 800abe2:	4603      	mov	r3, r0
 800abe4:	460a      	mov	r2, r1
 800abe6:	71fb      	strb	r3, [r7, #7]
 800abe8:	4613      	mov	r3, r2
 800abea:	71bb      	strb	r3, [r7, #6]
	//GPIOB->ODR ^= GPIO_ODR_OD1;
	switch(charNotification)
 800abec:	79fb      	ldrb	r3, [r7, #7]
 800abee:	2b02      	cmp	r3, #2
 800abf0:	d005      	beq.n	800abfe <__rf_processNotification+0x22>
 800abf2:	2b02      	cmp	r3, #2
 800abf4:	dc06      	bgt.n	800ac04 <__rf_processNotification+0x28>
 800abf6:	2b00      	cmp	r3, #0
 800abf8:	d003      	beq.n	800ac02 <__rf_processNotification+0x26>
 800abfa:	2b01      	cmp	r3, #1
	{
	case _MCU_P_CPS_NC:
		break;

	case _MCU_P_DATA_NC:
		break;
 800abfc:	e002      	b.n	800ac04 <__rf_processNotification+0x28>

	case _MCU_P_SPCB_NC:
		break;
 800abfe:	bf00      	nop
 800ac00:	e000      	b.n	800ac04 <__rf_processNotification+0x28>
		break;
 800ac02:	bf00      	nop
	}
}
 800ac04:	bf00      	nop
 800ac06:	370c      	adds	r7, #12
 800ac08:	46bd      	mov	sp, r7
 800ac0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ac0e:	4770      	bx	lr

0800ac10 <__rf_updateCpsChar>:

void __rf_updateCpsChar (uint32_t cpsValue) // finished
{
 800ac10:	b580      	push	{r7, lr}
 800ac12:	b082      	sub	sp, #8
 800ac14:	af00      	add	r7, sp, #0
 800ac16:	6078      	str	r0, [r7, #4]
	RFS->mcu_p_CPS_dat[0] = (uint8_t)((uint32_t) cpsValue >> 24);
 800ac18:	687b      	ldr	r3, [r7, #4]
 800ac1a:	0e1a      	lsrs	r2, r3, #24
 800ac1c:	4b10      	ldr	r3, [pc, #64]	; (800ac60 <__rf_updateCpsChar+0x50>)
 800ac1e:	681b      	ldr	r3, [r3, #0]
 800ac20:	b2d2      	uxtb	r2, r2
 800ac22:	f883 218e 	strb.w	r2, [r3, #398]	; 0x18e
	RFS->mcu_p_CPS_dat[1] = (uint8_t)((uint32_t) cpsValue >> 16);
 800ac26:	687b      	ldr	r3, [r7, #4]
 800ac28:	0c1a      	lsrs	r2, r3, #16
 800ac2a:	4b0d      	ldr	r3, [pc, #52]	; (800ac60 <__rf_updateCpsChar+0x50>)
 800ac2c:	681b      	ldr	r3, [r3, #0]
 800ac2e:	b2d2      	uxtb	r2, r2
 800ac30:	f883 218f 	strb.w	r2, [r3, #399]	; 0x18f
	RFS->mcu_p_CPS_dat[2] = (uint8_t)((uint32_t) cpsValue >> 8);
 800ac34:	687b      	ldr	r3, [r7, #4]
 800ac36:	0a1a      	lsrs	r2, r3, #8
 800ac38:	4b09      	ldr	r3, [pc, #36]	; (800ac60 <__rf_updateCpsChar+0x50>)
 800ac3a:	681b      	ldr	r3, [r3, #0]
 800ac3c:	b2d2      	uxtb	r2, r2
 800ac3e:	f883 2190 	strb.w	r2, [r3, #400]	; 0x190
	RFS->mcu_p_CPS_dat[3] = (uint8_t)cpsValue;
 800ac42:	4b07      	ldr	r3, [pc, #28]	; (800ac60 <__rf_updateCpsChar+0x50>)
 800ac44:	681b      	ldr	r3, [r3, #0]
 800ac46:	687a      	ldr	r2, [r7, #4]
 800ac48:	b2d2      	uxtb	r2, r2
 800ac4a:	f883 2191 	strb.w	r2, [r3, #401]	; 0x191
	UTIL_SEQ_SetTask(1 << USER_TASK_UPDATE_CPS_CHAR, CFG_SCH_PRIO_0);
 800ac4e:	2100      	movs	r1, #0
 800ac50:	2008      	movs	r0, #8
 800ac52:	f009 fe75 	bl	8014940 <UTIL_SEQ_SetTask>
}
 800ac56:	bf00      	nop
 800ac58:	3708      	adds	r7, #8
 800ac5a:	46bd      	mov	sp, r7
 800ac5c:	bd80      	pop	{r7, pc}
 800ac5e:	bf00      	nop
 800ac60:	2000101c 	.word	0x2000101c

0800ac64 <_init_rf_subsystem>:


void _init_rf_subsystem(struct _rf *RF) // finished
{
 800ac64:	b480      	push	{r7}
 800ac66:	b083      	sub	sp, #12
 800ac68:	af00      	add	r7, sp, #0
 800ac6a:	6078      	str	r0, [r7, #4]
	RFS = RF;
 800ac6c:	4a1a      	ldr	r2, [pc, #104]	; (800acd8 <_init_rf_subsystem+0x74>)
 800ac6e:	687b      	ldr	r3, [r7, #4]
 800ac70:	6013      	str	r3, [r2, #0]
	RFS->isConnected = 0;
 800ac72:	4b19      	ldr	r3, [pc, #100]	; (800acd8 <_init_rf_subsystem+0x74>)
 800ac74:	681b      	ldr	r3, [r3, #0]
 800ac76:	2200      	movs	r2, #0
 800ac78:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81
	RFS->p_mcu_cmd_len = 0;
 800ac7c:	4b16      	ldr	r3, [pc, #88]	; (800acd8 <_init_rf_subsystem+0x74>)
 800ac7e:	681b      	ldr	r3, [r3, #0]
 800ac80:	2200      	movs	r2, #0
 800ac82:	f883 2082 	strb.w	r2, [r3, #130]	; 0x82
	RFS->p_mcu_data_len = 0;
 800ac86:	4b14      	ldr	r3, [pc, #80]	; (800acd8 <_init_rf_subsystem+0x74>)
 800ac88:	681b      	ldr	r3, [r3, #0]
 800ac8a:	2200      	movs	r2, #0
 800ac8c:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
	RFS->ErrStatusesLen = 0;
 800ac90:	4b11      	ldr	r3, [pc, #68]	; (800acd8 <_init_rf_subsystem+0x74>)
 800ac92:	681b      	ldr	r3, [r3, #0]
 800ac94:	2200      	movs	r2, #0
 800ac96:	701a      	strb	r2, [r3, #0]
	RFS->setConnected = __rf_setConnected;
 800ac98:	4b0f      	ldr	r3, [pc, #60]	; (800acd8 <_init_rf_subsystem+0x74>)
 800ac9a:	681b      	ldr	r3, [r3, #0]
 800ac9c:	4a0f      	ldr	r2, [pc, #60]	; (800acdc <_init_rf_subsystem+0x78>)
 800ac9e:	f8c3 22ac 	str.w	r2, [r3, #684]	; 0x2ac
	RFS->processFirstCharWrite = __rf_processFirstCharWrite;
 800aca2:	4b0d      	ldr	r3, [pc, #52]	; (800acd8 <_init_rf_subsystem+0x74>)
 800aca4:	681b      	ldr	r3, [r3, #0]
 800aca6:	4a0e      	ldr	r2, [pc, #56]	; (800ace0 <_init_rf_subsystem+0x7c>)
 800aca8:	f8c3 22b0 	str.w	r2, [r3, #688]	; 0x2b0
	RFS->processSecondCharWrite = __rf_processSecondCharWrite;
 800acac:	4b0a      	ldr	r3, [pc, #40]	; (800acd8 <_init_rf_subsystem+0x74>)
 800acae:	681b      	ldr	r3, [r3, #0]
 800acb0:	4a0c      	ldr	r2, [pc, #48]	; (800ace4 <_init_rf_subsystem+0x80>)
 800acb2:	f8c3 22b4 	str.w	r2, [r3, #692]	; 0x2b4
	RFS->processNotification = __rf_processNotification;
 800acb6:	4b08      	ldr	r3, [pc, #32]	; (800acd8 <_init_rf_subsystem+0x74>)
 800acb8:	681b      	ldr	r3, [r3, #0]
 800acba:	4a0b      	ldr	r2, [pc, #44]	; (800ace8 <_init_rf_subsystem+0x84>)
 800acbc:	f8c3 22b8 	str.w	r2, [r3, #696]	; 0x2b8
	RFS->updateCpsChar = __rf_updateCpsChar;
 800acc0:	4b05      	ldr	r3, [pc, #20]	; (800acd8 <_init_rf_subsystem+0x74>)
 800acc2:	681b      	ldr	r3, [r3, #0]
 800acc4:	4a09      	ldr	r2, [pc, #36]	; (800acec <_init_rf_subsystem+0x88>)
 800acc6:	f8c3 22bc 	str.w	r2, [r3, #700]	; 0x2bc
}
 800acca:	bf00      	nop
 800accc:	370c      	adds	r7, #12
 800acce:	46bd      	mov	sp, r7
 800acd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800acd4:	4770      	bx	lr
 800acd6:	bf00      	nop
 800acd8:	2000101c 	.word	0x2000101c
 800acdc:	0800aaf1 	.word	0x0800aaf1
 800ace0:	0800ab15 	.word	0x0800ab15
 800ace4:	0800ab79 	.word	0x0800ab79
 800ace8:	0800abdd 	.word	0x0800abdd
 800acec:	0800ac11 	.word	0x0800ac11

0800acf0 <__rad_startComp>:
#include "radiation_subsystem.h"

static struct _rad *_RAD;

void __rad_startComp (void)
{
 800acf0:	b480      	push	{r7}
 800acf2:	af00      	add	r7, sp, #0
	COMP2->CSR |= COMP_CSR_EN;
 800acf4:	4b05      	ldr	r3, [pc, #20]	; (800ad0c <__rad_startComp+0x1c>)
 800acf6:	681b      	ldr	r3, [r3, #0]
 800acf8:	4a04      	ldr	r2, [pc, #16]	; (800ad0c <__rad_startComp+0x1c>)
 800acfa:	f043 0301 	orr.w	r3, r3, #1
 800acfe:	6013      	str	r3, [r2, #0]
}
 800ad00:	bf00      	nop
 800ad02:	46bd      	mov	sp, r7
 800ad04:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ad08:	4770      	bx	lr
 800ad0a:	bf00      	nop
 800ad0c:	40010204 	.word	0x40010204

0800ad10 <__rad_stopComp>:

void __rad_stopComp (void)
{
 800ad10:	b480      	push	{r7}
 800ad12:	af00      	add	r7, sp, #0
	COMP2->CSR &= ~COMP_CSR_EN;
 800ad14:	4b05      	ldr	r3, [pc, #20]	; (800ad2c <__rad_stopComp+0x1c>)
 800ad16:	681b      	ldr	r3, [r3, #0]
 800ad18:	4a04      	ldr	r2, [pc, #16]	; (800ad2c <__rad_stopComp+0x1c>)
 800ad1a:	f023 0301 	bic.w	r3, r3, #1
 800ad1e:	6013      	str	r3, [r2, #0]
}
 800ad20:	bf00      	nop
 800ad22:	46bd      	mov	sp, r7
 800ad24:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ad28:	4770      	bx	lr
 800ad2a:	bf00      	nop
 800ad2c:	40010204 	.word	0x40010204

0800ad30 <__rad_calculateMaxValue>:

uint16_t __rad_calculateMaxValue (uint16_t* mas, uint16_t len)
{
 800ad30:	b480      	push	{r7}
 800ad32:	b085      	sub	sp, #20
 800ad34:	af00      	add	r7, sp, #0
 800ad36:	6078      	str	r0, [r7, #4]
 800ad38:	460b      	mov	r3, r1
 800ad3a:	807b      	strh	r3, [r7, #2]
	uint16_t max_val = mas[0];
 800ad3c:	687b      	ldr	r3, [r7, #4]
 800ad3e:	881b      	ldrh	r3, [r3, #0]
 800ad40:	81fb      	strh	r3, [r7, #14]
	uint8_t returnCounter = 0;
 800ad42:	2300      	movs	r3, #0
 800ad44:	737b      	strb	r3, [r7, #13]
	for (uint16_t i = 1; i < len; i++)
 800ad46:	2301      	movs	r3, #1
 800ad48:	817b      	strh	r3, [r7, #10]
 800ad4a:	e019      	b.n	800ad80 <__rad_calculateMaxValue+0x50>
	{
		if (mas[i] > max_val)
 800ad4c:	897b      	ldrh	r3, [r7, #10]
 800ad4e:	005b      	lsls	r3, r3, #1
 800ad50:	687a      	ldr	r2, [r7, #4]
 800ad52:	4413      	add	r3, r2
 800ad54:	881b      	ldrh	r3, [r3, #0]
 800ad56:	89fa      	ldrh	r2, [r7, #14]
 800ad58:	429a      	cmp	r2, r3
 800ad5a:	d208      	bcs.n	800ad6e <__rad_calculateMaxValue+0x3e>
		{
			max_val = mas[i];
 800ad5c:	897b      	ldrh	r3, [r7, #10]
 800ad5e:	005b      	lsls	r3, r3, #1
 800ad60:	687a      	ldr	r2, [r7, #4]
 800ad62:	4413      	add	r3, r2
 800ad64:	881b      	ldrh	r3, [r3, #0]
 800ad66:	81fb      	strh	r3, [r7, #14]
			returnCounter = 0;
 800ad68:	2300      	movs	r3, #0
 800ad6a:	737b      	strb	r3, [r7, #13]
 800ad6c:	e002      	b.n	800ad74 <__rad_calculateMaxValue+0x44>
		}
		else
			++returnCounter;
 800ad6e:	7b7b      	ldrb	r3, [r7, #13]
 800ad70:	3301      	adds	r3, #1
 800ad72:	737b      	strb	r3, [r7, #13]
		if (returnCounter >= 3)
 800ad74:	7b7b      	ldrb	r3, [r7, #13]
 800ad76:	2b02      	cmp	r3, #2
 800ad78:	d807      	bhi.n	800ad8a <__rad_calculateMaxValue+0x5a>
	for (uint16_t i = 1; i < len; i++)
 800ad7a:	897b      	ldrh	r3, [r7, #10]
 800ad7c:	3301      	adds	r3, #1
 800ad7e:	817b      	strh	r3, [r7, #10]
 800ad80:	897a      	ldrh	r2, [r7, #10]
 800ad82:	887b      	ldrh	r3, [r7, #2]
 800ad84:	429a      	cmp	r2, r3
 800ad86:	d3e1      	bcc.n	800ad4c <__rad_calculateMaxValue+0x1c>
 800ad88:	e000      	b.n	800ad8c <__rad_calculateMaxValue+0x5c>
			break;
 800ad8a:	bf00      	nop
	}
	max_val &= 0x0FFF;
 800ad8c:	89fb      	ldrh	r3, [r7, #14]
 800ad8e:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800ad92:	81fb      	strh	r3, [r7, #14]
	return max_val;
 800ad94:	89fb      	ldrh	r3, [r7, #14]
}
 800ad96:	4618      	mov	r0, r3
 800ad98:	3714      	adds	r7, #20
 800ad9a:	46bd      	mov	sp, r7
 800ad9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ada0:	4770      	bx	lr
	...

0800ada4 <__rad_clearSpectrogramm>:

void __rad_clearSpectrogramm (void)
{
 800ada4:	b480      	push	{r7}
 800ada6:	b083      	sub	sp, #12
 800ada8:	af00      	add	r7, sp, #0
	for (uint16_t i = 0; i < 4096; i++)
 800adaa:	2300      	movs	r3, #0
 800adac:	80fb      	strh	r3, [r7, #6]
 800adae:	e008      	b.n	800adc2 <__rad_clearSpectrogramm+0x1e>
		_RAD->_spectrogram[i] = 0;
 800adb0:	4b09      	ldr	r3, [pc, #36]	; (800add8 <__rad_clearSpectrogramm+0x34>)
 800adb2:	681b      	ldr	r3, [r3, #0]
 800adb4:	88fa      	ldrh	r2, [r7, #6]
 800adb6:	2100      	movs	r1, #0
 800adb8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	for (uint16_t i = 0; i < 4096; i++)
 800adbc:	88fb      	ldrh	r3, [r7, #6]
 800adbe:	3301      	adds	r3, #1
 800adc0:	80fb      	strh	r3, [r7, #6]
 800adc2:	88fb      	ldrh	r3, [r7, #6]
 800adc4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800adc8:	d3f2      	bcc.n	800adb0 <__rad_clearSpectrogramm+0xc>
}
 800adca:	bf00      	nop
 800adcc:	bf00      	nop
 800adce:	370c      	adds	r7, #12
 800add0:	46bd      	mov	sp, r7
 800add2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800add6:	4770      	bx	lr
 800add8:	20000ee0 	.word	0x20000ee0

0800addc <_init_rad_subsystem>:

void _init_rad_subsystem(struct _rad *rad)
{
 800addc:	b580      	push	{r7, lr}
 800adde:	b082      	sub	sp, #8
 800ade0:	af00      	add	r7, sp, #0
 800ade2:	6078      	str	r0, [r7, #4]
	_RAD = rad;
 800ade4:	4a16      	ldr	r2, [pc, #88]	; (800ae40 <_init_rad_subsystem+0x64>)
 800ade6:	687b      	ldr	r3, [r7, #4]
 800ade8:	6013      	str	r3, [r2, #0]
	__rad_clearSpectrogramm();
 800adea:	f7ff ffdb 	bl	800ada4 <__rad_clearSpectrogramm>
	_RAD->_cps = 0;
 800adee:	4b14      	ldr	r3, [pc, #80]	; (800ae40 <_init_rad_subsystem+0x64>)
 800adf0:	681b      	ldr	r3, [r3, #0]
 800adf2:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 800adf6:	2200      	movs	r2, #0
 800adf8:	601a      	str	r2, [r3, #0]
	rad->_saveTime = 0xFFFFFFFF;
 800adfa:	687b      	ldr	r3, [r7, #4]
 800adfc:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 800ae00:	3304      	adds	r3, #4
 800ae02:	f04f 32ff 	mov.w	r2, #4294967295
 800ae06:	601a      	str	r2, [r3, #0]
	rad->startComp = __rad_startComp;
 800ae08:	687b      	ldr	r3, [r7, #4]
 800ae0a:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 800ae0e:	3308      	adds	r3, #8
 800ae10:	4a0c      	ldr	r2, [pc, #48]	; (800ae44 <_init_rad_subsystem+0x68>)
 800ae12:	601a      	str	r2, [r3, #0]
	rad->stopComp = __rad_stopComp;
 800ae14:	687b      	ldr	r3, [r7, #4]
 800ae16:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 800ae1a:	330c      	adds	r3, #12
 800ae1c:	4a0a      	ldr	r2, [pc, #40]	; (800ae48 <_init_rad_subsystem+0x6c>)
 800ae1e:	601a      	str	r2, [r3, #0]
	rad->calculateMaxValue = __rad_calculateMaxValue;
 800ae20:	687b      	ldr	r3, [r7, #4]
 800ae22:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 800ae26:	3310      	adds	r3, #16
 800ae28:	4a08      	ldr	r2, [pc, #32]	; (800ae4c <_init_rad_subsystem+0x70>)
 800ae2a:	601a      	str	r2, [r3, #0]
	rad->clearSpectrogramm = __rad_clearSpectrogramm;
 800ae2c:	687b      	ldr	r3, [r7, #4]
 800ae2e:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 800ae32:	3314      	adds	r3, #20
 800ae34:	4a06      	ldr	r2, [pc, #24]	; (800ae50 <_init_rad_subsystem+0x74>)
 800ae36:	601a      	str	r2, [r3, #0]
}
 800ae38:	bf00      	nop
 800ae3a:	3708      	adds	r7, #8
 800ae3c:	46bd      	mov	sp, r7
 800ae3e:	bd80      	pop	{r7, pc}
 800ae40:	20000ee0 	.word	0x20000ee0
 800ae44:	0800acf1 	.word	0x0800acf1
 800ae48:	0800ad11 	.word	0x0800ad11
 800ae4c:	0800ad31 	.word	0x0800ad31
 800ae50:	0800ada5 	.word	0x0800ada5

0800ae54 <InitSystemStructure>:
#include "System.h"

System sys;

void InitSystemStructure(void)
{
 800ae54:	b580      	push	{r7, lr}
 800ae56:	af00      	add	r7, sp, #0
	_init_uSD_subsystem(&sys.uSD);
 800ae58:	480f      	ldr	r0, [pc, #60]	; (800ae98 <InitSystemStructure+0x44>)
 800ae5a:	f000 fc4f 	bl	800b6fc <_init_uSD_subsystem>
	_init_tim16_subsystem(&sys.tim16);
 800ae5e:	480f      	ldr	r0, [pc, #60]	; (800ae9c <InitSystemStructure+0x48>)
 800ae60:	f000 f908 	bl	800b074 <_init_tim16_subsystem>
	_init_adc_subsystem(&sys.adc);
 800ae64:	480e      	ldr	r0, [pc, #56]	; (800aea0 <InitSystemStructure+0x4c>)
 800ae66:	f7ff f805 	bl	8009e74 <_init_adc_subsystem>
	_init_dma_dubsystem(&sys.dma);
 800ae6a:	480e      	ldr	r0, [pc, #56]	; (800aea4 <InitSystemStructure+0x50>)
 800ae6c:	f7ff f87c 	bl	8009f68 <_init_dma_dubsystem>
	_init_fs_subsystem(&sys.fs);
 800ae70:	480d      	ldr	r0, [pc, #52]	; (800aea8 <InitSystemStructure+0x54>)
 800ae72:	f7ff fe11 	bl	800aa98 <_init_fs_subsystem>
	_init_tim17_subsystem(&sys.tim17);
 800ae76:	480d      	ldr	r0, [pc, #52]	; (800aeac <InitSystemStructure+0x58>)
 800ae78:	f000 f9de 	bl	800b238 <_init_tim17_subsystem>
	_init_rad_subsystem(&sys.rad);
 800ae7c:	480c      	ldr	r0, [pc, #48]	; (800aeb0 <InitSystemStructure+0x5c>)
 800ae7e:	f7ff ffad 	bl	800addc <_init_rad_subsystem>
	_init_rf_subsystem(&sys.rf);
 800ae82:	480c      	ldr	r0, [pc, #48]	; (800aeb4 <InitSystemStructure+0x60>)
 800ae84:	f7ff feee 	bl	800ac64 <_init_rf_subsystem>
	_init_tim2_subsystem(&sys.tim2);
 800ae88:	480b      	ldr	r0, [pc, #44]	; (800aeb8 <InitSystemStructure+0x64>)
 800ae8a:	f000 facb 	bl	800b424 <_init_tim2_subsystem>

	_init_system_settings(&sys.settings);
 800ae8e:	480b      	ldr	r0, [pc, #44]	; (800aebc <InitSystemStructure+0x68>)
 800ae90:	f000 f816 	bl	800aec0 <_init_system_settings>
}
 800ae94:	bf00      	nop
 800ae96:	bd80      	pop	{r7, pc}
 800ae98:	20001038 	.word	0x20001038
 800ae9c:	20001058 	.word	0x20001058
 800aea0:	20001084 	.word	0x20001084
 800aea4:	200010a4 	.word	0x200010a4
 800aea8:	20001020 	.word	0x20001020
 800aeac:	20001074 	.word	0x20001074
 800aeb0:	200010ac 	.word	0x200010ac
 800aeb4:	200050c4 	.word	0x200050c4
 800aeb8:	20001044 	.word	0x20001044
 800aebc:	20005384 	.word	0x20005384

0800aec0 <_init_system_settings>:
#include "SystemSettings.h"

void _init_system_settings(struct SystemSettings *settings)
{
 800aec0:	b480      	push	{r7}
 800aec2:	b083      	sub	sp, #12
 800aec4:	af00      	add	r7, sp, #0
 800aec6:	6078      	str	r0, [r7, #4]
	settings->countsToDma = 128;
 800aec8:	687b      	ldr	r3, [r7, #4]
 800aeca:	2280      	movs	r2, #128	; 0x80
 800aecc:	805a      	strh	r2, [r3, #2]
	settings->deviceNumber[0] = 'X';
 800aece:	687b      	ldr	r3, [r7, #4]
 800aed0:	2258      	movs	r2, #88	; 0x58
 800aed2:	701a      	strb	r2, [r3, #0]
	settings->deviceNumber[1] = 'X';
 800aed4:	687b      	ldr	r3, [r7, #4]
 800aed6:	2258      	movs	r2, #88	; 0x58
 800aed8:	705a      	strb	r2, [r3, #1]
	settings->minValueFiltration = 0;
 800aeda:	687b      	ldr	r3, [r7, #4]
 800aedc:	2200      	movs	r2, #0
 800aede:	809a      	strh	r2, [r3, #4]
	settings->maxValueFiltration = 0xFFFF;
 800aee0:	687b      	ldr	r3, [r7, #4]
 800aee2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800aee6:	80da      	strh	r2, [r3, #6]
}
 800aee8:	bf00      	nop
 800aeea:	370c      	adds	r7, #12
 800aeec:	46bd      	mov	sp, r7
 800aeee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aef2:	4770      	bx	lr

0800aef4 <___dummyDelay>:
#include "TIM16_subsystem.h"

static uint8_t ___dumm = 0;

static void ___dummyDelay(void)
{
 800aef4:	b480      	push	{r7}
 800aef6:	af00      	add	r7, sp, #0
	++___dumm;
 800aef8:	4b05      	ldr	r3, [pc, #20]	; (800af10 <___dummyDelay+0x1c>)
 800aefa:	781b      	ldrb	r3, [r3, #0]
 800aefc:	3301      	adds	r3, #1
 800aefe:	b2da      	uxtb	r2, r3
 800af00:	4b03      	ldr	r3, [pc, #12]	; (800af10 <___dummyDelay+0x1c>)
 800af02:	701a      	strb	r2, [r3, #0]
}
 800af04:	bf00      	nop
 800af06:	46bd      	mov	sp, r7
 800af08:	f85d 7b04 	ldr.w	r7, [sp], #4
 800af0c:	4770      	bx	lr
 800af0e:	bf00      	nop
 800af10:	20000ee4 	.word	0x20000ee4

0800af14 <___tim16_updatePscArrCntRegisters>:

static void ___tim16_updatePscArrCntRegisters (void)
{
 800af14:	b580      	push	{r7, lr}
 800af16:	af00      	add	r7, sp, #0
	TIM16->CNT = 0;
 800af18:	4b09      	ldr	r3, [pc, #36]	; (800af40 <___tim16_updatePscArrCntRegisters+0x2c>)
 800af1a:	2200      	movs	r2, #0
 800af1c:	625a      	str	r2, [r3, #36]	; 0x24
	TIM16->EGR |= TIM_EGR_UG;
 800af1e:	4b08      	ldr	r3, [pc, #32]	; (800af40 <___tim16_updatePscArrCntRegisters+0x2c>)
 800af20:	695b      	ldr	r3, [r3, #20]
 800af22:	4a07      	ldr	r2, [pc, #28]	; (800af40 <___tim16_updatePscArrCntRegisters+0x2c>)
 800af24:	f043 0301 	orr.w	r3, r3, #1
 800af28:	6153      	str	r3, [r2, #20]
	___dummyDelay();
 800af2a:	f7ff ffe3 	bl	800aef4 <___dummyDelay>
	TIM16->SR &= ~TIM_SR_UIF;
 800af2e:	4b04      	ldr	r3, [pc, #16]	; (800af40 <___tim16_updatePscArrCntRegisters+0x2c>)
 800af30:	691b      	ldr	r3, [r3, #16]
 800af32:	4a03      	ldr	r2, [pc, #12]	; (800af40 <___tim16_updatePscArrCntRegisters+0x2c>)
 800af34:	f023 0301 	bic.w	r3, r3, #1
 800af38:	6113      	str	r3, [r2, #16]
}
 800af3a:	bf00      	nop
 800af3c:	bd80      	pop	{r7, pc}
 800af3e:	bf00      	nop
 800af40:	40014400 	.word	0x40014400

0800af44 <__tim16_initTimer>:

void __tim16_initTimer (void)
{
 800af44:	b580      	push	{r7, lr}
 800af46:	af00      	add	r7, sp, #0
	RCC->APB2ENR |= RCC_APB2ENR_TIM16EN;
 800af48:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800af4c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800af4e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800af52:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800af56:	6613      	str	r3, [r2, #96]	; 0x60
	___dummyDelay();
 800af58:	f7ff ffcc 	bl	800aef4 <___dummyDelay>
	TIM16->CR1 |= TIM_CR1_OPM;
 800af5c:	4b08      	ldr	r3, [pc, #32]	; (800af80 <__tim16_initTimer+0x3c>)
 800af5e:	681b      	ldr	r3, [r3, #0]
 800af60:	4a07      	ldr	r2, [pc, #28]	; (800af80 <__tim16_initTimer+0x3c>)
 800af62:	f043 0308 	orr.w	r3, r3, #8
 800af66:	6013      	str	r3, [r2, #0]
	TIM16->PSC = (uint16_t) 64000 - 1;
 800af68:	4b05      	ldr	r3, [pc, #20]	; (800af80 <__tim16_initTimer+0x3c>)
 800af6a:	f64f 12ff 	movw	r2, #63999	; 0xf9ff
 800af6e:	629a      	str	r2, [r3, #40]	; 0x28
	TIM16->ARR = (uint16_t) 32000;
 800af70:	4b03      	ldr	r3, [pc, #12]	; (800af80 <__tim16_initTimer+0x3c>)
 800af72:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
 800af76:	62da      	str	r2, [r3, #44]	; 0x2c
	___tim16_updatePscArrCntRegisters();
 800af78:	f7ff ffcc 	bl	800af14 <___tim16_updatePscArrCntRegisters>
}
 800af7c:	bf00      	nop
 800af7e:	bd80      	pop	{r7, pc}
 800af80:	40014400 	.word	0x40014400

0800af84 <__tim16_setPrescalerValue>:
void __tim16_setPrescalerValue (uint16_t val)
{
 800af84:	b480      	push	{r7}
 800af86:	b083      	sub	sp, #12
 800af88:	af00      	add	r7, sp, #0
 800af8a:	4603      	mov	r3, r0
 800af8c:	80fb      	strh	r3, [r7, #6]
	TIM16->PSC = val - 1;
 800af8e:	88fb      	ldrh	r3, [r7, #6]
 800af90:	1e5a      	subs	r2, r3, #1
 800af92:	4b04      	ldr	r3, [pc, #16]	; (800afa4 <__tim16_setPrescalerValue+0x20>)
 800af94:	629a      	str	r2, [r3, #40]	; 0x28
}
 800af96:	bf00      	nop
 800af98:	370c      	adds	r7, #12
 800af9a:	46bd      	mov	sp, r7
 800af9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800afa0:	4770      	bx	lr
 800afa2:	bf00      	nop
 800afa4:	40014400 	.word	0x40014400

0800afa8 <__tim16_setCounterValue>:

void __tim16_setCounterValue (uint16_t val)
{
 800afa8:	b580      	push	{r7, lr}
 800afaa:	b082      	sub	sp, #8
 800afac:	af00      	add	r7, sp, #0
 800afae:	4603      	mov	r3, r0
 800afb0:	80fb      	strh	r3, [r7, #6]
	TIM16->CR1 &= ~TIM_CR1_CEN;
 800afb2:	4b08      	ldr	r3, [pc, #32]	; (800afd4 <__tim16_setCounterValue+0x2c>)
 800afb4:	681b      	ldr	r3, [r3, #0]
 800afb6:	4a07      	ldr	r2, [pc, #28]	; (800afd4 <__tim16_setCounterValue+0x2c>)
 800afb8:	f023 0301 	bic.w	r3, r3, #1
 800afbc:	6013      	str	r3, [r2, #0]
	TIM16->ARR = val - 1;
 800afbe:	88fb      	ldrh	r3, [r7, #6]
 800afc0:	1e5a      	subs	r2, r3, #1
 800afc2:	4b04      	ldr	r3, [pc, #16]	; (800afd4 <__tim16_setCounterValue+0x2c>)
 800afc4:	62da      	str	r2, [r3, #44]	; 0x2c
	___tim16_updatePscArrCntRegisters();
 800afc6:	f7ff ffa5 	bl	800af14 <___tim16_updatePscArrCntRegisters>
}
 800afca:	bf00      	nop
 800afcc:	3708      	adds	r7, #8
 800afce:	46bd      	mov	sp, r7
 800afd0:	bd80      	pop	{r7, pc}
 800afd2:	bf00      	nop
 800afd4:	40014400 	.word	0x40014400

0800afd8 <__tim16_startTimer>:

void __tim16_startTimer(void)
{
 800afd8:	b480      	push	{r7}
 800afda:	af00      	add	r7, sp, #0
	TIM16->CR1 |= TIM_CR1_CEN;
 800afdc:	4b05      	ldr	r3, [pc, #20]	; (800aff4 <__tim16_startTimer+0x1c>)
 800afde:	681b      	ldr	r3, [r3, #0]
 800afe0:	4a04      	ldr	r2, [pc, #16]	; (800aff4 <__tim16_startTimer+0x1c>)
 800afe2:	f043 0301 	orr.w	r3, r3, #1
 800afe6:	6013      	str	r3, [r2, #0]
}
 800afe8:	bf00      	nop
 800afea:	46bd      	mov	sp, r7
 800afec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aff0:	4770      	bx	lr
 800aff2:	bf00      	nop
 800aff4:	40014400 	.word	0x40014400

0800aff8 <__tim16_isCounting>:

uint8_t __tim16_isCounting (void)
{
 800aff8:	b480      	push	{r7}
 800affa:	af00      	add	r7, sp, #0
	return (TIM16->CR1 & TIM_CR1_CEN)?0x01:0x00;
 800affc:	4b06      	ldr	r3, [pc, #24]	; (800b018 <__tim16_isCounting+0x20>)
 800affe:	681b      	ldr	r3, [r3, #0]
 800b000:	f003 0301 	and.w	r3, r3, #1
 800b004:	2b00      	cmp	r3, #0
 800b006:	bf14      	ite	ne
 800b008:	2301      	movne	r3, #1
 800b00a:	2300      	moveq	r3, #0
 800b00c:	b2db      	uxtb	r3, r3
}
 800b00e:	4618      	mov	r0, r3
 800b010:	46bd      	mov	sp, r7
 800b012:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b016:	4770      	bx	lr
 800b018:	40014400 	.word	0x40014400

0800b01c <__tim16_hasCounted_clearUIFflag>:

uint8_t __tim16_hasCounted_clearUIFflag (void)
{
 800b01c:	b480      	push	{r7}
 800b01e:	b083      	sub	sp, #12
 800b020:	af00      	add	r7, sp, #0
	uint8_t retval = (TIM16->SR & TIM_SR_UIF)?0x01:0x00;
 800b022:	4b0b      	ldr	r3, [pc, #44]	; (800b050 <__tim16_hasCounted_clearUIFflag+0x34>)
 800b024:	691b      	ldr	r3, [r3, #16]
 800b026:	f003 0301 	and.w	r3, r3, #1
 800b02a:	2b00      	cmp	r3, #0
 800b02c:	bf14      	ite	ne
 800b02e:	2301      	movne	r3, #1
 800b030:	2300      	moveq	r3, #0
 800b032:	b2db      	uxtb	r3, r3
 800b034:	71fb      	strb	r3, [r7, #7]
	TIM16->SR &= ~TIM_SR_UIF;
 800b036:	4b06      	ldr	r3, [pc, #24]	; (800b050 <__tim16_hasCounted_clearUIFflag+0x34>)
 800b038:	691b      	ldr	r3, [r3, #16]
 800b03a:	4a05      	ldr	r2, [pc, #20]	; (800b050 <__tim16_hasCounted_clearUIFflag+0x34>)
 800b03c:	f023 0301 	bic.w	r3, r3, #1
 800b040:	6113      	str	r3, [r2, #16]
	return retval;
 800b042:	79fb      	ldrb	r3, [r7, #7]
}
 800b044:	4618      	mov	r0, r3
 800b046:	370c      	adds	r7, #12
 800b048:	46bd      	mov	sp, r7
 800b04a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b04e:	4770      	bx	lr
 800b050:	40014400 	.word	0x40014400

0800b054 <__tim16_stopTimer>:

void __tim16_stopTimer (void)
{
 800b054:	b480      	push	{r7}
 800b056:	af00      	add	r7, sp, #0
	TIM16->CR1 &= ~TIM_CR1_CEN;
 800b058:	4b05      	ldr	r3, [pc, #20]	; (800b070 <__tim16_stopTimer+0x1c>)
 800b05a:	681b      	ldr	r3, [r3, #0]
 800b05c:	4a04      	ldr	r2, [pc, #16]	; (800b070 <__tim16_stopTimer+0x1c>)
 800b05e:	f023 0301 	bic.w	r3, r3, #1
 800b062:	6013      	str	r3, [r2, #0]
}
 800b064:	bf00      	nop
 800b066:	46bd      	mov	sp, r7
 800b068:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b06c:	4770      	bx	lr
 800b06e:	bf00      	nop
 800b070:	40014400 	.word	0x40014400

0800b074 <_init_tim16_subsystem>:


void _init_tim16_subsystem(struct _tim16 *timer)
{
 800b074:	b480      	push	{r7}
 800b076:	b083      	sub	sp, #12
 800b078:	af00      	add	r7, sp, #0
 800b07a:	6078      	str	r0, [r7, #4]
	timer->initTimer = __tim16_initTimer;
 800b07c:	687b      	ldr	r3, [r7, #4]
 800b07e:	4a0d      	ldr	r2, [pc, #52]	; (800b0b4 <_init_tim16_subsystem+0x40>)
 800b080:	601a      	str	r2, [r3, #0]
	timer->setPrescalerValue = __tim16_setPrescalerValue;
 800b082:	687b      	ldr	r3, [r7, #4]
 800b084:	4a0c      	ldr	r2, [pc, #48]	; (800b0b8 <_init_tim16_subsystem+0x44>)
 800b086:	605a      	str	r2, [r3, #4]
	timer->setCounterValue = __tim16_setCounterValue;
 800b088:	687b      	ldr	r3, [r7, #4]
 800b08a:	4a0c      	ldr	r2, [pc, #48]	; (800b0bc <_init_tim16_subsystem+0x48>)
 800b08c:	609a      	str	r2, [r3, #8]
	timer->startTimer = __tim16_startTimer;
 800b08e:	687b      	ldr	r3, [r7, #4]
 800b090:	4a0b      	ldr	r2, [pc, #44]	; (800b0c0 <_init_tim16_subsystem+0x4c>)
 800b092:	60da      	str	r2, [r3, #12]
	timer->isCounting = __tim16_isCounting;
 800b094:	687b      	ldr	r3, [r7, #4]
 800b096:	4a0b      	ldr	r2, [pc, #44]	; (800b0c4 <_init_tim16_subsystem+0x50>)
 800b098:	611a      	str	r2, [r3, #16]
	timer->hasCounted_clearUIFflag = __tim16_hasCounted_clearUIFflag;
 800b09a:	687b      	ldr	r3, [r7, #4]
 800b09c:	4a0a      	ldr	r2, [pc, #40]	; (800b0c8 <_init_tim16_subsystem+0x54>)
 800b09e:	615a      	str	r2, [r3, #20]
	timer->stopTimer = __tim16_stopTimer;
 800b0a0:	687b      	ldr	r3, [r7, #4]
 800b0a2:	4a0a      	ldr	r2, [pc, #40]	; (800b0cc <_init_tim16_subsystem+0x58>)
 800b0a4:	619a      	str	r2, [r3, #24]
}
 800b0a6:	bf00      	nop
 800b0a8:	370c      	adds	r7, #12
 800b0aa:	46bd      	mov	sp, r7
 800b0ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b0b0:	4770      	bx	lr
 800b0b2:	bf00      	nop
 800b0b4:	0800af45 	.word	0x0800af45
 800b0b8:	0800af85 	.word	0x0800af85
 800b0bc:	0800afa9 	.word	0x0800afa9
 800b0c0:	0800afd9 	.word	0x0800afd9
 800b0c4:	0800aff9 	.word	0x0800aff9
 800b0c8:	0800b01d 	.word	0x0800b01d
 800b0cc:	0800b055 	.word	0x0800b055

0800b0d0 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800b0d0:	b480      	push	{r7}
 800b0d2:	b083      	sub	sp, #12
 800b0d4:	af00      	add	r7, sp, #0
 800b0d6:	4603      	mov	r3, r0
 800b0d8:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800b0da:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800b0de:	2b00      	cmp	r3, #0
 800b0e0:	db0b      	blt.n	800b0fa <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800b0e2:	79fb      	ldrb	r3, [r7, #7]
 800b0e4:	f003 021f 	and.w	r2, r3, #31
 800b0e8:	4907      	ldr	r1, [pc, #28]	; (800b108 <__NVIC_EnableIRQ+0x38>)
 800b0ea:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800b0ee:	095b      	lsrs	r3, r3, #5
 800b0f0:	2001      	movs	r0, #1
 800b0f2:	fa00 f202 	lsl.w	r2, r0, r2
 800b0f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 800b0fa:	bf00      	nop
 800b0fc:	370c      	adds	r7, #12
 800b0fe:	46bd      	mov	sp, r7
 800b100:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b104:	4770      	bx	lr
 800b106:	bf00      	nop
 800b108:	e000e100 	.word	0xe000e100

0800b10c <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800b10c:	b480      	push	{r7}
 800b10e:	b083      	sub	sp, #12
 800b110:	af00      	add	r7, sp, #0
 800b112:	4603      	mov	r3, r0
 800b114:	6039      	str	r1, [r7, #0]
 800b116:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800b118:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800b11c:	2b00      	cmp	r3, #0
 800b11e:	db0a      	blt.n	800b136 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b120:	683b      	ldr	r3, [r7, #0]
 800b122:	b2da      	uxtb	r2, r3
 800b124:	490c      	ldr	r1, [pc, #48]	; (800b158 <__NVIC_SetPriority+0x4c>)
 800b126:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800b12a:	0112      	lsls	r2, r2, #4
 800b12c:	b2d2      	uxtb	r2, r2
 800b12e:	440b      	add	r3, r1
 800b130:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 800b134:	e00a      	b.n	800b14c <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b136:	683b      	ldr	r3, [r7, #0]
 800b138:	b2da      	uxtb	r2, r3
 800b13a:	4908      	ldr	r1, [pc, #32]	; (800b15c <__NVIC_SetPriority+0x50>)
 800b13c:	79fb      	ldrb	r3, [r7, #7]
 800b13e:	f003 030f 	and.w	r3, r3, #15
 800b142:	3b04      	subs	r3, #4
 800b144:	0112      	lsls	r2, r2, #4
 800b146:	b2d2      	uxtb	r2, r2
 800b148:	440b      	add	r3, r1
 800b14a:	761a      	strb	r2, [r3, #24]
}
 800b14c:	bf00      	nop
 800b14e:	370c      	adds	r7, #12
 800b150:	46bd      	mov	sp, r7
 800b152:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b156:	4770      	bx	lr
 800b158:	e000e100 	.word	0xe000e100
 800b15c:	e000ed00 	.word	0xe000ed00

0800b160 <___dDelay>:


static volatile uint8_t ___dm = 0;

static void ___dDelay(void)
{
 800b160:	b480      	push	{r7}
 800b162:	af00      	add	r7, sp, #0
	++___dm;
 800b164:	4b05      	ldr	r3, [pc, #20]	; (800b17c <___dDelay+0x1c>)
 800b166:	781b      	ldrb	r3, [r3, #0]
 800b168:	b2db      	uxtb	r3, r3
 800b16a:	3301      	adds	r3, #1
 800b16c:	b2da      	uxtb	r2, r3
 800b16e:	4b03      	ldr	r3, [pc, #12]	; (800b17c <___dDelay+0x1c>)
 800b170:	701a      	strb	r2, [r3, #0]
}
 800b172:	bf00      	nop
 800b174:	46bd      	mov	sp, r7
 800b176:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b17a:	4770      	bx	lr
 800b17c:	20000ee5 	.word	0x20000ee5

0800b180 <__tim17_initialize>:

void __tim17_initialize (void)
{
 800b180:	b580      	push	{r7, lr}
 800b182:	af00      	add	r7, sp, #0
	RCC->APB2ENR |= RCC_APB2ENR_TIM17EN;
 800b184:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800b188:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800b18a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800b18e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800b192:	6613      	str	r3, [r2, #96]	; 0x60
	___dDelay();
 800b194:	f7ff ffe4 	bl	800b160 <___dDelay>
	
	TIM17->PSC = (uint16_t) 64000 - 1;
 800b198:	4b16      	ldr	r3, [pc, #88]	; (800b1f4 <__tim17_initialize+0x74>)
 800b19a:	f64f 12ff 	movw	r2, #63999	; 0xf9ff
 800b19e:	629a      	str	r2, [r3, #40]	; 0x28
	TIM17->ARR = (uint16_t) 1000;
 800b1a0:	4b14      	ldr	r3, [pc, #80]	; (800b1f4 <__tim17_initialize+0x74>)
 800b1a2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800b1a6:	62da      	str	r2, [r3, #44]	; 0x2c
	
	TIM17->CR1 |= TIM_CR1_URS | TIM_CR1_OPM;
 800b1a8:	4b12      	ldr	r3, [pc, #72]	; (800b1f4 <__tim17_initialize+0x74>)
 800b1aa:	681b      	ldr	r3, [r3, #0]
 800b1ac:	4a11      	ldr	r2, [pc, #68]	; (800b1f4 <__tim17_initialize+0x74>)
 800b1ae:	f043 030c 	orr.w	r3, r3, #12
 800b1b2:	6013      	str	r3, [r2, #0]
	
	TIM17->CNT = 0;
 800b1b4:	4b0f      	ldr	r3, [pc, #60]	; (800b1f4 <__tim17_initialize+0x74>)
 800b1b6:	2200      	movs	r2, #0
 800b1b8:	625a      	str	r2, [r3, #36]	; 0x24
	TIM17->EGR |= TIM_EGR_UG;
 800b1ba:	4b0e      	ldr	r3, [pc, #56]	; (800b1f4 <__tim17_initialize+0x74>)
 800b1bc:	695b      	ldr	r3, [r3, #20]
 800b1be:	4a0d      	ldr	r2, [pc, #52]	; (800b1f4 <__tim17_initialize+0x74>)
 800b1c0:	f043 0301 	orr.w	r3, r3, #1
 800b1c4:	6153      	str	r3, [r2, #20]
	___dDelay();
 800b1c6:	f7ff ffcb 	bl	800b160 <___dDelay>
	TIM17->SR &= ~TIM_SR_UIF;
 800b1ca:	4b0a      	ldr	r3, [pc, #40]	; (800b1f4 <__tim17_initialize+0x74>)
 800b1cc:	691b      	ldr	r3, [r3, #16]
 800b1ce:	4a09      	ldr	r2, [pc, #36]	; (800b1f4 <__tim17_initialize+0x74>)
 800b1d0:	f023 0301 	bic.w	r3, r3, #1
 800b1d4:	6113      	str	r3, [r2, #16]
	NVIC_SetPriority(TIM1_TRG_COM_TIM17_IRQn, 1);
 800b1d6:	2101      	movs	r1, #1
 800b1d8:	201a      	movs	r0, #26
 800b1da:	f7ff ff97 	bl	800b10c <__NVIC_SetPriority>
	NVIC_EnableIRQ(TIM1_TRG_COM_TIM17_IRQn);
 800b1de:	201a      	movs	r0, #26
 800b1e0:	f7ff ff76 	bl	800b0d0 <__NVIC_EnableIRQ>
	TIM17->DIER |= TIM_DIER_UIE;
 800b1e4:	4b03      	ldr	r3, [pc, #12]	; (800b1f4 <__tim17_initialize+0x74>)
 800b1e6:	68db      	ldr	r3, [r3, #12]
 800b1e8:	4a02      	ldr	r2, [pc, #8]	; (800b1f4 <__tim17_initialize+0x74>)
 800b1ea:	f043 0301 	orr.w	r3, r3, #1
 800b1ee:	60d3      	str	r3, [r2, #12]
}
 800b1f0:	bf00      	nop
 800b1f2:	bd80      	pop	{r7, pc}
 800b1f4:	40014800 	.word	0x40014800

0800b1f8 <__tim17_turnOn>:

void __tim17_turnOn (void)
{
 800b1f8:	b480      	push	{r7}
 800b1fa:	af00      	add	r7, sp, #0
	TIM17->CR1 |= TIM_CR1_CEN;
 800b1fc:	4b05      	ldr	r3, [pc, #20]	; (800b214 <__tim17_turnOn+0x1c>)
 800b1fe:	681b      	ldr	r3, [r3, #0]
 800b200:	4a04      	ldr	r2, [pc, #16]	; (800b214 <__tim17_turnOn+0x1c>)
 800b202:	f043 0301 	orr.w	r3, r3, #1
 800b206:	6013      	str	r3, [r2, #0]
}
 800b208:	bf00      	nop
 800b20a:	46bd      	mov	sp, r7
 800b20c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b210:	4770      	bx	lr
 800b212:	bf00      	nop
 800b214:	40014800 	.word	0x40014800

0800b218 <__tim17_turnOff>:

void __tim17_turnOff (void)
{
 800b218:	b480      	push	{r7}
 800b21a:	af00      	add	r7, sp, #0
	TIM17->CR1 &= ~TIM_CR1_CEN;
 800b21c:	4b05      	ldr	r3, [pc, #20]	; (800b234 <__tim17_turnOff+0x1c>)
 800b21e:	681b      	ldr	r3, [r3, #0]
 800b220:	4a04      	ldr	r2, [pc, #16]	; (800b234 <__tim17_turnOff+0x1c>)
 800b222:	f023 0301 	bic.w	r3, r3, #1
 800b226:	6013      	str	r3, [r2, #0]
}
 800b228:	bf00      	nop
 800b22a:	46bd      	mov	sp, r7
 800b22c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b230:	4770      	bx	lr
 800b232:	bf00      	nop
 800b234:	40014800 	.word	0x40014800

0800b238 <_init_tim17_subsystem>:
	

void _init_tim17_subsystem(struct _tim17 *tim17)
{
 800b238:	b480      	push	{r7}
 800b23a:	b083      	sub	sp, #12
 800b23c:	af00      	add	r7, sp, #0
 800b23e:	6078      	str	r0, [r7, #4]
	//globalSystemTimeSec = 0;
	tim17->globalSystemTimeSec = 0;
 800b240:	687b      	ldr	r3, [r7, #4]
 800b242:	2200      	movs	r2, #0
 800b244:	601a      	str	r2, [r3, #0]
	tim17->initialize = __tim17_initialize;
 800b246:	687b      	ldr	r3, [r7, #4]
 800b248:	4a06      	ldr	r2, [pc, #24]	; (800b264 <_init_tim17_subsystem+0x2c>)
 800b24a:	605a      	str	r2, [r3, #4]
	tim17->turnOn = __tim17_turnOn;
 800b24c:	687b      	ldr	r3, [r7, #4]
 800b24e:	4a06      	ldr	r2, [pc, #24]	; (800b268 <_init_tim17_subsystem+0x30>)
 800b250:	609a      	str	r2, [r3, #8]
	tim17->turnOff = __tim17_turnOff;
 800b252:	687b      	ldr	r3, [r7, #4]
 800b254:	4a05      	ldr	r2, [pc, #20]	; (800b26c <_init_tim17_subsystem+0x34>)
 800b256:	60da      	str	r2, [r3, #12]
}
 800b258:	bf00      	nop
 800b25a:	370c      	adds	r7, #12
 800b25c:	46bd      	mov	sp, r7
 800b25e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b262:	4770      	bx	lr
 800b264:	0800b181 	.word	0x0800b181
 800b268:	0800b1f9 	.word	0x0800b1f9
 800b26c:	0800b219 	.word	0x0800b219

0800b270 <__NVIC_EnableIRQ>:
{
 800b270:	b480      	push	{r7}
 800b272:	b083      	sub	sp, #12
 800b274:	af00      	add	r7, sp, #0
 800b276:	4603      	mov	r3, r0
 800b278:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800b27a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800b27e:	2b00      	cmp	r3, #0
 800b280:	db0b      	blt.n	800b29a <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800b282:	79fb      	ldrb	r3, [r7, #7]
 800b284:	f003 021f 	and.w	r2, r3, #31
 800b288:	4907      	ldr	r1, [pc, #28]	; (800b2a8 <__NVIC_EnableIRQ+0x38>)
 800b28a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800b28e:	095b      	lsrs	r3, r3, #5
 800b290:	2001      	movs	r0, #1
 800b292:	fa00 f202 	lsl.w	r2, r0, r2
 800b296:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800b29a:	bf00      	nop
 800b29c:	370c      	adds	r7, #12
 800b29e:	46bd      	mov	sp, r7
 800b2a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b2a4:	4770      	bx	lr
 800b2a6:	bf00      	nop
 800b2a8:	e000e100 	.word	0xe000e100

0800b2ac <__NVIC_SetPriority>:
{
 800b2ac:	b480      	push	{r7}
 800b2ae:	b083      	sub	sp, #12
 800b2b0:	af00      	add	r7, sp, #0
 800b2b2:	4603      	mov	r3, r0
 800b2b4:	6039      	str	r1, [r7, #0]
 800b2b6:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800b2b8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800b2bc:	2b00      	cmp	r3, #0
 800b2be:	db0a      	blt.n	800b2d6 <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b2c0:	683b      	ldr	r3, [r7, #0]
 800b2c2:	b2da      	uxtb	r2, r3
 800b2c4:	490c      	ldr	r1, [pc, #48]	; (800b2f8 <__NVIC_SetPriority+0x4c>)
 800b2c6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800b2ca:	0112      	lsls	r2, r2, #4
 800b2cc:	b2d2      	uxtb	r2, r2
 800b2ce:	440b      	add	r3, r1
 800b2d0:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 800b2d4:	e00a      	b.n	800b2ec <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b2d6:	683b      	ldr	r3, [r7, #0]
 800b2d8:	b2da      	uxtb	r2, r3
 800b2da:	4908      	ldr	r1, [pc, #32]	; (800b2fc <__NVIC_SetPriority+0x50>)
 800b2dc:	79fb      	ldrb	r3, [r7, #7]
 800b2de:	f003 030f 	and.w	r3, r3, #15
 800b2e2:	3b04      	subs	r3, #4
 800b2e4:	0112      	lsls	r2, r2, #4
 800b2e6:	b2d2      	uxtb	r2, r2
 800b2e8:	440b      	add	r3, r1
 800b2ea:	761a      	strb	r2, [r3, #24]
}
 800b2ec:	bf00      	nop
 800b2ee:	370c      	adds	r7, #12
 800b2f0:	46bd      	mov	sp, r7
 800b2f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b2f6:	4770      	bx	lr
 800b2f8:	e000e100 	.word	0xe000e100
 800b2fc:	e000ed00 	.word	0xe000ed00

0800b300 <_t2_dDelay>:
static struct _tim2 *_T2;

static volatile uint8_t _t2_dm = 0;

static void _t2_dDelay(void)
{
 800b300:	b480      	push	{r7}
 800b302:	af00      	add	r7, sp, #0
	++_t2_dm;
 800b304:	4b05      	ldr	r3, [pc, #20]	; (800b31c <_t2_dDelay+0x1c>)
 800b306:	781b      	ldrb	r3, [r3, #0]
 800b308:	b2db      	uxtb	r3, r3
 800b30a:	3301      	adds	r3, #1
 800b30c:	b2da      	uxtb	r2, r3
 800b30e:	4b03      	ldr	r3, [pc, #12]	; (800b31c <_t2_dDelay+0x1c>)
 800b310:	701a      	strb	r2, [r3, #0]
}
 800b312:	bf00      	nop
 800b314:	46bd      	mov	sp, r7
 800b316:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b31a:	4770      	bx	lr
 800b31c:	20000eec 	.word	0x20000eec

0800b320 <__tim2_initialize>:


void __tim2_initialize (void)
{
 800b320:	b580      	push	{r7, lr}
 800b322:	af00      	add	r7, sp, #0

	RCC->APB1ENR1 |= RCC_APB1ENR1_TIM2EN;
 800b324:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800b328:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800b32a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800b32e:	f043 0301 	orr.w	r3, r3, #1
 800b332:	6593      	str	r3, [r2, #88]	; 0x58
	_t2_dDelay();
 800b334:	f7ff ffe4 	bl	800b300 <_t2_dDelay>

	TIM2->PSC = (uint16_t) 64000 - 1;
 800b338:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b33c:	f64f 12ff 	movw	r2, #63999	; 0xf9ff
 800b340:	629a      	str	r2, [r3, #40]	; 0x28
	TIM2->ARR = (uint16_t) 1000;
 800b342:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b346:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800b34a:	62da      	str	r2, [r3, #44]	; 0x2c
	TIM2->CR1 |= TIM_CR1_ARPE | TIM_CR1_OPM | TIM_CR1_URS;
 800b34c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b350:	681b      	ldr	r3, [r3, #0]
 800b352:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800b356:	f043 038c 	orr.w	r3, r3, #140	; 0x8c
 800b35a:	6013      	str	r3, [r2, #0]
	TIM2->CNT = 0;
 800b35c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b360:	2200      	movs	r2, #0
 800b362:	625a      	str	r2, [r3, #36]	; 0x24
	TIM2->EGR |= TIM_EGR_UG;
 800b364:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b368:	695b      	ldr	r3, [r3, #20]
 800b36a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800b36e:	f043 0301 	orr.w	r3, r3, #1
 800b372:	6153      	str	r3, [r2, #20]
	_t2_dDelay();
 800b374:	f7ff ffc4 	bl	800b300 <_t2_dDelay>
	TIM2->SR &= ~TIM_SR_UIF;
 800b378:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b37c:	691b      	ldr	r3, [r3, #16]
 800b37e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800b382:	f023 0301 	bic.w	r3, r3, #1
 800b386:	6113      	str	r3, [r2, #16]
	NVIC_SetPriority(TIM2_IRQn, 1);
 800b388:	2101      	movs	r1, #1
 800b38a:	201c      	movs	r0, #28
 800b38c:	f7ff ff8e 	bl	800b2ac <__NVIC_SetPriority>
	NVIC_EnableIRQ(TIM2_IRQn);
 800b390:	201c      	movs	r0, #28
 800b392:	f7ff ff6d 	bl	800b270 <__NVIC_EnableIRQ>
	TIM2->DIER |= TIM_DIER_UIE;
 800b396:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b39a:	68db      	ldr	r3, [r3, #12]
 800b39c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800b3a0:	f043 0301 	orr.w	r3, r3, #1
 800b3a4:	60d3      	str	r3, [r2, #12]
}
 800b3a6:	bf00      	nop
 800b3a8:	bd80      	pop	{r7, pc}

0800b3aa <__tim2_setTime>:

void __tim2_setTime (uint16_t millis)
{
 800b3aa:	b480      	push	{r7}
 800b3ac:	b083      	sub	sp, #12
 800b3ae:	af00      	add	r7, sp, #0
 800b3b0:	4603      	mov	r3, r0
 800b3b2:	80fb      	strh	r3, [r7, #6]
	TIM2->ARR = millis;
 800b3b4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800b3b8:	88fb      	ldrh	r3, [r7, #6]
 800b3ba:	62d3      	str	r3, [r2, #44]	; 0x2c
}
 800b3bc:	bf00      	nop
 800b3be:	370c      	adds	r7, #12
 800b3c0:	46bd      	mov	sp, r7
 800b3c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3c6:	4770      	bx	lr

0800b3c8 <__tim2_turnOn>:

void __tim2_turnOn (void)
{
 800b3c8:	b480      	push	{r7}
 800b3ca:	af00      	add	r7, sp, #0
	TIM2->CR1 |= TIM_CR1_CEN;
 800b3cc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b3d0:	681b      	ldr	r3, [r3, #0]
 800b3d2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800b3d6:	f043 0301 	orr.w	r3, r3, #1
 800b3da:	6013      	str	r3, [r2, #0]
	_T2->isTurnedOn = 1;
 800b3dc:	4b04      	ldr	r3, [pc, #16]	; (800b3f0 <__tim2_turnOn+0x28>)
 800b3de:	681b      	ldr	r3, [r3, #0]
 800b3e0:	2201      	movs	r2, #1
 800b3e2:	701a      	strb	r2, [r3, #0]
}
 800b3e4:	bf00      	nop
 800b3e6:	46bd      	mov	sp, r7
 800b3e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3ec:	4770      	bx	lr
 800b3ee:	bf00      	nop
 800b3f0:	20000ee8 	.word	0x20000ee8

0800b3f4 <__tim2_turnOff>:

void __tim2_turnOff (void)
{
 800b3f4:	b580      	push	{r7, lr}
 800b3f6:	af00      	add	r7, sp, #0
	TIM2->CR1 &= ~TIM_CR1_CEN;
 800b3f8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b3fc:	681b      	ldr	r3, [r3, #0]
 800b3fe:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800b402:	f023 0301 	bic.w	r3, r3, #1
 800b406:	6013      	str	r3, [r2, #0]
	_T2->isTurnedOn = 0;
 800b408:	4b05      	ldr	r3, [pc, #20]	; (800b420 <__tim2_turnOff+0x2c>)
 800b40a:	681b      	ldr	r3, [r3, #0]
 800b40c:	2200      	movs	r2, #0
 800b40e:	701a      	strb	r2, [r3, #0]
	_t2_dDelay();
 800b410:	f7ff ff76 	bl	800b300 <_t2_dDelay>
	TIM2->CNT = 0;
 800b414:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b418:	2200      	movs	r2, #0
 800b41a:	625a      	str	r2, [r3, #36]	; 0x24
}
 800b41c:	bf00      	nop
 800b41e:	bd80      	pop	{r7, pc}
 800b420:	20000ee8 	.word	0x20000ee8

0800b424 <_init_tim2_subsystem>:


void _init_tim2_subsystem(struct _tim2* tim2)
{
 800b424:	b480      	push	{r7}
 800b426:	b083      	sub	sp, #12
 800b428:	af00      	add	r7, sp, #0
 800b42a:	6078      	str	r0, [r7, #4]
	_T2 = tim2;
 800b42c:	4a0a      	ldr	r2, [pc, #40]	; (800b458 <_init_tim2_subsystem+0x34>)
 800b42e:	687b      	ldr	r3, [r7, #4]
 800b430:	6013      	str	r3, [r2, #0]
	tim2->initialize = __tim2_initialize;
 800b432:	687b      	ldr	r3, [r7, #4]
 800b434:	4a09      	ldr	r2, [pc, #36]	; (800b45c <_init_tim2_subsystem+0x38>)
 800b436:	605a      	str	r2, [r3, #4]
	tim2->setTime = __tim2_setTime;
 800b438:	687b      	ldr	r3, [r7, #4]
 800b43a:	4a09      	ldr	r2, [pc, #36]	; (800b460 <_init_tim2_subsystem+0x3c>)
 800b43c:	609a      	str	r2, [r3, #8]
	tim2->turnOn = __tim2_turnOn;
 800b43e:	687b      	ldr	r3, [r7, #4]
 800b440:	4a08      	ldr	r2, [pc, #32]	; (800b464 <_init_tim2_subsystem+0x40>)
 800b442:	60da      	str	r2, [r3, #12]
	tim2->turnOff = __tim2_turnOff;
 800b444:	687b      	ldr	r3, [r7, #4]
 800b446:	4a08      	ldr	r2, [pc, #32]	; (800b468 <_init_tim2_subsystem+0x44>)
 800b448:	611a      	str	r2, [r3, #16]
}
 800b44a:	bf00      	nop
 800b44c:	370c      	adds	r7, #12
 800b44e:	46bd      	mov	sp, r7
 800b450:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b454:	4770      	bx	lr
 800b456:	bf00      	nop
 800b458:	20000ee8 	.word	0x20000ee8
 800b45c:	0800b321 	.word	0x0800b321
 800b460:	0800b3ab 	.word	0x0800b3ab
 800b464:	0800b3c9 	.word	0x0800b3c9
 800b468:	0800b3f5 	.word	0x0800b3f5

0800b46c <USER_SPI_TransmitReceive>:
#include "main.h"
#include "../System.h"

//*************<required functons>****************
uint8_t USER_SPI_TransmitReceive(uint8_t *transmit, uint8_t *reseive, uint16_t count)
{
 800b46c:	b480      	push	{r7}
 800b46e:	b087      	sub	sp, #28
 800b470:	af00      	add	r7, sp, #0
 800b472:	60f8      	str	r0, [r7, #12]
 800b474:	60b9      	str	r1, [r7, #8]
 800b476:	4613      	mov	r3, r2
 800b478:	80fb      	strh	r3, [r7, #6]
	uint16_t i = 1;
 800b47a:	2301      	movs	r3, #1
 800b47c:	82fb      	strh	r3, [r7, #22]
	while(!(SPI1->SR & SPI_SR_TXE)) {;}
 800b47e:	bf00      	nop
 800b480:	4b24      	ldr	r3, [pc, #144]	; (800b514 <USER_SPI_TransmitReceive+0xa8>)
 800b482:	689b      	ldr	r3, [r3, #8]
 800b484:	f003 0302 	and.w	r3, r3, #2
 800b488:	2b00      	cmp	r3, #0
 800b48a:	d0f9      	beq.n	800b480 <USER_SPI_TransmitReceive+0x14>
	*((volatile uint8_t*)&SPI1->DR) = (uint8_t)(*transmit);
 800b48c:	4a22      	ldr	r2, [pc, #136]	; (800b518 <USER_SPI_TransmitReceive+0xac>)
 800b48e:	68fb      	ldr	r3, [r7, #12]
 800b490:	781b      	ldrb	r3, [r3, #0]
 800b492:	7013      	strb	r3, [r2, #0]
	for (; i<count; i++)
 800b494:	e01c      	b.n	800b4d0 <USER_SPI_TransmitReceive+0x64>
	{
		while(!(SPI1->SR & SPI_SR_TXE)) {;}
 800b496:	bf00      	nop
 800b498:	4b1e      	ldr	r3, [pc, #120]	; (800b514 <USER_SPI_TransmitReceive+0xa8>)
 800b49a:	689b      	ldr	r3, [r3, #8]
 800b49c:	f003 0302 	and.w	r3, r3, #2
 800b4a0:	2b00      	cmp	r3, #0
 800b4a2:	d0f9      	beq.n	800b498 <USER_SPI_TransmitReceive+0x2c>
		*((volatile uint8_t*)&SPI1->DR) = (uint8_t)(*transmit);
 800b4a4:	4a1c      	ldr	r2, [pc, #112]	; (800b518 <USER_SPI_TransmitReceive+0xac>)
 800b4a6:	68fb      	ldr	r3, [r7, #12]
 800b4a8:	781b      	ldrb	r3, [r3, #0]
 800b4aa:	7013      	strb	r3, [r2, #0]
		while(!(SPI1->SR & SPI_SR_RXNE)) {;}
 800b4ac:	bf00      	nop
 800b4ae:	4b19      	ldr	r3, [pc, #100]	; (800b514 <USER_SPI_TransmitReceive+0xa8>)
 800b4b0:	689b      	ldr	r3, [r3, #8]
 800b4b2:	f003 0301 	and.w	r3, r3, #1
 800b4b6:	2b00      	cmp	r3, #0
 800b4b8:	d0f9      	beq.n	800b4ae <USER_SPI_TransmitReceive+0x42>
		reseive[i - 1] = *((volatile uint8_t*)&SPI1->DR);
 800b4ba:	4917      	ldr	r1, [pc, #92]	; (800b518 <USER_SPI_TransmitReceive+0xac>)
 800b4bc:	8afb      	ldrh	r3, [r7, #22]
 800b4be:	3b01      	subs	r3, #1
 800b4c0:	68ba      	ldr	r2, [r7, #8]
 800b4c2:	4413      	add	r3, r2
 800b4c4:	780a      	ldrb	r2, [r1, #0]
 800b4c6:	b2d2      	uxtb	r2, r2
 800b4c8:	701a      	strb	r2, [r3, #0]
	for (; i<count; i++)
 800b4ca:	8afb      	ldrh	r3, [r7, #22]
 800b4cc:	3301      	adds	r3, #1
 800b4ce:	82fb      	strh	r3, [r7, #22]
 800b4d0:	8afa      	ldrh	r2, [r7, #22]
 800b4d2:	88fb      	ldrh	r3, [r7, #6]
 800b4d4:	429a      	cmp	r2, r3
 800b4d6:	d3de      	bcc.n	800b496 <USER_SPI_TransmitReceive+0x2a>
	}
	while(!(SPI1->SR & SPI_SR_RXNE)) {;}
 800b4d8:	bf00      	nop
 800b4da:	4b0e      	ldr	r3, [pc, #56]	; (800b514 <USER_SPI_TransmitReceive+0xa8>)
 800b4dc:	689b      	ldr	r3, [r3, #8]
 800b4de:	f003 0301 	and.w	r3, r3, #1
 800b4e2:	2b00      	cmp	r3, #0
 800b4e4:	d0f9      	beq.n	800b4da <USER_SPI_TransmitReceive+0x6e>
	reseive[i - 1] = *((volatile uint8_t*)&SPI1->DR);
 800b4e6:	490c      	ldr	r1, [pc, #48]	; (800b518 <USER_SPI_TransmitReceive+0xac>)
 800b4e8:	8afb      	ldrh	r3, [r7, #22]
 800b4ea:	3b01      	subs	r3, #1
 800b4ec:	68ba      	ldr	r2, [r7, #8]
 800b4ee:	4413      	add	r3, r2
 800b4f0:	780a      	ldrb	r2, [r1, #0]
 800b4f2:	b2d2      	uxtb	r2, r2
 800b4f4:	701a      	strb	r2, [r3, #0]
	//while(SPI1->SR & SPI_SR_BSY);
	while(SPI1->SR & (SPI_SR_FRLVL | SPI_SR_FTLVL));
 800b4f6:	bf00      	nop
 800b4f8:	4b06      	ldr	r3, [pc, #24]	; (800b514 <USER_SPI_TransmitReceive+0xa8>)
 800b4fa:	689b      	ldr	r3, [r3, #8]
 800b4fc:	f403 53f0 	and.w	r3, r3, #7680	; 0x1e00
 800b500:	2b00      	cmp	r3, #0
 800b502:	d1f9      	bne.n	800b4f8 <USER_SPI_TransmitReceive+0x8c>
	return 0;
 800b504:	2300      	movs	r3, #0
}
 800b506:	4618      	mov	r0, r3
 800b508:	371c      	adds	r7, #28
 800b50a:	46bd      	mov	sp, r7
 800b50c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b510:	4770      	bx	lr
 800b512:	bf00      	nop
 800b514:	40013000 	.word	0x40013000
 800b518:	4001300c 	.word	0x4001300c

0800b51c <USER_SPI_Transmit>:

void USER_SPI_Transmit(uint8_t *buf, uint16_t size) 
{
 800b51c:	b480      	push	{r7}
 800b51e:	b085      	sub	sp, #20
 800b520:	af00      	add	r7, sp, #0
 800b522:	6078      	str	r0, [r7, #4]
 800b524:	460b      	mov	r3, r1
 800b526:	807b      	strh	r3, [r7, #2]
	uint16_t i = 0;
 800b528:	2300      	movs	r3, #0
 800b52a:	81fb      	strh	r3, [r7, #14]
	uint8_t dummy_get;
	while(!(SPI1->SR & SPI_SR_TXE)) {;}
 800b52c:	bf00      	nop
 800b52e:	4b22      	ldr	r3, [pc, #136]	; (800b5b8 <USER_SPI_Transmit+0x9c>)
 800b530:	689b      	ldr	r3, [r3, #8]
 800b532:	f003 0302 	and.w	r3, r3, #2
 800b536:	2b00      	cmp	r3, #0
 800b538:	d0f9      	beq.n	800b52e <USER_SPI_Transmit+0x12>
	*((volatile uint8_t*)&SPI1->DR) = (uint8_t)(buf[i]);
 800b53a:	89fb      	ldrh	r3, [r7, #14]
 800b53c:	687a      	ldr	r2, [r7, #4]
 800b53e:	4413      	add	r3, r2
 800b540:	4a1e      	ldr	r2, [pc, #120]	; (800b5bc <USER_SPI_Transmit+0xa0>)
 800b542:	781b      	ldrb	r3, [r3, #0]
 800b544:	7013      	strb	r3, [r2, #0]
	for (i = 1; i<size; i++)
 800b546:	2301      	movs	r3, #1
 800b548:	81fb      	strh	r3, [r7, #14]
 800b54a:	e019      	b.n	800b580 <USER_SPI_Transmit+0x64>
	{
		while(!(SPI1->SR & SPI_SR_TXE)) {;}
 800b54c:	bf00      	nop
 800b54e:	4b1a      	ldr	r3, [pc, #104]	; (800b5b8 <USER_SPI_Transmit+0x9c>)
 800b550:	689b      	ldr	r3, [r3, #8]
 800b552:	f003 0302 	and.w	r3, r3, #2
 800b556:	2b00      	cmp	r3, #0
 800b558:	d0f9      	beq.n	800b54e <USER_SPI_Transmit+0x32>
		*((volatile uint8_t*)&SPI1->DR) = (uint8_t)(buf[i]);
 800b55a:	89fb      	ldrh	r3, [r7, #14]
 800b55c:	687a      	ldr	r2, [r7, #4]
 800b55e:	4413      	add	r3, r2
 800b560:	4a16      	ldr	r2, [pc, #88]	; (800b5bc <USER_SPI_Transmit+0xa0>)
 800b562:	781b      	ldrb	r3, [r3, #0]
 800b564:	7013      	strb	r3, [r2, #0]
		while(!(SPI1->SR & SPI_SR_RXNE)) {;}
 800b566:	bf00      	nop
 800b568:	4b13      	ldr	r3, [pc, #76]	; (800b5b8 <USER_SPI_Transmit+0x9c>)
 800b56a:	689b      	ldr	r3, [r3, #8]
 800b56c:	f003 0301 	and.w	r3, r3, #1
 800b570:	2b00      	cmp	r3, #0
 800b572:	d0f9      	beq.n	800b568 <USER_SPI_Transmit+0x4c>
		dummy_get = *((volatile uint8_t*)&SPI1->DR);
 800b574:	4b11      	ldr	r3, [pc, #68]	; (800b5bc <USER_SPI_Transmit+0xa0>)
 800b576:	781b      	ldrb	r3, [r3, #0]
 800b578:	737b      	strb	r3, [r7, #13]
	for (i = 1; i<size; i++)
 800b57a:	89fb      	ldrh	r3, [r7, #14]
 800b57c:	3301      	adds	r3, #1
 800b57e:	81fb      	strh	r3, [r7, #14]
 800b580:	89fa      	ldrh	r2, [r7, #14]
 800b582:	887b      	ldrh	r3, [r7, #2]
 800b584:	429a      	cmp	r2, r3
 800b586:	d3e1      	bcc.n	800b54c <USER_SPI_Transmit+0x30>
	}
	while(!(SPI1->SR & SPI_SR_RXNE)) {;}
 800b588:	bf00      	nop
 800b58a:	4b0b      	ldr	r3, [pc, #44]	; (800b5b8 <USER_SPI_Transmit+0x9c>)
 800b58c:	689b      	ldr	r3, [r3, #8]
 800b58e:	f003 0301 	and.w	r3, r3, #1
 800b592:	2b00      	cmp	r3, #0
 800b594:	d0f9      	beq.n	800b58a <USER_SPI_Transmit+0x6e>
	dummy_get = *((volatile uint8_t*)&SPI1->DR);
 800b596:	4b09      	ldr	r3, [pc, #36]	; (800b5bc <USER_SPI_Transmit+0xa0>)
 800b598:	781b      	ldrb	r3, [r3, #0]
 800b59a:	737b      	strb	r3, [r7, #13]
	(void)dummy_get;
	//while(SPI1->SR & SPI_SR_BSY);
	while(SPI1->SR & (SPI_SR_FRLVL | SPI_SR_FTLVL));
 800b59c:	bf00      	nop
 800b59e:	4b06      	ldr	r3, [pc, #24]	; (800b5b8 <USER_SPI_Transmit+0x9c>)
 800b5a0:	689b      	ldr	r3, [r3, #8]
 800b5a2:	f403 53f0 	and.w	r3, r3, #7680	; 0x1e00
 800b5a6:	2b00      	cmp	r3, #0
 800b5a8:	d1f9      	bne.n	800b59e <USER_SPI_Transmit+0x82>
	return;
 800b5aa:	bf00      	nop
}
 800b5ac:	3714      	adds	r7, #20
 800b5ae:	46bd      	mov	sp, r7
 800b5b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b5b4:	4770      	bx	lr
 800b5b6:	bf00      	nop
 800b5b8:	40013000 	.word	0x40013000
 800b5bc:	4001300c 	.word	0x4001300c

0800b5c0 <USER_SDCARD_Select>:

void USER_SDCARD_Select() 
{ GPIOA->BSRR |= GPIO_BSRR_BR8; }
 800b5c0:	b480      	push	{r7}
 800b5c2:	af00      	add	r7, sp, #0
 800b5c4:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 800b5c8:	699b      	ldr	r3, [r3, #24]
 800b5ca:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 800b5ce:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800b5d2:	6193      	str	r3, [r2, #24]
 800b5d4:	bf00      	nop
 800b5d6:	46bd      	mov	sp, r7
 800b5d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b5dc:	4770      	bx	lr

0800b5de <USER_SDCARD_Unselect>:

void USER_SDCARD_Unselect()
{ GPIOA->BSRR |= GPIO_BSRR_BS8; }
 800b5de:	b480      	push	{r7}
 800b5e0:	af00      	add	r7, sp, #0
 800b5e2:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 800b5e6:	699b      	ldr	r3, [r3, #24]
 800b5e8:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 800b5ec:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800b5f0:	6193      	str	r3, [r2, #24]
 800b5f2:	bf00      	nop
 800b5f4:	46bd      	mov	sp, r7
 800b5f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b5fa:	4770      	bx	lr

0800b5fc <USER_SDCARD_isAvailable>:
//*************</required functons>****************

//*************<additional functions>****************
uint8_t USER_SDCARD_isAvailable() // return value: !0 - available; 0 - isn't available
{
 800b5fc:	b580      	push	{r7, lr}
 800b5fe:	af00      	add	r7, sp, #0
	return sys.uSD.isAvailable();
 800b600:	4b02      	ldr	r3, [pc, #8]	; (800b60c <USER_SDCARD_isAvailable+0x10>)
 800b602:	699b      	ldr	r3, [r3, #24]
 800b604:	4798      	blx	r3
 800b606:	4603      	mov	r3, r0
}
 800b608:	4618      	mov	r0, r3
 800b60a:	bd80      	pop	{r7, pc}
 800b60c:	20001020 	.word	0x20001020

0800b610 <USER_SDCARD_isInitialisedCallback>:

void USER_SDCARD_isInitialisedCallback() // Callback, which is called after succesfull uSD initialisation
{
 800b610:	b580      	push	{r7, lr}
 800b612:	af00      	add	r7, sp, #0
	sys.uSD.setInitialized(1);
 800b614:	4b02      	ldr	r3, [pc, #8]	; (800b620 <USER_SDCARD_isInitialisedCallback+0x10>)
 800b616:	69db      	ldr	r3, [r3, #28]
 800b618:	2001      	movs	r0, #1
 800b61a:	4798      	blx	r3
}
 800b61c:	bf00      	nop
 800b61e:	bd80      	pop	{r7, pc}
 800b620:	20001020 	.word	0x20001020

0800b624 <USER_Return_uSD_Status>:
* return 0 when everything ok
* return 0x01 when drive is not initialized
* return 0x02 when there is no drive right now
*/
uint8_t USER_Return_uSD_Status()
{
 800b624:	b580      	push	{r7, lr}
 800b626:	af00      	add	r7, sp, #0
	if (!sys.uSD.isAvailable())
 800b628:	4b09      	ldr	r3, [pc, #36]	; (800b650 <USER_Return_uSD_Status+0x2c>)
 800b62a:	699b      	ldr	r3, [r3, #24]
 800b62c:	4798      	blx	r3
 800b62e:	4603      	mov	r3, r0
 800b630:	2b00      	cmp	r3, #0
 800b632:	d101      	bne.n	800b638 <USER_Return_uSD_Status+0x14>
		return 0x02;
 800b634:	2302      	movs	r3, #2
 800b636:	e008      	b.n	800b64a <USER_Return_uSD_Status+0x26>
	if (!sys.uSD.isInitialized())
 800b638:	4b05      	ldr	r3, [pc, #20]	; (800b650 <USER_Return_uSD_Status+0x2c>)
 800b63a:	6a1b      	ldr	r3, [r3, #32]
 800b63c:	4798      	blx	r3
 800b63e:	4603      	mov	r3, r0
 800b640:	2b00      	cmp	r3, #0
 800b642:	d101      	bne.n	800b648 <USER_Return_uSD_Status+0x24>
		return 0x01;
 800b644:	2301      	movs	r3, #1
 800b646:	e000      	b.n	800b64a <USER_Return_uSD_Status+0x26>
	return 0x00;
 800b648:	2300      	movs	r3, #0
}
 800b64a:	4618      	mov	r0, r3
 800b64c:	bd80      	pop	{r7, pc}
 800b64e:	bf00      	nop
 800b650:	20001020 	.word	0x20001020

0800b654 <USER_ICP_ResetCondition>:

//*************<user infinite cycle protection (ICP) functions>****************
void USER_ICP_ResetCondition() // Reset the condition (example: start timer)
{
 800b654:	b580      	push	{r7, lr}
 800b656:	af00      	add	r7, sp, #0
	sys.tim16.setCounterValue(3000);
 800b658:	4b04      	ldr	r3, [pc, #16]	; (800b66c <USER_ICP_ResetCondition+0x18>)
 800b65a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b65c:	f640 30b8 	movw	r0, #3000	; 0xbb8
 800b660:	4798      	blx	r3
	sys.tim16.startTimer();
 800b662:	4b02      	ldr	r3, [pc, #8]	; (800b66c <USER_ICP_ResetCondition+0x18>)
 800b664:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800b666:	4798      	blx	r3
}
 800b668:	bf00      	nop
 800b66a:	bd80      	pop	{r7, pc}
 800b66c:	20001020 	.word	0x20001020

0800b670 <USER_ICP_CheckCondition>:
uint8_t USER_ICP_CheckCondition() // Check the condition. 1 = continue cycle. 0 = end cycle (example: timer value < SET_VALUE)
{
 800b670:	b580      	push	{r7, lr}
 800b672:	af00      	add	r7, sp, #0
	return sys.tim16.isCounting();
 800b674:	4b02      	ldr	r3, [pc, #8]	; (800b680 <USER_ICP_CheckCondition+0x10>)
 800b676:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800b678:	4798      	blx	r3
 800b67a:	4603      	mov	r3, r0
}
 800b67c:	4618      	mov	r0, r3
 800b67e:	bd80      	pop	{r7, pc}
 800b680:	20001020 	.word	0x20001020

0800b684 <USER_ICP_ConditionValidation>:

uint8_t USER_ICP_ConditionValidation() // if condition happened, return 1 (means error), return 0 if everything ok (example: timer value >= SET_VALUE means error)
{
 800b684:	b580      	push	{r7, lr}
 800b686:	af00      	add	r7, sp, #0
	sys.tim16.stopTimer();
 800b688:	4b04      	ldr	r3, [pc, #16]	; (800b69c <USER_ICP_ConditionValidation+0x18>)
 800b68a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800b68c:	4798      	blx	r3
	return sys.tim16.hasCounted_clearUIFflag();
 800b68e:	4b03      	ldr	r3, [pc, #12]	; (800b69c <USER_ICP_ConditionValidation+0x18>)
 800b690:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800b692:	4798      	blx	r3
 800b694:	4603      	mov	r3, r0
}
 800b696:	4618      	mov	r0, r3
 800b698:	bd80      	pop	{r7, pc}
 800b69a:	bf00      	nop
 800b69c:	20001020 	.word	0x20001020

0800b6a0 <__uSD_isAvailable>:

static uint8_t __uSD_initialized;


uint8_t __uSD_isAvailable(void)
{
 800b6a0:	b480      	push	{r7}
 800b6a2:	af00      	add	r7, sp, #0
	return (GPIOA->IDR & GPIO_IDR_ID9)?0x00:0x01;
 800b6a4:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 800b6a8:	691b      	ldr	r3, [r3, #16]
 800b6aa:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800b6ae:	2b00      	cmp	r3, #0
 800b6b0:	bf0c      	ite	eq
 800b6b2:	2301      	moveq	r3, #1
 800b6b4:	2300      	movne	r3, #0
 800b6b6:	b2db      	uxtb	r3, r3
}
 800b6b8:	4618      	mov	r0, r3
 800b6ba:	46bd      	mov	sp, r7
 800b6bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b6c0:	4770      	bx	lr
	...

0800b6c4 <__uSD_setInitialized>:

void __uSD_setInitialized(uint8_t initValue)
{
 800b6c4:	b480      	push	{r7}
 800b6c6:	b083      	sub	sp, #12
 800b6c8:	af00      	add	r7, sp, #0
 800b6ca:	4603      	mov	r3, r0
 800b6cc:	71fb      	strb	r3, [r7, #7]
	__uSD_initialized = initValue;
 800b6ce:	4a04      	ldr	r2, [pc, #16]	; (800b6e0 <__uSD_setInitialized+0x1c>)
 800b6d0:	79fb      	ldrb	r3, [r7, #7]
 800b6d2:	7013      	strb	r3, [r2, #0]
}
 800b6d4:	bf00      	nop
 800b6d6:	370c      	adds	r7, #12
 800b6d8:	46bd      	mov	sp, r7
 800b6da:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b6de:	4770      	bx	lr
 800b6e0:	20000eed 	.word	0x20000eed

0800b6e4 <__uSD_isInitialized>:

uint8_t __uSD_isInitialized (void)
{
 800b6e4:	b480      	push	{r7}
 800b6e6:	af00      	add	r7, sp, #0
	return __uSD_initialized;
 800b6e8:	4b03      	ldr	r3, [pc, #12]	; (800b6f8 <__uSD_isInitialized+0x14>)
 800b6ea:	781b      	ldrb	r3, [r3, #0]
}
 800b6ec:	4618      	mov	r0, r3
 800b6ee:	46bd      	mov	sp, r7
 800b6f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b6f4:	4770      	bx	lr
 800b6f6:	bf00      	nop
 800b6f8:	20000eed 	.word	0x20000eed

0800b6fc <_init_uSD_subsystem>:

void _init_uSD_subsystem(struct _uSD *uSD)
{
 800b6fc:	b480      	push	{r7}
 800b6fe:	b083      	sub	sp, #12
 800b700:	af00      	add	r7, sp, #0
 800b702:	6078      	str	r0, [r7, #4]
	__uSD_initialized = 0;
 800b704:	4b08      	ldr	r3, [pc, #32]	; (800b728 <_init_uSD_subsystem+0x2c>)
 800b706:	2200      	movs	r2, #0
 800b708:	701a      	strb	r2, [r3, #0]
	uSD->isAvailable = __uSD_isAvailable;
 800b70a:	687b      	ldr	r3, [r7, #4]
 800b70c:	4a07      	ldr	r2, [pc, #28]	; (800b72c <_init_uSD_subsystem+0x30>)
 800b70e:	601a      	str	r2, [r3, #0]
	uSD->setInitialized = __uSD_setInitialized;
 800b710:	687b      	ldr	r3, [r7, #4]
 800b712:	4a07      	ldr	r2, [pc, #28]	; (800b730 <_init_uSD_subsystem+0x34>)
 800b714:	605a      	str	r2, [r3, #4]
	uSD->isInitialized = __uSD_isInitialized;
 800b716:	687b      	ldr	r3, [r7, #4]
 800b718:	4a06      	ldr	r2, [pc, #24]	; (800b734 <_init_uSD_subsystem+0x38>)
 800b71a:	609a      	str	r2, [r3, #8]
}
 800b71c:	bf00      	nop
 800b71e:	370c      	adds	r7, #12
 800b720:	46bd      	mov	sp, r7
 800b722:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b726:	4770      	bx	lr
 800b728:	20000eed 	.word	0x20000eed
 800b72c:	0800b6a1 	.word	0x0800b6a1
 800b730:	0800b6c5 	.word	0x0800b6c5
 800b734:	0800b6e5 	.word	0x0800b6e5

0800b738 <APPD_EnableCPU2>:
/* USER CODE END APPD_Init */
  return;
}

void APPD_EnableCPU2( void )
{
 800b738:	b5b0      	push	{r4, r5, r7, lr}
 800b73a:	b088      	sub	sp, #32
 800b73c:	af00      	add	r7, sp, #0
/* USER CODE BEGIN APPD_EnableCPU2 */
  SHCI_C2_DEBUG_Init_Cmd_Packet_t DebugCmdPacket =
 800b73e:	4b0b      	ldr	r3, [pc, #44]	; (800b76c <APPD_EnableCPU2+0x34>)
 800b740:	1d3c      	adds	r4, r7, #4
 800b742:	461d      	mov	r5, r3
 800b744:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b746:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800b748:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800b74c:	c403      	stmia	r4!, {r0, r1}
 800b74e:	8022      	strh	r2, [r4, #0]
 800b750:	3402      	adds	r4, #2
 800b752:	0c13      	lsrs	r3, r2, #16
 800b754:	7023      	strb	r3, [r4, #0]
    NBR_OF_TRACES_CONFIG_PARAMETERS,
    NBR_OF_GENERAL_CONFIG_PARAMETERS}
  };

  /**< Traces channel initialization */
  TL_TRACES_Init( );
 800b756:	f007 fe5f 	bl	8013418 <TL_TRACES_Init>

  /** GPIO DEBUG Initialization */
  SHCI_C2_DEBUG_Init( &DebugCmdPacket  );
 800b75a:	1d3b      	adds	r3, r7, #4
 800b75c:	4618      	mov	r0, r3
 800b75e:	f007 f9be 	bl	8012ade <SHCI_C2_DEBUG_Init>

/* USER CODE END APPD_EnableCPU2 */
  return;
 800b762:	bf00      	nop
}
 800b764:	3720      	adds	r7, #32
 800b766:	46bd      	mov	sp, r7
 800b768:	bdb0      	pop	{r4, r5, r7, pc}
 800b76a:	bf00      	nop
 800b76c:	08014d0c 	.word	0x08014d0c

0800b770 <LL_C2_PWR_SetPowerMode>:
  *
  *         (*) Not available on devices STM32WB15xx, STM32WB10xx
  * @retval None
  */
__STATIC_INLINE void LL_C2_PWR_SetPowerMode(uint32_t LowPowerMode)
{
 800b770:	b480      	push	{r7}
 800b772:	b083      	sub	sp, #12
 800b774:	af00      	add	r7, sp, #0
 800b776:	6078      	str	r0, [r7, #4]
  MODIFY_REG(PWR->C2CR1, PWR_C2CR1_LPMS, LowPowerMode);
 800b778:	4b07      	ldr	r3, [pc, #28]	; (800b798 <LL_C2_PWR_SetPowerMode+0x28>)
 800b77a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800b77e:	f023 0207 	bic.w	r2, r3, #7
 800b782:	4905      	ldr	r1, [pc, #20]	; (800b798 <LL_C2_PWR_SetPowerMode+0x28>)
 800b784:	687b      	ldr	r3, [r7, #4]
 800b786:	4313      	orrs	r3, r2
 800b788:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
}
 800b78c:	bf00      	nop
 800b78e:	370c      	adds	r7, #12
 800b790:	46bd      	mov	sp, r7
 800b792:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b796:	4770      	bx	lr
 800b798:	58000400 	.word	0x58000400

0800b79c <LL_RCC_SetClkAfterWakeFromStop>:
  *         @arg @ref LL_RCC_STOP_WAKEUPCLOCK_MSI
  *         @arg @ref LL_RCC_STOP_WAKEUPCLOCK_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetClkAfterWakeFromStop(uint32_t Clock)
{
 800b79c:	b480      	push	{r7}
 800b79e:	b083      	sub	sp, #12
 800b7a0:	af00      	add	r7, sp, #0
 800b7a2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPWUCK, Clock);
 800b7a4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800b7a8:	689b      	ldr	r3, [r3, #8]
 800b7aa:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 800b7ae:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800b7b2:	687b      	ldr	r3, [r7, #4]
 800b7b4:	4313      	orrs	r3, r2
 800b7b6:	608b      	str	r3, [r1, #8]
}
 800b7b8:	bf00      	nop
 800b7ba:	370c      	adds	r7, #12
 800b7bc:	46bd      	mov	sp, r7
 800b7be:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b7c2:	4770      	bx	lr

0800b7c4 <APPE_Init>:

/* USER CODE END PFP */

/* Functions Definition ------------------------------------------------------*/
void APPE_Init( void )
{
 800b7c4:	b580      	push	{r7, lr}
 800b7c6:	af00      	add	r7, sp, #0
  SystemPower_Config(); /**< Configure the system Power Mode */
 800b7c8:	f000 f80a 	bl	800b7e0 <SystemPower_Config>

  HW_TS_Init(hw_ts_InitMode_Full, &hrtc); /**< Initialize the TimerServer */
 800b7cc:	4903      	ldr	r1, [pc, #12]	; (800b7dc <APPE_Init+0x18>)
 800b7ce:	2000      	movs	r0, #0
 800b7d0:	f000 fcc6 	bl	800c160 <HW_TS_Init>

/* USER CODE BEGIN APPE_Init_1 */

/* USER CODE END APPE_Init_1 */
  appe_Tl_Init();	/* Initialize all transport layers */
 800b7d4:	f000 f812 	bl	800b7fc <appe_Tl_Init>
   * This system event is received with APPE_SysUserEvtRx()
   */
/* USER CODE BEGIN APPE_Init_2 */

/* USER CODE END APPE_Init_2 */
   return;
 800b7d8:	bf00      	nop
}
 800b7da:	bd80      	pop	{r7, pc}
 800b7dc:	20005450 	.word	0x20005450

0800b7e0 <SystemPower_Config>:
 *
 * @param  None
 * @retval None
 */
static void SystemPower_Config(void)
{
 800b7e0:	b580      	push	{r7, lr}
 800b7e2:	af00      	add	r7, sp, #0
  /**
   * Select HSI as system clock source after Wake Up from Stop mode
   */
  LL_RCC_SetClkAfterWakeFromStop(LL_RCC_STOP_WAKEUPCLOCK_HSI);
 800b7e4:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800b7e8:	f7ff ffd8 	bl	800b79c <LL_RCC_SetClkAfterWakeFromStop>

  /* Initialize low power manager */
  UTIL_LPM_Init();
 800b7ec:	f008 ff60 	bl	80146b0 <UTIL_LPM_Init>
  /* Initialize the CPU2 reset value before starting CPU2 with C2BOOT */
  LL_C2_PWR_SetPowerMode(LL_PWR_MODE_SHUTDOWN);
 800b7f0:	2004      	movs	r0, #4
 800b7f2:	f7ff ffbd 	bl	800b770 <LL_C2_PWR_SetPowerMode>
   *  Enable USB power
   */
  HAL_PWREx_EnableVddUSB();
#endif

  return;
 800b7f6:	bf00      	nop
}
 800b7f8:	bd80      	pop	{r7, pc}
	...

0800b7fc <appe_Tl_Init>:

static void appe_Tl_Init( void )
{
 800b7fc:	b580      	push	{r7, lr}
 800b7fe:	b088      	sub	sp, #32
 800b800:	af00      	add	r7, sp, #0
  TL_MM_Config_t tl_mm_config;
  SHCI_TL_HciInitConf_t SHci_Tl_Init_Conf;
  /**< Reference table initialization */
  TL_Init();
 800b802:	f007 fc53 	bl	80130ac <TL_Init>

  /**< System channel initialization */
  UTIL_SEQ_RegTask( 1<< CFG_TASK_SYSTEM_HCI_ASYNCH_EVT_ID, UTIL_SEQ_RFU, shci_user_evt_proc );
 800b806:	4a11      	ldr	r2, [pc, #68]	; (800b84c <appe_Tl_Init+0x50>)
 800b808:	2100      	movs	r1, #0
 800b80a:	2040      	movs	r0, #64	; 0x40
 800b80c:	f009 f876 	bl	80148fc <UTIL_SEQ_RegTask>
  SHci_Tl_Init_Conf.p_cmdbuffer = (uint8_t*)&SystemCmdBuffer;
 800b810:	4b0f      	ldr	r3, [pc, #60]	; (800b850 <appe_Tl_Init+0x54>)
 800b812:	603b      	str	r3, [r7, #0]
  SHci_Tl_Init_Conf.StatusNotCallBack = APPE_SysStatusNot;
 800b814:	4b0f      	ldr	r3, [pc, #60]	; (800b854 <appe_Tl_Init+0x58>)
 800b816:	607b      	str	r3, [r7, #4]
  shci_init(APPE_SysUserEvtRx, (void*) &SHci_Tl_Init_Conf);
 800b818:	463b      	mov	r3, r7
 800b81a:	4619      	mov	r1, r3
 800b81c:	480e      	ldr	r0, [pc, #56]	; (800b858 <appe_Tl_Init+0x5c>)
 800b81e:	f007 fb0b 	bl	8012e38 <shci_init>

  /**< Memory Manager channel initialization */
  tl_mm_config.p_BleSpareEvtBuffer = BleSpareEvtBuffer;
 800b822:	4b0e      	ldr	r3, [pc, #56]	; (800b85c <appe_Tl_Init+0x60>)
 800b824:	60bb      	str	r3, [r7, #8]
  tl_mm_config.p_SystemSpareEvtBuffer = SystemSpareEvtBuffer;
 800b826:	4b0e      	ldr	r3, [pc, #56]	; (800b860 <appe_Tl_Init+0x64>)
 800b828:	60fb      	str	r3, [r7, #12]
  tl_mm_config.p_AsynchEvtPool = EvtPool;
 800b82a:	4b0e      	ldr	r3, [pc, #56]	; (800b864 <appe_Tl_Init+0x68>)
 800b82c:	613b      	str	r3, [r7, #16]
  tl_mm_config.AsynchEvtPoolSize = POOL_SIZE;
 800b82e:	f240 533c 	movw	r3, #1340	; 0x53c
 800b832:	617b      	str	r3, [r7, #20]
  TL_MM_Init( &tl_mm_config );
 800b834:	f107 0308 	add.w	r3, r7, #8
 800b838:	4618      	mov	r0, r3
 800b83a:	f007 fd79 	bl	8013330 <TL_MM_Init>

  TL_Enable();
 800b83e:	f007 fc2f 	bl	80130a0 <TL_Enable>

  return;
 800b842:	bf00      	nop
}
 800b844:	3720      	adds	r7, #32
 800b846:	46bd      	mov	sp, r7
 800b848:	bd80      	pop	{r7, pc}
 800b84a:	bf00      	nop
 800b84c:	08012e71 	.word	0x08012e71
 800b850:	20030724 	.word	0x20030724
 800b854:	0800b869 	.word	0x0800b869
 800b858:	0800b87f 	.word	0x0800b87f
 800b85c:	2003093c 	.word	0x2003093c
 800b860:	20030830 	.word	0x20030830
 800b864:	200301e8 	.word	0x200301e8

0800b868 <APPE_SysStatusNot>:

static void APPE_SysStatusNot( SHCI_TL_CmdStatus_t status )
{
 800b868:	b480      	push	{r7}
 800b86a:	b083      	sub	sp, #12
 800b86c:	af00      	add	r7, sp, #0
 800b86e:	4603      	mov	r3, r0
 800b870:	71fb      	strb	r3, [r7, #7]
  UNUSED(status);
  return;
 800b872:	bf00      	nop
}
 800b874:	370c      	adds	r7, #12
 800b876:	46bd      	mov	sp, r7
 800b878:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b87c:	4770      	bx	lr

0800b87e <APPE_SysUserEvtRx>:
 * The buffer shall not be released
 * ( eg ((tSHCI_UserEvtRxParam*)pPayload)->status shall be set to SHCI_TL_UserEventFlow_Disable )
 * When the status is not filled, the buffer is released by default
 */
static void APPE_SysUserEvtRx( void * pPayload )
{
 800b87e:	b580      	push	{r7, lr}
 800b880:	b082      	sub	sp, #8
 800b882:	af00      	add	r7, sp, #0
 800b884:	6078      	str	r0, [r7, #4]
  UNUSED(pPayload);
  /* Traces channel initialization */
  APPD_EnableCPU2( );
 800b886:	f7ff ff57 	bl	800b738 <APPD_EnableCPU2>

  APP_BLE_Init( );
 800b88a:	f007 ff5b 	bl	8013744 <APP_BLE_Init>
  UTIL_LPM_SetOffMode(1U << CFG_LPM_APP, UTIL_LPM_ENABLE);
 800b88e:	2100      	movs	r1, #0
 800b890:	2001      	movs	r0, #1
 800b892:	f008 ff1f 	bl	80146d4 <UTIL_LPM_SetOffMode>
  return;
 800b896:	bf00      	nop
}
 800b898:	3708      	adds	r7, #8
 800b89a:	46bd      	mov	sp, r7
 800b89c:	bd80      	pop	{r7, pc}

0800b89e <UTIL_SEQ_Idle>:
 * WRAP FUNCTIONS
 *
 *************************************************************/

void UTIL_SEQ_Idle( void )
{
 800b89e:	b480      	push	{r7}
 800b8a0:	af00      	add	r7, sp, #0
#if ( CFG_LPM_SUPPORTED == 1)
  UTIL_LPM_EnterLowPower( );
#endif
  return;
 800b8a2:	bf00      	nop
}
 800b8a4:	46bd      	mov	sp, r7
 800b8a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b8aa:	4770      	bx	lr

0800b8ac <UTIL_SEQ_EvtIdle>:
  *
  * @param  evt_waited_bm : Event pending.
  * @retval None
  */
void UTIL_SEQ_EvtIdle( UTIL_SEQ_bm_t task_id_bm, UTIL_SEQ_bm_t evt_waited_bm )
{
 800b8ac:	b580      	push	{r7, lr}
 800b8ae:	b082      	sub	sp, #8
 800b8b0:	af00      	add	r7, sp, #0
 800b8b2:	6078      	str	r0, [r7, #4]
 800b8b4:	6039      	str	r1, [r7, #0]
  UTIL_SEQ_Run( UTIL_SEQ_DEFAULT );
 800b8b6:	f04f 30ff 	mov.w	r0, #4294967295
 800b8ba:	f008 ff3b 	bl	8014734 <UTIL_SEQ_Run>
}
 800b8be:	bf00      	nop
 800b8c0:	3708      	adds	r7, #8
 800b8c2:	46bd      	mov	sp, r7
 800b8c4:	bd80      	pop	{r7, pc}

0800b8c6 <shci_notify_asynch_evt>:

void shci_notify_asynch_evt(void* pdata)
{
 800b8c6:	b580      	push	{r7, lr}
 800b8c8:	b082      	sub	sp, #8
 800b8ca:	af00      	add	r7, sp, #0
 800b8cc:	6078      	str	r0, [r7, #4]
  UTIL_SEQ_SetTask( 1<<CFG_TASK_SYSTEM_HCI_ASYNCH_EVT_ID, CFG_SCH_PRIO_0);
 800b8ce:	2100      	movs	r1, #0
 800b8d0:	2040      	movs	r0, #64	; 0x40
 800b8d2:	f009 f835 	bl	8014940 <UTIL_SEQ_SetTask>
  return;
 800b8d6:	bf00      	nop
}
 800b8d8:	3708      	adds	r7, #8
 800b8da:	46bd      	mov	sp, r7
 800b8dc:	bd80      	pop	{r7, pc}

0800b8de <shci_cmd_resp_release>:

void shci_cmd_resp_release(uint32_t flag)
{
 800b8de:	b580      	push	{r7, lr}
 800b8e0:	b082      	sub	sp, #8
 800b8e2:	af00      	add	r7, sp, #0
 800b8e4:	6078      	str	r0, [r7, #4]
  UTIL_SEQ_SetEvt( 1<< CFG_IDLEEVT_SYSTEM_HCI_CMD_EVT_RSP_ID );
 800b8e6:	2002      	movs	r0, #2
 800b8e8:	f009 f896 	bl	8014a18 <UTIL_SEQ_SetEvt>
  return;
 800b8ec:	bf00      	nop
}
 800b8ee:	3708      	adds	r7, #8
 800b8f0:	46bd      	mov	sp, r7
 800b8f2:	bd80      	pop	{r7, pc}

0800b8f4 <shci_cmd_resp_wait>:

void shci_cmd_resp_wait(uint32_t timeout)
{
 800b8f4:	b580      	push	{r7, lr}
 800b8f6:	b082      	sub	sp, #8
 800b8f8:	af00      	add	r7, sp, #0
 800b8fa:	6078      	str	r0, [r7, #4]
  UTIL_SEQ_WaitEvt( 1<< CFG_IDLEEVT_SYSTEM_HCI_CMD_EVT_RSP_ID );
 800b8fc:	2002      	movs	r0, #2
 800b8fe:	f009 f8ab 	bl	8014a58 <UTIL_SEQ_WaitEvt>
  return;
 800b902:	bf00      	nop
}
 800b904:	3708      	adds	r7, #8
 800b906:	46bd      	mov	sp, r7
 800b908:	bd80      	pop	{r7, pc}
	...

0800b90c <LL_EXTI_EnableIT_0_31>:
  *         @arg @ref LL_EXTI_LINE_ALL_0_31
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableIT_0_31(uint32_t ExtiLine)
{
 800b90c:	b480      	push	{r7}
 800b90e:	b083      	sub	sp, #12
 800b910:	af00      	add	r7, sp, #0
 800b912:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->IMR1, ExtiLine);
 800b914:	4b06      	ldr	r3, [pc, #24]	; (800b930 <LL_EXTI_EnableIT_0_31+0x24>)
 800b916:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 800b91a:	4905      	ldr	r1, [pc, #20]	; (800b930 <LL_EXTI_EnableIT_0_31+0x24>)
 800b91c:	687b      	ldr	r3, [r7, #4]
 800b91e:	4313      	orrs	r3, r2
 800b920:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
}
 800b924:	bf00      	nop
 800b926:	370c      	adds	r7, #12
 800b928:	46bd      	mov	sp, r7
 800b92a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b92e:	4770      	bx	lr
 800b930:	58000800 	.word	0x58000800

0800b934 <LL_EXTI_EnableRisingTrig_0_31>:
  *         @arg @ref LL_EXTI_LINE_31 (*)
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableRisingTrig_0_31(uint32_t ExtiLine)
{
 800b934:	b480      	push	{r7}
 800b936:	b083      	sub	sp, #12
 800b938:	af00      	add	r7, sp, #0
 800b93a:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->RTSR1, ExtiLine);
 800b93c:	4b05      	ldr	r3, [pc, #20]	; (800b954 <LL_EXTI_EnableRisingTrig_0_31+0x20>)
 800b93e:	681a      	ldr	r2, [r3, #0]
 800b940:	4904      	ldr	r1, [pc, #16]	; (800b954 <LL_EXTI_EnableRisingTrig_0_31+0x20>)
 800b942:	687b      	ldr	r3, [r7, #4]
 800b944:	4313      	orrs	r3, r2
 800b946:	600b      	str	r3, [r1, #0]

}
 800b948:	bf00      	nop
 800b94a:	370c      	adds	r7, #12
 800b94c:	46bd      	mov	sp, r7
 800b94e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b952:	4770      	bx	lr
 800b954:	58000800 	.word	0x58000800

0800b958 <ReadRtcSsrValue>:
 *         reliability of the value
 * @param  None
 * @retval SSR value read
 */
static uint32_t ReadRtcSsrValue(void)
{
 800b958:	b480      	push	{r7}
 800b95a:	b083      	sub	sp, #12
 800b95c:	af00      	add	r7, sp, #0
  uint32_t first_read;
  uint32_t second_read;

  first_read = (uint32_t)(READ_BIT(RTC->SSR, RTC_SSR_SS));
 800b95e:	4b0d      	ldr	r3, [pc, #52]	; (800b994 <ReadRtcSsrValue+0x3c>)
 800b960:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b962:	b29b      	uxth	r3, r3
 800b964:	607b      	str	r3, [r7, #4]

  second_read = (uint32_t)(READ_BIT(RTC->SSR, RTC_SSR_SS));
 800b966:	4b0b      	ldr	r3, [pc, #44]	; (800b994 <ReadRtcSsrValue+0x3c>)
 800b968:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b96a:	b29b      	uxth	r3, r3
 800b96c:	603b      	str	r3, [r7, #0]

  while(first_read != second_read)
 800b96e:	e005      	b.n	800b97c <ReadRtcSsrValue+0x24>
  {
    first_read = second_read;
 800b970:	683b      	ldr	r3, [r7, #0]
 800b972:	607b      	str	r3, [r7, #4]

    second_read = (uint32_t)(READ_BIT(RTC->SSR, RTC_SSR_SS));
 800b974:	4b07      	ldr	r3, [pc, #28]	; (800b994 <ReadRtcSsrValue+0x3c>)
 800b976:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b978:	b29b      	uxth	r3, r3
 800b97a:	603b      	str	r3, [r7, #0]
  while(first_read != second_read)
 800b97c:	687a      	ldr	r2, [r7, #4]
 800b97e:	683b      	ldr	r3, [r7, #0]
 800b980:	429a      	cmp	r2, r3
 800b982:	d1f5      	bne.n	800b970 <ReadRtcSsrValue+0x18>
  }

  return second_read;
 800b984:	683b      	ldr	r3, [r7, #0]
}
 800b986:	4618      	mov	r0, r3
 800b988:	370c      	adds	r7, #12
 800b98a:	46bd      	mov	sp, r7
 800b98c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b990:	4770      	bx	lr
 800b992:	bf00      	nop
 800b994:	40002800 	.word	0x40002800

0800b998 <LinkTimerAfter>:
 * @param  TimerID:   The ID of the Timer
 * @param  RefTimerID: The ID of the Timer to be linked after
 * @retval None
 */
static void LinkTimerAfter(uint8_t TimerID, uint8_t RefTimerID)
{
 800b998:	b480      	push	{r7}
 800b99a:	b085      	sub	sp, #20
 800b99c:	af00      	add	r7, sp, #0
 800b99e:	4603      	mov	r3, r0
 800b9a0:	460a      	mov	r2, r1
 800b9a2:	71fb      	strb	r3, [r7, #7]
 800b9a4:	4613      	mov	r3, r2
 800b9a6:	71bb      	strb	r3, [r7, #6]
  uint8_t next_id;

  next_id = aTimerContext[RefTimerID].NextID;
 800b9a8:	79ba      	ldrb	r2, [r7, #6]
 800b9aa:	491d      	ldr	r1, [pc, #116]	; (800ba20 <LinkTimerAfter+0x88>)
 800b9ac:	4613      	mov	r3, r2
 800b9ae:	005b      	lsls	r3, r3, #1
 800b9b0:	4413      	add	r3, r2
 800b9b2:	00db      	lsls	r3, r3, #3
 800b9b4:	440b      	add	r3, r1
 800b9b6:	3315      	adds	r3, #21
 800b9b8:	781b      	ldrb	r3, [r3, #0]
 800b9ba:	73fb      	strb	r3, [r7, #15]

  if(next_id != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 800b9bc:	7bfb      	ldrb	r3, [r7, #15]
 800b9be:	2b06      	cmp	r3, #6
 800b9c0:	d009      	beq.n	800b9d6 <LinkTimerAfter+0x3e>
  {
    aTimerContext[next_id].PreviousID = TimerID;
 800b9c2:	7bfa      	ldrb	r2, [r7, #15]
 800b9c4:	4916      	ldr	r1, [pc, #88]	; (800ba20 <LinkTimerAfter+0x88>)
 800b9c6:	4613      	mov	r3, r2
 800b9c8:	005b      	lsls	r3, r3, #1
 800b9ca:	4413      	add	r3, r2
 800b9cc:	00db      	lsls	r3, r3, #3
 800b9ce:	440b      	add	r3, r1
 800b9d0:	3314      	adds	r3, #20
 800b9d2:	79fa      	ldrb	r2, [r7, #7]
 800b9d4:	701a      	strb	r2, [r3, #0]
  }
  aTimerContext[TimerID].NextID = next_id;
 800b9d6:	79fa      	ldrb	r2, [r7, #7]
 800b9d8:	4911      	ldr	r1, [pc, #68]	; (800ba20 <LinkTimerAfter+0x88>)
 800b9da:	4613      	mov	r3, r2
 800b9dc:	005b      	lsls	r3, r3, #1
 800b9de:	4413      	add	r3, r2
 800b9e0:	00db      	lsls	r3, r3, #3
 800b9e2:	440b      	add	r3, r1
 800b9e4:	3315      	adds	r3, #21
 800b9e6:	7bfa      	ldrb	r2, [r7, #15]
 800b9e8:	701a      	strb	r2, [r3, #0]
  aTimerContext[TimerID].PreviousID = RefTimerID ;
 800b9ea:	79fa      	ldrb	r2, [r7, #7]
 800b9ec:	490c      	ldr	r1, [pc, #48]	; (800ba20 <LinkTimerAfter+0x88>)
 800b9ee:	4613      	mov	r3, r2
 800b9f0:	005b      	lsls	r3, r3, #1
 800b9f2:	4413      	add	r3, r2
 800b9f4:	00db      	lsls	r3, r3, #3
 800b9f6:	440b      	add	r3, r1
 800b9f8:	3314      	adds	r3, #20
 800b9fa:	79ba      	ldrb	r2, [r7, #6]
 800b9fc:	701a      	strb	r2, [r3, #0]
  aTimerContext[RefTimerID].NextID = TimerID;
 800b9fe:	79ba      	ldrb	r2, [r7, #6]
 800ba00:	4907      	ldr	r1, [pc, #28]	; (800ba20 <LinkTimerAfter+0x88>)
 800ba02:	4613      	mov	r3, r2
 800ba04:	005b      	lsls	r3, r3, #1
 800ba06:	4413      	add	r3, r2
 800ba08:	00db      	lsls	r3, r3, #3
 800ba0a:	440b      	add	r3, r1
 800ba0c:	3315      	adds	r3, #21
 800ba0e:	79fa      	ldrb	r2, [r7, #7]
 800ba10:	701a      	strb	r2, [r3, #0]

  return;
 800ba12:	bf00      	nop
}
 800ba14:	3714      	adds	r7, #20
 800ba16:	46bd      	mov	sp, r7
 800ba18:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ba1c:	4770      	bx	lr
 800ba1e:	bf00      	nop
 800ba20:	20000028 	.word	0x20000028

0800ba24 <LinkTimerBefore>:
 * @param  TimerID:   The ID of the Timer
 * @param  RefTimerID: The ID of the Timer to be linked before
 * @retval None
 */
static void LinkTimerBefore(uint8_t TimerID, uint8_t RefTimerID)
{
 800ba24:	b480      	push	{r7}
 800ba26:	b085      	sub	sp, #20
 800ba28:	af00      	add	r7, sp, #0
 800ba2a:	4603      	mov	r3, r0
 800ba2c:	460a      	mov	r2, r1
 800ba2e:	71fb      	strb	r3, [r7, #7]
 800ba30:	4613      	mov	r3, r2
 800ba32:	71bb      	strb	r3, [r7, #6]
  uint8_t previous_id;

  if(RefTimerID != CurrentRunningTimerID)
 800ba34:	4b29      	ldr	r3, [pc, #164]	; (800badc <LinkTimerBefore+0xb8>)
 800ba36:	781b      	ldrb	r3, [r3, #0]
 800ba38:	b2db      	uxtb	r3, r3
 800ba3a:	79ba      	ldrb	r2, [r7, #6]
 800ba3c:	429a      	cmp	r2, r3
 800ba3e:	d032      	beq.n	800baa6 <LinkTimerBefore+0x82>
  {
    previous_id = aTimerContext[RefTimerID].PreviousID;
 800ba40:	79ba      	ldrb	r2, [r7, #6]
 800ba42:	4927      	ldr	r1, [pc, #156]	; (800bae0 <LinkTimerBefore+0xbc>)
 800ba44:	4613      	mov	r3, r2
 800ba46:	005b      	lsls	r3, r3, #1
 800ba48:	4413      	add	r3, r2
 800ba4a:	00db      	lsls	r3, r3, #3
 800ba4c:	440b      	add	r3, r1
 800ba4e:	3314      	adds	r3, #20
 800ba50:	781b      	ldrb	r3, [r3, #0]
 800ba52:	73fb      	strb	r3, [r7, #15]

    aTimerContext[previous_id].NextID = TimerID;
 800ba54:	7bfa      	ldrb	r2, [r7, #15]
 800ba56:	4922      	ldr	r1, [pc, #136]	; (800bae0 <LinkTimerBefore+0xbc>)
 800ba58:	4613      	mov	r3, r2
 800ba5a:	005b      	lsls	r3, r3, #1
 800ba5c:	4413      	add	r3, r2
 800ba5e:	00db      	lsls	r3, r3, #3
 800ba60:	440b      	add	r3, r1
 800ba62:	3315      	adds	r3, #21
 800ba64:	79fa      	ldrb	r2, [r7, #7]
 800ba66:	701a      	strb	r2, [r3, #0]
    aTimerContext[TimerID].NextID = RefTimerID;
 800ba68:	79fa      	ldrb	r2, [r7, #7]
 800ba6a:	491d      	ldr	r1, [pc, #116]	; (800bae0 <LinkTimerBefore+0xbc>)
 800ba6c:	4613      	mov	r3, r2
 800ba6e:	005b      	lsls	r3, r3, #1
 800ba70:	4413      	add	r3, r2
 800ba72:	00db      	lsls	r3, r3, #3
 800ba74:	440b      	add	r3, r1
 800ba76:	3315      	adds	r3, #21
 800ba78:	79ba      	ldrb	r2, [r7, #6]
 800ba7a:	701a      	strb	r2, [r3, #0]
    aTimerContext[TimerID].PreviousID = previous_id ;
 800ba7c:	79fa      	ldrb	r2, [r7, #7]
 800ba7e:	4918      	ldr	r1, [pc, #96]	; (800bae0 <LinkTimerBefore+0xbc>)
 800ba80:	4613      	mov	r3, r2
 800ba82:	005b      	lsls	r3, r3, #1
 800ba84:	4413      	add	r3, r2
 800ba86:	00db      	lsls	r3, r3, #3
 800ba88:	440b      	add	r3, r1
 800ba8a:	3314      	adds	r3, #20
 800ba8c:	7bfa      	ldrb	r2, [r7, #15]
 800ba8e:	701a      	strb	r2, [r3, #0]
    aTimerContext[RefTimerID].PreviousID = TimerID;
 800ba90:	79ba      	ldrb	r2, [r7, #6]
 800ba92:	4913      	ldr	r1, [pc, #76]	; (800bae0 <LinkTimerBefore+0xbc>)
 800ba94:	4613      	mov	r3, r2
 800ba96:	005b      	lsls	r3, r3, #1
 800ba98:	4413      	add	r3, r2
 800ba9a:	00db      	lsls	r3, r3, #3
 800ba9c:	440b      	add	r3, r1
 800ba9e:	3314      	adds	r3, #20
 800baa0:	79fa      	ldrb	r2, [r7, #7]
 800baa2:	701a      	strb	r2, [r3, #0]
  {
    aTimerContext[TimerID].NextID = RefTimerID;
    aTimerContext[RefTimerID].PreviousID = TimerID;
  }

  return;
 800baa4:	e014      	b.n	800bad0 <LinkTimerBefore+0xac>
    aTimerContext[TimerID].NextID = RefTimerID;
 800baa6:	79fa      	ldrb	r2, [r7, #7]
 800baa8:	490d      	ldr	r1, [pc, #52]	; (800bae0 <LinkTimerBefore+0xbc>)
 800baaa:	4613      	mov	r3, r2
 800baac:	005b      	lsls	r3, r3, #1
 800baae:	4413      	add	r3, r2
 800bab0:	00db      	lsls	r3, r3, #3
 800bab2:	440b      	add	r3, r1
 800bab4:	3315      	adds	r3, #21
 800bab6:	79ba      	ldrb	r2, [r7, #6]
 800bab8:	701a      	strb	r2, [r3, #0]
    aTimerContext[RefTimerID].PreviousID = TimerID;
 800baba:	79ba      	ldrb	r2, [r7, #6]
 800babc:	4908      	ldr	r1, [pc, #32]	; (800bae0 <LinkTimerBefore+0xbc>)
 800babe:	4613      	mov	r3, r2
 800bac0:	005b      	lsls	r3, r3, #1
 800bac2:	4413      	add	r3, r2
 800bac4:	00db      	lsls	r3, r3, #3
 800bac6:	440b      	add	r3, r1
 800bac8:	3314      	adds	r3, #20
 800baca:	79fa      	ldrb	r2, [r7, #7]
 800bacc:	701a      	strb	r2, [r3, #0]
  return;
 800bace:	bf00      	nop
}
 800bad0:	3714      	adds	r7, #20
 800bad2:	46bd      	mov	sp, r7
 800bad4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bad8:	4770      	bx	lr
 800bada:	bf00      	nop
 800badc:	200000b8 	.word	0x200000b8
 800bae0:	20000028 	.word	0x20000028

0800bae4 <linkTimer>:
 * @brief  Insert a Timer in the list
 * @param  TimerID:   The ID of the Timer
 * @retval None
 */
static uint16_t linkTimer(uint8_t TimerID)
{
 800bae4:	b580      	push	{r7, lr}
 800bae6:	b084      	sub	sp, #16
 800bae8:	af00      	add	r7, sp, #0
 800baea:	4603      	mov	r3, r0
 800baec:	71fb      	strb	r3, [r7, #7]
  uint32_t time_left;
  uint16_t time_elapsed;
  uint8_t timer_id_lookup;
  uint8_t next_id;

  if(CurrentRunningTimerID == CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 800baee:	4b4e      	ldr	r3, [pc, #312]	; (800bc28 <linkTimer+0x144>)
 800baf0:	781b      	ldrb	r3, [r3, #0]
 800baf2:	b2db      	uxtb	r3, r3
 800baf4:	2b06      	cmp	r3, #6
 800baf6:	d118      	bne.n	800bb2a <linkTimer+0x46>
  {
    /**
     * No timer in the list
     */
    PreviousRunningTimerID = CurrentRunningTimerID;
 800baf8:	4b4b      	ldr	r3, [pc, #300]	; (800bc28 <linkTimer+0x144>)
 800bafa:	781b      	ldrb	r3, [r3, #0]
 800bafc:	b2da      	uxtb	r2, r3
 800bafe:	4b4b      	ldr	r3, [pc, #300]	; (800bc2c <linkTimer+0x148>)
 800bb00:	701a      	strb	r2, [r3, #0]
    CurrentRunningTimerID = TimerID;
 800bb02:	4a49      	ldr	r2, [pc, #292]	; (800bc28 <linkTimer+0x144>)
 800bb04:	79fb      	ldrb	r3, [r7, #7]
 800bb06:	7013      	strb	r3, [r2, #0]
    aTimerContext[TimerID].NextID = CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER;
 800bb08:	79fa      	ldrb	r2, [r7, #7]
 800bb0a:	4949      	ldr	r1, [pc, #292]	; (800bc30 <linkTimer+0x14c>)
 800bb0c:	4613      	mov	r3, r2
 800bb0e:	005b      	lsls	r3, r3, #1
 800bb10:	4413      	add	r3, r2
 800bb12:	00db      	lsls	r3, r3, #3
 800bb14:	440b      	add	r3, r1
 800bb16:	3315      	adds	r3, #21
 800bb18:	2206      	movs	r2, #6
 800bb1a:	701a      	strb	r2, [r3, #0]

    SSRValueOnLastSetup = SSR_FORBIDDEN_VALUE;
 800bb1c:	4b45      	ldr	r3, [pc, #276]	; (800bc34 <linkTimer+0x150>)
 800bb1e:	f04f 32ff 	mov.w	r2, #4294967295
 800bb22:	601a      	str	r2, [r3, #0]
    time_elapsed = 0;
 800bb24:	2300      	movs	r3, #0
 800bb26:	81fb      	strh	r3, [r7, #14]
 800bb28:	e078      	b.n	800bc1c <linkTimer+0x138>
  }
  else
  {
    time_elapsed = ReturnTimeElapsed();
 800bb2a:	f000 f909 	bl	800bd40 <ReturnTimeElapsed>
 800bb2e:	4603      	mov	r3, r0
 800bb30:	81fb      	strh	r3, [r7, #14]

    /**
     * update count of the timer to be linked
     */
    aTimerContext[TimerID].CountLeft += time_elapsed;
 800bb32:	79fa      	ldrb	r2, [r7, #7]
 800bb34:	493e      	ldr	r1, [pc, #248]	; (800bc30 <linkTimer+0x14c>)
 800bb36:	4613      	mov	r3, r2
 800bb38:	005b      	lsls	r3, r3, #1
 800bb3a:	4413      	add	r3, r2
 800bb3c:	00db      	lsls	r3, r3, #3
 800bb3e:	440b      	add	r3, r1
 800bb40:	3308      	adds	r3, #8
 800bb42:	6819      	ldr	r1, [r3, #0]
 800bb44:	89fb      	ldrh	r3, [r7, #14]
 800bb46:	79fa      	ldrb	r2, [r7, #7]
 800bb48:	4419      	add	r1, r3
 800bb4a:	4839      	ldr	r0, [pc, #228]	; (800bc30 <linkTimer+0x14c>)
 800bb4c:	4613      	mov	r3, r2
 800bb4e:	005b      	lsls	r3, r3, #1
 800bb50:	4413      	add	r3, r2
 800bb52:	00db      	lsls	r3, r3, #3
 800bb54:	4403      	add	r3, r0
 800bb56:	3308      	adds	r3, #8
 800bb58:	6019      	str	r1, [r3, #0]
    time_left = aTimerContext[TimerID].CountLeft;
 800bb5a:	79fa      	ldrb	r2, [r7, #7]
 800bb5c:	4934      	ldr	r1, [pc, #208]	; (800bc30 <linkTimer+0x14c>)
 800bb5e:	4613      	mov	r3, r2
 800bb60:	005b      	lsls	r3, r3, #1
 800bb62:	4413      	add	r3, r2
 800bb64:	00db      	lsls	r3, r3, #3
 800bb66:	440b      	add	r3, r1
 800bb68:	3308      	adds	r3, #8
 800bb6a:	681b      	ldr	r3, [r3, #0]
 800bb6c:	60bb      	str	r3, [r7, #8]

    /**
     * Search for index where the new timer shall be linked
     */
    if(aTimerContext[CurrentRunningTimerID].CountLeft <= time_left)
 800bb6e:	4b2e      	ldr	r3, [pc, #184]	; (800bc28 <linkTimer+0x144>)
 800bb70:	781b      	ldrb	r3, [r3, #0]
 800bb72:	b2db      	uxtb	r3, r3
 800bb74:	4619      	mov	r1, r3
 800bb76:	4a2e      	ldr	r2, [pc, #184]	; (800bc30 <linkTimer+0x14c>)
 800bb78:	460b      	mov	r3, r1
 800bb7a:	005b      	lsls	r3, r3, #1
 800bb7c:	440b      	add	r3, r1
 800bb7e:	00db      	lsls	r3, r3, #3
 800bb80:	4413      	add	r3, r2
 800bb82:	3308      	adds	r3, #8
 800bb84:	681b      	ldr	r3, [r3, #0]
 800bb86:	68ba      	ldr	r2, [r7, #8]
 800bb88:	429a      	cmp	r2, r3
 800bb8a:	d337      	bcc.n	800bbfc <linkTimer+0x118>
    {
      /**
       * Search for the ID after the first one
       */
      timer_id_lookup = CurrentRunningTimerID;
 800bb8c:	4b26      	ldr	r3, [pc, #152]	; (800bc28 <linkTimer+0x144>)
 800bb8e:	781b      	ldrb	r3, [r3, #0]
 800bb90:	737b      	strb	r3, [r7, #13]
      next_id = aTimerContext[timer_id_lookup].NextID;
 800bb92:	7b7a      	ldrb	r2, [r7, #13]
 800bb94:	4926      	ldr	r1, [pc, #152]	; (800bc30 <linkTimer+0x14c>)
 800bb96:	4613      	mov	r3, r2
 800bb98:	005b      	lsls	r3, r3, #1
 800bb9a:	4413      	add	r3, r2
 800bb9c:	00db      	lsls	r3, r3, #3
 800bb9e:	440b      	add	r3, r1
 800bba0:	3315      	adds	r3, #21
 800bba2:	781b      	ldrb	r3, [r3, #0]
 800bba4:	733b      	strb	r3, [r7, #12]
      while((next_id != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER) && (aTimerContext[next_id].CountLeft <= time_left))
 800bba6:	e013      	b.n	800bbd0 <linkTimer+0xec>
      {
        timer_id_lookup = aTimerContext[timer_id_lookup].NextID;
 800bba8:	7b7a      	ldrb	r2, [r7, #13]
 800bbaa:	4921      	ldr	r1, [pc, #132]	; (800bc30 <linkTimer+0x14c>)
 800bbac:	4613      	mov	r3, r2
 800bbae:	005b      	lsls	r3, r3, #1
 800bbb0:	4413      	add	r3, r2
 800bbb2:	00db      	lsls	r3, r3, #3
 800bbb4:	440b      	add	r3, r1
 800bbb6:	3315      	adds	r3, #21
 800bbb8:	781b      	ldrb	r3, [r3, #0]
 800bbba:	737b      	strb	r3, [r7, #13]
        next_id = aTimerContext[timer_id_lookup].NextID;
 800bbbc:	7b7a      	ldrb	r2, [r7, #13]
 800bbbe:	491c      	ldr	r1, [pc, #112]	; (800bc30 <linkTimer+0x14c>)
 800bbc0:	4613      	mov	r3, r2
 800bbc2:	005b      	lsls	r3, r3, #1
 800bbc4:	4413      	add	r3, r2
 800bbc6:	00db      	lsls	r3, r3, #3
 800bbc8:	440b      	add	r3, r1
 800bbca:	3315      	adds	r3, #21
 800bbcc:	781b      	ldrb	r3, [r3, #0]
 800bbce:	733b      	strb	r3, [r7, #12]
      while((next_id != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER) && (aTimerContext[next_id].CountLeft <= time_left))
 800bbd0:	7b3b      	ldrb	r3, [r7, #12]
 800bbd2:	2b06      	cmp	r3, #6
 800bbd4:	d00b      	beq.n	800bbee <linkTimer+0x10a>
 800bbd6:	7b3a      	ldrb	r2, [r7, #12]
 800bbd8:	4915      	ldr	r1, [pc, #84]	; (800bc30 <linkTimer+0x14c>)
 800bbda:	4613      	mov	r3, r2
 800bbdc:	005b      	lsls	r3, r3, #1
 800bbde:	4413      	add	r3, r2
 800bbe0:	00db      	lsls	r3, r3, #3
 800bbe2:	440b      	add	r3, r1
 800bbe4:	3308      	adds	r3, #8
 800bbe6:	681b      	ldr	r3, [r3, #0]
 800bbe8:	68ba      	ldr	r2, [r7, #8]
 800bbea:	429a      	cmp	r2, r3
 800bbec:	d2dc      	bcs.n	800bba8 <linkTimer+0xc4>
      }

      /**
       * Link after the ID
       */
      LinkTimerAfter(TimerID, timer_id_lookup);
 800bbee:	7b7a      	ldrb	r2, [r7, #13]
 800bbf0:	79fb      	ldrb	r3, [r7, #7]
 800bbf2:	4611      	mov	r1, r2
 800bbf4:	4618      	mov	r0, r3
 800bbf6:	f7ff fecf 	bl	800b998 <LinkTimerAfter>
 800bbfa:	e00f      	b.n	800bc1c <linkTimer+0x138>
    else
    {
      /**
       * Link before the first ID
       */
      LinkTimerBefore(TimerID, CurrentRunningTimerID);
 800bbfc:	4b0a      	ldr	r3, [pc, #40]	; (800bc28 <linkTimer+0x144>)
 800bbfe:	781b      	ldrb	r3, [r3, #0]
 800bc00:	b2da      	uxtb	r2, r3
 800bc02:	79fb      	ldrb	r3, [r7, #7]
 800bc04:	4611      	mov	r1, r2
 800bc06:	4618      	mov	r0, r3
 800bc08:	f7ff ff0c 	bl	800ba24 <LinkTimerBefore>
      PreviousRunningTimerID = CurrentRunningTimerID;
 800bc0c:	4b06      	ldr	r3, [pc, #24]	; (800bc28 <linkTimer+0x144>)
 800bc0e:	781b      	ldrb	r3, [r3, #0]
 800bc10:	b2da      	uxtb	r2, r3
 800bc12:	4b06      	ldr	r3, [pc, #24]	; (800bc2c <linkTimer+0x148>)
 800bc14:	701a      	strb	r2, [r3, #0]
      CurrentRunningTimerID = TimerID;
 800bc16:	4a04      	ldr	r2, [pc, #16]	; (800bc28 <linkTimer+0x144>)
 800bc18:	79fb      	ldrb	r3, [r7, #7]
 800bc1a:	7013      	strb	r3, [r2, #0]
    }
  }

  return time_elapsed;
 800bc1c:	89fb      	ldrh	r3, [r7, #14]
}
 800bc1e:	4618      	mov	r0, r3
 800bc20:	3710      	adds	r7, #16
 800bc22:	46bd      	mov	sp, r7
 800bc24:	bd80      	pop	{r7, pc}
 800bc26:	bf00      	nop
 800bc28:	200000b8 	.word	0x200000b8
 800bc2c:	200000b9 	.word	0x200000b9
 800bc30:	20000028 	.word	0x20000028
 800bc34:	200000bc 	.word	0x200000bc

0800bc38 <UnlinkTimer>:
 * @param  TimerID:   The ID of the Timer
 * @param  RequestReadSSR: Request to read the SSR register or not
 * @retval None
 */
static void UnlinkTimer(uint8_t TimerID, RequestReadSSR_t RequestReadSSR)
{
 800bc38:	b480      	push	{r7}
 800bc3a:	b085      	sub	sp, #20
 800bc3c:	af00      	add	r7, sp, #0
 800bc3e:	4603      	mov	r3, r0
 800bc40:	460a      	mov	r2, r1
 800bc42:	71fb      	strb	r3, [r7, #7]
 800bc44:	4613      	mov	r3, r2
 800bc46:	71bb      	strb	r3, [r7, #6]
  uint8_t previous_id;
  uint8_t next_id;

  if(TimerID == CurrentRunningTimerID)
 800bc48:	4b39      	ldr	r3, [pc, #228]	; (800bd30 <UnlinkTimer+0xf8>)
 800bc4a:	781b      	ldrb	r3, [r3, #0]
 800bc4c:	b2db      	uxtb	r3, r3
 800bc4e:	79fa      	ldrb	r2, [r7, #7]
 800bc50:	429a      	cmp	r2, r3
 800bc52:	d111      	bne.n	800bc78 <UnlinkTimer+0x40>
  {
    PreviousRunningTimerID = CurrentRunningTimerID;
 800bc54:	4b36      	ldr	r3, [pc, #216]	; (800bd30 <UnlinkTimer+0xf8>)
 800bc56:	781b      	ldrb	r3, [r3, #0]
 800bc58:	b2da      	uxtb	r2, r3
 800bc5a:	4b36      	ldr	r3, [pc, #216]	; (800bd34 <UnlinkTimer+0xfc>)
 800bc5c:	701a      	strb	r2, [r3, #0]
    CurrentRunningTimerID = aTimerContext[TimerID].NextID;
 800bc5e:	79fa      	ldrb	r2, [r7, #7]
 800bc60:	4935      	ldr	r1, [pc, #212]	; (800bd38 <UnlinkTimer+0x100>)
 800bc62:	4613      	mov	r3, r2
 800bc64:	005b      	lsls	r3, r3, #1
 800bc66:	4413      	add	r3, r2
 800bc68:	00db      	lsls	r3, r3, #3
 800bc6a:	440b      	add	r3, r1
 800bc6c:	3315      	adds	r3, #21
 800bc6e:	781b      	ldrb	r3, [r3, #0]
 800bc70:	b2da      	uxtb	r2, r3
 800bc72:	4b2f      	ldr	r3, [pc, #188]	; (800bd30 <UnlinkTimer+0xf8>)
 800bc74:	701a      	strb	r2, [r3, #0]
 800bc76:	e03e      	b.n	800bcf6 <UnlinkTimer+0xbe>
  }
  else
  {
    previous_id = aTimerContext[TimerID].PreviousID;
 800bc78:	79fa      	ldrb	r2, [r7, #7]
 800bc7a:	492f      	ldr	r1, [pc, #188]	; (800bd38 <UnlinkTimer+0x100>)
 800bc7c:	4613      	mov	r3, r2
 800bc7e:	005b      	lsls	r3, r3, #1
 800bc80:	4413      	add	r3, r2
 800bc82:	00db      	lsls	r3, r3, #3
 800bc84:	440b      	add	r3, r1
 800bc86:	3314      	adds	r3, #20
 800bc88:	781b      	ldrb	r3, [r3, #0]
 800bc8a:	73fb      	strb	r3, [r7, #15]
    next_id = aTimerContext[TimerID].NextID;
 800bc8c:	79fa      	ldrb	r2, [r7, #7]
 800bc8e:	492a      	ldr	r1, [pc, #168]	; (800bd38 <UnlinkTimer+0x100>)
 800bc90:	4613      	mov	r3, r2
 800bc92:	005b      	lsls	r3, r3, #1
 800bc94:	4413      	add	r3, r2
 800bc96:	00db      	lsls	r3, r3, #3
 800bc98:	440b      	add	r3, r1
 800bc9a:	3315      	adds	r3, #21
 800bc9c:	781b      	ldrb	r3, [r3, #0]
 800bc9e:	73bb      	strb	r3, [r7, #14]

    aTimerContext[previous_id].NextID = aTimerContext[TimerID].NextID;
 800bca0:	79f9      	ldrb	r1, [r7, #7]
 800bca2:	7bfa      	ldrb	r2, [r7, #15]
 800bca4:	4824      	ldr	r0, [pc, #144]	; (800bd38 <UnlinkTimer+0x100>)
 800bca6:	460b      	mov	r3, r1
 800bca8:	005b      	lsls	r3, r3, #1
 800bcaa:	440b      	add	r3, r1
 800bcac:	00db      	lsls	r3, r3, #3
 800bcae:	4403      	add	r3, r0
 800bcb0:	3315      	adds	r3, #21
 800bcb2:	781b      	ldrb	r3, [r3, #0]
 800bcb4:	b2d8      	uxtb	r0, r3
 800bcb6:	4920      	ldr	r1, [pc, #128]	; (800bd38 <UnlinkTimer+0x100>)
 800bcb8:	4613      	mov	r3, r2
 800bcba:	005b      	lsls	r3, r3, #1
 800bcbc:	4413      	add	r3, r2
 800bcbe:	00db      	lsls	r3, r3, #3
 800bcc0:	440b      	add	r3, r1
 800bcc2:	3315      	adds	r3, #21
 800bcc4:	4602      	mov	r2, r0
 800bcc6:	701a      	strb	r2, [r3, #0]
    if(next_id != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 800bcc8:	7bbb      	ldrb	r3, [r7, #14]
 800bcca:	2b06      	cmp	r3, #6
 800bccc:	d013      	beq.n	800bcf6 <UnlinkTimer+0xbe>
    {
      aTimerContext[next_id].PreviousID = aTimerContext[TimerID].PreviousID;
 800bcce:	79f9      	ldrb	r1, [r7, #7]
 800bcd0:	7bba      	ldrb	r2, [r7, #14]
 800bcd2:	4819      	ldr	r0, [pc, #100]	; (800bd38 <UnlinkTimer+0x100>)
 800bcd4:	460b      	mov	r3, r1
 800bcd6:	005b      	lsls	r3, r3, #1
 800bcd8:	440b      	add	r3, r1
 800bcda:	00db      	lsls	r3, r3, #3
 800bcdc:	4403      	add	r3, r0
 800bcde:	3314      	adds	r3, #20
 800bce0:	781b      	ldrb	r3, [r3, #0]
 800bce2:	b2d8      	uxtb	r0, r3
 800bce4:	4914      	ldr	r1, [pc, #80]	; (800bd38 <UnlinkTimer+0x100>)
 800bce6:	4613      	mov	r3, r2
 800bce8:	005b      	lsls	r3, r3, #1
 800bcea:	4413      	add	r3, r2
 800bcec:	00db      	lsls	r3, r3, #3
 800bcee:	440b      	add	r3, r1
 800bcf0:	3314      	adds	r3, #20
 800bcf2:	4602      	mov	r2, r0
 800bcf4:	701a      	strb	r2, [r3, #0]
  }

  /**
   * Timer is out of the list
   */
  aTimerContext[TimerID].TimerIDStatus = TimerID_Created;
 800bcf6:	79fa      	ldrb	r2, [r7, #7]
 800bcf8:	490f      	ldr	r1, [pc, #60]	; (800bd38 <UnlinkTimer+0x100>)
 800bcfa:	4613      	mov	r3, r2
 800bcfc:	005b      	lsls	r3, r3, #1
 800bcfe:	4413      	add	r3, r2
 800bd00:	00db      	lsls	r3, r3, #3
 800bd02:	440b      	add	r3, r1
 800bd04:	330c      	adds	r3, #12
 800bd06:	2201      	movs	r2, #1
 800bd08:	701a      	strb	r2, [r3, #0]

  if((CurrentRunningTimerID == CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER) && (RequestReadSSR == SSR_Read_Requested))
 800bd0a:	4b09      	ldr	r3, [pc, #36]	; (800bd30 <UnlinkTimer+0xf8>)
 800bd0c:	781b      	ldrb	r3, [r3, #0]
 800bd0e:	b2db      	uxtb	r3, r3
 800bd10:	2b06      	cmp	r3, #6
 800bd12:	d107      	bne.n	800bd24 <UnlinkTimer+0xec>
 800bd14:	79bb      	ldrb	r3, [r7, #6]
 800bd16:	2b00      	cmp	r3, #0
 800bd18:	d104      	bne.n	800bd24 <UnlinkTimer+0xec>
  {
    SSRValueOnLastSetup = SSR_FORBIDDEN_VALUE;
 800bd1a:	4b08      	ldr	r3, [pc, #32]	; (800bd3c <UnlinkTimer+0x104>)
 800bd1c:	f04f 32ff 	mov.w	r2, #4294967295
 800bd20:	601a      	str	r2, [r3, #0]
  }

  return;
 800bd22:	bf00      	nop
 800bd24:	bf00      	nop
}
 800bd26:	3714      	adds	r7, #20
 800bd28:	46bd      	mov	sp, r7
 800bd2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bd2e:	4770      	bx	lr
 800bd30:	200000b8 	.word	0x200000b8
 800bd34:	200000b9 	.word	0x200000b9
 800bd38:	20000028 	.word	0x20000028
 800bd3c:	200000bc 	.word	0x200000bc

0800bd40 <ReturnTimeElapsed>:
 *        since the time the timer has been started
 * @param  None
 * @retval Time expired in Ticks
 */
static uint16_t ReturnTimeElapsed(void)
{
 800bd40:	b580      	push	{r7, lr}
 800bd42:	b082      	sub	sp, #8
 800bd44:	af00      	add	r7, sp, #0
  uint32_t  return_value;
  uint32_t  wrap_counter;

  if(SSRValueOnLastSetup != SSR_FORBIDDEN_VALUE)
 800bd46:	4b1a      	ldr	r3, [pc, #104]	; (800bdb0 <ReturnTimeElapsed+0x70>)
 800bd48:	681b      	ldr	r3, [r3, #0]
 800bd4a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800bd4e:	d026      	beq.n	800bd9e <ReturnTimeElapsed+0x5e>
  {
    return_value = ReadRtcSsrValue(); /**< Read SSR register first */
 800bd50:	f7ff fe02 	bl	800b958 <ReadRtcSsrValue>
 800bd54:	6078      	str	r0, [r7, #4]

    if (SSRValueOnLastSetup >= return_value)
 800bd56:	4b16      	ldr	r3, [pc, #88]	; (800bdb0 <ReturnTimeElapsed+0x70>)
 800bd58:	681b      	ldr	r3, [r3, #0]
 800bd5a:	687a      	ldr	r2, [r7, #4]
 800bd5c:	429a      	cmp	r2, r3
 800bd5e:	d805      	bhi.n	800bd6c <ReturnTimeElapsed+0x2c>
    {
      return_value = SSRValueOnLastSetup - return_value;
 800bd60:	4b13      	ldr	r3, [pc, #76]	; (800bdb0 <ReturnTimeElapsed+0x70>)
 800bd62:	681a      	ldr	r2, [r3, #0]
 800bd64:	687b      	ldr	r3, [r7, #4]
 800bd66:	1ad3      	subs	r3, r2, r3
 800bd68:	607b      	str	r3, [r7, #4]
 800bd6a:	e00a      	b.n	800bd82 <ReturnTimeElapsed+0x42>
    }
    else
    {
      wrap_counter = SynchPrescalerUserConfig - return_value;
 800bd6c:	4b11      	ldr	r3, [pc, #68]	; (800bdb4 <ReturnTimeElapsed+0x74>)
 800bd6e:	881b      	ldrh	r3, [r3, #0]
 800bd70:	461a      	mov	r2, r3
 800bd72:	687b      	ldr	r3, [r7, #4]
 800bd74:	1ad3      	subs	r3, r2, r3
 800bd76:	603b      	str	r3, [r7, #0]
      return_value = SSRValueOnLastSetup + wrap_counter;
 800bd78:	4b0d      	ldr	r3, [pc, #52]	; (800bdb0 <ReturnTimeElapsed+0x70>)
 800bd7a:	681b      	ldr	r3, [r3, #0]
 800bd7c:	683a      	ldr	r2, [r7, #0]
 800bd7e:	4413      	add	r3, r2
 800bd80:	607b      	str	r3, [r7, #4]

    /**
     * At this stage, ReturnValue holds the number of ticks counted by SSR
     * Need to translate in number of ticks counted by the Wakeuptimer
     */
    return_value = return_value*AsynchPrescalerUserConfig;
 800bd82:	4b0d      	ldr	r3, [pc, #52]	; (800bdb8 <ReturnTimeElapsed+0x78>)
 800bd84:	781b      	ldrb	r3, [r3, #0]
 800bd86:	461a      	mov	r2, r3
 800bd88:	687b      	ldr	r3, [r7, #4]
 800bd8a:	fb02 f303 	mul.w	r3, r2, r3
 800bd8e:	607b      	str	r3, [r7, #4]
    return_value = return_value >> WakeupTimerDivider;
 800bd90:	4b0a      	ldr	r3, [pc, #40]	; (800bdbc <ReturnTimeElapsed+0x7c>)
 800bd92:	781b      	ldrb	r3, [r3, #0]
 800bd94:	461a      	mov	r2, r3
 800bd96:	687b      	ldr	r3, [r7, #4]
 800bd98:	40d3      	lsrs	r3, r2
 800bd9a:	607b      	str	r3, [r7, #4]
 800bd9c:	e001      	b.n	800bda2 <ReturnTimeElapsed+0x62>
  }
  else
  {
    return_value = 0;
 800bd9e:	2300      	movs	r3, #0
 800bda0:	607b      	str	r3, [r7, #4]
  }

  return (uint16_t)return_value;
 800bda2:	687b      	ldr	r3, [r7, #4]
 800bda4:	b29b      	uxth	r3, r3
}
 800bda6:	4618      	mov	r0, r3
 800bda8:	3708      	adds	r7, #8
 800bdaa:	46bd      	mov	sp, r7
 800bdac:	bd80      	pop	{r7, pc}
 800bdae:	bf00      	nop
 800bdb0:	200000bc 	.word	0x200000bc
 800bdb4:	20000ef6 	.word	0x20000ef6
 800bdb8:	20000ef5 	.word	0x20000ef5
 800bdbc:	20000ef4 	.word	0x20000ef4

0800bdc0 <RestartWakeupCounter>:
 *    It assumes all condition are met to be allowed to write the wakeup counter
 * @param  Value: Value to be written in the counter
 * @retval None
 */
static void RestartWakeupCounter(uint16_t Value)
{
 800bdc0:	b580      	push	{r7, lr}
 800bdc2:	b082      	sub	sp, #8
 800bdc4:	af00      	add	r7, sp, #0
 800bdc6:	4603      	mov	r3, r0
 800bdc8:	80fb      	strh	r3, [r7, #6]
   * The wakeuptimer has been disabled in the calling function to reduce the time to poll the WUTWF
   * FLAG when the new value will have to be written
   *  __HAL_RTC_WAKEUPTIMER_DISABLE(phrtc);
   */

  if(Value == 0)
 800bdca:	88fb      	ldrh	r3, [r7, #6]
 800bdcc:	2b00      	cmp	r3, #0
 800bdce:	d108      	bne.n	800bde2 <RestartWakeupCounter+0x22>
  {
    SSRValueOnLastSetup = ReadRtcSsrValue();
 800bdd0:	f7ff fdc2 	bl	800b958 <ReadRtcSsrValue>
 800bdd4:	4603      	mov	r3, r0
 800bdd6:	4a24      	ldr	r2, [pc, #144]	; (800be68 <RestartWakeupCounter+0xa8>)
 800bdd8:	6013      	str	r3, [r2, #0]

    /**
     * Simulate that the Timer expired
     */
    HAL_NVIC_SetPendingIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);
 800bdda:	2003      	movs	r0, #3
 800bddc:	f003 fad7 	bl	800f38e <HAL_NVIC_SetPendingIRQ>
    __HAL_RTC_WAKEUPTIMER_ENABLE(phrtc);    /**<  Enable the Wakeup Timer */

    HW_TS_RTC_CountUpdated_AppNot();
  }

  return ;
 800bde0:	e03e      	b.n	800be60 <RestartWakeupCounter+0xa0>
    if((Value > 1) ||(WakeupTimerDivider != 1))
 800bde2:	88fb      	ldrh	r3, [r7, #6]
 800bde4:	2b01      	cmp	r3, #1
 800bde6:	d803      	bhi.n	800bdf0 <RestartWakeupCounter+0x30>
 800bde8:	4b20      	ldr	r3, [pc, #128]	; (800be6c <RestartWakeupCounter+0xac>)
 800bdea:	781b      	ldrb	r3, [r3, #0]
 800bdec:	2b01      	cmp	r3, #1
 800bdee:	d002      	beq.n	800bdf6 <RestartWakeupCounter+0x36>
      Value -= 1;
 800bdf0:	88fb      	ldrh	r3, [r7, #6]
 800bdf2:	3b01      	subs	r3, #1
 800bdf4:	80fb      	strh	r3, [r7, #6]
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(phrtc, RTC_FLAG_WUTWF) == RESET);
 800bdf6:	bf00      	nop
 800bdf8:	4b1d      	ldr	r3, [pc, #116]	; (800be70 <RestartWakeupCounter+0xb0>)
 800bdfa:	681b      	ldr	r3, [r3, #0]
 800bdfc:	681b      	ldr	r3, [r3, #0]
 800bdfe:	68db      	ldr	r3, [r3, #12]
 800be00:	f003 0304 	and.w	r3, r3, #4
 800be04:	2b00      	cmp	r3, #0
 800be06:	d0f7      	beq.n	800bdf8 <RestartWakeupCounter+0x38>
    __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(phrtc, RTC_FLAG_WUTF);   /**<  Clear flag in RTC module */
 800be08:	4b19      	ldr	r3, [pc, #100]	; (800be70 <RestartWakeupCounter+0xb0>)
 800be0a:	681b      	ldr	r3, [r3, #0]
 800be0c:	681b      	ldr	r3, [r3, #0]
 800be0e:	68db      	ldr	r3, [r3, #12]
 800be10:	b2da      	uxtb	r2, r3
 800be12:	4b17      	ldr	r3, [pc, #92]	; (800be70 <RestartWakeupCounter+0xb0>)
 800be14:	681b      	ldr	r3, [r3, #0]
 800be16:	681b      	ldr	r3, [r3, #0]
 800be18:	f462 6290 	orn	r2, r2, #1152	; 0x480
 800be1c:	60da      	str	r2, [r3, #12]
    __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG(); /**<  Clear flag in EXTI module */
 800be1e:	4b15      	ldr	r3, [pc, #84]	; (800be74 <RestartWakeupCounter+0xb4>)
 800be20:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800be24:	60da      	str	r2, [r3, #12]
    HAL_NVIC_ClearPendingIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);   /**<  Clear pending bit in NVIC */
 800be26:	2003      	movs	r0, #3
 800be28:	f003 fabf 	bl	800f3aa <HAL_NVIC_ClearPendingIRQ>
    MODIFY_REG(RTC->WUTR, RTC_WUTR_WUT, Value);
 800be2c:	4b12      	ldr	r3, [pc, #72]	; (800be78 <RestartWakeupCounter+0xb8>)
 800be2e:	695b      	ldr	r3, [r3, #20]
 800be30:	0c1b      	lsrs	r3, r3, #16
 800be32:	041b      	lsls	r3, r3, #16
 800be34:	88fa      	ldrh	r2, [r7, #6]
 800be36:	4910      	ldr	r1, [pc, #64]	; (800be78 <RestartWakeupCounter+0xb8>)
 800be38:	4313      	orrs	r3, r2
 800be3a:	614b      	str	r3, [r1, #20]
    SSRValueOnLastSetup = ReadRtcSsrValue();
 800be3c:	f7ff fd8c 	bl	800b958 <ReadRtcSsrValue>
 800be40:	4603      	mov	r3, r0
 800be42:	4a09      	ldr	r2, [pc, #36]	; (800be68 <RestartWakeupCounter+0xa8>)
 800be44:	6013      	str	r3, [r2, #0]
    __HAL_RTC_WAKEUPTIMER_ENABLE(phrtc);    /**<  Enable the Wakeup Timer */
 800be46:	4b0a      	ldr	r3, [pc, #40]	; (800be70 <RestartWakeupCounter+0xb0>)
 800be48:	681b      	ldr	r3, [r3, #0]
 800be4a:	681b      	ldr	r3, [r3, #0]
 800be4c:	689a      	ldr	r2, [r3, #8]
 800be4e:	4b08      	ldr	r3, [pc, #32]	; (800be70 <RestartWakeupCounter+0xb0>)
 800be50:	681b      	ldr	r3, [r3, #0]
 800be52:	681b      	ldr	r3, [r3, #0]
 800be54:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800be58:	609a      	str	r2, [r3, #8]
    HW_TS_RTC_CountUpdated_AppNot();
 800be5a:	f3af 8000 	nop.w
  return ;
 800be5e:	bf00      	nop
}
 800be60:	3708      	adds	r7, #8
 800be62:	46bd      	mov	sp, r7
 800be64:	bd80      	pop	{r7, pc}
 800be66:	bf00      	nop
 800be68:	200000bc 	.word	0x200000bc
 800be6c:	20000ef4 	.word	0x20000ef4
 800be70:	20000ef0 	.word	0x20000ef0
 800be74:	58000800 	.word	0x58000800
 800be78:	40002800 	.word	0x40002800

0800be7c <RescheduleTimerList>:
 *    2) Setup the wakeuptimer
 * @param  None
 * @retval None
 */
static void RescheduleTimerList(void)
{
 800be7c:	b580      	push	{r7, lr}
 800be7e:	b084      	sub	sp, #16
 800be80:	af00      	add	r7, sp, #0

  /**
   * The wakeuptimer is disabled now to reduce the time to poll the WUTWF
   * FLAG when the new value will have to be written
   */
  if((READ_BIT(RTC->CR, RTC_CR_WUTE) == (RTC_CR_WUTE)) == SET)
 800be82:	4b47      	ldr	r3, [pc, #284]	; (800bfa0 <RescheduleTimerList+0x124>)
 800be84:	689b      	ldr	r3, [r3, #8]
 800be86:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800be8a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800be8e:	d108      	bne.n	800bea2 <RescheduleTimerList+0x26>
  {
    /**
     * Wait for the flag to be back to 0 when the wakeup timer is enabled
     */
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(phrtc, RTC_FLAG_WUTWF) == SET);
 800be90:	bf00      	nop
 800be92:	4b44      	ldr	r3, [pc, #272]	; (800bfa4 <RescheduleTimerList+0x128>)
 800be94:	681b      	ldr	r3, [r3, #0]
 800be96:	681b      	ldr	r3, [r3, #0]
 800be98:	68db      	ldr	r3, [r3, #12]
 800be9a:	f003 0304 	and.w	r3, r3, #4
 800be9e:	2b00      	cmp	r3, #0
 800bea0:	d1f7      	bne.n	800be92 <RescheduleTimerList+0x16>
  }
  __HAL_RTC_WAKEUPTIMER_DISABLE(phrtc);   /**<  Disable the Wakeup Timer */
 800bea2:	4b40      	ldr	r3, [pc, #256]	; (800bfa4 <RescheduleTimerList+0x128>)
 800bea4:	681b      	ldr	r3, [r3, #0]
 800bea6:	681b      	ldr	r3, [r3, #0]
 800bea8:	689a      	ldr	r2, [r3, #8]
 800beaa:	4b3e      	ldr	r3, [pc, #248]	; (800bfa4 <RescheduleTimerList+0x128>)
 800beac:	681b      	ldr	r3, [r3, #0]
 800beae:	681b      	ldr	r3, [r3, #0]
 800beb0:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800beb4:	609a      	str	r2, [r3, #8]

  localTimerID = CurrentRunningTimerID;
 800beb6:	4b3c      	ldr	r3, [pc, #240]	; (800bfa8 <RescheduleTimerList+0x12c>)
 800beb8:	781b      	ldrb	r3, [r3, #0]
 800beba:	73fb      	strb	r3, [r7, #15]

  /**
   * Calculate what will be the value to write in the wakeuptimer
   */
  timecountleft = aTimerContext[localTimerID].CountLeft;
 800bebc:	7bfa      	ldrb	r2, [r7, #15]
 800bebe:	493b      	ldr	r1, [pc, #236]	; (800bfac <RescheduleTimerList+0x130>)
 800bec0:	4613      	mov	r3, r2
 800bec2:	005b      	lsls	r3, r3, #1
 800bec4:	4413      	add	r3, r2
 800bec6:	00db      	lsls	r3, r3, #3
 800bec8:	440b      	add	r3, r1
 800beca:	3308      	adds	r3, #8
 800becc:	681b      	ldr	r3, [r3, #0]
 800bece:	60bb      	str	r3, [r7, #8]

  /**
   * Read how much has been counted
   */
  time_elapsed = ReturnTimeElapsed();
 800bed0:	f7ff ff36 	bl	800bd40 <ReturnTimeElapsed>
 800bed4:	4603      	mov	r3, r0
 800bed6:	80fb      	strh	r3, [r7, #6]

  if(timecountleft < time_elapsed )
 800bed8:	88fb      	ldrh	r3, [r7, #6]
 800beda:	68ba      	ldr	r2, [r7, #8]
 800bedc:	429a      	cmp	r2, r3
 800bede:	d205      	bcs.n	800beec <RescheduleTimerList+0x70>
  {
    /**
     * There is no tick left to count
     */
    wakeup_timer_value = 0;
 800bee0:	2300      	movs	r3, #0
 800bee2:	81bb      	strh	r3, [r7, #12]
    WakeupTimerLimitation = WakeupTimerValue_LargeEnough;
 800bee4:	4b32      	ldr	r3, [pc, #200]	; (800bfb0 <RescheduleTimerList+0x134>)
 800bee6:	2201      	movs	r2, #1
 800bee8:	701a      	strb	r2, [r3, #0]
 800beea:	e04d      	b.n	800bf88 <RescheduleTimerList+0x10c>
  }
  else
  {
    if(timecountleft > (time_elapsed + MaxWakeupTimerSetup))
 800beec:	88fb      	ldrh	r3, [r7, #6]
 800beee:	4a31      	ldr	r2, [pc, #196]	; (800bfb4 <RescheduleTimerList+0x138>)
 800bef0:	8812      	ldrh	r2, [r2, #0]
 800bef2:	b292      	uxth	r2, r2
 800bef4:	4413      	add	r3, r2
 800bef6:	461a      	mov	r2, r3
 800bef8:	68bb      	ldr	r3, [r7, #8]
 800befa:	4293      	cmp	r3, r2
 800befc:	d906      	bls.n	800bf0c <RescheduleTimerList+0x90>
    {
      /**
       * The number of tick left is greater than the Wakeuptimer maximum value
       */
      wakeup_timer_value = MaxWakeupTimerSetup;
 800befe:	4b2d      	ldr	r3, [pc, #180]	; (800bfb4 <RescheduleTimerList+0x138>)
 800bf00:	881b      	ldrh	r3, [r3, #0]
 800bf02:	81bb      	strh	r3, [r7, #12]

      WakeupTimerLimitation = WakeupTimerValue_Overpassed;
 800bf04:	4b2a      	ldr	r3, [pc, #168]	; (800bfb0 <RescheduleTimerList+0x134>)
 800bf06:	2200      	movs	r2, #0
 800bf08:	701a      	strb	r2, [r3, #0]
 800bf0a:	e03d      	b.n	800bf88 <RescheduleTimerList+0x10c>
    }
    else
    {
      wakeup_timer_value = timecountleft - time_elapsed;
 800bf0c:	68bb      	ldr	r3, [r7, #8]
 800bf0e:	b29a      	uxth	r2, r3
 800bf10:	88fb      	ldrh	r3, [r7, #6]
 800bf12:	1ad3      	subs	r3, r2, r3
 800bf14:	81bb      	strh	r3, [r7, #12]
      WakeupTimerLimitation = WakeupTimerValue_LargeEnough;
 800bf16:	4b26      	ldr	r3, [pc, #152]	; (800bfb0 <RescheduleTimerList+0x134>)
 800bf18:	2201      	movs	r2, #1
 800bf1a:	701a      	strb	r2, [r3, #0]
  }

  /**
   * update ticks left to be counted for each timer
   */
  while(localTimerID != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 800bf1c:	e034      	b.n	800bf88 <RescheduleTimerList+0x10c>
  {
    if (aTimerContext[localTimerID].CountLeft < time_elapsed)
 800bf1e:	7bfa      	ldrb	r2, [r7, #15]
 800bf20:	4922      	ldr	r1, [pc, #136]	; (800bfac <RescheduleTimerList+0x130>)
 800bf22:	4613      	mov	r3, r2
 800bf24:	005b      	lsls	r3, r3, #1
 800bf26:	4413      	add	r3, r2
 800bf28:	00db      	lsls	r3, r3, #3
 800bf2a:	440b      	add	r3, r1
 800bf2c:	3308      	adds	r3, #8
 800bf2e:	681a      	ldr	r2, [r3, #0]
 800bf30:	88fb      	ldrh	r3, [r7, #6]
 800bf32:	429a      	cmp	r2, r3
 800bf34:	d20a      	bcs.n	800bf4c <RescheduleTimerList+0xd0>
    {
      aTimerContext[localTimerID].CountLeft = 0;
 800bf36:	7bfa      	ldrb	r2, [r7, #15]
 800bf38:	491c      	ldr	r1, [pc, #112]	; (800bfac <RescheduleTimerList+0x130>)
 800bf3a:	4613      	mov	r3, r2
 800bf3c:	005b      	lsls	r3, r3, #1
 800bf3e:	4413      	add	r3, r2
 800bf40:	00db      	lsls	r3, r3, #3
 800bf42:	440b      	add	r3, r1
 800bf44:	3308      	adds	r3, #8
 800bf46:	2200      	movs	r2, #0
 800bf48:	601a      	str	r2, [r3, #0]
 800bf4a:	e013      	b.n	800bf74 <RescheduleTimerList+0xf8>
    }
    else
    {
      aTimerContext[localTimerID].CountLeft -= time_elapsed;
 800bf4c:	7bfa      	ldrb	r2, [r7, #15]
 800bf4e:	4917      	ldr	r1, [pc, #92]	; (800bfac <RescheduleTimerList+0x130>)
 800bf50:	4613      	mov	r3, r2
 800bf52:	005b      	lsls	r3, r3, #1
 800bf54:	4413      	add	r3, r2
 800bf56:	00db      	lsls	r3, r3, #3
 800bf58:	440b      	add	r3, r1
 800bf5a:	3308      	adds	r3, #8
 800bf5c:	6819      	ldr	r1, [r3, #0]
 800bf5e:	88fb      	ldrh	r3, [r7, #6]
 800bf60:	7bfa      	ldrb	r2, [r7, #15]
 800bf62:	1ac9      	subs	r1, r1, r3
 800bf64:	4811      	ldr	r0, [pc, #68]	; (800bfac <RescheduleTimerList+0x130>)
 800bf66:	4613      	mov	r3, r2
 800bf68:	005b      	lsls	r3, r3, #1
 800bf6a:	4413      	add	r3, r2
 800bf6c:	00db      	lsls	r3, r3, #3
 800bf6e:	4403      	add	r3, r0
 800bf70:	3308      	adds	r3, #8
 800bf72:	6019      	str	r1, [r3, #0]
    }
    localTimerID = aTimerContext[localTimerID].NextID;
 800bf74:	7bfa      	ldrb	r2, [r7, #15]
 800bf76:	490d      	ldr	r1, [pc, #52]	; (800bfac <RescheduleTimerList+0x130>)
 800bf78:	4613      	mov	r3, r2
 800bf7a:	005b      	lsls	r3, r3, #1
 800bf7c:	4413      	add	r3, r2
 800bf7e:	00db      	lsls	r3, r3, #3
 800bf80:	440b      	add	r3, r1
 800bf82:	3315      	adds	r3, #21
 800bf84:	781b      	ldrb	r3, [r3, #0]
 800bf86:	73fb      	strb	r3, [r7, #15]
  while(localTimerID != CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 800bf88:	7bfb      	ldrb	r3, [r7, #15]
 800bf8a:	2b06      	cmp	r3, #6
 800bf8c:	d1c7      	bne.n	800bf1e <RescheduleTimerList+0xa2>
  }

  /**
   * Write next count
   */
  RestartWakeupCounter(wakeup_timer_value);
 800bf8e:	89bb      	ldrh	r3, [r7, #12]
 800bf90:	4618      	mov	r0, r3
 800bf92:	f7ff ff15 	bl	800bdc0 <RestartWakeupCounter>

  return ;
 800bf96:	bf00      	nop
}
 800bf98:	3710      	adds	r7, #16
 800bf9a:	46bd      	mov	sp, r7
 800bf9c:	bd80      	pop	{r7, pc}
 800bf9e:	bf00      	nop
 800bfa0:	40002800 	.word	0x40002800
 800bfa4:	20000ef0 	.word	0x20000ef0
 800bfa8:	200000b8 	.word	0x200000b8
 800bfac:	20000028 	.word	0x20000028
 800bfb0:	200000c0 	.word	0x200000c0
 800bfb4:	20000ef8 	.word	0x20000ef8

0800bfb8 <HW_TS_RTC_Wakeup_Handler>:
 * In order to ease maintainability, the unlock is done at the top and the lock at then end
 * in case some new implementation is coming in the future
 */

void HW_TS_RTC_Wakeup_Handler(void)
{
 800bfb8:	b580      	push	{r7, lr}
 800bfba:	b08a      	sub	sp, #40	; 0x28
 800bfbc:	af00      	add	r7, sp, #0
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800bfbe:	f3ef 8310 	mrs	r3, PRIMASK
 800bfc2:	617b      	str	r3, [r7, #20]
  return(result);
 800bfc4:	697b      	ldr	r3, [r7, #20]
#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  uint32_t primask_bit;
#endif

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 800bfc6:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("cpsid i" : : : "memory");
 800bfc8:	b672      	cpsid	i
}
 800bfca:	bf00      	nop
  __disable_irq();          /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
#endif

/* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE( phrtc );
 800bfcc:	4b5f      	ldr	r3, [pc, #380]	; (800c14c <HW_TS_RTC_Wakeup_Handler+0x194>)
 800bfce:	681b      	ldr	r3, [r3, #0]
 800bfd0:	681b      	ldr	r3, [r3, #0]
 800bfd2:	22ca      	movs	r2, #202	; 0xca
 800bfd4:	625a      	str	r2, [r3, #36]	; 0x24
 800bfd6:	4b5d      	ldr	r3, [pc, #372]	; (800c14c <HW_TS_RTC_Wakeup_Handler+0x194>)
 800bfd8:	681b      	ldr	r3, [r3, #0]
 800bfda:	681b      	ldr	r3, [r3, #0]
 800bfdc:	2253      	movs	r2, #83	; 0x53
 800bfde:	625a      	str	r2, [r3, #36]	; 0x24
  /**
   * Disable the Wakeup Timer
   * This may speed up a bit the processing to wait the timer to be disabled
   * The timer is still counting 2 RTCCLK
   */
  __HAL_RTC_WAKEUPTIMER_DISABLE(phrtc);
 800bfe0:	4b5a      	ldr	r3, [pc, #360]	; (800c14c <HW_TS_RTC_Wakeup_Handler+0x194>)
 800bfe2:	681b      	ldr	r3, [r3, #0]
 800bfe4:	681b      	ldr	r3, [r3, #0]
 800bfe6:	689a      	ldr	r2, [r3, #8]
 800bfe8:	4b58      	ldr	r3, [pc, #352]	; (800c14c <HW_TS_RTC_Wakeup_Handler+0x194>)
 800bfea:	681b      	ldr	r3, [r3, #0]
 800bfec:	681b      	ldr	r3, [r3, #0]
 800bfee:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800bff2:	609a      	str	r2, [r3, #8]

  local_current_running_timer_id = CurrentRunningTimerID;
 800bff4:	4b56      	ldr	r3, [pc, #344]	; (800c150 <HW_TS_RTC_Wakeup_Handler+0x198>)
 800bff6:	781b      	ldrb	r3, [r3, #0]
 800bff8:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

  if(aTimerContext[local_current_running_timer_id].TimerIDStatus == TimerID_Running)
 800bffc:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 800c000:	4954      	ldr	r1, [pc, #336]	; (800c154 <HW_TS_RTC_Wakeup_Handler+0x19c>)
 800c002:	4613      	mov	r3, r2
 800c004:	005b      	lsls	r3, r3, #1
 800c006:	4413      	add	r3, r2
 800c008:	00db      	lsls	r3, r3, #3
 800c00a:	440b      	add	r3, r1
 800c00c:	330c      	adds	r3, #12
 800c00e:	781b      	ldrb	r3, [r3, #0]
 800c010:	b2db      	uxtb	r3, r3
 800c012:	2b02      	cmp	r3, #2
 800c014:	d172      	bne.n	800c0fc <HW_TS_RTC_Wakeup_Handler+0x144>
  {
    ptimer_callback = aTimerContext[local_current_running_timer_id].pTimerCallBack;
 800c016:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 800c01a:	494e      	ldr	r1, [pc, #312]	; (800c154 <HW_TS_RTC_Wakeup_Handler+0x19c>)
 800c01c:	4613      	mov	r3, r2
 800c01e:	005b      	lsls	r3, r3, #1
 800c020:	4413      	add	r3, r2
 800c022:	00db      	lsls	r3, r3, #3
 800c024:	440b      	add	r3, r1
 800c026:	681b      	ldr	r3, [r3, #0]
 800c028:	61fb      	str	r3, [r7, #28]
    timer_process_id = aTimerContext[local_current_running_timer_id].TimerProcessID;
 800c02a:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 800c02e:	4949      	ldr	r1, [pc, #292]	; (800c154 <HW_TS_RTC_Wakeup_Handler+0x19c>)
 800c030:	4613      	mov	r3, r2
 800c032:	005b      	lsls	r3, r3, #1
 800c034:	4413      	add	r3, r2
 800c036:	00db      	lsls	r3, r3, #3
 800c038:	440b      	add	r3, r1
 800c03a:	3310      	adds	r3, #16
 800c03c:	681b      	ldr	r3, [r3, #0]
 800c03e:	61bb      	str	r3, [r7, #24]
     * However, due to the inaccuracy of the reading of the time elapsed, it may return there is 1 tick
     * to be left whereas the count is over
     * A more secure implementation has been done with a flag to state whereas the full count has been written
     * in the wakeuptimer or not
     */
    if(WakeupTimerLimitation != WakeupTimerValue_Overpassed)
 800c040:	4b45      	ldr	r3, [pc, #276]	; (800c158 <HW_TS_RTC_Wakeup_Handler+0x1a0>)
 800c042:	781b      	ldrb	r3, [r3, #0]
 800c044:	b2db      	uxtb	r3, r3
 800c046:	2b00      	cmp	r3, #0
 800c048:	d050      	beq.n	800c0ec <HW_TS_RTC_Wakeup_Handler+0x134>
    {
      if(aTimerContext[local_current_running_timer_id].TimerMode == hw_ts_Repeated)
 800c04a:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 800c04e:	4941      	ldr	r1, [pc, #260]	; (800c154 <HW_TS_RTC_Wakeup_Handler+0x19c>)
 800c050:	4613      	mov	r3, r2
 800c052:	005b      	lsls	r3, r3, #1
 800c054:	4413      	add	r3, r2
 800c056:	00db      	lsls	r3, r3, #3
 800c058:	440b      	add	r3, r1
 800c05a:	330d      	adds	r3, #13
 800c05c:	781b      	ldrb	r3, [r3, #0]
 800c05e:	b2db      	uxtb	r3, r3
 800c060:	2b01      	cmp	r3, #1
 800c062:	d126      	bne.n	800c0b2 <HW_TS_RTC_Wakeup_Handler+0xfa>
      {
        UnlinkTimer(local_current_running_timer_id, SSR_Read_Not_Requested);
 800c064:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800c068:	2101      	movs	r1, #1
 800c06a:	4618      	mov	r0, r3
 800c06c:	f7ff fde4 	bl	800bc38 <UnlinkTimer>
 800c070:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c072:	613b      	str	r3, [r7, #16]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800c074:	693b      	ldr	r3, [r7, #16]
 800c076:	f383 8810 	msr	PRIMASK, r3
}
 800c07a:	bf00      	nop
#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
        __set_PRIMASK(primask_bit); /**< Restore PRIMASK bit*/
#endif
        HW_TS_Start(local_current_running_timer_id, aTimerContext[local_current_running_timer_id].CounterInit);
 800c07c:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 800c080:	4934      	ldr	r1, [pc, #208]	; (800c154 <HW_TS_RTC_Wakeup_Handler+0x19c>)
 800c082:	4613      	mov	r3, r2
 800c084:	005b      	lsls	r3, r3, #1
 800c086:	4413      	add	r3, r2
 800c088:	00db      	lsls	r3, r3, #3
 800c08a:	440b      	add	r3, r1
 800c08c:	3304      	adds	r3, #4
 800c08e:	681a      	ldr	r2, [r3, #0]
 800c090:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800c094:	4611      	mov	r1, r2
 800c096:	4618      	mov	r0, r3
 800c098:	f000 f9d4 	bl	800c444 <HW_TS_Start>

        /* Disable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_DISABLE( phrtc );
 800c09c:	4b2b      	ldr	r3, [pc, #172]	; (800c14c <HW_TS_RTC_Wakeup_Handler+0x194>)
 800c09e:	681b      	ldr	r3, [r3, #0]
 800c0a0:	681b      	ldr	r3, [r3, #0]
 800c0a2:	22ca      	movs	r2, #202	; 0xca
 800c0a4:	625a      	str	r2, [r3, #36]	; 0x24
 800c0a6:	4b29      	ldr	r3, [pc, #164]	; (800c14c <HW_TS_RTC_Wakeup_Handler+0x194>)
 800c0a8:	681b      	ldr	r3, [r3, #0]
 800c0aa:	681b      	ldr	r3, [r3, #0]
 800c0ac:	2253      	movs	r2, #83	; 0x53
 800c0ae:	625a      	str	r2, [r3, #36]	; 0x24
 800c0b0:	e014      	b.n	800c0dc <HW_TS_RTC_Wakeup_Handler+0x124>
 800c0b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c0b4:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800c0b6:	68fb      	ldr	r3, [r7, #12]
 800c0b8:	f383 8810 	msr	PRIMASK, r3
}
 800c0bc:	bf00      	nop
      else
      {
#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
        __set_PRIMASK(primask_bit); /**< Restore PRIMASK bit*/
#endif
        HW_TS_Stop(local_current_running_timer_id);
 800c0be:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800c0c2:	4618      	mov	r0, r3
 800c0c4:	f000 f932 	bl	800c32c <HW_TS_Stop>

        /* Disable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_DISABLE( phrtc );
 800c0c8:	4b20      	ldr	r3, [pc, #128]	; (800c14c <HW_TS_RTC_Wakeup_Handler+0x194>)
 800c0ca:	681b      	ldr	r3, [r3, #0]
 800c0cc:	681b      	ldr	r3, [r3, #0]
 800c0ce:	22ca      	movs	r2, #202	; 0xca
 800c0d0:	625a      	str	r2, [r3, #36]	; 0x24
 800c0d2:	4b1e      	ldr	r3, [pc, #120]	; (800c14c <HW_TS_RTC_Wakeup_Handler+0x194>)
 800c0d4:	681b      	ldr	r3, [r3, #0]
 800c0d6:	681b      	ldr	r3, [r3, #0]
 800c0d8:	2253      	movs	r2, #83	; 0x53
 800c0da:	625a      	str	r2, [r3, #36]	; 0x24
        }

      HW_TS_RTC_Int_AppNot(timer_process_id, local_current_running_timer_id, ptimer_callback);
 800c0dc:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800c0e0:	69fa      	ldr	r2, [r7, #28]
 800c0e2:	4619      	mov	r1, r3
 800c0e4:	69b8      	ldr	r0, [r7, #24]
 800c0e6:	f000 fa35 	bl	800c554 <HW_TS_RTC_Int_AppNot>
 800c0ea:	e025      	b.n	800c138 <HW_TS_RTC_Wakeup_Handler+0x180>
    }
    else
    {
      RescheduleTimerList();
 800c0ec:	f7ff fec6 	bl	800be7c <RescheduleTimerList>
 800c0f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c0f2:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800c0f4:	68bb      	ldr	r3, [r7, #8]
 800c0f6:	f383 8810 	msr	PRIMASK, r3
}
 800c0fa:	e01d      	b.n	800c138 <HW_TS_RTC_Wakeup_Handler+0x180>
    /**
     * We should never end up in this case
     * However, if due to any bug in the timer server this is the case, the mistake may not impact the user.
     * We could just clean the interrupt flag and get out from this unexpected interrupt
     */
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(phrtc, RTC_FLAG_WUTWF) == RESET);
 800c0fc:	bf00      	nop
 800c0fe:	4b13      	ldr	r3, [pc, #76]	; (800c14c <HW_TS_RTC_Wakeup_Handler+0x194>)
 800c100:	681b      	ldr	r3, [r3, #0]
 800c102:	681b      	ldr	r3, [r3, #0]
 800c104:	68db      	ldr	r3, [r3, #12]
 800c106:	f003 0304 	and.w	r3, r3, #4
 800c10a:	2b00      	cmp	r3, #0
 800c10c:	d0f7      	beq.n	800c0fe <HW_TS_RTC_Wakeup_Handler+0x146>
     * It takes 2 RTCCLK between the time the WUTE bit is disabled and the
     * time the timer is disabled. The WUTWF bit somehow guarantee the system is stable
     * Otherwise, when the timer is periodic with 1 Tick, it may generate an extra interrupt in between
     * due to the autoreload feature
     */
    __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(phrtc, RTC_FLAG_WUTF);   /**<  Clear flag in RTC module */
 800c10e:	4b0f      	ldr	r3, [pc, #60]	; (800c14c <HW_TS_RTC_Wakeup_Handler+0x194>)
 800c110:	681b      	ldr	r3, [r3, #0]
 800c112:	681b      	ldr	r3, [r3, #0]
 800c114:	68db      	ldr	r3, [r3, #12]
 800c116:	b2da      	uxtb	r2, r3
 800c118:	4b0c      	ldr	r3, [pc, #48]	; (800c14c <HW_TS_RTC_Wakeup_Handler+0x194>)
 800c11a:	681b      	ldr	r3, [r3, #0]
 800c11c:	681b      	ldr	r3, [r3, #0]
 800c11e:	f462 6290 	orn	r2, r2, #1152	; 0x480
 800c122:	60da      	str	r2, [r3, #12]
    __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG(); /**<  Clear flag in EXTI module */
 800c124:	4b0d      	ldr	r3, [pc, #52]	; (800c15c <HW_TS_RTC_Wakeup_Handler+0x1a4>)
 800c126:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800c12a:	60da      	str	r2, [r3, #12]
 800c12c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c12e:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800c130:	687b      	ldr	r3, [r7, #4]
 800c132:	f383 8810 	msr	PRIMASK, r3
}
 800c136:	bf00      	nop
    __set_PRIMASK(primask_bit); /**< Restore PRIMASK bit*/
#endif
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE( phrtc );
 800c138:	4b04      	ldr	r3, [pc, #16]	; (800c14c <HW_TS_RTC_Wakeup_Handler+0x194>)
 800c13a:	681b      	ldr	r3, [r3, #0]
 800c13c:	681b      	ldr	r3, [r3, #0]
 800c13e:	22ff      	movs	r2, #255	; 0xff
 800c140:	625a      	str	r2, [r3, #36]	; 0x24

  return;
 800c142:	bf00      	nop
}
 800c144:	3728      	adds	r7, #40	; 0x28
 800c146:	46bd      	mov	sp, r7
 800c148:	bd80      	pop	{r7, pc}
 800c14a:	bf00      	nop
 800c14c:	20000ef0 	.word	0x20000ef0
 800c150:	200000b8 	.word	0x200000b8
 800c154:	20000028 	.word	0x20000028
 800c158:	200000c0 	.word	0x200000c0
 800c15c:	58000800 	.word	0x58000800

0800c160 <HW_TS_Init>:

void HW_TS_Init(HW_TS_InitMode_t TimerInitMode, RTC_HandleTypeDef *hrtc)
{
 800c160:	b580      	push	{r7, lr}
 800c162:	b088      	sub	sp, #32
 800c164:	af00      	add	r7, sp, #0
 800c166:	4603      	mov	r3, r0
 800c168:	6039      	str	r1, [r7, #0]
 800c16a:	71fb      	strb	r3, [r7, #7]
  uint32_t localmaxwakeuptimersetup;

  /**
   * Get RTC handler
   */
  phrtc = hrtc;
 800c16c:	4a64      	ldr	r2, [pc, #400]	; (800c300 <HW_TS_Init+0x1a0>)
 800c16e:	683b      	ldr	r3, [r7, #0]
 800c170:	6013      	str	r3, [r2, #0]

 /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE( phrtc );
 800c172:	4b63      	ldr	r3, [pc, #396]	; (800c300 <HW_TS_Init+0x1a0>)
 800c174:	681b      	ldr	r3, [r3, #0]
 800c176:	681b      	ldr	r3, [r3, #0]
 800c178:	22ca      	movs	r2, #202	; 0xca
 800c17a:	625a      	str	r2, [r3, #36]	; 0x24
 800c17c:	4b60      	ldr	r3, [pc, #384]	; (800c300 <HW_TS_Init+0x1a0>)
 800c17e:	681b      	ldr	r3, [r3, #0]
 800c180:	681b      	ldr	r3, [r3, #0]
 800c182:	2253      	movs	r2, #83	; 0x53
 800c184:	625a      	str	r2, [r3, #36]	; 0x24

  SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 800c186:	4b5f      	ldr	r3, [pc, #380]	; (800c304 <HW_TS_Init+0x1a4>)
 800c188:	689b      	ldr	r3, [r3, #8]
 800c18a:	4a5e      	ldr	r2, [pc, #376]	; (800c304 <HW_TS_Init+0x1a4>)
 800c18c:	f043 0320 	orr.w	r3, r3, #32
 800c190:	6093      	str	r3, [r2, #8]

  /**
   * Readout the user config
   */
  WakeupTimerDivider = (4 - ((uint32_t)(READ_BIT(RTC->CR, RTC_CR_WUCKSEL))));
 800c192:	4b5c      	ldr	r3, [pc, #368]	; (800c304 <HW_TS_Init+0x1a4>)
 800c194:	689b      	ldr	r3, [r3, #8]
 800c196:	b2db      	uxtb	r3, r3
 800c198:	f003 0307 	and.w	r3, r3, #7
 800c19c:	b2db      	uxtb	r3, r3
 800c19e:	f1c3 0304 	rsb	r3, r3, #4
 800c1a2:	b2da      	uxtb	r2, r3
 800c1a4:	4b58      	ldr	r3, [pc, #352]	; (800c308 <HW_TS_Init+0x1a8>)
 800c1a6:	701a      	strb	r2, [r3, #0]

  AsynchPrescalerUserConfig = (uint8_t)(READ_BIT(RTC->PRER, RTC_PRER_PREDIV_A) >> (uint32_t)POSITION_VAL(RTC_PRER_PREDIV_A)) + 1;
 800c1a8:	4b56      	ldr	r3, [pc, #344]	; (800c304 <HW_TS_Init+0x1a4>)
 800c1aa:	691b      	ldr	r3, [r3, #16]
 800c1ac:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
 800c1b0:	f44f 02fe 	mov.w	r2, #8323072	; 0x7f0000
 800c1b4:	613a      	str	r2, [r7, #16]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800c1b6:	693a      	ldr	r2, [r7, #16]
 800c1b8:	fa92 f2a2 	rbit	r2, r2
 800c1bc:	60fa      	str	r2, [r7, #12]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
 800c1be:	68fa      	ldr	r2, [r7, #12]
 800c1c0:	617a      	str	r2, [r7, #20]
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
 800c1c2:	697a      	ldr	r2, [r7, #20]
 800c1c4:	2a00      	cmp	r2, #0
 800c1c6:	d101      	bne.n	800c1cc <HW_TS_Init+0x6c>
  {
    return 32U;
 800c1c8:	2220      	movs	r2, #32
 800c1ca:	e003      	b.n	800c1d4 <HW_TS_Init+0x74>
  }
  return __builtin_clz(value);
 800c1cc:	697a      	ldr	r2, [r7, #20]
 800c1ce:	fab2 f282 	clz	r2, r2
 800c1d2:	b2d2      	uxtb	r2, r2
 800c1d4:	40d3      	lsrs	r3, r2
 800c1d6:	b2db      	uxtb	r3, r3
 800c1d8:	3301      	adds	r3, #1
 800c1da:	b2da      	uxtb	r2, r3
 800c1dc:	4b4b      	ldr	r3, [pc, #300]	; (800c30c <HW_TS_Init+0x1ac>)
 800c1de:	701a      	strb	r2, [r3, #0]

  SynchPrescalerUserConfig = (uint16_t)(READ_BIT(RTC->PRER, RTC_PRER_PREDIV_S)) + 1;
 800c1e0:	4b48      	ldr	r3, [pc, #288]	; (800c304 <HW_TS_Init+0x1a4>)
 800c1e2:	691b      	ldr	r3, [r3, #16]
 800c1e4:	b29b      	uxth	r3, r3
 800c1e6:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800c1ea:	b29b      	uxth	r3, r3
 800c1ec:	3301      	adds	r3, #1
 800c1ee:	b29a      	uxth	r2, r3
 800c1f0:	4b47      	ldr	r3, [pc, #284]	; (800c310 <HW_TS_Init+0x1b0>)
 800c1f2:	801a      	strh	r2, [r3, #0]

  /**
   *  Margin is taken to avoid wrong calculation when the wrap around is there and some
   *  application interrupts may have delayed the reading
   */
  localmaxwakeuptimersetup = ((((SynchPrescalerUserConfig - 1)*AsynchPrescalerUserConfig) - CFG_HW_TS_RTC_HANDLER_MAX_DELAY) >> WakeupTimerDivider);
 800c1f4:	4b46      	ldr	r3, [pc, #280]	; (800c310 <HW_TS_Init+0x1b0>)
 800c1f6:	881b      	ldrh	r3, [r3, #0]
 800c1f8:	3b01      	subs	r3, #1
 800c1fa:	4a44      	ldr	r2, [pc, #272]	; (800c30c <HW_TS_Init+0x1ac>)
 800c1fc:	7812      	ldrb	r2, [r2, #0]
 800c1fe:	fb02 f303 	mul.w	r3, r2, r3
 800c202:	f5a3 73a0 	sub.w	r3, r3, #320	; 0x140
 800c206:	4a40      	ldr	r2, [pc, #256]	; (800c308 <HW_TS_Init+0x1a8>)
 800c208:	7812      	ldrb	r2, [r2, #0]
 800c20a:	40d3      	lsrs	r3, r2
 800c20c:	61bb      	str	r3, [r7, #24]

  if(localmaxwakeuptimersetup >= 0xFFFF)
 800c20e:	69bb      	ldr	r3, [r7, #24]
 800c210:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 800c214:	4293      	cmp	r3, r2
 800c216:	d904      	bls.n	800c222 <HW_TS_Init+0xc2>
  {
    MaxWakeupTimerSetup = 0xFFFF;
 800c218:	4b3e      	ldr	r3, [pc, #248]	; (800c314 <HW_TS_Init+0x1b4>)
 800c21a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800c21e:	801a      	strh	r2, [r3, #0]
 800c220:	e003      	b.n	800c22a <HW_TS_Init+0xca>
  }
  else
  {
    MaxWakeupTimerSetup = (uint16_t)localmaxwakeuptimersetup;
 800c222:	69bb      	ldr	r3, [r7, #24]
 800c224:	b29a      	uxth	r2, r3
 800c226:	4b3b      	ldr	r3, [pc, #236]	; (800c314 <HW_TS_Init+0x1b4>)
 800c228:	801a      	strh	r2, [r3, #0]
  }

  /**
   * Configure EXTI module
   */
  LL_EXTI_EnableRisingTrig_0_31(RTC_EXTI_LINE_WAKEUPTIMER_EVENT);
 800c22a:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800c22e:	f7ff fb81 	bl	800b934 <LL_EXTI_EnableRisingTrig_0_31>
  LL_EXTI_EnableIT_0_31(RTC_EXTI_LINE_WAKEUPTIMER_EVENT);
 800c232:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800c236:	f7ff fb69 	bl	800b90c <LL_EXTI_EnableIT_0_31>

  if(TimerInitMode == hw_ts_InitMode_Full)
 800c23a:	79fb      	ldrb	r3, [r7, #7]
 800c23c:	2b00      	cmp	r3, #0
 800c23e:	d143      	bne.n	800c2c8 <HW_TS_Init+0x168>
  {
    WakeupTimerLimitation = WakeupTimerValue_LargeEnough;
 800c240:	4b35      	ldr	r3, [pc, #212]	; (800c318 <HW_TS_Init+0x1b8>)
 800c242:	2201      	movs	r2, #1
 800c244:	701a      	strb	r2, [r3, #0]
    SSRValueOnLastSetup = SSR_FORBIDDEN_VALUE;
 800c246:	4b35      	ldr	r3, [pc, #212]	; (800c31c <HW_TS_Init+0x1bc>)
 800c248:	f04f 32ff 	mov.w	r2, #4294967295
 800c24c:	601a      	str	r2, [r3, #0]

    /**
     * Initialize the timer server
     */
    for(loop = 0; loop < CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER; loop++)
 800c24e:	2300      	movs	r3, #0
 800c250:	77fb      	strb	r3, [r7, #31]
 800c252:	e00c      	b.n	800c26e <HW_TS_Init+0x10e>
    {
      aTimerContext[loop].TimerIDStatus = TimerID_Free;
 800c254:	7ffa      	ldrb	r2, [r7, #31]
 800c256:	4932      	ldr	r1, [pc, #200]	; (800c320 <HW_TS_Init+0x1c0>)
 800c258:	4613      	mov	r3, r2
 800c25a:	005b      	lsls	r3, r3, #1
 800c25c:	4413      	add	r3, r2
 800c25e:	00db      	lsls	r3, r3, #3
 800c260:	440b      	add	r3, r1
 800c262:	330c      	adds	r3, #12
 800c264:	2200      	movs	r2, #0
 800c266:	701a      	strb	r2, [r3, #0]
    for(loop = 0; loop < CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER; loop++)
 800c268:	7ffb      	ldrb	r3, [r7, #31]
 800c26a:	3301      	adds	r3, #1
 800c26c:	77fb      	strb	r3, [r7, #31]
 800c26e:	7ffb      	ldrb	r3, [r7, #31]
 800c270:	2b05      	cmp	r3, #5
 800c272:	d9ef      	bls.n	800c254 <HW_TS_Init+0xf4>
    }

    CurrentRunningTimerID = CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER;   /**<  Set ID to non valid value */
 800c274:	4b2b      	ldr	r3, [pc, #172]	; (800c324 <HW_TS_Init+0x1c4>)
 800c276:	2206      	movs	r2, #6
 800c278:	701a      	strb	r2, [r3, #0]

    __HAL_RTC_WAKEUPTIMER_DISABLE(phrtc);                       /**<  Disable the Wakeup Timer */
 800c27a:	4b21      	ldr	r3, [pc, #132]	; (800c300 <HW_TS_Init+0x1a0>)
 800c27c:	681b      	ldr	r3, [r3, #0]
 800c27e:	681b      	ldr	r3, [r3, #0]
 800c280:	689a      	ldr	r2, [r3, #8]
 800c282:	4b1f      	ldr	r3, [pc, #124]	; (800c300 <HW_TS_Init+0x1a0>)
 800c284:	681b      	ldr	r3, [r3, #0]
 800c286:	681b      	ldr	r3, [r3, #0]
 800c288:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800c28c:	609a      	str	r2, [r3, #8]
    __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(phrtc, RTC_FLAG_WUTF);     /**<  Clear flag in RTC module */
 800c28e:	4b1c      	ldr	r3, [pc, #112]	; (800c300 <HW_TS_Init+0x1a0>)
 800c290:	681b      	ldr	r3, [r3, #0]
 800c292:	681b      	ldr	r3, [r3, #0]
 800c294:	68db      	ldr	r3, [r3, #12]
 800c296:	b2da      	uxtb	r2, r3
 800c298:	4b19      	ldr	r3, [pc, #100]	; (800c300 <HW_TS_Init+0x1a0>)
 800c29a:	681b      	ldr	r3, [r3, #0]
 800c29c:	681b      	ldr	r3, [r3, #0]
 800c29e:	f462 6290 	orn	r2, r2, #1152	; 0x480
 800c2a2:	60da      	str	r2, [r3, #12]
    __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG(); /**<  Clear flag in EXTI module  */
 800c2a4:	4b20      	ldr	r3, [pc, #128]	; (800c328 <HW_TS_Init+0x1c8>)
 800c2a6:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800c2aa:	60da      	str	r2, [r3, #12]
    HAL_NVIC_ClearPendingIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);       /**<  Clear pending bit in NVIC  */
 800c2ac:	2003      	movs	r0, #3
 800c2ae:	f003 f87c 	bl	800f3aa <HAL_NVIC_ClearPendingIRQ>
    __HAL_RTC_WAKEUPTIMER_ENABLE_IT(phrtc, RTC_IT_WUT);         /**<  Enable interrupt in RTC module  */
 800c2b2:	4b13      	ldr	r3, [pc, #76]	; (800c300 <HW_TS_Init+0x1a0>)
 800c2b4:	681b      	ldr	r3, [r3, #0]
 800c2b6:	681b      	ldr	r3, [r3, #0]
 800c2b8:	689a      	ldr	r2, [r3, #8]
 800c2ba:	4b11      	ldr	r3, [pc, #68]	; (800c300 <HW_TS_Init+0x1a0>)
 800c2bc:	681b      	ldr	r3, [r3, #0]
 800c2be:	681b      	ldr	r3, [r3, #0]
 800c2c0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800c2c4:	609a      	str	r2, [r3, #8]
 800c2c6:	e00a      	b.n	800c2de <HW_TS_Init+0x17e>
  }
  else
  {
    if(__HAL_RTC_WAKEUPTIMER_GET_FLAG(phrtc, RTC_FLAG_WUTF) != RESET)
 800c2c8:	4b0d      	ldr	r3, [pc, #52]	; (800c300 <HW_TS_Init+0x1a0>)
 800c2ca:	681b      	ldr	r3, [r3, #0]
 800c2cc:	681b      	ldr	r3, [r3, #0]
 800c2ce:	68db      	ldr	r3, [r3, #12]
 800c2d0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800c2d4:	2b00      	cmp	r3, #0
 800c2d6:	d002      	beq.n	800c2de <HW_TS_Init+0x17e>
    {
      /**
       * Simulate that the Timer expired
       */
      HAL_NVIC_SetPendingIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);
 800c2d8:	2003      	movs	r0, #3
 800c2da:	f003 f858 	bl	800f38e <HAL_NVIC_SetPendingIRQ>
    }
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE( phrtc );
 800c2de:	4b08      	ldr	r3, [pc, #32]	; (800c300 <HW_TS_Init+0x1a0>)
 800c2e0:	681b      	ldr	r3, [r3, #0]
 800c2e2:	681b      	ldr	r3, [r3, #0]
 800c2e4:	22ff      	movs	r2, #255	; 0xff
 800c2e6:	625a      	str	r2, [r3, #36]	; 0x24

  HAL_NVIC_SetPriority(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID, CFG_HW_TS_NVIC_RTC_WAKEUP_IT_PREEMPTPRIO, CFG_HW_TS_NVIC_RTC_WAKEUP_IT_SUBPRIO);   /**<  Set NVIC priority */
 800c2e8:	2200      	movs	r2, #0
 800c2ea:	2103      	movs	r1, #3
 800c2ec:	2003      	movs	r0, #3
 800c2ee:	f003 f80c 	bl	800f30a <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID); /**<  Enable NVIC */
 800c2f2:	2003      	movs	r0, #3
 800c2f4:	f003 f823 	bl	800f33e <HAL_NVIC_EnableIRQ>

  return;
 800c2f8:	bf00      	nop
}
 800c2fa:	3720      	adds	r7, #32
 800c2fc:	46bd      	mov	sp, r7
 800c2fe:	bd80      	pop	{r7, pc}
 800c300:	20000ef0 	.word	0x20000ef0
 800c304:	40002800 	.word	0x40002800
 800c308:	20000ef4 	.word	0x20000ef4
 800c30c:	20000ef5 	.word	0x20000ef5
 800c310:	20000ef6 	.word	0x20000ef6
 800c314:	20000ef8 	.word	0x20000ef8
 800c318:	200000c0 	.word	0x200000c0
 800c31c:	200000bc 	.word	0x200000bc
 800c320:	20000028 	.word	0x20000028
 800c324:	200000b8 	.word	0x200000b8
 800c328:	58000800 	.word	0x58000800

0800c32c <HW_TS_Stop>:

  return;
}

void HW_TS_Stop(uint8_t timer_id)
{
 800c32c:	b580      	push	{r7, lr}
 800c32e:	b086      	sub	sp, #24
 800c330:	af00      	add	r7, sp, #0
 800c332:	4603      	mov	r3, r0
 800c334:	71fb      	strb	r3, [r7, #7]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800c336:	f3ef 8310 	mrs	r3, PRIMASK
 800c33a:	60fb      	str	r3, [r7, #12]
  return(result);
 800c33c:	68fb      	ldr	r3, [r7, #12]
#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  uint32_t primask_bit;
#endif

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 800c33e:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 800c340:	b672      	cpsid	i
}
 800c342:	bf00      	nop
  __disable_irq();          /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
#endif

  HAL_NVIC_DisableIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);    /**<  Disable NVIC */
 800c344:	2003      	movs	r0, #3
 800c346:	f003 f808 	bl	800f35a <HAL_NVIC_DisableIRQ>

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE( phrtc );
 800c34a:	4b38      	ldr	r3, [pc, #224]	; (800c42c <HW_TS_Stop+0x100>)
 800c34c:	681b      	ldr	r3, [r3, #0]
 800c34e:	681b      	ldr	r3, [r3, #0]
 800c350:	22ca      	movs	r2, #202	; 0xca
 800c352:	625a      	str	r2, [r3, #36]	; 0x24
 800c354:	4b35      	ldr	r3, [pc, #212]	; (800c42c <HW_TS_Stop+0x100>)
 800c356:	681b      	ldr	r3, [r3, #0]
 800c358:	681b      	ldr	r3, [r3, #0]
 800c35a:	2253      	movs	r2, #83	; 0x53
 800c35c:	625a      	str	r2, [r3, #36]	; 0x24

  if(aTimerContext[timer_id].TimerIDStatus == TimerID_Running)
 800c35e:	79fa      	ldrb	r2, [r7, #7]
 800c360:	4933      	ldr	r1, [pc, #204]	; (800c430 <HW_TS_Stop+0x104>)
 800c362:	4613      	mov	r3, r2
 800c364:	005b      	lsls	r3, r3, #1
 800c366:	4413      	add	r3, r2
 800c368:	00db      	lsls	r3, r3, #3
 800c36a:	440b      	add	r3, r1
 800c36c:	330c      	adds	r3, #12
 800c36e:	781b      	ldrb	r3, [r3, #0]
 800c370:	b2db      	uxtb	r3, r3
 800c372:	2b02      	cmp	r3, #2
 800c374:	d148      	bne.n	800c408 <HW_TS_Stop+0xdc>
  {
    UnlinkTimer(timer_id, SSR_Read_Requested);
 800c376:	79fb      	ldrb	r3, [r7, #7]
 800c378:	2100      	movs	r1, #0
 800c37a:	4618      	mov	r0, r3
 800c37c:	f7ff fc5c 	bl	800bc38 <UnlinkTimer>
    localcurrentrunningtimerid = CurrentRunningTimerID;
 800c380:	4b2c      	ldr	r3, [pc, #176]	; (800c434 <HW_TS_Stop+0x108>)
 800c382:	781b      	ldrb	r3, [r3, #0]
 800c384:	74fb      	strb	r3, [r7, #19]

    if(localcurrentrunningtimerid == CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER)
 800c386:	7cfb      	ldrb	r3, [r7, #19]
 800c388:	2b06      	cmp	r3, #6
 800c38a:	d135      	bne.n	800c3f8 <HW_TS_Stop+0xcc>
       */

      /**
       * Disable the timer
       */
      if((READ_BIT(RTC->CR, RTC_CR_WUTE) == (RTC_CR_WUTE)) == SET)
 800c38c:	4b2a      	ldr	r3, [pc, #168]	; (800c438 <HW_TS_Stop+0x10c>)
 800c38e:	689b      	ldr	r3, [r3, #8]
 800c390:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800c394:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800c398:	d108      	bne.n	800c3ac <HW_TS_Stop+0x80>
      {
        /**
         * Wait for the flag to be back to 0 when the wakeup timer is enabled
         */
        while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(phrtc, RTC_FLAG_WUTWF) == SET);
 800c39a:	bf00      	nop
 800c39c:	4b23      	ldr	r3, [pc, #140]	; (800c42c <HW_TS_Stop+0x100>)
 800c39e:	681b      	ldr	r3, [r3, #0]
 800c3a0:	681b      	ldr	r3, [r3, #0]
 800c3a2:	68db      	ldr	r3, [r3, #12]
 800c3a4:	f003 0304 	and.w	r3, r3, #4
 800c3a8:	2b00      	cmp	r3, #0
 800c3aa:	d1f7      	bne.n	800c39c <HW_TS_Stop+0x70>
      }
      __HAL_RTC_WAKEUPTIMER_DISABLE(phrtc);   /**<  Disable the Wakeup Timer */
 800c3ac:	4b1f      	ldr	r3, [pc, #124]	; (800c42c <HW_TS_Stop+0x100>)
 800c3ae:	681b      	ldr	r3, [r3, #0]
 800c3b0:	681b      	ldr	r3, [r3, #0]
 800c3b2:	689a      	ldr	r2, [r3, #8]
 800c3b4:	4b1d      	ldr	r3, [pc, #116]	; (800c42c <HW_TS_Stop+0x100>)
 800c3b6:	681b      	ldr	r3, [r3, #0]
 800c3b8:	681b      	ldr	r3, [r3, #0]
 800c3ba:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800c3be:	609a      	str	r2, [r3, #8]

      while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(phrtc, RTC_FLAG_WUTWF) == RESET);
 800c3c0:	bf00      	nop
 800c3c2:	4b1a      	ldr	r3, [pc, #104]	; (800c42c <HW_TS_Stop+0x100>)
 800c3c4:	681b      	ldr	r3, [r3, #0]
 800c3c6:	681b      	ldr	r3, [r3, #0]
 800c3c8:	68db      	ldr	r3, [r3, #12]
 800c3ca:	f003 0304 	and.w	r3, r3, #4
 800c3ce:	2b00      	cmp	r3, #0
 800c3d0:	d0f7      	beq.n	800c3c2 <HW_TS_Stop+0x96>
       * It takes 2 RTCCLK between the time the WUTE bit is disabled and the
       * time the timer is disabled. The WUTWF bit somehow guarantee the system is stable
       * Otherwise, when the timer is periodic with 1 Tick, it may generate an extra interrupt in between
       * due to the autoreload feature
       */
      __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(phrtc, RTC_FLAG_WUTF);   /**<  Clear flag in RTC module */
 800c3d2:	4b16      	ldr	r3, [pc, #88]	; (800c42c <HW_TS_Stop+0x100>)
 800c3d4:	681b      	ldr	r3, [r3, #0]
 800c3d6:	681b      	ldr	r3, [r3, #0]
 800c3d8:	68db      	ldr	r3, [r3, #12]
 800c3da:	b2da      	uxtb	r2, r3
 800c3dc:	4b13      	ldr	r3, [pc, #76]	; (800c42c <HW_TS_Stop+0x100>)
 800c3de:	681b      	ldr	r3, [r3, #0]
 800c3e0:	681b      	ldr	r3, [r3, #0]
 800c3e2:	f462 6290 	orn	r2, r2, #1152	; 0x480
 800c3e6:	60da      	str	r2, [r3, #12]
      __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG(); /**<  Clear flag in EXTI module */
 800c3e8:	4b14      	ldr	r3, [pc, #80]	; (800c43c <HW_TS_Stop+0x110>)
 800c3ea:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800c3ee:	60da      	str	r2, [r3, #12]
      HAL_NVIC_ClearPendingIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);   /**<  Clear pending bit in NVIC */
 800c3f0:	2003      	movs	r0, #3
 800c3f2:	f002 ffda 	bl	800f3aa <HAL_NVIC_ClearPendingIRQ>
 800c3f6:	e007      	b.n	800c408 <HW_TS_Stop+0xdc>
    }
    else if(PreviousRunningTimerID != localcurrentrunningtimerid)
 800c3f8:	4b11      	ldr	r3, [pc, #68]	; (800c440 <HW_TS_Stop+0x114>)
 800c3fa:	781b      	ldrb	r3, [r3, #0]
 800c3fc:	b2db      	uxtb	r3, r3
 800c3fe:	7cfa      	ldrb	r2, [r7, #19]
 800c400:	429a      	cmp	r2, r3
 800c402:	d001      	beq.n	800c408 <HW_TS_Stop+0xdc>
    {
      RescheduleTimerList();
 800c404:	f7ff fd3a 	bl	800be7c <RescheduleTimerList>
    }
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE( phrtc );
 800c408:	4b08      	ldr	r3, [pc, #32]	; (800c42c <HW_TS_Stop+0x100>)
 800c40a:	681b      	ldr	r3, [r3, #0]
 800c40c:	681b      	ldr	r3, [r3, #0]
 800c40e:	22ff      	movs	r2, #255	; 0xff
 800c410:	625a      	str	r2, [r3, #36]	; 0x24

  HAL_NVIC_EnableIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID); /**<  Enable NVIC */
 800c412:	2003      	movs	r0, #3
 800c414:	f002 ff93 	bl	800f33e <HAL_NVIC_EnableIRQ>
 800c418:	697b      	ldr	r3, [r7, #20]
 800c41a:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800c41c:	68bb      	ldr	r3, [r7, #8]
 800c41e:	f383 8810 	msr	PRIMASK, r3
}
 800c422:	bf00      	nop

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  __set_PRIMASK(primask_bit); /**< Restore PRIMASK bit*/
#endif

  return;
 800c424:	bf00      	nop
}
 800c426:	3718      	adds	r7, #24
 800c428:	46bd      	mov	sp, r7
 800c42a:	bd80      	pop	{r7, pc}
 800c42c:	20000ef0 	.word	0x20000ef0
 800c430:	20000028 	.word	0x20000028
 800c434:	200000b8 	.word	0x200000b8
 800c438:	40002800 	.word	0x40002800
 800c43c:	58000800 	.word	0x58000800
 800c440:	200000b9 	.word	0x200000b9

0800c444 <HW_TS_Start>:

void HW_TS_Start(uint8_t timer_id, uint32_t timeout_ticks)
{
 800c444:	b580      	push	{r7, lr}
 800c446:	b086      	sub	sp, #24
 800c448:	af00      	add	r7, sp, #0
 800c44a:	4603      	mov	r3, r0
 800c44c:	6039      	str	r1, [r7, #0]
 800c44e:	71fb      	strb	r3, [r7, #7]

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  uint32_t primask_bit;
#endif

  if(aTimerContext[timer_id].TimerIDStatus == TimerID_Running)
 800c450:	79fa      	ldrb	r2, [r7, #7]
 800c452:	493c      	ldr	r1, [pc, #240]	; (800c544 <HW_TS_Start+0x100>)
 800c454:	4613      	mov	r3, r2
 800c456:	005b      	lsls	r3, r3, #1
 800c458:	4413      	add	r3, r2
 800c45a:	00db      	lsls	r3, r3, #3
 800c45c:	440b      	add	r3, r1
 800c45e:	330c      	adds	r3, #12
 800c460:	781b      	ldrb	r3, [r3, #0]
 800c462:	b2db      	uxtb	r3, r3
 800c464:	2b02      	cmp	r3, #2
 800c466:	d103      	bne.n	800c470 <HW_TS_Start+0x2c>
  {
    HW_TS_Stop( timer_id );
 800c468:	79fb      	ldrb	r3, [r7, #7]
 800c46a:	4618      	mov	r0, r3
 800c46c:	f7ff ff5e 	bl	800c32c <HW_TS_Stop>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800c470:	f3ef 8310 	mrs	r3, PRIMASK
 800c474:	60fb      	str	r3, [r7, #12]
  return(result);
 800c476:	68fb      	ldr	r3, [r7, #12]
  }

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 800c478:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 800c47a:	b672      	cpsid	i
}
 800c47c:	bf00      	nop
  __disable_irq();          /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
#endif

  HAL_NVIC_DisableIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID);    /**<  Disable NVIC */
 800c47e:	2003      	movs	r0, #3
 800c480:	f002 ff6b 	bl	800f35a <HAL_NVIC_DisableIRQ>

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE( phrtc );
 800c484:	4b30      	ldr	r3, [pc, #192]	; (800c548 <HW_TS_Start+0x104>)
 800c486:	681b      	ldr	r3, [r3, #0]
 800c488:	681b      	ldr	r3, [r3, #0]
 800c48a:	22ca      	movs	r2, #202	; 0xca
 800c48c:	625a      	str	r2, [r3, #36]	; 0x24
 800c48e:	4b2e      	ldr	r3, [pc, #184]	; (800c548 <HW_TS_Start+0x104>)
 800c490:	681b      	ldr	r3, [r3, #0]
 800c492:	681b      	ldr	r3, [r3, #0]
 800c494:	2253      	movs	r2, #83	; 0x53
 800c496:	625a      	str	r2, [r3, #36]	; 0x24

  aTimerContext[timer_id].TimerIDStatus = TimerID_Running;
 800c498:	79fa      	ldrb	r2, [r7, #7]
 800c49a:	492a      	ldr	r1, [pc, #168]	; (800c544 <HW_TS_Start+0x100>)
 800c49c:	4613      	mov	r3, r2
 800c49e:	005b      	lsls	r3, r3, #1
 800c4a0:	4413      	add	r3, r2
 800c4a2:	00db      	lsls	r3, r3, #3
 800c4a4:	440b      	add	r3, r1
 800c4a6:	330c      	adds	r3, #12
 800c4a8:	2202      	movs	r2, #2
 800c4aa:	701a      	strb	r2, [r3, #0]

  aTimerContext[timer_id].CountLeft = timeout_ticks;
 800c4ac:	79fa      	ldrb	r2, [r7, #7]
 800c4ae:	4925      	ldr	r1, [pc, #148]	; (800c544 <HW_TS_Start+0x100>)
 800c4b0:	4613      	mov	r3, r2
 800c4b2:	005b      	lsls	r3, r3, #1
 800c4b4:	4413      	add	r3, r2
 800c4b6:	00db      	lsls	r3, r3, #3
 800c4b8:	440b      	add	r3, r1
 800c4ba:	3308      	adds	r3, #8
 800c4bc:	683a      	ldr	r2, [r7, #0]
 800c4be:	601a      	str	r2, [r3, #0]
  aTimerContext[timer_id].CounterInit = timeout_ticks;
 800c4c0:	79fa      	ldrb	r2, [r7, #7]
 800c4c2:	4920      	ldr	r1, [pc, #128]	; (800c544 <HW_TS_Start+0x100>)
 800c4c4:	4613      	mov	r3, r2
 800c4c6:	005b      	lsls	r3, r3, #1
 800c4c8:	4413      	add	r3, r2
 800c4ca:	00db      	lsls	r3, r3, #3
 800c4cc:	440b      	add	r3, r1
 800c4ce:	3304      	adds	r3, #4
 800c4d0:	683a      	ldr	r2, [r7, #0]
 800c4d2:	601a      	str	r2, [r3, #0]

  time_elapsed =  linkTimer(timer_id);
 800c4d4:	79fb      	ldrb	r3, [r7, #7]
 800c4d6:	4618      	mov	r0, r3
 800c4d8:	f7ff fb04 	bl	800bae4 <linkTimer>
 800c4dc:	4603      	mov	r3, r0
 800c4de:	827b      	strh	r3, [r7, #18]

  localcurrentrunningtimerid = CurrentRunningTimerID;
 800c4e0:	4b1a      	ldr	r3, [pc, #104]	; (800c54c <HW_TS_Start+0x108>)
 800c4e2:	781b      	ldrb	r3, [r3, #0]
 800c4e4:	747b      	strb	r3, [r7, #17]

  if(PreviousRunningTimerID != localcurrentrunningtimerid)
 800c4e6:	4b1a      	ldr	r3, [pc, #104]	; (800c550 <HW_TS_Start+0x10c>)
 800c4e8:	781b      	ldrb	r3, [r3, #0]
 800c4ea:	b2db      	uxtb	r3, r3
 800c4ec:	7c7a      	ldrb	r2, [r7, #17]
 800c4ee:	429a      	cmp	r2, r3
 800c4f0:	d002      	beq.n	800c4f8 <HW_TS_Start+0xb4>
  {
    RescheduleTimerList();
 800c4f2:	f7ff fcc3 	bl	800be7c <RescheduleTimerList>
 800c4f6:	e013      	b.n	800c520 <HW_TS_Start+0xdc>
  }
  else
  {
    aTimerContext[timer_id].CountLeft -= time_elapsed;
 800c4f8:	79fa      	ldrb	r2, [r7, #7]
 800c4fa:	4912      	ldr	r1, [pc, #72]	; (800c544 <HW_TS_Start+0x100>)
 800c4fc:	4613      	mov	r3, r2
 800c4fe:	005b      	lsls	r3, r3, #1
 800c500:	4413      	add	r3, r2
 800c502:	00db      	lsls	r3, r3, #3
 800c504:	440b      	add	r3, r1
 800c506:	3308      	adds	r3, #8
 800c508:	6819      	ldr	r1, [r3, #0]
 800c50a:	8a7b      	ldrh	r3, [r7, #18]
 800c50c:	79fa      	ldrb	r2, [r7, #7]
 800c50e:	1ac9      	subs	r1, r1, r3
 800c510:	480c      	ldr	r0, [pc, #48]	; (800c544 <HW_TS_Start+0x100>)
 800c512:	4613      	mov	r3, r2
 800c514:	005b      	lsls	r3, r3, #1
 800c516:	4413      	add	r3, r2
 800c518:	00db      	lsls	r3, r3, #3
 800c51a:	4403      	add	r3, r0
 800c51c:	3308      	adds	r3, #8
 800c51e:	6019      	str	r1, [r3, #0]
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE( phrtc );
 800c520:	4b09      	ldr	r3, [pc, #36]	; (800c548 <HW_TS_Start+0x104>)
 800c522:	681b      	ldr	r3, [r3, #0]
 800c524:	681b      	ldr	r3, [r3, #0]
 800c526:	22ff      	movs	r2, #255	; 0xff
 800c528:	625a      	str	r2, [r3, #36]	; 0x24

  HAL_NVIC_EnableIRQ(CFG_HW_TS_RTC_WAKEUP_HANDLER_ID); /**<  Enable NVIC */
 800c52a:	2003      	movs	r0, #3
 800c52c:	f002 ff07 	bl	800f33e <HAL_NVIC_EnableIRQ>
 800c530:	697b      	ldr	r3, [r7, #20]
 800c532:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800c534:	68bb      	ldr	r3, [r7, #8]
 800c536:	f383 8810 	msr	PRIMASK, r3
}
 800c53a:	bf00      	nop

#if (CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION == 1)
  __set_PRIMASK(primask_bit); /**< Restore PRIMASK bit*/
#endif

  return;
 800c53c:	bf00      	nop
}
 800c53e:	3718      	adds	r7, #24
 800c540:	46bd      	mov	sp, r7
 800c542:	bd80      	pop	{r7, pc}
 800c544:	20000028 	.word	0x20000028
 800c548:	20000ef0 	.word	0x20000ef0
 800c54c:	200000b8 	.word	0x200000b8
 800c550:	200000b9 	.word	0x200000b9

0800c554 <HW_TS_RTC_Int_AppNot>:

  return (return_value);
}

__weak void HW_TS_RTC_Int_AppNot(uint32_t TimerProcessID, uint8_t TimerID, HW_TS_pTimerCb_t pTimerCallBack)
{
 800c554:	b580      	push	{r7, lr}
 800c556:	b084      	sub	sp, #16
 800c558:	af00      	add	r7, sp, #0
 800c55a:	60f8      	str	r0, [r7, #12]
 800c55c:	460b      	mov	r3, r1
 800c55e:	607a      	str	r2, [r7, #4]
 800c560:	72fb      	strb	r3, [r7, #11]
  pTimerCallBack();
 800c562:	687b      	ldr	r3, [r7, #4]
 800c564:	4798      	blx	r3

  return;
 800c566:	bf00      	nop
}
 800c568:	3710      	adds	r7, #16
 800c56a:	46bd      	mov	sp, r7
 800c56c:	bd80      	pop	{r7, pc}

0800c56e <LL_RCC_LSE_SetDriveCapability>:
{
 800c56e:	b480      	push	{r7}
 800c570:	b083      	sub	sp, #12
 800c572:	af00      	add	r7, sp, #0
 800c574:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, LSEDrive);
 800c576:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c57a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800c57e:	f023 0218 	bic.w	r2, r3, #24
 800c582:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c586:	687b      	ldr	r3, [r7, #4]
 800c588:	4313      	orrs	r3, r2
 800c58a:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
}
 800c58e:	bf00      	nop
 800c590:	370c      	adds	r7, #12
 800c592:	46bd      	mov	sp, r7
 800c594:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c598:	4770      	bx	lr

0800c59a <LL_AHB1_GRP1_EnableClock>:
  *         @arg @ref LL_AHB1_GRP1_PERIPH_TSC
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
 800c59a:	b480      	push	{r7}
 800c59c:	b085      	sub	sp, #20
 800c59e:	af00      	add	r7, sp, #0
 800c5a0:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB1ENR, Periphs);
 800c5a2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c5a6:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800c5a8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c5ac:	687b      	ldr	r3, [r7, #4]
 800c5ae:	4313      	orrs	r3, r2
 800c5b0:	648b      	str	r3, [r1, #72]	; 0x48
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 800c5b2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c5b6:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800c5b8:	687b      	ldr	r3, [r7, #4]
 800c5ba:	4013      	ands	r3, r2
 800c5bc:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800c5be:	68fb      	ldr	r3, [r7, #12]
}
 800c5c0:	bf00      	nop
 800c5c2:	3714      	adds	r7, #20
 800c5c4:	46bd      	mov	sp, r7
 800c5c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c5ca:	4770      	bx	lr

0800c5cc <LL_AHB2_GRP1_EnableClock>:
  *         @arg @ref LL_AHB2_GRP1_PERIPH_AES1 (*)
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_AHB2_GRP1_EnableClock(uint32_t Periphs)
{
 800c5cc:	b480      	push	{r7}
 800c5ce:	b085      	sub	sp, #20
 800c5d0:	af00      	add	r7, sp, #0
 800c5d2:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB2ENR, Periphs);
 800c5d4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c5d8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800c5da:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800c5de:	687b      	ldr	r3, [r7, #4]
 800c5e0:	4313      	orrs	r3, r2
 800c5e2:	64cb      	str	r3, [r1, #76]	; 0x4c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 800c5e4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800c5e8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800c5ea:	687b      	ldr	r3, [r7, #4]
 800c5ec:	4013      	ands	r3, r2
 800c5ee:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800c5f0:	68fb      	ldr	r3, [r7, #12]
}
 800c5f2:	bf00      	nop
 800c5f4:	3714      	adds	r7, #20
 800c5f6:	46bd      	mov	sp, r7
 800c5f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c5fc:	4770      	bx	lr
	...

0800c600 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 800c600:	b580      	push	{r7, lr}
 800c602:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 1 */
	InitSystemStructure();
 800c604:	f7fe fc26 	bl	800ae54 <InitSystemStructure>
  __ASM volatile ("cpsie i" : : : "memory");
 800c608:	b662      	cpsie	i
}
 800c60a:	bf00      	nop
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 800c60c:	f000 fe32 	bl	800d274 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 800c610:	f000 f886 	bl	800c720 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 800c614:	f000 fa62 	bl	800cadc <MX_GPIO_Init>
  MX_DMA_Init();
 800c618:	f000 fa4e 	bl	800cab8 <MX_DMA_Init>
  MX_ADC1_Init();
 800c61c:	f000 f914 	bl	800c848 <MX_ADC1_Init>
  MX_RF_Init();
 800c620:	f000 f9da 	bl	800c9d8 <MX_RF_Init>
  MX_RTC_Init();
 800c624:	f000 f9e0 	bl	800c9e8 <MX_RTC_Init>
  MX_COMP2_Init();
 800c628:	f000 f9a6 	bl	800c978 <MX_COMP2_Init>
  MX_SPI1_Init();
 800c62c:	f000 fa06 	bl	800ca3c <MX_SPI1_Init>
  /* USER CODE BEGIN 2 */
  HAL_Delay(10);
 800c630:	200a      	movs	r0, #10
 800c632:	f000 fea5 	bl	800d380 <HAL_Delay>
  sys.tim16.initTimer();
 800c636:	4b30      	ldr	r3, [pc, #192]	; (800c6f8 <main+0xf8>)
 800c638:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c63a:	4798      	blx	r3
  sys.tim17.initialize();
 800c63c:	4b2e      	ldr	r3, [pc, #184]	; (800c6f8 <main+0xf8>)
 800c63e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800c640:	4798      	blx	r3
  sys.tim2.initialize();
 800c642:	4b2d      	ldr	r3, [pc, #180]	; (800c6f8 <main+0xf8>)
 800c644:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800c646:	4798      	blx	r3
  SPI1->CR1 |= SPI_CR1_SPE;
 800c648:	4b2c      	ldr	r3, [pc, #176]	; (800c6fc <main+0xfc>)
 800c64a:	681b      	ldr	r3, [r3, #0]
 800c64c:	4a2b      	ldr	r2, [pc, #172]	; (800c6fc <main+0xfc>)
 800c64e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800c652:	6013      	str	r3, [r2, #0]
  if (sys.uSD.isAvailable())
 800c654:	4b28      	ldr	r3, [pc, #160]	; (800c6f8 <main+0xf8>)
 800c656:	699b      	ldr	r3, [r3, #24]
 800c658:	4798      	blx	r3
 800c65a:	4603      	mov	r3, r0
 800c65c:	2b00      	cmp	r3, #0
 800c65e:	d008      	beq.n	800c672 <main+0x72>
  {
	  sys.fs.initialize("Project name:ZSpectrum\nVersion: 0.0.1", 1);
 800c660:	4b25      	ldr	r3, [pc, #148]	; (800c6f8 <main+0xf8>)
 800c662:	689b      	ldr	r3, [r3, #8]
 800c664:	2101      	movs	r1, #1
 800c666:	4826      	ldr	r0, [pc, #152]	; (800c700 <main+0x100>)
 800c668:	4798      	blx	r3
	  sys.fs.downloadSystemSettingsInfo(&sys.settings);
 800c66a:	4b23      	ldr	r3, [pc, #140]	; (800c6f8 <main+0xf8>)
 800c66c:	691b      	ldr	r3, [r3, #16]
 800c66e:	4825      	ldr	r0, [pc, #148]	; (800c704 <main+0x104>)
 800c670:	4798      	blx	r3
  }
  sys.dma.initialize(sys.settings.countsToDma);
 800c672:	4b21      	ldr	r3, [pc, #132]	; (800c6f8 <main+0xf8>)
 800c674:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 800c678:	4b1f      	ldr	r3, [pc, #124]	; (800c6f8 <main+0xf8>)
 800c67a:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 800c67e:	3366      	adds	r3, #102	; 0x66
 800c680:	881b      	ldrh	r3, [r3, #0]
 800c682:	4618      	mov	r0, r3
 800c684:	4790      	blx	r2
  ad_data[8] = sys.settings.deviceNumber[0];
 800c686:	4b1c      	ldr	r3, [pc, #112]	; (800c6f8 <main+0xf8>)
 800c688:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 800c68c:	3364      	adds	r3, #100	; 0x64
 800c68e:	781a      	ldrb	r2, [r3, #0]
 800c690:	4b1d      	ldr	r3, [pc, #116]	; (800c708 <main+0x108>)
 800c692:	721a      	strb	r2, [r3, #8]
  ad_data[9] = sys.settings.deviceNumber[1];
 800c694:	4b18      	ldr	r3, [pc, #96]	; (800c6f8 <main+0xf8>)
 800c696:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 800c69a:	3365      	adds	r3, #101	; 0x65
 800c69c:	781a      	ldrb	r2, [r3, #0]
 800c69e:	4b1a      	ldr	r3, [pc, #104]	; (800c708 <main+0x108>)
 800c6a0:	725a      	strb	r2, [r3, #9]
  sys.adc.calibrateAndReinit();
 800c6a2:	4b15      	ldr	r3, [pc, #84]	; (800c6f8 <main+0xf8>)
 800c6a4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800c6a6:	4798      	blx	r3
  HAL_Delay(100);
 800c6a8:	2064      	movs	r0, #100	; 0x64
 800c6aa:	f000 fe69 	bl	800d380 <HAL_Delay>

  //reg tasks

  UTIL_SEQ_RegTask(1 << USER_TASK_PROCESS_FCW, UTIL_SEQ_RFU, ST_rf_ProcessFirstCharWrite);
 800c6ae:	4a17      	ldr	r2, [pc, #92]	; (800c70c <main+0x10c>)
 800c6b0:	2100      	movs	r1, #0
 800c6b2:	2010      	movs	r0, #16
 800c6b4:	f008 f922 	bl	80148fc <UTIL_SEQ_RegTask>
  UTIL_SEQ_RegTask(1 << USER_TASK_PROCESS_SCW, UTIL_SEQ_RFU, ST_rf_ProcessSecondCharWrite);
 800c6b8:	4a15      	ldr	r2, [pc, #84]	; (800c710 <main+0x110>)
 800c6ba:	2100      	movs	r1, #0
 800c6bc:	2020      	movs	r0, #32
 800c6be:	f008 f91d 	bl	80148fc <UTIL_SEQ_RegTask>
  UTIL_SEQ_RegTask(1 << USER_TASK_UPDATE_CPS_CHAR, UTIL_SEQ_RFU, ST_rf_UpdateCPS);
 800c6c2:	4a14      	ldr	r2, [pc, #80]	; (800c714 <main+0x114>)
 800c6c4:	2100      	movs	r1, #0
 800c6c6:	2008      	movs	r0, #8
 800c6c8:	f008 f918 	bl	80148fc <UTIL_SEQ_RegTask>
  UTIL_SEQ_RegTask(1 << USER_TASK_INITIALIZE_FS, UTIL_SEQ_RFU, ST_fs_Initialize);
 800c6cc:	4a12      	ldr	r2, [pc, #72]	; (800c718 <main+0x118>)
 800c6ce:	2100      	movs	r1, #0
 800c6d0:	2080      	movs	r0, #128	; 0x80
 800c6d2:	f008 f913 	bl	80148fc <UTIL_SEQ_RegTask>
  UTIL_SEQ_RegTask(1 << USER_TASK_SAVE_SPECTR_POST_DELAYED, UTIL_SEQ_RFU, ST_fs_SaveSpectrPostDelayed);
 800c6d6:	4a11      	ldr	r2, [pc, #68]	; (800c71c <main+0x11c>)
 800c6d8:	2100      	movs	r1, #0
 800c6da:	f44f 7080 	mov.w	r0, #256	; 0x100
 800c6de:	f008 f90d 	bl	80148fc <UTIL_SEQ_RegTask>

  sys.tim17.turnOn();
 800c6e2:	4b05      	ldr	r3, [pc, #20]	; (800c6f8 <main+0xf8>)
 800c6e4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800c6e6:	4798      	blx	r3


  /* USER CODE END 2 */

  /* Init code for STM32_WPAN */
  APPE_Init();
 800c6e8:	f7ff f86c 	bl	800b7c4 <APPE_Init>
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */
	  UTIL_SEQ_Run(~0);
 800c6ec:	f04f 30ff 	mov.w	r0, #4294967295
 800c6f0:	f008 f820 	bl	8014734 <UTIL_SEQ_Run>
 800c6f4:	e7fa      	b.n	800c6ec <main+0xec>
 800c6f6:	bf00      	nop
 800c6f8:	20001020 	.word	0x20001020
 800c6fc:	40013000 	.word	0x40013000
 800c700:	08014d28 	.word	0x08014d28
 800c704:	20005384 	.word	0x20005384
 800c708:	20000010 	.word	0x20000010
 800c70c:	080091e1 	.word	0x080091e1
 800c710:	080099d5 	.word	0x080099d5
 800c714:	08009b49 	.word	0x08009b49
 800c718:	08009bb9 	.word	0x08009bb9
 800c71c:	08009be1 	.word	0x08009be1

0800c720 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 800c720:	b580      	push	{r7, lr}
 800c722:	b0ae      	sub	sp, #184	; 0xb8
 800c724:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800c726:	f107 0370 	add.w	r3, r7, #112	; 0x70
 800c72a:	2248      	movs	r2, #72	; 0x48
 800c72c:	2100      	movs	r1, #0
 800c72e:	4618      	mov	r0, r3
 800c730:	f008 fa4e 	bl	8014bd0 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800c734:	f107 0354 	add.w	r3, r7, #84	; 0x54
 800c738:	2200      	movs	r2, #0
 800c73a:	601a      	str	r2, [r3, #0]
 800c73c:	605a      	str	r2, [r3, #4]
 800c73e:	609a      	str	r2, [r3, #8]
 800c740:	60da      	str	r2, [r3, #12]
 800c742:	611a      	str	r2, [r3, #16]
 800c744:	615a      	str	r2, [r3, #20]
 800c746:	619a      	str	r2, [r3, #24]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800c748:	1d3b      	adds	r3, r7, #4
 800c74a:	2250      	movs	r2, #80	; 0x50
 800c74c:	2100      	movs	r1, #0
 800c74e:	4618      	mov	r0, r3
 800c750:	f008 fa3e 	bl	8014bd0 <memset>

  /** Configure LSE Drive Capability
  */
  HAL_PWR_EnableBkUpAccess();
 800c754:	f003 f9c4 	bl	800fae0 <HAL_PWR_EnableBkUpAccess>
  __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
 800c758:	2000      	movs	r0, #0
 800c75a:	f7ff ff08 	bl	800c56e <LL_RCC_LSE_SetDriveCapability>
  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800c75e:	4b39      	ldr	r3, [pc, #228]	; (800c844 <SystemClock_Config+0x124>)
 800c760:	681b      	ldr	r3, [r3, #0]
 800c762:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 800c766:	4a37      	ldr	r2, [pc, #220]	; (800c844 <SystemClock_Config+0x124>)
 800c768:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800c76c:	6013      	str	r3, [r2, #0]
 800c76e:	4b35      	ldr	r3, [pc, #212]	; (800c844 <SystemClock_Config+0x124>)
 800c770:	681b      	ldr	r3, [r3, #0]
 800c772:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 800c776:	603b      	str	r3, [r7, #0]
 800c778:	683b      	ldr	r3, [r7, #0]
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE
 800c77a:	2307      	movs	r3, #7
 800c77c:	673b      	str	r3, [r7, #112]	; 0x70
                              |RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800c77e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800c782:	677b      	str	r3, [r7, #116]	; 0x74
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 800c784:	2301      	movs	r3, #1
 800c786:	67bb      	str	r3, [r7, #120]	; 0x78
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 800c788:	f44f 7380 	mov.w	r3, #256	; 0x100
 800c78c:	67fb      	str	r3, [r7, #124]	; 0x7c
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 800c78e:	2340      	movs	r3, #64	; 0x40
 800c790:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800c794:	2302      	movs	r3, #2
 800c796:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800c79a:	2303      	movs	r3, #3
 800c79c:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV2;
 800c7a0:	2310      	movs	r3, #16
 800c7a2:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  RCC_OscInitStruct.PLL.PLLN = 8;
 800c7a6:	2308      	movs	r3, #8
 800c7a8:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800c7ac:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800c7b0:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 800c7b4:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 800c7b8:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 800c7bc:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800c7c0:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800c7c4:	f107 0370 	add.w	r3, r7, #112	; 0x70
 800c7c8:	4618      	mov	r0, r3
 800c7ca:	f003 fd05 	bl	80101d8 <HAL_RCC_OscConfig>
 800c7ce:	4603      	mov	r3, r0
 800c7d0:	2b00      	cmp	r3, #0
 800c7d2:	d001      	beq.n	800c7d8 <SystemClock_Config+0xb8>
  {
    Error_Handler();
 800c7d4:	f000 f9da 	bl	800cb8c <Error_Handler>
  }
  /** Configure the SYSCLKSource, HCLK, PCLK1 and PCLK2 clocks dividers
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK4|RCC_CLOCKTYPE_HCLK2
 800c7d8:	236f      	movs	r3, #111	; 0x6f
 800c7da:	657b      	str	r3, [r7, #84]	; 0x54
                              |RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800c7dc:	2303      	movs	r3, #3
 800c7de:	65bb      	str	r3, [r7, #88]	; 0x58
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800c7e0:	2300      	movs	r3, #0
 800c7e2:	65fb      	str	r3, [r7, #92]	; 0x5c
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 800c7e4:	2300      	movs	r3, #0
 800c7e6:	663b      	str	r3, [r7, #96]	; 0x60
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 800c7e8:	2300      	movs	r3, #0
 800c7ea:	667b      	str	r3, [r7, #100]	; 0x64
  RCC_ClkInitStruct.AHBCLK2Divider = RCC_SYSCLK_DIV2;
 800c7ec:	2380      	movs	r3, #128	; 0x80
 800c7ee:	66bb      	str	r3, [r7, #104]	; 0x68
  RCC_ClkInitStruct.AHBCLK4Divider = RCC_SYSCLK_DIV1;
 800c7f0:	2300      	movs	r3, #0
 800c7f2:	66fb      	str	r3, [r7, #108]	; 0x6c

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
 800c7f4:	f107 0354 	add.w	r3, r7, #84	; 0x54
 800c7f8:	2103      	movs	r1, #3
 800c7fa:	4618      	mov	r0, r3
 800c7fc:	f004 f878 	bl	80108f0 <HAL_RCC_ClockConfig>
 800c800:	4603      	mov	r3, r0
 800c802:	2b00      	cmp	r3, #0
 800c804:	d001      	beq.n	800c80a <SystemClock_Config+0xea>
  {
    Error_Handler();
 800c806:	f000 f9c1 	bl	800cb8c <Error_Handler>
  }
  /** Initializes the peripherals clocks
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SMPS|RCC_PERIPHCLK_RFWAKEUP
 800c80a:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800c80e:	607b      	str	r3, [r7, #4]
                              |RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_ADC;
  PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_SYSCLK;
 800c810:	f04f 5340 	mov.w	r3, #805306368	; 0x30000000
 800c814:	643b      	str	r3, [r7, #64]	; 0x40
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 800c816:	f44f 7380 	mov.w	r3, #256	; 0x100
 800c81a:	647b      	str	r3, [r7, #68]	; 0x44
  PeriphClkInitStruct.RFWakeUpClockSelection = RCC_RFWKPCLKSOURCE_LSE;
 800c81c:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800c820:	64bb      	str	r3, [r7, #72]	; 0x48
  PeriphClkInitStruct.SmpsClockSelection = RCC_SMPSCLKSOURCE_HSI;
 800c822:	2300      	movs	r3, #0
 800c824:	64fb      	str	r3, [r7, #76]	; 0x4c
  PeriphClkInitStruct.SmpsDivSelection = RCC_SMPSCLKDIV_RANGE1;
 800c826:	2310      	movs	r3, #16
 800c828:	653b      	str	r3, [r7, #80]	; 0x50
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800c82a:	1d3b      	adds	r3, r7, #4
 800c82c:	4618      	mov	r0, r3
 800c82e:	f004 fc74 	bl	801111a <HAL_RCCEx_PeriphCLKConfig>
 800c832:	4603      	mov	r3, r0
 800c834:	2b00      	cmp	r3, #0
 800c836:	d001      	beq.n	800c83c <SystemClock_Config+0x11c>
  {
    Error_Handler();
 800c838:	f000 f9a8 	bl	800cb8c <Error_Handler>
  }
  /* USER CODE BEGIN Smps */

  /* USER CODE END Smps */
}
 800c83c:	bf00      	nop
 800c83e:	37b8      	adds	r7, #184	; 0xb8
 800c840:	46bd      	mov	sp, r7
 800c842:	bd80      	pop	{r7, pc}
 800c844:	58000400 	.word	0x58000400

0800c848 <MX_ADC1_Init>:
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{
 800c848:	b580      	push	{r7, lr}
 800c84a:	b094      	sub	sp, #80	; 0x50
 800c84c:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};
 800c84e:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800c852:	2200      	movs	r2, #0
 800c854:	601a      	str	r2, [r3, #0]
 800c856:	605a      	str	r2, [r3, #4]
 800c858:	609a      	str	r2, [r3, #8]
 800c85a:	60da      	str	r2, [r3, #12]
 800c85c:	611a      	str	r2, [r3, #16]
 800c85e:	615a      	str	r2, [r3, #20]
  ADC_InjectionConfTypeDef sConfigInjected = {0};
 800c860:	1d3b      	adds	r3, r7, #4
 800c862:	2234      	movs	r2, #52	; 0x34
 800c864:	2100      	movs	r1, #0
 800c866:	4618      	mov	r0, r3
 800c868:	f008 f9b2 	bl	8014bd0 <memset>
  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */
  /** Common config
  */
  hadc1.Instance = ADC1;
 800c86c:	4b3e      	ldr	r3, [pc, #248]	; (800c968 <MX_ADC1_Init+0x120>)
 800c86e:	4a3f      	ldr	r2, [pc, #252]	; (800c96c <MX_ADC1_Init+0x124>)
 800c870:	601a      	str	r2, [r3, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 800c872:	4b3d      	ldr	r3, [pc, #244]	; (800c968 <MX_ADC1_Init+0x120>)
 800c874:	2200      	movs	r2, #0
 800c876:	605a      	str	r2, [r3, #4]
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 800c878:	4b3b      	ldr	r3, [pc, #236]	; (800c968 <MX_ADC1_Init+0x120>)
 800c87a:	2200      	movs	r2, #0
 800c87c:	609a      	str	r2, [r3, #8]
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 800c87e:	4b3a      	ldr	r3, [pc, #232]	; (800c968 <MX_ADC1_Init+0x120>)
 800c880:	2200      	movs	r2, #0
 800c882:	60da      	str	r2, [r3, #12]
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
 800c884:	4b38      	ldr	r3, [pc, #224]	; (800c968 <MX_ADC1_Init+0x120>)
 800c886:	2200      	movs	r2, #0
 800c888:	611a      	str	r2, [r3, #16]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 800c88a:	4b37      	ldr	r3, [pc, #220]	; (800c968 <MX_ADC1_Init+0x120>)
 800c88c:	2204      	movs	r2, #4
 800c88e:	615a      	str	r2, [r3, #20]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 800c890:	4b35      	ldr	r3, [pc, #212]	; (800c968 <MX_ADC1_Init+0x120>)
 800c892:	2200      	movs	r2, #0
 800c894:	761a      	strb	r2, [r3, #24]
  hadc1.Init.ContinuousConvMode = DISABLE;
 800c896:	4b34      	ldr	r3, [pc, #208]	; (800c968 <MX_ADC1_Init+0x120>)
 800c898:	2200      	movs	r2, #0
 800c89a:	765a      	strb	r2, [r3, #25]
  hadc1.Init.NbrOfConversion = 1;
 800c89c:	4b32      	ldr	r3, [pc, #200]	; (800c968 <MX_ADC1_Init+0x120>)
 800c89e:	2201      	movs	r2, #1
 800c8a0:	61da      	str	r2, [r3, #28]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 800c8a2:	4b31      	ldr	r3, [pc, #196]	; (800c968 <MX_ADC1_Init+0x120>)
 800c8a4:	2200      	movs	r2, #0
 800c8a6:	f883 2020 	strb.w	r2, [r3, #32]
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 800c8aa:	4b2f      	ldr	r3, [pc, #188]	; (800c968 <MX_ADC1_Init+0x120>)
 800c8ac:	2200      	movs	r2, #0
 800c8ae:	629a      	str	r2, [r3, #40]	; 0x28
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 800c8b0:	4b2d      	ldr	r3, [pc, #180]	; (800c968 <MX_ADC1_Init+0x120>)
 800c8b2:	2200      	movs	r2, #0
 800c8b4:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc1.Init.DMAContinuousRequests = DISABLE;
 800c8b6:	4b2c      	ldr	r3, [pc, #176]	; (800c968 <MX_ADC1_Init+0x120>)
 800c8b8:	2200      	movs	r2, #0
 800c8ba:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 800c8be:	4b2a      	ldr	r3, [pc, #168]	; (800c968 <MX_ADC1_Init+0x120>)
 800c8c0:	2200      	movs	r2, #0
 800c8c2:	635a      	str	r2, [r3, #52]	; 0x34
  hadc1.Init.OversamplingMode = DISABLE;
 800c8c4:	4b28      	ldr	r3, [pc, #160]	; (800c968 <MX_ADC1_Init+0x120>)
 800c8c6:	2200      	movs	r2, #0
 800c8c8:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 800c8cc:	4826      	ldr	r0, [pc, #152]	; (800c968 <MX_ADC1_Init+0x120>)
 800c8ce:	f000 ff07 	bl	800d6e0 <HAL_ADC_Init>
 800c8d2:	4603      	mov	r3, r0
 800c8d4:	2b00      	cmp	r3, #0
 800c8d6:	d001      	beq.n	800c8dc <MX_ADC1_Init+0x94>
  {
    Error_Handler();
 800c8d8:	f000 f958 	bl	800cb8c <Error_Handler>
  }
  /** Disable Injected Queue
  */
  HAL_ADCEx_DisableInjectedQueue(&hadc1);
 800c8dc:	4822      	ldr	r0, [pc, #136]	; (800c968 <MX_ADC1_Init+0x120>)
 800c8de:	f002 f9d1 	bl	800ec84 <HAL_ADCEx_DisableInjectedQueue>
  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_5;
 800c8e2:	4b23      	ldr	r3, [pc, #140]	; (800c970 <MX_ADC1_Init+0x128>)
 800c8e4:	63bb      	str	r3, [r7, #56]	; 0x38
  sConfig.Rank = ADC_REGULAR_RANK_1;
 800c8e6:	2306      	movs	r3, #6
 800c8e8:	63fb      	str	r3, [r7, #60]	; 0x3c
  sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
 800c8ea:	2300      	movs	r3, #0
 800c8ec:	643b      	str	r3, [r7, #64]	; 0x40
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 800c8ee:	237f      	movs	r3, #127	; 0x7f
 800c8f0:	647b      	str	r3, [r7, #68]	; 0x44
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 800c8f2:	2304      	movs	r3, #4
 800c8f4:	64bb      	str	r3, [r7, #72]	; 0x48
  sConfig.Offset = 0;
 800c8f6:	2300      	movs	r3, #0
 800c8f8:	64fb      	str	r3, [r7, #76]	; 0x4c
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 800c8fa:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800c8fe:	4619      	mov	r1, r3
 800c900:	4819      	ldr	r0, [pc, #100]	; (800c968 <MX_ADC1_Init+0x120>)
 800c902:	f001 f837 	bl	800d974 <HAL_ADC_ConfigChannel>
 800c906:	4603      	mov	r3, r0
 800c908:	2b00      	cmp	r3, #0
 800c90a:	d001      	beq.n	800c910 <MX_ADC1_Init+0xc8>
  {
    Error_Handler();
 800c90c:	f000 f93e 	bl	800cb8c <Error_Handler>
  }
  /** Configure Injected Channel
  */
  sConfigInjected.InjectedChannel = ADC_CHANNEL_6;
 800c910:	4b18      	ldr	r3, [pc, #96]	; (800c974 <MX_ADC1_Init+0x12c>)
 800c912:	607b      	str	r3, [r7, #4]
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_1;
 800c914:	2308      	movs	r3, #8
 800c916:	60bb      	str	r3, [r7, #8]
  sConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_640CYCLES_5;
 800c918:	2307      	movs	r3, #7
 800c91a:	60fb      	str	r3, [r7, #12]
  sConfigInjected.InjectedSingleDiff = ADC_SINGLE_ENDED;
 800c91c:	237f      	movs	r3, #127	; 0x7f
 800c91e:	613b      	str	r3, [r7, #16]
  sConfigInjected.InjectedOffsetNumber = ADC_OFFSET_NONE;
 800c920:	2304      	movs	r3, #4
 800c922:	617b      	str	r3, [r7, #20]
  sConfigInjected.InjectedOffset = 0;
 800c924:	2300      	movs	r3, #0
 800c926:	61bb      	str	r3, [r7, #24]
  sConfigInjected.InjectedNbrOfConversion = 1;
 800c928:	2301      	movs	r3, #1
 800c92a:	61fb      	str	r3, [r7, #28]
  sConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
 800c92c:	2300      	movs	r3, #0
 800c92e:	f887 3020 	strb.w	r3, [r7, #32]
  sConfigInjected.AutoInjectedConv = DISABLE;
 800c932:	2300      	movs	r3, #0
 800c934:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
  sConfigInjected.QueueInjectedContext = DISABLE;
 800c938:	2300      	movs	r3, #0
 800c93a:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
  sConfigInjected.ExternalTrigInjecConv = ADC_INJECTED_SOFTWARE_START;
 800c93e:	2300      	movs	r3, #0
 800c940:	627b      	str	r3, [r7, #36]	; 0x24
  sConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONV_EDGE_NONE;
 800c942:	2300      	movs	r3, #0
 800c944:	62bb      	str	r3, [r7, #40]	; 0x28
  sConfigInjected.InjecOversamplingMode = DISABLE;
 800c946:	2300      	movs	r3, #0
 800c948:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
 800c94c:	1d3b      	adds	r3, r7, #4
 800c94e:	4619      	mov	r1, r3
 800c950:	4805      	ldr	r0, [pc, #20]	; (800c968 <MX_ADC1_Init+0x120>)
 800c952:	f001 fce9 	bl	800e328 <HAL_ADCEx_InjectedConfigChannel>
 800c956:	4603      	mov	r3, r0
 800c958:	2b00      	cmp	r3, #0
 800c95a:	d001      	beq.n	800c960 <MX_ADC1_Init+0x118>
  {
    Error_Handler();
 800c95c:	f000 f916 	bl	800cb8c <Error_Handler>
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}
 800c960:	bf00      	nop
 800c962:	3750      	adds	r7, #80	; 0x50
 800c964:	46bd      	mov	sp, r7
 800c966:	bd80      	pop	{r7, pc}
 800c968:	2000538c 	.word	0x2000538c
 800c96c:	50040000 	.word	0x50040000
 800c970:	14f00020 	.word	0x14f00020
 800c974:	19200040 	.word	0x19200040

0800c978 <MX_COMP2_Init>:
  * @brief COMP2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_COMP2_Init(void)
{
 800c978:	b580      	push	{r7, lr}
 800c97a:	af00      	add	r7, sp, #0
  /* USER CODE END COMP2_Init 0 */

  /* USER CODE BEGIN COMP2_Init 1 */

  /* USER CODE END COMP2_Init 1 */
  hcomp2.Instance = COMP2;
 800c97c:	4b13      	ldr	r3, [pc, #76]	; (800c9cc <MX_COMP2_Init+0x54>)
 800c97e:	4a14      	ldr	r2, [pc, #80]	; (800c9d0 <MX_COMP2_Init+0x58>)
 800c980:	601a      	str	r2, [r3, #0]
  hcomp2.Init.InputMinus = COMP_INPUT_MINUS_IO4;
 800c982:	4b12      	ldr	r3, [pc, #72]	; (800c9cc <MX_COMP2_Init+0x54>)
 800c984:	4a13      	ldr	r2, [pc, #76]	; (800c9d4 <MX_COMP2_Init+0x5c>)
 800c986:	611a      	str	r2, [r3, #16]
  hcomp2.Init.InputPlus = COMP_INPUT_PLUS_IO3;
 800c988:	4b10      	ldr	r3, [pc, #64]	; (800c9cc <MX_COMP2_Init+0x54>)
 800c98a:	f44f 7280 	mov.w	r2, #256	; 0x100
 800c98e:	60da      	str	r2, [r3, #12]
  hcomp2.Init.OutputPol = COMP_OUTPUTPOL_NONINVERTED;
 800c990:	4b0e      	ldr	r3, [pc, #56]	; (800c9cc <MX_COMP2_Init+0x54>)
 800c992:	2200      	movs	r2, #0
 800c994:	619a      	str	r2, [r3, #24]
  hcomp2.Init.Hysteresis = COMP_HYSTERESIS_MEDIUM;
 800c996:	4b0d      	ldr	r3, [pc, #52]	; (800c9cc <MX_COMP2_Init+0x54>)
 800c998:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 800c99c:	615a      	str	r2, [r3, #20]
  hcomp2.Init.BlankingSrce = COMP_BLANKINGSRC_NONE;
 800c99e:	4b0b      	ldr	r3, [pc, #44]	; (800c9cc <MX_COMP2_Init+0x54>)
 800c9a0:	2200      	movs	r2, #0
 800c9a2:	61da      	str	r2, [r3, #28]
  hcomp2.Init.Mode = COMP_POWERMODE_HIGHSPEED;
 800c9a4:	4b09      	ldr	r3, [pc, #36]	; (800c9cc <MX_COMP2_Init+0x54>)
 800c9a6:	2200      	movs	r2, #0
 800c9a8:	609a      	str	r2, [r3, #8]
  hcomp2.Init.WindowMode = COMP_WINDOWMODE_DISABLE;
 800c9aa:	4b08      	ldr	r3, [pc, #32]	; (800c9cc <MX_COMP2_Init+0x54>)
 800c9ac:	2200      	movs	r2, #0
 800c9ae:	605a      	str	r2, [r3, #4]
  hcomp2.Init.TriggerMode = COMP_TRIGGERMODE_IT_RISING;
 800c9b0:	4b06      	ldr	r3, [pc, #24]	; (800c9cc <MX_COMP2_Init+0x54>)
 800c9b2:	2211      	movs	r2, #17
 800c9b4:	621a      	str	r2, [r3, #32]
  if (HAL_COMP_Init(&hcomp2) != HAL_OK)
 800c9b6:	4805      	ldr	r0, [pc, #20]	; (800c9cc <MX_COMP2_Init+0x54>)
 800c9b8:	f002 fa52 	bl	800ee60 <HAL_COMP_Init>
 800c9bc:	4603      	mov	r3, r0
 800c9be:	2b00      	cmp	r3, #0
 800c9c0:	d001      	beq.n	800c9c6 <MX_COMP2_Init+0x4e>
  {
    Error_Handler();
 800c9c2:	f000 f8e3 	bl	800cb8c <Error_Handler>
  }
  /* USER CODE BEGIN COMP2_Init 2 */

  /* USER CODE END COMP2_Init 2 */

}
 800c9c6:	bf00      	nop
 800c9c8:	bd80      	pop	{r7, pc}
 800c9ca:	bf00      	nop
 800c9cc:	20005474 	.word	0x20005474
 800c9d0:	40010204 	.word	0x40010204
 800c9d4:	04000070 	.word	0x04000070

0800c9d8 <MX_RF_Init>:
  * @brief RF Initialization Function
  * @param None
  * @retval None
  */
static void MX_RF_Init(void)
{
 800c9d8:	b480      	push	{r7}
 800c9da:	af00      	add	r7, sp, #0
  /* USER CODE END RF_Init 1 */
  /* USER CODE BEGIN RF_Init 2 */

  /* USER CODE END RF_Init 2 */

}
 800c9dc:	bf00      	nop
 800c9de:	46bd      	mov	sp, r7
 800c9e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c9e4:	4770      	bx	lr
	...

0800c9e8 <MX_RTC_Init>:
  * @brief RTC Initialization Function
  * @param None
  * @retval None
  */
static void MX_RTC_Init(void)
{
 800c9e8:	b580      	push	{r7, lr}
 800c9ea:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */
  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
 800c9ec:	4b11      	ldr	r3, [pc, #68]	; (800ca34 <MX_RTC_Init+0x4c>)
 800c9ee:	4a12      	ldr	r2, [pc, #72]	; (800ca38 <MX_RTC_Init+0x50>)
 800c9f0:	601a      	str	r2, [r3, #0]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 800c9f2:	4b10      	ldr	r3, [pc, #64]	; (800ca34 <MX_RTC_Init+0x4c>)
 800c9f4:	2200      	movs	r2, #0
 800c9f6:	605a      	str	r2, [r3, #4]
  hrtc.Init.AsynchPrediv = CFG_RTC_ASYNCH_PRESCALER;
 800c9f8:	4b0e      	ldr	r3, [pc, #56]	; (800ca34 <MX_RTC_Init+0x4c>)
 800c9fa:	220f      	movs	r2, #15
 800c9fc:	609a      	str	r2, [r3, #8]
  hrtc.Init.SynchPrediv = CFG_RTC_SYNCH_PRESCALER;
 800c9fe:	4b0d      	ldr	r3, [pc, #52]	; (800ca34 <MX_RTC_Init+0x4c>)
 800ca00:	f647 72ff 	movw	r2, #32767	; 0x7fff
 800ca04:	60da      	str	r2, [r3, #12]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 800ca06:	4b0b      	ldr	r3, [pc, #44]	; (800ca34 <MX_RTC_Init+0x4c>)
 800ca08:	2200      	movs	r2, #0
 800ca0a:	611a      	str	r2, [r3, #16]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 800ca0c:	4b09      	ldr	r3, [pc, #36]	; (800ca34 <MX_RTC_Init+0x4c>)
 800ca0e:	2200      	movs	r2, #0
 800ca10:	619a      	str	r2, [r3, #24]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 800ca12:	4b08      	ldr	r3, [pc, #32]	; (800ca34 <MX_RTC_Init+0x4c>)
 800ca14:	2200      	movs	r2, #0
 800ca16:	61da      	str	r2, [r3, #28]
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 800ca18:	4b06      	ldr	r3, [pc, #24]	; (800ca34 <MX_RTC_Init+0x4c>)
 800ca1a:	2200      	movs	r2, #0
 800ca1c:	615a      	str	r2, [r3, #20]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 800ca1e:	4805      	ldr	r0, [pc, #20]	; (800ca34 <MX_RTC_Init+0x4c>)
 800ca20:	f004 fe02 	bl	8011628 <HAL_RTC_Init>
 800ca24:	4603      	mov	r3, r0
 800ca26:	2b00      	cmp	r3, #0
 800ca28:	d001      	beq.n	800ca2e <MX_RTC_Init+0x46>
  {
    Error_Handler();
 800ca2a:	f000 f8af 	bl	800cb8c <Error_Handler>
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
 800ca2e:	bf00      	nop
 800ca30:	bd80      	pop	{r7, pc}
 800ca32:	bf00      	nop
 800ca34:	20005450 	.word	0x20005450
 800ca38:	40002800 	.word	0x40002800

0800ca3c <MX_SPI1_Init>:
  * @brief SPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI1_Init(void)
{
 800ca3c:	b580      	push	{r7, lr}
 800ca3e:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
 800ca40:	4b1b      	ldr	r3, [pc, #108]	; (800cab0 <MX_SPI1_Init+0x74>)
 800ca42:	4a1c      	ldr	r2, [pc, #112]	; (800cab4 <MX_SPI1_Init+0x78>)
 800ca44:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 800ca46:	4b1a      	ldr	r3, [pc, #104]	; (800cab0 <MX_SPI1_Init+0x74>)
 800ca48:	f44f 7282 	mov.w	r2, #260	; 0x104
 800ca4c:	605a      	str	r2, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 800ca4e:	4b18      	ldr	r3, [pc, #96]	; (800cab0 <MX_SPI1_Init+0x74>)
 800ca50:	2200      	movs	r2, #0
 800ca52:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 800ca54:	4b16      	ldr	r3, [pc, #88]	; (800cab0 <MX_SPI1_Init+0x74>)
 800ca56:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 800ca5a:	60da      	str	r2, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 800ca5c:	4b14      	ldr	r3, [pc, #80]	; (800cab0 <MX_SPI1_Init+0x74>)
 800ca5e:	2200      	movs	r2, #0
 800ca60:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 800ca62:	4b13      	ldr	r3, [pc, #76]	; (800cab0 <MX_SPI1_Init+0x74>)
 800ca64:	2200      	movs	r2, #0
 800ca66:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 800ca68:	4b11      	ldr	r3, [pc, #68]	; (800cab0 <MX_SPI1_Init+0x74>)
 800ca6a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800ca6e:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 800ca70:	4b0f      	ldr	r3, [pc, #60]	; (800cab0 <MX_SPI1_Init+0x74>)
 800ca72:	2208      	movs	r2, #8
 800ca74:	61da      	str	r2, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 800ca76:	4b0e      	ldr	r3, [pc, #56]	; (800cab0 <MX_SPI1_Init+0x74>)
 800ca78:	2200      	movs	r2, #0
 800ca7a:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 800ca7c:	4b0c      	ldr	r3, [pc, #48]	; (800cab0 <MX_SPI1_Init+0x74>)
 800ca7e:	2200      	movs	r2, #0
 800ca80:	625a      	str	r2, [r3, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800ca82:	4b0b      	ldr	r3, [pc, #44]	; (800cab0 <MX_SPI1_Init+0x74>)
 800ca84:	2200      	movs	r2, #0
 800ca86:	629a      	str	r2, [r3, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 7;
 800ca88:	4b09      	ldr	r3, [pc, #36]	; (800cab0 <MX_SPI1_Init+0x74>)
 800ca8a:	2207      	movs	r2, #7
 800ca8c:	62da      	str	r2, [r3, #44]	; 0x2c
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 800ca8e:	4b08      	ldr	r3, [pc, #32]	; (800cab0 <MX_SPI1_Init+0x74>)
 800ca90:	2200      	movs	r2, #0
 800ca92:	631a      	str	r2, [r3, #48]	; 0x30
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 800ca94:	4b06      	ldr	r3, [pc, #24]	; (800cab0 <MX_SPI1_Init+0x74>)
 800ca96:	2208      	movs	r2, #8
 800ca98:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 800ca9a:	4805      	ldr	r0, [pc, #20]	; (800cab0 <MX_SPI1_Init+0x74>)
 800ca9c:	f004 feb2 	bl	8011804 <HAL_SPI_Init>
 800caa0:	4603      	mov	r3, r0
 800caa2:	2b00      	cmp	r3, #0
 800caa4:	d001      	beq.n	800caaa <MX_SPI1_Init+0x6e>
  {
    Error_Handler();
 800caa6:	f000 f871 	bl	800cb8c <Error_Handler>
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}
 800caaa:	bf00      	nop
 800caac:	bd80      	pop	{r7, pc}
 800caae:	bf00      	nop
 800cab0:	200054a0 	.word	0x200054a0
 800cab4:	40013000 	.word	0x40013000

0800cab8 <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{
 800cab8:	b580      	push	{r7, lr}
 800caba:	af00      	add	r7, sp, #0

  /* DMA controller clock enable */
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
 800cabc:	2004      	movs	r0, #4
 800cabe:	f7ff fd6c 	bl	800c59a <LL_AHB1_GRP1_EnableClock>
  __HAL_RCC_DMA1_CLK_ENABLE();
 800cac2:	2001      	movs	r0, #1
 800cac4:	f7ff fd69 	bl	800c59a <LL_AHB1_GRP1_EnableClock>

  /* DMA interrupt init */
  /* DMA1_Channel1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 1, 0);
 800cac8:	2200      	movs	r2, #0
 800caca:	2101      	movs	r1, #1
 800cacc:	200b      	movs	r0, #11
 800cace:	f002 fc1c 	bl	800f30a <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 800cad2:	200b      	movs	r0, #11
 800cad4:	f002 fc33 	bl	800f33e <HAL_NVIC_EnableIRQ>

}
 800cad8:	bf00      	nop
 800cada:	bd80      	pop	{r7, pc}

0800cadc <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 800cadc:	b580      	push	{r7, lr}
 800cade:	b086      	sub	sp, #24
 800cae0:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800cae2:	1d3b      	adds	r3, r7, #4
 800cae4:	2200      	movs	r2, #0
 800cae6:	601a      	str	r2, [r3, #0]
 800cae8:	605a      	str	r2, [r3, #4]
 800caea:	609a      	str	r2, [r3, #8]
 800caec:	60da      	str	r2, [r3, #12]
 800caee:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800caf0:	2004      	movs	r0, #4
 800caf2:	f7ff fd6b 	bl	800c5cc <LL_AHB2_GRP1_EnableClock>
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800caf6:	2001      	movs	r0, #1
 800caf8:	f7ff fd68 	bl	800c5cc <LL_AHB2_GRP1_EnableClock>
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800cafc:	2002      	movs	r0, #2
 800cafe:	f7ff fd65 	bl	800c5cc <LL_AHB2_GRP1_EnableClock>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
 800cb02:	2201      	movs	r2, #1
 800cb04:	f44f 7180 	mov.w	r1, #256	; 0x100
 800cb08:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800cb0c:	f002 ff88 	bl	800fa20 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);
 800cb10:	2200      	movs	r2, #0
 800cb12:	2102      	movs	r1, #2
 800cb14:	481b      	ldr	r0, [pc, #108]	; (800cb84 <MX_GPIO_Init+0xa8>)
 800cb16:	f002 ff83 	bl	800fa20 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PA8 */
  GPIO_InitStruct.Pin = GPIO_PIN_8;
 800cb1a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800cb1e:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800cb20:	2301      	movs	r3, #1
 800cb22:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800cb24:	2300      	movs	r3, #0
 800cb26:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800cb28:	2302      	movs	r3, #2
 800cb2a:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800cb2c:	1d3b      	adds	r3, r7, #4
 800cb2e:	4619      	mov	r1, r3
 800cb30:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800cb34:	f002 fe04 	bl	800f740 <HAL_GPIO_Init>

  /*Configure GPIO pin : PA9 */
  GPIO_InitStruct.Pin = GPIO_PIN_9;
 800cb38:	f44f 7300 	mov.w	r3, #512	; 0x200
 800cb3c:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
 800cb3e:	4b12      	ldr	r3, [pc, #72]	; (800cb88 <MX_GPIO_Init+0xac>)
 800cb40:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800cb42:	2300      	movs	r3, #0
 800cb44:	60fb      	str	r3, [r7, #12]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800cb46:	1d3b      	adds	r3, r7, #4
 800cb48:	4619      	mov	r1, r3
 800cb4a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800cb4e:	f002 fdf7 	bl	800f740 <HAL_GPIO_Init>

  /*Configure GPIO pin : PB1 */
  GPIO_InitStruct.Pin = GPIO_PIN_1;
 800cb52:	2302      	movs	r3, #2
 800cb54:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800cb56:	2301      	movs	r3, #1
 800cb58:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800cb5a:	2300      	movs	r3, #0
 800cb5c:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800cb5e:	2302      	movs	r3, #2
 800cb60:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800cb62:	1d3b      	adds	r3, r7, #4
 800cb64:	4619      	mov	r1, r3
 800cb66:	4807      	ldr	r0, [pc, #28]	; (800cb84 <MX_GPIO_Init+0xa8>)
 800cb68:	f002 fdea 	bl	800f740 <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI9_5_IRQn, 1, 0);
 800cb6c:	2200      	movs	r2, #0
 800cb6e:	2101      	movs	r1, #1
 800cb70:	2017      	movs	r0, #23
 800cb72:	f002 fbca 	bl	800f30a <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 800cb76:	2017      	movs	r0, #23
 800cb78:	f002 fbe1 	bl	800f33e <HAL_NVIC_EnableIRQ>

}
 800cb7c:	bf00      	nop
 800cb7e:	3718      	adds	r7, #24
 800cb80:	46bd      	mov	sp, r7
 800cb82:	bd80      	pop	{r7, pc}
 800cb84:	48000400 	.word	0x48000400
 800cb88:	10310000 	.word	0x10310000

0800cb8c <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 800cb8c:	b480      	push	{r7}
 800cb8e:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 800cb90:	b672      	cpsid	i
}
 800cb92:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 800cb94:	e7fe      	b.n	800cb94 <Error_Handler+0x8>

0800cb96 <LL_RCC_EnableRTC>:
  * @brief  Enable RTC
  * @rmtoll BDCR         RTCEN         LL_RCC_EnableRTC
  * @retval None
  */
__STATIC_INLINE void LL_RCC_EnableRTC(void)
{
 800cb96:	b480      	push	{r7}
 800cb98:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
 800cb9a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800cb9e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800cba2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800cba6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800cbaa:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 800cbae:	bf00      	nop
 800cbb0:	46bd      	mov	sp, r7
 800cbb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cbb6:	4770      	bx	lr

0800cbb8 <LL_AHB2_GRP1_EnableClock>:
{
 800cbb8:	b480      	push	{r7}
 800cbba:	b085      	sub	sp, #20
 800cbbc:	af00      	add	r7, sp, #0
 800cbbe:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 800cbc0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800cbc4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800cbc6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800cbca:	687b      	ldr	r3, [r7, #4]
 800cbcc:	4313      	orrs	r3, r2
 800cbce:	64cb      	str	r3, [r1, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 800cbd0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800cbd4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800cbd6:	687b      	ldr	r3, [r7, #4]
 800cbd8:	4013      	ands	r3, r2
 800cbda:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800cbdc:	68fb      	ldr	r3, [r7, #12]
}
 800cbde:	bf00      	nop
 800cbe0:	3714      	adds	r7, #20
 800cbe2:	46bd      	mov	sp, r7
 800cbe4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cbe8:	4770      	bx	lr

0800cbea <LL_AHB3_GRP1_EnableClock>:
  *         @arg @ref LL_AHB3_GRP1_PERIPH_FLASH
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
 800cbea:	b480      	push	{r7}
 800cbec:	b085      	sub	sp, #20
 800cbee:	af00      	add	r7, sp, #0
 800cbf0:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB3ENR, Periphs);
 800cbf2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800cbf6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800cbf8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800cbfc:	687b      	ldr	r3, [r7, #4]
 800cbfe:	4313      	orrs	r3, r2
 800cc00:	650b      	str	r3, [r1, #80]	; 0x50
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB3ENR, Periphs);
 800cc02:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800cc06:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800cc08:	687b      	ldr	r3, [r7, #4]
 800cc0a:	4013      	ands	r3, r2
 800cc0c:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800cc0e:	68fb      	ldr	r3, [r7, #12]
}
 800cc10:	bf00      	nop
 800cc12:	3714      	adds	r7, #20
 800cc14:	46bd      	mov	sp, r7
 800cc16:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc1a:	4770      	bx	lr

0800cc1c <LL_APB1_GRP1_EnableClock>:
  *         @arg @ref LL_APB1_GRP1_PERIPH_LPTIM1
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
 800cc1c:	b480      	push	{r7}
 800cc1e:	b085      	sub	sp, #20
 800cc20:	af00      	add	r7, sp, #0
 800cc22:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR1, Periphs);
 800cc24:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800cc28:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800cc2a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800cc2e:	687b      	ldr	r3, [r7, #4]
 800cc30:	4313      	orrs	r3, r2
 800cc32:	658b      	str	r3, [r1, #88]	; 0x58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 800cc34:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800cc38:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800cc3a:	687b      	ldr	r3, [r7, #4]
 800cc3c:	4013      	ands	r3, r2
 800cc3e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800cc40:	68fb      	ldr	r3, [r7, #12]
}
 800cc42:	bf00      	nop
 800cc44:	3714      	adds	r7, #20
 800cc46:	46bd      	mov	sp, r7
 800cc48:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc4c:	4770      	bx	lr

0800cc4e <LL_APB2_GRP1_EnableClock>:
  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI1 (*)
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
 800cc4e:	b480      	push	{r7}
 800cc50:	b085      	sub	sp, #20
 800cc52:	af00      	add	r7, sp, #0
 800cc54:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 800cc56:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800cc5a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800cc5c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800cc60:	687b      	ldr	r3, [r7, #4]
 800cc62:	4313      	orrs	r3, r2
 800cc64:	660b      	str	r3, [r1, #96]	; 0x60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 800cc66:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800cc6a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800cc6c:	687b      	ldr	r3, [r7, #4]
 800cc6e:	4013      	ands	r3, r2
 800cc70:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800cc72:	68fb      	ldr	r3, [r7, #12]
}
 800cc74:	bf00      	nop
 800cc76:	3714      	adds	r7, #20
 800cc78:	46bd      	mov	sp, r7
 800cc7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc7e:	4770      	bx	lr

0800cc80 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800cc80:	b580      	push	{r7, lr}
 800cc82:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_HSEM_CLK_ENABLE();
 800cc84:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800cc88:	f7ff ffaf 	bl	800cbea <LL_AHB3_GRP1_EnableClock>

  /* System interrupt init*/
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 1, 0);
 800cc8c:	2200      	movs	r2, #0
 800cc8e:	2101      	movs	r1, #1
 800cc90:	f06f 0009 	mvn.w	r0, #9
 800cc94:	f002 fb39 	bl	800f30a <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 1, 0);
 800cc98:	2200      	movs	r2, #0
 800cc9a:	2101      	movs	r1, #1
 800cc9c:	f06f 0003 	mvn.w	r0, #3
 800cca0:	f002 fb33 	bl	800f30a <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 1, 0);
 800cca4:	2200      	movs	r2, #0
 800cca6:	2101      	movs	r1, #1
 800cca8:	f06f 0001 	mvn.w	r0, #1
 800ccac:	f002 fb2d 	bl	800f30a <HAL_NVIC_SetPriority>

  /* Peripheral interrupt init */
  /* HSEM_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(HSEM_IRQn, 1, 0);
 800ccb0:	2200      	movs	r2, #0
 800ccb2:	2101      	movs	r1, #1
 800ccb4:	202e      	movs	r0, #46	; 0x2e
 800ccb6:	f002 fb28 	bl	800f30a <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(HSEM_IRQn);
 800ccba:	202e      	movs	r0, #46	; 0x2e
 800ccbc:	f002 fb3f 	bl	800f33e <HAL_NVIC_EnableIRQ>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800ccc0:	bf00      	nop
 800ccc2:	bd80      	pop	{r7, pc}

0800ccc4 <HAL_ADC_MspInit>:
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 800ccc4:	b580      	push	{r7, lr}
 800ccc6:	b088      	sub	sp, #32
 800ccc8:	af00      	add	r7, sp, #0
 800ccca:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800cccc:	f107 030c 	add.w	r3, r7, #12
 800ccd0:	2200      	movs	r2, #0
 800ccd2:	601a      	str	r2, [r3, #0]
 800ccd4:	605a      	str	r2, [r3, #4]
 800ccd6:	609a      	str	r2, [r3, #8]
 800ccd8:	60da      	str	r2, [r3, #12]
 800ccda:	611a      	str	r2, [r3, #16]
  if(hadc->Instance==ADC1)
 800ccdc:	687b      	ldr	r3, [r7, #4]
 800ccde:	681b      	ldr	r3, [r3, #0]
 800cce0:	4a23      	ldr	r2, [pc, #140]	; (800cd70 <HAL_ADC_MspInit+0xac>)
 800cce2:	4293      	cmp	r3, r2
 800cce4:	d13f      	bne.n	800cd66 <HAL_ADC_MspInit+0xa2>
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_ADC_CLK_ENABLE();
 800cce6:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800ccea:	f7ff ff65 	bl	800cbb8 <LL_AHB2_GRP1_EnableClock>

    __HAL_RCC_GPIOA_CLK_ENABLE();
 800ccee:	2001      	movs	r0, #1
 800ccf0:	f7ff ff62 	bl	800cbb8 <LL_AHB2_GRP1_EnableClock>
    /**ADC1 GPIO Configuration
    PA0     ------> ADC1_IN5
    PA1     ------> ADC1_IN6
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
 800ccf4:	2303      	movs	r3, #3
 800ccf6:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800ccf8:	2303      	movs	r3, #3
 800ccfa:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ccfc:	2300      	movs	r3, #0
 800ccfe:	617b      	str	r3, [r7, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800cd00:	f107 030c 	add.w	r3, r7, #12
 800cd04:	4619      	mov	r1, r3
 800cd06:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800cd0a:	f002 fd19 	bl	800f740 <HAL_GPIO_Init>

    /* ADC1 DMA Init */
    /* ADC1 Init */
    hdma_adc1.Instance = DMA1_Channel1;
 800cd0e:	4b19      	ldr	r3, [pc, #100]	; (800cd74 <HAL_ADC_MspInit+0xb0>)
 800cd10:	4a19      	ldr	r2, [pc, #100]	; (800cd78 <HAL_ADC_MspInit+0xb4>)
 800cd12:	601a      	str	r2, [r3, #0]
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
 800cd14:	4b17      	ldr	r3, [pc, #92]	; (800cd74 <HAL_ADC_MspInit+0xb0>)
 800cd16:	2205      	movs	r2, #5
 800cd18:	605a      	str	r2, [r3, #4]
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
 800cd1a:	4b16      	ldr	r3, [pc, #88]	; (800cd74 <HAL_ADC_MspInit+0xb0>)
 800cd1c:	2200      	movs	r2, #0
 800cd1e:	609a      	str	r2, [r3, #8]
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
 800cd20:	4b14      	ldr	r3, [pc, #80]	; (800cd74 <HAL_ADC_MspInit+0xb0>)
 800cd22:	2200      	movs	r2, #0
 800cd24:	60da      	str	r2, [r3, #12]
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
 800cd26:	4b13      	ldr	r3, [pc, #76]	; (800cd74 <HAL_ADC_MspInit+0xb0>)
 800cd28:	2280      	movs	r2, #128	; 0x80
 800cd2a:	611a      	str	r2, [r3, #16]
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 800cd2c:	4b11      	ldr	r3, [pc, #68]	; (800cd74 <HAL_ADC_MspInit+0xb0>)
 800cd2e:	f44f 7280 	mov.w	r2, #256	; 0x100
 800cd32:	615a      	str	r2, [r3, #20]
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 800cd34:	4b0f      	ldr	r3, [pc, #60]	; (800cd74 <HAL_ADC_MspInit+0xb0>)
 800cd36:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800cd3a:	619a      	str	r2, [r3, #24]
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
 800cd3c:	4b0d      	ldr	r3, [pc, #52]	; (800cd74 <HAL_ADC_MspInit+0xb0>)
 800cd3e:	2220      	movs	r2, #32
 800cd40:	61da      	str	r2, [r3, #28]
    hdma_adc1.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 800cd42:	4b0c      	ldr	r3, [pc, #48]	; (800cd74 <HAL_ADC_MspInit+0xb0>)
 800cd44:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 800cd48:	621a      	str	r2, [r3, #32]
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
 800cd4a:	480a      	ldr	r0, [pc, #40]	; (800cd74 <HAL_ADC_MspInit+0xb0>)
 800cd4c:	f002 fb3c 	bl	800f3c8 <HAL_DMA_Init>
 800cd50:	4603      	mov	r3, r0
 800cd52:	2b00      	cmp	r3, #0
 800cd54:	d001      	beq.n	800cd5a <HAL_ADC_MspInit+0x96>
    {
      Error_Handler();
 800cd56:	f7ff ff19 	bl	800cb8c <Error_Handler>
    }

    __HAL_LINKDMA(hadc,DMA_Handle,hdma_adc1);
 800cd5a:	687b      	ldr	r3, [r7, #4]
 800cd5c:	4a05      	ldr	r2, [pc, #20]	; (800cd74 <HAL_ADC_MspInit+0xb0>)
 800cd5e:	64da      	str	r2, [r3, #76]	; 0x4c
 800cd60:	4a04      	ldr	r2, [pc, #16]	; (800cd74 <HAL_ADC_MspInit+0xb0>)
 800cd62:	687b      	ldr	r3, [r7, #4]
 800cd64:	6293      	str	r3, [r2, #40]	; 0x28
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }

}
 800cd66:	bf00      	nop
 800cd68:	3720      	adds	r7, #32
 800cd6a:	46bd      	mov	sp, r7
 800cd6c:	bd80      	pop	{r7, pc}
 800cd6e:	bf00      	nop
 800cd70:	50040000 	.word	0x50040000
 800cd74:	200053f0 	.word	0x200053f0
 800cd78:	40020008 	.word	0x40020008

0800cd7c <HAL_COMP_MspInit>:
* This function configures the hardware resources used in this example
* @param hcomp: COMP handle pointer
* @retval None
*/
void HAL_COMP_MspInit(COMP_HandleTypeDef* hcomp)
{
 800cd7c:	b580      	push	{r7, lr}
 800cd7e:	b088      	sub	sp, #32
 800cd80:	af00      	add	r7, sp, #0
 800cd82:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800cd84:	f107 030c 	add.w	r3, r7, #12
 800cd88:	2200      	movs	r2, #0
 800cd8a:	601a      	str	r2, [r3, #0]
 800cd8c:	605a      	str	r2, [r3, #4]
 800cd8e:	609a      	str	r2, [r3, #8]
 800cd90:	60da      	str	r2, [r3, #12]
 800cd92:	611a      	str	r2, [r3, #16]
  if(hcomp->Instance==COMP2)
 800cd94:	687b      	ldr	r3, [r7, #4]
 800cd96:	681b      	ldr	r3, [r3, #0]
 800cd98:	4a0f      	ldr	r2, [pc, #60]	; (800cdd8 <HAL_COMP_MspInit+0x5c>)
 800cd9a:	4293      	cmp	r3, r2
 800cd9c:	d117      	bne.n	800cdce <HAL_COMP_MspInit+0x52>
  {
  /* USER CODE BEGIN COMP2_MspInit 0 */

  /* USER CODE END COMP2_MspInit 0 */

    __HAL_RCC_GPIOA_CLK_ENABLE();
 800cd9e:	2001      	movs	r0, #1
 800cda0:	f7ff ff0a 	bl	800cbb8 <LL_AHB2_GRP1_EnableClock>
    /**COMP2 GPIO Configuration
    PA3     ------> COMP2_INP
    PA4     ------> COMP2_INM
    */
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4;
 800cda4:	2318      	movs	r3, #24
 800cda6:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800cda8:	2303      	movs	r3, #3
 800cdaa:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800cdac:	2300      	movs	r3, #0
 800cdae:	617b      	str	r3, [r7, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800cdb0:	f107 030c 	add.w	r3, r7, #12
 800cdb4:	4619      	mov	r1, r3
 800cdb6:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800cdba:	f002 fcc1 	bl	800f740 <HAL_GPIO_Init>

    /* COMP2 interrupt Init */
    HAL_NVIC_SetPriority(COMP_IRQn, 0, 0);
 800cdbe:	2200      	movs	r2, #0
 800cdc0:	2100      	movs	r1, #0
 800cdc2:	2016      	movs	r0, #22
 800cdc4:	f002 faa1 	bl	800f30a <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(COMP_IRQn);
 800cdc8:	2016      	movs	r0, #22
 800cdca:	f002 fab8 	bl	800f33e <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN COMP2_MspInit 1 */

  /* USER CODE END COMP2_MspInit 1 */
  }

}
 800cdce:	bf00      	nop
 800cdd0:	3720      	adds	r7, #32
 800cdd2:	46bd      	mov	sp, r7
 800cdd4:	bd80      	pop	{r7, pc}
 800cdd6:	bf00      	nop
 800cdd8:	40010204 	.word	0x40010204

0800cddc <HAL_RTC_MspInit>:
* This function configures the hardware resources used in this example
* @param hrtc: RTC handle pointer
* @retval None
*/
void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{
 800cddc:	b580      	push	{r7, lr}
 800cdde:	b082      	sub	sp, #8
 800cde0:	af00      	add	r7, sp, #0
 800cde2:	6078      	str	r0, [r7, #4]
  if(hrtc->Instance==RTC)
 800cde4:	687b      	ldr	r3, [r7, #4]
 800cde6:	681b      	ldr	r3, [r3, #0]
 800cde8:	4a06      	ldr	r2, [pc, #24]	; (800ce04 <HAL_RTC_MspInit+0x28>)
 800cdea:	4293      	cmp	r3, r2
 800cdec:	d105      	bne.n	800cdfa <HAL_RTC_MspInit+0x1e>
  {
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_RTC_ENABLE();
 800cdee:	f7ff fed2 	bl	800cb96 <LL_RCC_EnableRTC>
    __HAL_RCC_RTCAPB_CLK_ENABLE();
 800cdf2:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800cdf6:	f7ff ff11 	bl	800cc1c <LL_APB1_GRP1_EnableClock>
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }

}
 800cdfa:	bf00      	nop
 800cdfc:	3708      	adds	r7, #8
 800cdfe:	46bd      	mov	sp, r7
 800ce00:	bd80      	pop	{r7, pc}
 800ce02:	bf00      	nop
 800ce04:	40002800 	.word	0x40002800

0800ce08 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 800ce08:	b580      	push	{r7, lr}
 800ce0a:	b088      	sub	sp, #32
 800ce0c:	af00      	add	r7, sp, #0
 800ce0e:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800ce10:	f107 030c 	add.w	r3, r7, #12
 800ce14:	2200      	movs	r2, #0
 800ce16:	601a      	str	r2, [r3, #0]
 800ce18:	605a      	str	r2, [r3, #4]
 800ce1a:	609a      	str	r2, [r3, #8]
 800ce1c:	60da      	str	r2, [r3, #12]
 800ce1e:	611a      	str	r2, [r3, #16]
  if(hspi->Instance==SPI1)
 800ce20:	687b      	ldr	r3, [r7, #4]
 800ce22:	681b      	ldr	r3, [r3, #0]
 800ce24:	4a0f      	ldr	r2, [pc, #60]	; (800ce64 <HAL_SPI_MspInit+0x5c>)
 800ce26:	4293      	cmp	r3, r2
 800ce28:	d117      	bne.n	800ce5a <HAL_SPI_MspInit+0x52>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 800ce2a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800ce2e:	f7ff ff0e 	bl	800cc4e <LL_APB2_GRP1_EnableClock>

    __HAL_RCC_GPIOA_CLK_ENABLE();
 800ce32:	2001      	movs	r0, #1
 800ce34:	f7ff fec0 	bl	800cbb8 <LL_AHB2_GRP1_EnableClock>
    /**SPI1 GPIO Configuration
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
 800ce38:	23e0      	movs	r3, #224	; 0xe0
 800ce3a:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ce3c:	2302      	movs	r3, #2
 800ce3e:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ce40:	2300      	movs	r3, #0
 800ce42:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800ce44:	2300      	movs	r3, #0
 800ce46:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 800ce48:	2305      	movs	r3, #5
 800ce4a:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800ce4c:	f107 030c 	add.w	r3, r7, #12
 800ce50:	4619      	mov	r1, r3
 800ce52:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800ce56:	f002 fc73 	bl	800f740 <HAL_GPIO_Init>
  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }

}
 800ce5a:	bf00      	nop
 800ce5c:	3720      	adds	r7, #32
 800ce5e:	46bd      	mov	sp, r7
 800ce60:	bd80      	pop	{r7, pc}
 800ce62:	bf00      	nop
 800ce64:	40013000 	.word	0x40013000

0800ce68 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 800ce68:	b480      	push	{r7}
 800ce6a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 800ce6c:	e7fe      	b.n	800ce6c <NMI_Handler+0x4>
	...

0800ce70 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800ce70:	b480      	push	{r7}
 800ce72:	b083      	sub	sp, #12
 800ce74:	af00      	add	r7, sp, #0

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_HardFault_IRQn 0 */
	  GPIOB->ODR ^= GPIO_ODR_OD1;
 800ce76:	4b08      	ldr	r3, [pc, #32]	; (800ce98 <HardFault_Handler+0x28>)
 800ce78:	695b      	ldr	r3, [r3, #20]
 800ce7a:	4a07      	ldr	r2, [pc, #28]	; (800ce98 <HardFault_Handler+0x28>)
 800ce7c:	f083 0302 	eor.w	r3, r3, #2
 800ce80:	6153      	str	r3, [r2, #20]
	  for (uint32_t i = 0; i < 1000000; i++);
 800ce82:	2300      	movs	r3, #0
 800ce84:	607b      	str	r3, [r7, #4]
 800ce86:	e002      	b.n	800ce8e <HardFault_Handler+0x1e>
 800ce88:	687b      	ldr	r3, [r7, #4]
 800ce8a:	3301      	adds	r3, #1
 800ce8c:	607b      	str	r3, [r7, #4]
 800ce8e:	687b      	ldr	r3, [r7, #4]
 800ce90:	4a02      	ldr	r2, [pc, #8]	; (800ce9c <HardFault_Handler+0x2c>)
 800ce92:	4293      	cmp	r3, r2
 800ce94:	d9f8      	bls.n	800ce88 <HardFault_Handler+0x18>
	  GPIOB->ODR ^= GPIO_ODR_OD1;
 800ce96:	e7ee      	b.n	800ce76 <HardFault_Handler+0x6>
 800ce98:	48000400 	.word	0x48000400
 800ce9c:	000f423f 	.word	0x000f423f

0800cea0 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 800cea0:	b480      	push	{r7}
 800cea2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 800cea4:	e7fe      	b.n	800cea4 <MemManage_Handler+0x4>

0800cea6 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800cea6:	b480      	push	{r7}
 800cea8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 800ceaa:	e7fe      	b.n	800ceaa <BusFault_Handler+0x4>

0800ceac <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 800ceac:	b480      	push	{r7}
 800ceae:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 800ceb0:	e7fe      	b.n	800ceb0 <UsageFault_Handler+0x4>

0800ceb2 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 800ceb2:	b480      	push	{r7}
 800ceb4:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 800ceb6:	bf00      	nop
 800ceb8:	46bd      	mov	sp, r7
 800ceba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cebe:	4770      	bx	lr

0800cec0 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 800cec0:	b480      	push	{r7}
 800cec2:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800cec4:	bf00      	nop
 800cec6:	46bd      	mov	sp, r7
 800cec8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cecc:	4770      	bx	lr

0800cece <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 800cece:	b480      	push	{r7}
 800ced0:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 800ced2:	bf00      	nop
 800ced4:	46bd      	mov	sp, r7
 800ced6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ceda:	4770      	bx	lr

0800cedc <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 800cedc:	b580      	push	{r7, lr}
 800cede:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800cee0:	f000 fa22 	bl	800d328 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800cee4:	bf00      	nop
 800cee6:	bd80      	pop	{r7, pc}

0800cee8 <DMA1_Channel1_IRQHandler>:

/**
  * @brief This function handles DMA1 channel1 global interrupt.
  */
void DMA1_Channel1_IRQHandler(void)
{
 800cee8:	b580      	push	{r7, lr}
 800ceea:	b084      	sub	sp, #16
 800ceec:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Channel1_IRQn 0 */
	uint16_t *dma_buffer;
	uint16_t dma_buf_len;

	sys.dma.returnDataInfo(&dma_buffer, &dma_buf_len);
 800ceee:	4b2d      	ldr	r3, [pc, #180]	; (800cfa4 <DMA1_Channel1_IRQHandler+0xbc>)
 800cef0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800cef4:	1db9      	adds	r1, r7, #6
 800cef6:	f107 0208 	add.w	r2, r7, #8
 800cefa:	4610      	mov	r0, r2
 800cefc:	4798      	blx	r3
	uint16_t max_val = sys.rad.calculateMaxValue(dma_buffer, dma_buf_len);
 800cefe:	4b29      	ldr	r3, [pc, #164]	; (800cfa4 <DMA1_Channel1_IRQHandler+0xbc>)
 800cf00:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 800cf04:	331c      	adds	r3, #28
 800cf06:	681b      	ldr	r3, [r3, #0]
 800cf08:	68ba      	ldr	r2, [r7, #8]
 800cf0a:	88f9      	ldrh	r1, [r7, #6]
 800cf0c:	4610      	mov	r0, r2
 800cf0e:	4798      	blx	r3
 800cf10:	4603      	mov	r3, r0
 800cf12:	81fb      	strh	r3, [r7, #14]
	//sys.rad.increaseChannelData(max_val);

	if (max_val > sys.settings.minValueFiltration && max_val < sys.settings.maxValueFiltration)
 800cf14:	4b23      	ldr	r3, [pc, #140]	; (800cfa4 <DMA1_Channel1_IRQHandler+0xbc>)
 800cf16:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 800cf1a:	3368      	adds	r3, #104	; 0x68
 800cf1c:	881b      	ldrh	r3, [r3, #0]
 800cf1e:	89fa      	ldrh	r2, [r7, #14]
 800cf20:	429a      	cmp	r2, r3
 800cf22:	d925      	bls.n	800cf70 <DMA1_Channel1_IRQHandler+0x88>
 800cf24:	4b1f      	ldr	r3, [pc, #124]	; (800cfa4 <DMA1_Channel1_IRQHandler+0xbc>)
 800cf26:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 800cf2a:	336a      	adds	r3, #106	; 0x6a
 800cf2c:	881b      	ldrh	r3, [r3, #0]
 800cf2e:	89fa      	ldrh	r2, [r7, #14]
 800cf30:	429a      	cmp	r2, r3
 800cf32:	d21d      	bcs.n	800cf70 <DMA1_Channel1_IRQHandler+0x88>
	{
		if (sys.tim2.isTurnedOn)
 800cf34:	4b1b      	ldr	r3, [pc, #108]	; (800cfa4 <DMA1_Channel1_IRQHandler+0xbc>)
 800cf36:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800cf3a:	2b00      	cmp	r3, #0
 800cf3c:	d00a      	beq.n	800cf54 <DMA1_Channel1_IRQHandler+0x6c>
			++sys.rad._cps;
 800cf3e:	4b19      	ldr	r3, [pc, #100]	; (800cfa4 <DMA1_Channel1_IRQHandler+0xbc>)
 800cf40:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 800cf44:	330c      	adds	r3, #12
 800cf46:	681b      	ldr	r3, [r3, #0]
 800cf48:	1c5a      	adds	r2, r3, #1
 800cf4a:	4b16      	ldr	r3, [pc, #88]	; (800cfa4 <DMA1_Channel1_IRQHandler+0xbc>)
 800cf4c:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 800cf50:	330c      	adds	r3, #12
 800cf52:	601a      	str	r2, [r3, #0]
		++sys.rad._spectrogram[max_val];
 800cf54:	89fa      	ldrh	r2, [r7, #14]
 800cf56:	4913      	ldr	r1, [pc, #76]	; (800cfa4 <DMA1_Channel1_IRQHandler+0xbc>)
 800cf58:	f102 0322 	add.w	r3, r2, #34	; 0x22
 800cf5c:	009b      	lsls	r3, r3, #2
 800cf5e:	440b      	add	r3, r1
 800cf60:	685b      	ldr	r3, [r3, #4]
 800cf62:	1c59      	adds	r1, r3, #1
 800cf64:	480f      	ldr	r0, [pc, #60]	; (800cfa4 <DMA1_Channel1_IRQHandler+0xbc>)
 800cf66:	f102 0322 	add.w	r3, r2, #34	; 0x22
 800cf6a:	009b      	lsls	r3, r3, #2
 800cf6c:	4403      	add	r3, r0
 800cf6e:	6059      	str	r1, [r3, #4]
	}


	GPIOB->BSRR |= GPIO_BSRR_BS1; // LED
 800cf70:	4b0d      	ldr	r3, [pc, #52]	; (800cfa8 <DMA1_Channel1_IRQHandler+0xc0>)
 800cf72:	699b      	ldr	r3, [r3, #24]
 800cf74:	4a0c      	ldr	r2, [pc, #48]	; (800cfa8 <DMA1_Channel1_IRQHandler+0xc0>)
 800cf76:	f043 0302 	orr.w	r3, r3, #2
 800cf7a:	6193      	str	r3, [r2, #24]


	DMA1->IFCR |= DMA_IFCR_CGIF1 | DMA_IFCR_CHTIF1;
 800cf7c:	4b0b      	ldr	r3, [pc, #44]	; (800cfac <DMA1_Channel1_IRQHandler+0xc4>)
 800cf7e:	685b      	ldr	r3, [r3, #4]
 800cf80:	4a0a      	ldr	r2, [pc, #40]	; (800cfac <DMA1_Channel1_IRQHandler+0xc4>)
 800cf82:	f043 0305 	orr.w	r3, r3, #5
 800cf86:	6053      	str	r3, [r2, #4]
	ADC1->ISR |= ADC_ISR_EOS | ADC_ISR_EOSMP;
 800cf88:	4b09      	ldr	r3, [pc, #36]	; (800cfb0 <DMA1_Channel1_IRQHandler+0xc8>)
 800cf8a:	681b      	ldr	r3, [r3, #0]
 800cf8c:	4a08      	ldr	r2, [pc, #32]	; (800cfb0 <DMA1_Channel1_IRQHandler+0xc8>)
 800cf8e:	f043 030a 	orr.w	r3, r3, #10
 800cf92:	6013      	str	r3, [r2, #0]
  /* USER CODE END DMA1_Channel1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc1);
 800cf94:	4807      	ldr	r0, [pc, #28]	; (800cfb4 <DMA1_Channel1_IRQHandler+0xcc>)
 800cf96:	f002 fabf 	bl	800f518 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel1_IRQn 1 */

  /* USER CODE END DMA1_Channel1_IRQn 1 */
}
 800cf9a:	bf00      	nop
 800cf9c:	3710      	adds	r7, #16
 800cf9e:	46bd      	mov	sp, r7
 800cfa0:	bd80      	pop	{r7, pc}
 800cfa2:	bf00      	nop
 800cfa4:	20001020 	.word	0x20001020
 800cfa8:	48000400 	.word	0x48000400
 800cfac:	40020000 	.word	0x40020000
 800cfb0:	50040000 	.word	0x50040000
 800cfb4:	200053f0 	.word	0x200053f0

0800cfb8 <COMP_IRQHandler>:

/**
  * @brief This function handles COMP1 and COMP2 interrupts through EXTI lines 20 and 21.
  */
void COMP_IRQHandler(void)
{
 800cfb8:	b580      	push	{r7, lr}
 800cfba:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN COMP_IRQn 0 */
	if (!(ADC1->CR & ADC_CR_ADSTART) && !(DMA1->IFCR & (DMA_IFCR_CGIF1 | DMA_IFCR_CHTIF1)))
 800cfbc:	4b0e      	ldr	r3, [pc, #56]	; (800cff8 <COMP_IRQHandler+0x40>)
 800cfbe:	689b      	ldr	r3, [r3, #8]
 800cfc0:	f003 0304 	and.w	r3, r3, #4
 800cfc4:	2b00      	cmp	r3, #0
 800cfc6:	d111      	bne.n	800cfec <COMP_IRQHandler+0x34>
 800cfc8:	4b0c      	ldr	r3, [pc, #48]	; (800cffc <COMP_IRQHandler+0x44>)
 800cfca:	685b      	ldr	r3, [r3, #4]
 800cfcc:	f003 0305 	and.w	r3, r3, #5
 800cfd0:	2b00      	cmp	r3, #0
 800cfd2:	d10b      	bne.n	800cfec <COMP_IRQHandler+0x34>
	{
		ADC1->CR |= ADC_CR_ADSTART;
 800cfd4:	4b08      	ldr	r3, [pc, #32]	; (800cff8 <COMP_IRQHandler+0x40>)
 800cfd6:	689b      	ldr	r3, [r3, #8]
 800cfd8:	4a07      	ldr	r2, [pc, #28]	; (800cff8 <COMP_IRQHandler+0x40>)
 800cfda:	f043 0304 	orr.w	r3, r3, #4
 800cfde:	6093      	str	r3, [r2, #8]
		GPIOB->BSRR |= GPIO_BSRR_BR1; // LED
 800cfe0:	4b07      	ldr	r3, [pc, #28]	; (800d000 <COMP_IRQHandler+0x48>)
 800cfe2:	699b      	ldr	r3, [r3, #24]
 800cfe4:	4a06      	ldr	r2, [pc, #24]	; (800d000 <COMP_IRQHandler+0x48>)
 800cfe6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800cfea:	6193      	str	r3, [r2, #24]
	}

  /* USER CODE END COMP_IRQn 0 */
  HAL_COMP_IRQHandler(&hcomp2);
 800cfec:	4805      	ldr	r0, [pc, #20]	; (800d004 <COMP_IRQHandler+0x4c>)
 800cfee:	f002 f819 	bl	800f024 <HAL_COMP_IRQHandler>
  /* USER CODE BEGIN COMP_IRQn 1 */

  /* USER CODE END COMP_IRQn 1 */
}
 800cff2:	bf00      	nop
 800cff4:	bd80      	pop	{r7, pc}
 800cff6:	bf00      	nop
 800cff8:	50040000 	.word	0x50040000
 800cffc:	40020000 	.word	0x40020000
 800d000:	48000400 	.word	0x48000400
 800d004:	20005474 	.word	0x20005474

0800d008 <EXTI9_5_IRQHandler>:

/**
  * @brief This function handles EXTI line[9:5] interrupts.
  */
void EXTI9_5_IRQHandler(void)
{
 800d008:	b580      	push	{r7, lr}
 800d00a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI9_5_IRQn 0 */
	if (!sys.uSD.isAvailable()) // if uSD has been detached
 800d00c:	4b0e      	ldr	r3, [pc, #56]	; (800d048 <EXTI9_5_IRQHandler+0x40>)
 800d00e:	699b      	ldr	r3, [r3, #24]
 800d010:	4798      	blx	r3
 800d012:	4603      	mov	r3, r0
 800d014:	2b00      	cmp	r3, #0
 800d016:	d10b      	bne.n	800d030 <EXTI9_5_IRQHandler+0x28>
	{
		sys.uSD.setInitialized(0);
 800d018:	4b0b      	ldr	r3, [pc, #44]	; (800d048 <EXTI9_5_IRQHandler+0x40>)
 800d01a:	69db      	ldr	r3, [r3, #28]
 800d01c:	2000      	movs	r0, #0
 800d01e:	4798      	blx	r3
		sys.fs._isInitialized = 0;
 800d020:	4b09      	ldr	r3, [pc, #36]	; (800d048 <EXTI9_5_IRQHandler+0x40>)
 800d022:	2200      	movs	r2, #0
 800d024:	701a      	strb	r2, [r3, #0]
		sys.fs._initializationTime = 0xFFFFFFFF;
 800d026:	4b08      	ldr	r3, [pc, #32]	; (800d048 <EXTI9_5_IRQHandler+0x40>)
 800d028:	f04f 32ff 	mov.w	r2, #4294967295
 800d02c:	605a      	str	r2, [r3, #4]
 800d02e:	e004      	b.n	800d03a <EXTI9_5_IRQHandler+0x32>
	}
	else
	{
		sys.fs._initializationTime = sys.tim17.globalSystemTimeSec + 3;
 800d030:	4b05      	ldr	r3, [pc, #20]	; (800d048 <EXTI9_5_IRQHandler+0x40>)
 800d032:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800d034:	3303      	adds	r3, #3
 800d036:	4a04      	ldr	r2, [pc, #16]	; (800d048 <EXTI9_5_IRQHandler+0x40>)
 800d038:	6053      	str	r3, [r2, #4]
	}
  /* USER CODE END EXTI9_5_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_9);
 800d03a:	f44f 7000 	mov.w	r0, #512	; 0x200
 800d03e:	f002 fd07 	bl	800fa50 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI9_5_IRQn 1 */

  /* USER CODE END EXTI9_5_IRQn 1 */
}
 800d042:	bf00      	nop
 800d044:	bd80      	pop	{r7, pc}
 800d046:	bf00      	nop
 800d048:	20001020 	.word	0x20001020

0800d04c <HSEM_IRQHandler>:

/**
  * @brief This function handles HSEM global interrupt.
  */
void HSEM_IRQHandler(void)
{
 800d04c:	b580      	push	{r7, lr}
 800d04e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HSEM_IRQn 0 */

  /* USER CODE END HSEM_IRQn 0 */
  HAL_HSEM_IRQHandler();
 800d050:	f002 fd22 	bl	800fa98 <HAL_HSEM_IRQHandler>
  /* USER CODE BEGIN HSEM_IRQn 1 */

  /* USER CODE END HSEM_IRQn 1 */
}
 800d054:	bf00      	nop
 800d056:	bd80      	pop	{r7, pc}

0800d058 <RTC_WKUP_IRQHandler>:

/* USER CODE BEGIN 1 */
void RTC_WKUP_IRQHandler(void)
{
 800d058:	b580      	push	{r7, lr}
 800d05a:	af00      	add	r7, sp, #0
	HW_TS_RTC_Wakeup_Handler();
 800d05c:	f7fe ffac 	bl	800bfb8 <HW_TS_RTC_Wakeup_Handler>
}
 800d060:	bf00      	nop
 800d062:	bd80      	pop	{r7, pc}

0800d064 <IPCC_C1_RX_IRQHandler>:
void IPCC_C1_RX_IRQHandler(void)
{
 800d064:	b580      	push	{r7, lr}
 800d066:	af00      	add	r7, sp, #0
	HW_IPCC_Rx_Handler();
 800d068:	f007 f9ce 	bl	8014408 <HW_IPCC_Rx_Handler>
}
 800d06c:	bf00      	nop
 800d06e:	bd80      	pop	{r7, pc}

0800d070 <IPCC_C1_TX_IRQHandler>:
void IPCC_C1_TX_IRQHandler(void)
{
 800d070:	b580      	push	{r7, lr}
 800d072:	af00      	add	r7, sp, #0
	HW_IPCC_Tx_Handler();
 800d074:	f007 fa00 	bl	8014478 <HW_IPCC_Tx_Handler>
}
 800d078:	bf00      	nop
 800d07a:	bd80      	pop	{r7, pc}

0800d07c <TIM1_TRG_COM_TIM17_IRQHandler>:

void TIM1_TRG_COM_TIM17_IRQHandler(void) // ONE SECOND TIMER
{
 800d07c:	b580      	push	{r7, lr}
 800d07e:	af00      	add	r7, sp, #0

	if (sys.tim17.globalSystemTimeSec >= sys.fs._initializationTime)
 800d080:	4b1a      	ldr	r3, [pc, #104]	; (800d0ec <TIM1_TRG_COM_TIM17_IRQHandler+0x70>)
 800d082:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800d084:	4b19      	ldr	r3, [pc, #100]	; (800d0ec <TIM1_TRG_COM_TIM17_IRQHandler+0x70>)
 800d086:	685b      	ldr	r3, [r3, #4]
 800d088:	429a      	cmp	r2, r3
 800d08a:	d307      	bcc.n	800d09c <TIM1_TRG_COM_TIM17_IRQHandler+0x20>
	{
		sys.fs._initializationTime = 0xFFFFFFFF;
 800d08c:	4b17      	ldr	r3, [pc, #92]	; (800d0ec <TIM1_TRG_COM_TIM17_IRQHandler+0x70>)
 800d08e:	f04f 32ff 	mov.w	r2, #4294967295
 800d092:	605a      	str	r2, [r3, #4]
		UTIL_SEQ_SetTask(1 << USER_TASK_INITIALIZE_FS, CFG_SCH_PRIO_0);
 800d094:	2100      	movs	r1, #0
 800d096:	2080      	movs	r0, #128	; 0x80
 800d098:	f007 fc52 	bl	8014940 <UTIL_SEQ_SetTask>
	}
	if (sys.tim17.globalSystemTimeSec >= sys.rad._saveTime)
 800d09c:	4b13      	ldr	r3, [pc, #76]	; (800d0ec <TIM1_TRG_COM_TIM17_IRQHandler+0x70>)
 800d09e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800d0a0:	4b12      	ldr	r3, [pc, #72]	; (800d0ec <TIM1_TRG_COM_TIM17_IRQHandler+0x70>)
 800d0a2:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 800d0a6:	3310      	adds	r3, #16
 800d0a8:	681b      	ldr	r3, [r3, #0]
 800d0aa:	429a      	cmp	r2, r3
 800d0ac:	d30b      	bcc.n	800d0c6 <TIM1_TRG_COM_TIM17_IRQHandler+0x4a>
	{
		sys.rad._saveTime = 0xFFFFFFFF;
 800d0ae:	4b0f      	ldr	r3, [pc, #60]	; (800d0ec <TIM1_TRG_COM_TIM17_IRQHandler+0x70>)
 800d0b0:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 800d0b4:	3310      	adds	r3, #16
 800d0b6:	f04f 32ff 	mov.w	r2, #4294967295
 800d0ba:	601a      	str	r2, [r3, #0]
		UTIL_SEQ_SetTask(1 << USER_TASK_SAVE_SPECTR_POST_DELAYED, CFG_SCH_PRIO_0);
 800d0bc:	2100      	movs	r1, #0
 800d0be:	f44f 7080 	mov.w	r0, #256	; 0x100
 800d0c2:	f007 fc3d 	bl	8014940 <UTIL_SEQ_SetTask>
	}

	++sys.tim17.globalSystemTimeSec;
 800d0c6:	4b09      	ldr	r3, [pc, #36]	; (800d0ec <TIM1_TRG_COM_TIM17_IRQHandler+0x70>)
 800d0c8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800d0ca:	3301      	adds	r3, #1
 800d0cc:	4a07      	ldr	r2, [pc, #28]	; (800d0ec <TIM1_TRG_COM_TIM17_IRQHandler+0x70>)
 800d0ce:	6553      	str	r3, [r2, #84]	; 0x54
	TIM17->SR &= ~TIM_SR_UIF;
 800d0d0:	4b07      	ldr	r3, [pc, #28]	; (800d0f0 <TIM1_TRG_COM_TIM17_IRQHandler+0x74>)
 800d0d2:	691b      	ldr	r3, [r3, #16]
 800d0d4:	4a06      	ldr	r2, [pc, #24]	; (800d0f0 <TIM1_TRG_COM_TIM17_IRQHandler+0x74>)
 800d0d6:	f023 0301 	bic.w	r3, r3, #1
 800d0da:	6113      	str	r3, [r2, #16]
	TIM17->CR1 |= TIM_CR1_CEN;
 800d0dc:	4b04      	ldr	r3, [pc, #16]	; (800d0f0 <TIM1_TRG_COM_TIM17_IRQHandler+0x74>)
 800d0de:	681b      	ldr	r3, [r3, #0]
 800d0e0:	4a03      	ldr	r2, [pc, #12]	; (800d0f0 <TIM1_TRG_COM_TIM17_IRQHandler+0x74>)
 800d0e2:	f043 0301 	orr.w	r3, r3, #1
 800d0e6:	6013      	str	r3, [r2, #0]
}
 800d0e8:	bf00      	nop
 800d0ea:	bd80      	pop	{r7, pc}
 800d0ec:	20001020 	.word	0x20001020
 800d0f0:	40014800 	.word	0x40014800

0800d0f4 <TIM2_IRQHandler>:

void TIM2_IRQHandler(void) // CPS UPDATER TIMER
{
 800d0f4:	b580      	push	{r7, lr}
 800d0f6:	af00      	add	r7, sp, #0
	if (sys.rf.isConnected)
 800d0f8:	4b15      	ldr	r3, [pc, #84]	; (800d150 <TIM2_IRQHandler+0x5c>)
 800d0fa:	f503 4382 	add.w	r3, r3, #16640	; 0x4100
 800d0fe:	3325      	adds	r3, #37	; 0x25
 800d100:	781b      	ldrb	r3, [r3, #0]
 800d102:	2b00      	cmp	r3, #0
 800d104:	d00b      	beq.n	800d11e <TIM2_IRQHandler+0x2a>
		sys.rf.updateCpsChar(sys.rad._cps);
 800d106:	4b12      	ldr	r3, [pc, #72]	; (800d150 <TIM2_IRQHandler+0x5c>)
 800d108:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 800d10c:	3360      	adds	r3, #96	; 0x60
 800d10e:	681a      	ldr	r2, [r3, #0]
 800d110:	4b0f      	ldr	r3, [pc, #60]	; (800d150 <TIM2_IRQHandler+0x5c>)
 800d112:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 800d116:	330c      	adds	r3, #12
 800d118:	681b      	ldr	r3, [r3, #0]
 800d11a:	4618      	mov	r0, r3
 800d11c:	4790      	blx	r2
	sys.rad._cps = 0;
 800d11e:	4b0c      	ldr	r3, [pc, #48]	; (800d150 <TIM2_IRQHandler+0x5c>)
 800d120:	f503 4381 	add.w	r3, r3, #16512	; 0x4080
 800d124:	330c      	adds	r3, #12
 800d126:	2200      	movs	r2, #0
 800d128:	601a      	str	r2, [r3, #0]
	TIM2->SR &= ~TIM_SR_UIF;
 800d12a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800d12e:	691b      	ldr	r3, [r3, #16]
 800d130:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800d134:	f023 0301 	bic.w	r3, r3, #1
 800d138:	6113      	str	r3, [r2, #16]
	TIM2->CR1 |= TIM_CR1_CEN;
 800d13a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800d13e:	681b      	ldr	r3, [r3, #0]
 800d140:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800d144:	f043 0301 	orr.w	r3, r3, #1
 800d148:	6013      	str	r3, [r2, #0]
}
 800d14a:	bf00      	nop
 800d14c:	bd80      	pop	{r7, pc}
 800d14e:	bf00      	nop
 800d150:	20001020 	.word	0x20001020

0800d154 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 800d154:	b480      	push	{r7}
 800d156:	af00      	add	r7, sp, #0
  /* Configure the Vector Table location add offset address ------------------*/
#if defined(VECT_TAB_SRAM) && defined(VECT_TAB_BASE_ADDRESS)  
  /* program in SRAMx */
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;  /* Vector Table Relocation in Internal SRAMx for CPU1 */
#else    /* program in FLASH */
  SCB->VTOR = VECT_TAB_OFFSET;              /* Vector Table Relocation in Internal FLASH */
 800d158:	4b26      	ldr	r3, [pc, #152]	; (800d1f4 <SystemInit+0xa0>)
 800d15a:	4a27      	ldr	r2, [pc, #156]	; (800d1f8 <SystemInit+0xa4>)
 800d15c:	609a      	str	r2, [r3, #8]
#endif

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
 800d15e:	4b25      	ldr	r3, [pc, #148]	; (800d1f4 <SystemInit+0xa0>)
 800d160:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800d164:	4a23      	ldr	r2, [pc, #140]	; (800d1f4 <SystemInit+0xa0>)
 800d166:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800d16a:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 800d16e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d172:	681b      	ldr	r3, [r3, #0]
 800d174:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800d178:	f043 0301 	orr.w	r3, r3, #1
 800d17c:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00070000U;
 800d17e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d182:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
 800d186:	609a      	str	r2, [r3, #8]

  /* Reset PLLSAI1ON, PLLON, HSECSSON, HSEON, HSION, and MSIPLLON bits */
  RCC->CR &= (uint32_t)0xFAF6FEFBU;
 800d188:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d18c:	681a      	ldr	r2, [r3, #0]
 800d18e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800d192:	4b1a      	ldr	r3, [pc, #104]	; (800d1fc <SystemInit+0xa8>)
 800d194:	4013      	ands	r3, r2
 800d196:	600b      	str	r3, [r1, #0]

  /*!< Reset LSI1 and LSI2 bits */
  RCC->CSR &= (uint32_t)0xFFFFFFFAU;
 800d198:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d19c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800d1a0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800d1a4:	f023 0305 	bic.w	r3, r3, #5
 800d1a8:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  
  /*!< Reset HSI48ON  bit */
  RCC->CRRCR &= (uint32_t)0xFFFFFFFEU;
 800d1ac:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d1b0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800d1b4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800d1b8:	f023 0301 	bic.w	r3, r3, #1
 800d1bc:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
    
  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x22041000U;
 800d1c0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d1c4:	4a0e      	ldr	r2, [pc, #56]	; (800d200 <SystemInit+0xac>)
 800d1c6:	60da      	str	r2, [r3, #12]

#if defined(STM32WB55xx) || defined(STM32WB5Mxx)
  /* Reset PLLSAI1CFGR register */
  RCC->PLLSAI1CFGR = 0x22041000U;
 800d1c8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d1cc:	4a0c      	ldr	r2, [pc, #48]	; (800d200 <SystemInit+0xac>)
 800d1ce:	611a      	str	r2, [r3, #16]
#endif
  
  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 800d1d0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d1d4:	681b      	ldr	r3, [r3, #0]
 800d1d6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800d1da:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800d1de:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 800d1e0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800d1e4:	2200      	movs	r2, #0
 800d1e6:	619a      	str	r2, [r3, #24]
}
 800d1e8:	bf00      	nop
 800d1ea:	46bd      	mov	sp, r7
 800d1ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d1f0:	4770      	bx	lr
 800d1f2:	bf00      	nop
 800d1f4:	e000ed00 	.word	0xe000ed00
 800d1f8:	08005000 	.word	0x08005000
 800d1fc:	faf6fefb 	.word	0xfaf6fefb
 800d200:	22041000 	.word	0x22041000

0800d204 <CopyDataInit>:
  bl LoopCopyDataInit
.endm

.section  .text.data_initializers
CopyDataInit:
  ldr r4, [r2, r3]
 800d204:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800d206:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800d208:	3304      	adds	r3, #4

0800d20a <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800d20a:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800d20c:	428c      	cmp	r4, r1
  bcc  CopyDataInit
 800d20e:	d3f9      	bcc.n	800d204 <CopyDataInit>
  bx lr
 800d210:	4770      	bx	lr

0800d212 <FillZerobss>:

FillZerobss:
  str  r3, [r0]
 800d212:	6003      	str	r3, [r0, #0]
  adds r0, r0, #4
 800d214:	3004      	adds	r0, #4

0800d216 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r0, r1
 800d216:	4288      	cmp	r0, r1
  bcc FillZerobss
 800d218:	d3fb      	bcc.n	800d212 <FillZerobss>
  bx lr
 800d21a:	4770      	bx	lr

0800d21c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 800d21c:	480c      	ldr	r0, [pc, #48]	; (800d250 <LoopForever+0x4>)
  mov   sp, r0          /* set stack pointer */
 800d21e:	4685      	mov	sp, r0
/* Call the clock system intitialization function.*/
  bl  SystemInit
 800d220:	f7ff ff98 	bl	800d154 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  INIT_DATA _sdata, _edata, _sidata
 800d224:	480b      	ldr	r0, [pc, #44]	; (800d254 <LoopForever+0x8>)
 800d226:	490c      	ldr	r1, [pc, #48]	; (800d258 <LoopForever+0xc>)
 800d228:	4a0c      	ldr	r2, [pc, #48]	; (800d25c <LoopForever+0x10>)
 800d22a:	2300      	movs	r3, #0
 800d22c:	f7ff ffed 	bl	800d20a <LoopCopyDataInit>

/* Zero fill the bss segments. */
  INIT_BSS _sbss, _ebss
 800d230:	480b      	ldr	r0, [pc, #44]	; (800d260 <LoopForever+0x14>)
 800d232:	490c      	ldr	r1, [pc, #48]	; (800d264 <LoopForever+0x18>)
 800d234:	2300      	movs	r3, #0
 800d236:	f7ff ffee 	bl	800d216 <LoopFillZerobss>
  INIT_BSS _sMB_MEM2, _eMB_MEM2
 800d23a:	480b      	ldr	r0, [pc, #44]	; (800d268 <LoopForever+0x1c>)
 800d23c:	490b      	ldr	r1, [pc, #44]	; (800d26c <LoopForever+0x20>)
 800d23e:	2300      	movs	r3, #0
 800d240:	f7ff ffe9 	bl	800d216 <LoopFillZerobss>

/* Call static constructors */
  bl __libc_init_array
 800d244:	f007 fc92 	bl	8014b6c <__libc_init_array>
/* Call the application s entry point.*/
	bl	main
 800d248:	f7ff f9da 	bl	800c600 <main>

0800d24c <LoopForever>:

LoopForever:
  b LoopForever
 800d24c:	e7fe      	b.n	800d24c <LoopForever>
 800d24e:	0000      	.short	0x0000
  ldr   r0, =_estack
 800d250:	20030000 	.word	0x20030000
  INIT_DATA _sdata, _edata, _sidata
 800d254:	20000004 	.word	0x20000004
 800d258:	20000028 	.word	0x20000028
 800d25c:	080153c8 	.word	0x080153c8
  INIT_BSS _sbss, _ebss
 800d260:	200001a0 	.word	0x200001a0
 800d264:	2000550c 	.word	0x2000550c
  INIT_BSS _sMB_MEM2, _eMB_MEM2
 800d268:	200301e0 	.word	0x200301e0
 800d26c:	20030a57 	.word	0x20030a57

0800d270 <ADC1_IRQHandler>:
 * @retval None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 800d270:	e7fe      	b.n	800d270 <ADC1_IRQHandler>
	...

0800d274 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800d274:	b580      	push	{r7, lr}
 800d276:	b082      	sub	sp, #8
 800d278:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 800d27a:	2300      	movs	r3, #0
 800d27c:	71fb      	strb	r3, [r7, #7]
#if (DATA_CACHE_ENABLE == 0U)
   __HAL_FLASH_DATA_CACHE_DISABLE();
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800d27e:	4b0c      	ldr	r3, [pc, #48]	; (800d2b0 <HAL_Init+0x3c>)
 800d280:	681b      	ldr	r3, [r3, #0]
 800d282:	4a0b      	ldr	r2, [pc, #44]	; (800d2b0 <HAL_Init+0x3c>)
 800d284:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800d288:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800d28a:	2003      	movs	r0, #3
 800d28c:	f002 f832 	bl	800f2f4 <HAL_NVIC_SetPriorityGrouping>
  
  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 800d290:	2001      	movs	r0, #1
 800d292:	f000 f80f 	bl	800d2b4 <HAL_InitTick>
 800d296:	4603      	mov	r3, r0
 800d298:	2b00      	cmp	r3, #0
 800d29a:	d002      	beq.n	800d2a2 <HAL_Init+0x2e>
  {
    status = HAL_ERROR;
 800d29c:	2301      	movs	r3, #1
 800d29e:	71fb      	strb	r3, [r7, #7]
 800d2a0:	e001      	b.n	800d2a6 <HAL_Init+0x32>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 800d2a2:	f7ff fced 	bl	800cc80 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 800d2a6:	79fb      	ldrb	r3, [r7, #7]
}
 800d2a8:	4618      	mov	r0, r3
 800d2aa:	3708      	adds	r7, #8
 800d2ac:	46bd      	mov	sp, r7
 800d2ae:	bd80      	pop	{r7, pc}
 800d2b0:	58004000 	.word	0x58004000

0800d2b4 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800d2b4:	b580      	push	{r7, lr}
 800d2b6:	b084      	sub	sp, #16
 800d2b8:	af00      	add	r7, sp, #0
 800d2ba:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
 800d2bc:	2300      	movs	r3, #0
 800d2be:	73fb      	strb	r3, [r7, #15]

  if ((uint32_t)uwTickFreq != 0U)
 800d2c0:	4b17      	ldr	r3, [pc, #92]	; (800d320 <HAL_InitTick+0x6c>)
 800d2c2:	781b      	ldrb	r3, [r3, #0]
 800d2c4:	2b00      	cmp	r3, #0
 800d2c6:	d024      	beq.n	800d312 <HAL_InitTick+0x5e>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/ (1000U / (uint32_t)uwTickFreq)) == 0U)
 800d2c8:	f003 fcbe 	bl	8010c48 <HAL_RCC_GetHCLKFreq>
 800d2cc:	4602      	mov	r2, r0
 800d2ce:	4b14      	ldr	r3, [pc, #80]	; (800d320 <HAL_InitTick+0x6c>)
 800d2d0:	781b      	ldrb	r3, [r3, #0]
 800d2d2:	4619      	mov	r1, r3
 800d2d4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800d2d8:	fbb3 f3f1 	udiv	r3, r3, r1
 800d2dc:	fbb2 f3f3 	udiv	r3, r2, r3
 800d2e0:	4618      	mov	r0, r3
 800d2e2:	f002 f848 	bl	800f376 <HAL_SYSTICK_Config>
 800d2e6:	4603      	mov	r3, r0
 800d2e8:	2b00      	cmp	r3, #0
 800d2ea:	d10f      	bne.n	800d30c <HAL_InitTick+0x58>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800d2ec:	687b      	ldr	r3, [r7, #4]
 800d2ee:	2b0f      	cmp	r3, #15
 800d2f0:	d809      	bhi.n	800d306 <HAL_InitTick+0x52>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800d2f2:	2200      	movs	r2, #0
 800d2f4:	6879      	ldr	r1, [r7, #4]
 800d2f6:	f04f 30ff 	mov.w	r0, #4294967295
 800d2fa:	f002 f806 	bl	800f30a <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 800d2fe:	4a09      	ldr	r2, [pc, #36]	; (800d324 <HAL_InitTick+0x70>)
 800d300:	687b      	ldr	r3, [r7, #4]
 800d302:	6013      	str	r3, [r2, #0]
 800d304:	e007      	b.n	800d316 <HAL_InitTick+0x62>
      }
      else
      {
        status = HAL_ERROR;
 800d306:	2301      	movs	r3, #1
 800d308:	73fb      	strb	r3, [r7, #15]
 800d30a:	e004      	b.n	800d316 <HAL_InitTick+0x62>
      }
    }
    else
    {  
      status = HAL_ERROR;
 800d30c:	2301      	movs	r3, #1
 800d30e:	73fb      	strb	r3, [r7, #15]
 800d310:	e001      	b.n	800d316 <HAL_InitTick+0x62>
    }
  }
  else
  {
    status = HAL_ERROR;
 800d312:	2301      	movs	r3, #1
 800d314:	73fb      	strb	r3, [r7, #15]
  }

  /* Return function status */
  return status;
 800d316:	7bfb      	ldrb	r3, [r7, #15]
}
 800d318:	4618      	mov	r0, r3
 800d31a:	3710      	adds	r7, #16
 800d31c:	46bd      	mov	sp, r7
 800d31e:	bd80      	pop	{r7, pc}
 800d320:	2000000c 	.word	0x2000000c
 800d324:	20000008 	.word	0x20000008

0800d328 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 800d328:	b480      	push	{r7}
 800d32a:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 800d32c:	4b06      	ldr	r3, [pc, #24]	; (800d348 <HAL_IncTick+0x20>)
 800d32e:	781b      	ldrb	r3, [r3, #0]
 800d330:	461a      	mov	r2, r3
 800d332:	4b06      	ldr	r3, [pc, #24]	; (800d34c <HAL_IncTick+0x24>)
 800d334:	681b      	ldr	r3, [r3, #0]
 800d336:	4413      	add	r3, r2
 800d338:	4a04      	ldr	r2, [pc, #16]	; (800d34c <HAL_IncTick+0x24>)
 800d33a:	6013      	str	r3, [r2, #0]
}
 800d33c:	bf00      	nop
 800d33e:	46bd      	mov	sp, r7
 800d340:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d344:	4770      	bx	lr
 800d346:	bf00      	nop
 800d348:	2000000c 	.word	0x2000000c
 800d34c:	20005504 	.word	0x20005504

0800d350 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800d350:	b480      	push	{r7}
 800d352:	af00      	add	r7, sp, #0
  return uwTick;
 800d354:	4b03      	ldr	r3, [pc, #12]	; (800d364 <HAL_GetTick+0x14>)
 800d356:	681b      	ldr	r3, [r3, #0]
}
 800d358:	4618      	mov	r0, r3
 800d35a:	46bd      	mov	sp, r7
 800d35c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d360:	4770      	bx	lr
 800d362:	bf00      	nop
 800d364:	20005504 	.word	0x20005504

0800d368 <HAL_GetTickPrio>:
/**
  * @brief This function returns a tick priority.
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
 800d368:	b480      	push	{r7}
 800d36a:	af00      	add	r7, sp, #0
  return uwTickPrio;
 800d36c:	4b03      	ldr	r3, [pc, #12]	; (800d37c <HAL_GetTickPrio+0x14>)
 800d36e:	681b      	ldr	r3, [r3, #0]
}
 800d370:	4618      	mov	r0, r3
 800d372:	46bd      	mov	sp, r7
 800d374:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d378:	4770      	bx	lr
 800d37a:	bf00      	nop
 800d37c:	20000008 	.word	0x20000008

0800d380 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
  __weak void HAL_Delay(uint32_t Delay)
  {
 800d380:	b580      	push	{r7, lr}
 800d382:	b084      	sub	sp, #16
 800d384:	af00      	add	r7, sp, #0
 800d386:	6078      	str	r0, [r7, #4]
    uint32_t tickstart = HAL_GetTick();
 800d388:	f7ff ffe2 	bl	800d350 <HAL_GetTick>
 800d38c:	60b8      	str	r0, [r7, #8]
    uint32_t wait = Delay;
 800d38e:	687b      	ldr	r3, [r7, #4]
 800d390:	60fb      	str	r3, [r7, #12]
  
    /* Add a freq to guarantee minimum wait */
    if (wait < HAL_MAX_DELAY)
 800d392:	68fb      	ldr	r3, [r7, #12]
 800d394:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d398:	d005      	beq.n	800d3a6 <HAL_Delay+0x26>
    {
      wait += (uint32_t)(uwTickFreq);
 800d39a:	4b0a      	ldr	r3, [pc, #40]	; (800d3c4 <HAL_Delay+0x44>)
 800d39c:	781b      	ldrb	r3, [r3, #0]
 800d39e:	461a      	mov	r2, r3
 800d3a0:	68fb      	ldr	r3, [r7, #12]
 800d3a2:	4413      	add	r3, r2
 800d3a4:	60fb      	str	r3, [r7, #12]
    }
  
    while ((HAL_GetTick() - tickstart) < wait)
 800d3a6:	bf00      	nop
 800d3a8:	f7ff ffd2 	bl	800d350 <HAL_GetTick>
 800d3ac:	4602      	mov	r2, r0
 800d3ae:	68bb      	ldr	r3, [r7, #8]
 800d3b0:	1ad3      	subs	r3, r2, r3
 800d3b2:	68fa      	ldr	r2, [r7, #12]
 800d3b4:	429a      	cmp	r2, r3
 800d3b6:	d8f7      	bhi.n	800d3a8 <HAL_Delay+0x28>
    {
    }
  }
 800d3b8:	bf00      	nop
 800d3ba:	bf00      	nop
 800d3bc:	3710      	adds	r7, #16
 800d3be:	46bd      	mov	sp, r7
 800d3c0:	bd80      	pop	{r7, pc}
 800d3c2:	bf00      	nop
 800d3c4:	2000000c 	.word	0x2000000c

0800d3c8 <LL_ADC_SetCommonClock>:
  *
  *         (*) Value available on all STM32 devices except: STM32W10xxx, STM32W15xxx.
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonClock(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t CommonClock)
{
 800d3c8:	b480      	push	{r7}
 800d3ca:	b083      	sub	sp, #12
 800d3cc:	af00      	add	r7, sp, #0
 800d3ce:	6078      	str	r0, [r7, #4]
 800d3d0:	6039      	str	r1, [r7, #0]
#if defined (ADC_SUPPORT_2_5_MSPS)
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_PRESC, CommonClock);
#else
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 800d3d2:	687b      	ldr	r3, [r7, #4]
 800d3d4:	689b      	ldr	r3, [r3, #8]
 800d3d6:	f423 127c 	bic.w	r2, r3, #4128768	; 0x3f0000
 800d3da:	683b      	ldr	r3, [r7, #0]
 800d3dc:	431a      	orrs	r2, r3
 800d3de:	687b      	ldr	r3, [r7, #4]
 800d3e0:	609a      	str	r2, [r3, #8]
#endif
}
 800d3e2:	bf00      	nop
 800d3e4:	370c      	adds	r7, #12
 800d3e6:	46bd      	mov	sp, r7
 800d3e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d3ec:	4770      	bx	lr

0800d3ee <LL_ADC_SetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal)
{
 800d3ee:	b480      	push	{r7}
 800d3f0:	b083      	sub	sp, #12
 800d3f2:	af00      	add	r7, sp, #0
 800d3f4:	6078      	str	r0, [r7, #4]
 800d3f6:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 800d3f8:	687b      	ldr	r3, [r7, #4]
 800d3fa:	689b      	ldr	r3, [r3, #8]
 800d3fc:	f023 72e0 	bic.w	r2, r3, #29360128	; 0x1c00000
 800d400:	683b      	ldr	r3, [r7, #0]
 800d402:	431a      	orrs	r2, r3
 800d404:	687b      	ldr	r3, [r7, #4]
 800d406:	609a      	str	r2, [r3, #8]
}
 800d408:	bf00      	nop
 800d40a:	370c      	adds	r7, #12
 800d40c:	46bd      	mov	sp, r7
 800d40e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d412:	4770      	bx	lr

0800d414 <LL_ADC_GetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  */
__STATIC_INLINE uint32_t LL_ADC_GetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON)
{
 800d414:	b480      	push	{r7}
 800d416:	b083      	sub	sp, #12
 800d418:	af00      	add	r7, sp, #0
 800d41a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 800d41c:	687b      	ldr	r3, [r7, #4]
 800d41e:	689b      	ldr	r3, [r3, #8]
 800d420:	f003 73e0 	and.w	r3, r3, #29360128	; 0x1c00000
}
 800d424:	4618      	mov	r0, r3
 800d426:	370c      	adds	r7, #12
 800d428:	46bd      	mov	sp, r7
 800d42a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d42e:	4770      	bx	lr

0800d430 <LL_ADC_SetOffset>:
  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
  * @param  OffsetLevel Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffset(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t Channel, uint32_t OffsetLevel)
{
 800d430:	b480      	push	{r7}
 800d432:	b087      	sub	sp, #28
 800d434:	af00      	add	r7, sp, #0
 800d436:	60f8      	str	r0, [r7, #12]
 800d438:	60b9      	str	r1, [r7, #8]
 800d43a:	607a      	str	r2, [r7, #4]
 800d43c:	603b      	str	r3, [r7, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800d43e:	68fb      	ldr	r3, [r7, #12]
 800d440:	3360      	adds	r3, #96	; 0x60
 800d442:	461a      	mov	r2, r3
 800d444:	68bb      	ldr	r3, [r7, #8]
 800d446:	009b      	lsls	r3, r3, #2
 800d448:	4413      	add	r3, r2
 800d44a:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 800d44c:	697b      	ldr	r3, [r7, #20]
 800d44e:	681a      	ldr	r2, [r3, #0]
 800d450:	4b08      	ldr	r3, [pc, #32]	; (800d474 <LL_ADC_SetOffset+0x44>)
 800d452:	4013      	ands	r3, r2
 800d454:	687a      	ldr	r2, [r7, #4]
 800d456:	f002 41f8 	and.w	r1, r2, #2080374784	; 0x7c000000
 800d45a:	683a      	ldr	r2, [r7, #0]
 800d45c:	430a      	orrs	r2, r1
 800d45e:	4313      	orrs	r3, r2
 800d460:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 800d464:	697b      	ldr	r3, [r7, #20]
 800d466:	601a      	str	r2, [r3, #0]
             ADC_OFR1_OFFSET1_EN | ADC_OFR1_OFFSET1_CH | ADC_OFR1_OFFSET1,
             ADC_OFR1_OFFSET1_EN | (Channel & ADC_CHANNEL_ID_NUMBER_MASK) | OffsetLevel);
}
 800d468:	bf00      	nop
 800d46a:	371c      	adds	r7, #28
 800d46c:	46bd      	mov	sp, r7
 800d46e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d472:	4770      	bx	lr
 800d474:	03fff000 	.word	0x03fff000

0800d478 <LL_ADC_GetOffsetChannel>:
  *         (4) For ADC channel read back from ADC register,
  *             comparison with internal channel parameter to be done
  *             using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
  */
__STATIC_INLINE uint32_t LL_ADC_GetOffsetChannel(ADC_TypeDef *ADCx, uint32_t Offsety)
{
 800d478:	b480      	push	{r7}
 800d47a:	b085      	sub	sp, #20
 800d47c:	af00      	add	r7, sp, #0
 800d47e:	6078      	str	r0, [r7, #4]
 800d480:	6039      	str	r1, [r7, #0]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800d482:	687b      	ldr	r3, [r7, #4]
 800d484:	3360      	adds	r3, #96	; 0x60
 800d486:	461a      	mov	r2, r3
 800d488:	683b      	ldr	r3, [r7, #0]
 800d48a:	009b      	lsls	r3, r3, #2
 800d48c:	4413      	add	r3, r2
 800d48e:	60fb      	str	r3, [r7, #12]

  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800d490:	68fb      	ldr	r3, [r7, #12]
 800d492:	681b      	ldr	r3, [r3, #0]
 800d494:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
}
 800d498:	4618      	mov	r0, r3
 800d49a:	3714      	adds	r7, #20
 800d49c:	46bd      	mov	sp, r7
 800d49e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d4a2:	4770      	bx	lr

0800d4a4 <LL_ADC_SetOffsetState>:
  *         @arg @ref LL_ADC_OFFSET_DISABLE
  *         @arg @ref LL_ADC_OFFSET_ENABLE
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetState(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetState)
{
 800d4a4:	b480      	push	{r7}
 800d4a6:	b087      	sub	sp, #28
 800d4a8:	af00      	add	r7, sp, #0
 800d4aa:	60f8      	str	r0, [r7, #12]
 800d4ac:	60b9      	str	r1, [r7, #8]
 800d4ae:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800d4b0:	68fb      	ldr	r3, [r7, #12]
 800d4b2:	3360      	adds	r3, #96	; 0x60
 800d4b4:	461a      	mov	r2, r3
 800d4b6:	68bb      	ldr	r3, [r7, #8]
 800d4b8:	009b      	lsls	r3, r3, #2
 800d4ba:	4413      	add	r3, r2
 800d4bc:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 800d4be:	697b      	ldr	r3, [r7, #20]
 800d4c0:	681b      	ldr	r3, [r3, #0]
 800d4c2:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 800d4c6:	687b      	ldr	r3, [r7, #4]
 800d4c8:	431a      	orrs	r2, r3
 800d4ca:	697b      	ldr	r3, [r7, #20]
 800d4cc:	601a      	str	r2, [r3, #0]
             ADC_OFR1_OFFSET1_EN,
             OffsetState);
}
 800d4ce:	bf00      	nop
 800d4d0:	371c      	adds	r7, #28
 800d4d2:	46bd      	mov	sp, r7
 800d4d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d4d8:	4770      	bx	lr

0800d4da <LL_ADC_REG_SetSequencerRanks>:
  *         (7) On STM32WB devices (except devices: STM32WB10xx, STM32WB15xx) fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)
{
 800d4da:	b480      	push	{r7}
 800d4dc:	b087      	sub	sp, #28
 800d4de:	af00      	add	r7, sp, #0
 800d4e0:	60f8      	str	r0, [r7, #12]
 800d4e2:	60b9      	str	r1, [r7, #8]
 800d4e4:	607a      	str	r2, [r7, #4]
#else
  /* Set bits with content of parameter "Channel" with bits position          */
  /* in register and register position depending on parameter "Rank".         */
  /* Parameters "Rank" and "Channel" are used with masks because containing   */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 800d4e6:	68fb      	ldr	r3, [r7, #12]
 800d4e8:	3330      	adds	r3, #48	; 0x30
 800d4ea:	461a      	mov	r2, r3
 800d4ec:	68bb      	ldr	r3, [r7, #8]
 800d4ee:	0a1b      	lsrs	r3, r3, #8
 800d4f0:	009b      	lsls	r3, r3, #2
 800d4f2:	f003 030c 	and.w	r3, r3, #12
 800d4f6:	4413      	add	r3, r2
 800d4f8:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 800d4fa:	697b      	ldr	r3, [r7, #20]
 800d4fc:	681a      	ldr	r2, [r3, #0]
 800d4fe:	68bb      	ldr	r3, [r7, #8]
 800d500:	f003 031f 	and.w	r3, r3, #31
 800d504:	211f      	movs	r1, #31
 800d506:	fa01 f303 	lsl.w	r3, r1, r3
 800d50a:	43db      	mvns	r3, r3
 800d50c:	401a      	ands	r2, r3
 800d50e:	687b      	ldr	r3, [r7, #4]
 800d510:	0e9b      	lsrs	r3, r3, #26
 800d512:	f003 011f 	and.w	r1, r3, #31
 800d516:	68bb      	ldr	r3, [r7, #8]
 800d518:	f003 031f 	and.w	r3, r3, #31
 800d51c:	fa01 f303 	lsl.w	r3, r1, r3
 800d520:	431a      	orrs	r2, r3
 800d522:	697b      	ldr	r3, [r7, #20]
 800d524:	601a      	str	r2, [r3, #0]
             ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 << (Rank & ADC_REG_RANK_ID_SQRX_MASK),
             ((Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << (Rank & ADC_REG_RANK_ID_SQRX_MASK));
#endif
}
 800d526:	bf00      	nop
 800d528:	371c      	adds	r7, #28
 800d52a:	46bd      	mov	sp, r7
 800d52c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d530:	4770      	bx	lr

0800d532 <LL_ADC_SetChannelSamplingTime>:
  *         @arg @ref LL_ADC_SAMPLINGTIME_247CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_640CYCLES_5
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
{
 800d532:	b480      	push	{r7}
 800d534:	b087      	sub	sp, #28
 800d536:	af00      	add	r7, sp, #0
 800d538:	60f8      	str	r0, [r7, #12]
 800d53a:	60b9      	str	r1, [r7, #8]
 800d53c:	607a      	str	r2, [r7, #4]
#else
  /* Set bits with content of parameter "SamplingTime" with bits position     */
  /* in register and register position depending on parameter "Channel".      */
  /* Parameter "Channel" is used with masks because containing                */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 800d53e:	68fb      	ldr	r3, [r7, #12]
 800d540:	3314      	adds	r3, #20
 800d542:	461a      	mov	r2, r3
 800d544:	68bb      	ldr	r3, [r7, #8]
 800d546:	0e5b      	lsrs	r3, r3, #25
 800d548:	009b      	lsls	r3, r3, #2
 800d54a:	f003 0304 	and.w	r3, r3, #4
 800d54e:	4413      	add	r3, r2
 800d550:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 800d552:	697b      	ldr	r3, [r7, #20]
 800d554:	681a      	ldr	r2, [r3, #0]
 800d556:	68bb      	ldr	r3, [r7, #8]
 800d558:	0d1b      	lsrs	r3, r3, #20
 800d55a:	f003 031f 	and.w	r3, r3, #31
 800d55e:	2107      	movs	r1, #7
 800d560:	fa01 f303 	lsl.w	r3, r1, r3
 800d564:	43db      	mvns	r3, r3
 800d566:	401a      	ands	r2, r3
 800d568:	68bb      	ldr	r3, [r7, #8]
 800d56a:	0d1b      	lsrs	r3, r3, #20
 800d56c:	f003 031f 	and.w	r3, r3, #31
 800d570:	6879      	ldr	r1, [r7, #4]
 800d572:	fa01 f303 	lsl.w	r3, r1, r3
 800d576:	431a      	orrs	r2, r3
 800d578:	697b      	ldr	r3, [r7, #20]
 800d57a:	601a      	str	r2, [r3, #0]
             ADC_SMPR1_SMP0 << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS),
             SamplingTime   << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS));
#endif
}
 800d57c:	bf00      	nop
 800d57e:	371c      	adds	r7, #28
 800d580:	46bd      	mov	sp, r7
 800d582:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d586:	4770      	bx	lr

0800d588 <LL_ADC_SetChannelSingleDiff>:
  *         @arg @ref LL_ADC_SINGLE_ENDED
  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSingleDiff(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SingleDiff)
{
 800d588:	b480      	push	{r7}
 800d58a:	b085      	sub	sp, #20
 800d58c:	af00      	add	r7, sp, #0
 800d58e:	60f8      	str	r0, [r7, #12]
 800d590:	60b9      	str	r1, [r7, #8]
 800d592:	607a      	str	r2, [r7, #4]
  /* Bits of channels in single or differential mode are set only for         */
  /* differential mode (for single mode, mask of bits allowed to be set is    */
  /* shifted out of range of bits of channels in single or differential mode. */
  MODIFY_REG(ADCx->DIFSEL,
 800d594:	68fb      	ldr	r3, [r7, #12]
 800d596:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
 800d59a:	68bb      	ldr	r3, [r7, #8]
 800d59c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d5a0:	43db      	mvns	r3, r3
 800d5a2:	401a      	ands	r2, r3
 800d5a4:	687b      	ldr	r3, [r7, #4]
 800d5a6:	f003 0318 	and.w	r3, r3, #24
 800d5aa:	4908      	ldr	r1, [pc, #32]	; (800d5cc <LL_ADC_SetChannelSingleDiff+0x44>)
 800d5ac:	40d9      	lsrs	r1, r3
 800d5ae:	68bb      	ldr	r3, [r7, #8]
 800d5b0:	400b      	ands	r3, r1
 800d5b2:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800d5b6:	431a      	orrs	r2, r3
 800d5b8:	68fb      	ldr	r3, [r7, #12]
 800d5ba:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
             Channel & ADC_SINGLEDIFF_CHANNEL_MASK,
             (Channel & ADC_SINGLEDIFF_CHANNEL_MASK) & (ADC_DIFSEL_DIFSEL >> (SingleDiff & ADC_SINGLEDIFF_CHANNEL_SHIFT_MASK)));
}
 800d5be:	bf00      	nop
 800d5c0:	3714      	adds	r7, #20
 800d5c2:	46bd      	mov	sp, r7
 800d5c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d5c8:	4770      	bx	lr
 800d5ca:	bf00      	nop
 800d5cc:	0007ffff 	.word	0x0007ffff

0800d5d0 <LL_ADC_DisableDeepPowerDown>:
  * @rmtoll CR       DEEPPWD        LL_ADC_DisableDeepPowerDown
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableDeepPowerDown(ADC_TypeDef *ADCx)
{
 800d5d0:	b480      	push	{r7}
 800d5d2:	b083      	sub	sp, #12
 800d5d4:	af00      	add	r7, sp, #0
 800d5d6:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 800d5d8:	687b      	ldr	r3, [r7, #4]
 800d5da:	689b      	ldr	r3, [r3, #8]
 800d5dc:	f023 4320 	bic.w	r3, r3, #2684354560	; 0xa0000000
 800d5e0:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800d5e4:	687a      	ldr	r2, [r7, #4]
 800d5e6:	6093      	str	r3, [r2, #8]
}
 800d5e8:	bf00      	nop
 800d5ea:	370c      	adds	r7, #12
 800d5ec:	46bd      	mov	sp, r7
 800d5ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d5f2:	4770      	bx	lr

0800d5f4 <LL_ADC_IsDeepPowerDownEnabled>:
  * @rmtoll CR       DEEPPWD        LL_ADC_IsDeepPowerDownEnabled
  * @param  ADCx ADC instance
  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(ADC_TypeDef *ADCx)
{
 800d5f4:	b480      	push	{r7}
 800d5f6:	b083      	sub	sp, #12
 800d5f8:	af00      	add	r7, sp, #0
 800d5fa:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 800d5fc:	687b      	ldr	r3, [r7, #4]
 800d5fe:	689b      	ldr	r3, [r3, #8]
 800d600:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800d604:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800d608:	d101      	bne.n	800d60e <LL_ADC_IsDeepPowerDownEnabled+0x1a>
 800d60a:	2301      	movs	r3, #1
 800d60c:	e000      	b.n	800d610 <LL_ADC_IsDeepPowerDownEnabled+0x1c>
 800d60e:	2300      	movs	r3, #0
}
 800d610:	4618      	mov	r0, r3
 800d612:	370c      	adds	r7, #12
 800d614:	46bd      	mov	sp, r7
 800d616:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d61a:	4770      	bx	lr

0800d61c <LL_ADC_EnableInternalRegulator>:
  * @rmtoll CR       ADVREGEN       LL_ADC_EnableInternalRegulator
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableInternalRegulator(ADC_TypeDef *ADCx)
{
 800d61c:	b480      	push	{r7}
 800d61e:	b083      	sub	sp, #12
 800d620:	af00      	add	r7, sp, #0
 800d622:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
 800d624:	687b      	ldr	r3, [r7, #4]
 800d626:	689b      	ldr	r3, [r3, #8]
 800d628:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 800d62c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800d630:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
 800d634:	687b      	ldr	r3, [r7, #4]
 800d636:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADVREGEN);
}
 800d638:	bf00      	nop
 800d63a:	370c      	adds	r7, #12
 800d63c:	46bd      	mov	sp, r7
 800d63e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d642:	4770      	bx	lr

0800d644 <LL_ADC_IsInternalRegulatorEnabled>:
  * @rmtoll CR       ADVREGEN       LL_ADC_IsInternalRegulatorEnabled
  * @param  ADCx ADC instance
  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(ADC_TypeDef *ADCx)
{
 800d644:	b480      	push	{r7}
 800d646:	b083      	sub	sp, #12
 800d648:	af00      	add	r7, sp, #0
 800d64a:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 800d64c:	687b      	ldr	r3, [r7, #4]
 800d64e:	689b      	ldr	r3, [r3, #8]
 800d650:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800d654:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800d658:	d101      	bne.n	800d65e <LL_ADC_IsInternalRegulatorEnabled+0x1a>
 800d65a:	2301      	movs	r3, #1
 800d65c:	e000      	b.n	800d660 <LL_ADC_IsInternalRegulatorEnabled+0x1c>
 800d65e:	2300      	movs	r3, #0
}
 800d660:	4618      	mov	r0, r3
 800d662:	370c      	adds	r7, #12
 800d664:	46bd      	mov	sp, r7
 800d666:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d66a:	4770      	bx	lr

0800d66c <LL_ADC_IsEnabled>:
  * @rmtoll CR       ADEN           LL_ADC_IsEnabled
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(ADC_TypeDef *ADCx)
{
 800d66c:	b480      	push	{r7}
 800d66e:	b083      	sub	sp, #12
 800d670:	af00      	add	r7, sp, #0
 800d672:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 800d674:	687b      	ldr	r3, [r7, #4]
 800d676:	689b      	ldr	r3, [r3, #8]
 800d678:	f003 0301 	and.w	r3, r3, #1
 800d67c:	2b01      	cmp	r3, #1
 800d67e:	d101      	bne.n	800d684 <LL_ADC_IsEnabled+0x18>
 800d680:	2301      	movs	r3, #1
 800d682:	e000      	b.n	800d686 <LL_ADC_IsEnabled+0x1a>
 800d684:	2300      	movs	r3, #0
}
 800d686:	4618      	mov	r0, r3
 800d688:	370c      	adds	r7, #12
 800d68a:	46bd      	mov	sp, r7
 800d68c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d690:	4770      	bx	lr

0800d692 <LL_ADC_REG_IsConversionOngoing>:
  * @rmtoll CR       ADSTART        LL_ADC_REG_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
 800d692:	b480      	push	{r7}
 800d694:	b083      	sub	sp, #12
 800d696:	af00      	add	r7, sp, #0
 800d698:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 800d69a:	687b      	ldr	r3, [r7, #4]
 800d69c:	689b      	ldr	r3, [r3, #8]
 800d69e:	f003 0304 	and.w	r3, r3, #4
 800d6a2:	2b04      	cmp	r3, #4
 800d6a4:	d101      	bne.n	800d6aa <LL_ADC_REG_IsConversionOngoing+0x18>
 800d6a6:	2301      	movs	r3, #1
 800d6a8:	e000      	b.n	800d6ac <LL_ADC_REG_IsConversionOngoing+0x1a>
 800d6aa:	2300      	movs	r3, #0
}
 800d6ac:	4618      	mov	r0, r3
 800d6ae:	370c      	adds	r7, #12
 800d6b0:	46bd      	mov	sp, r7
 800d6b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d6b6:	4770      	bx	lr

0800d6b8 <LL_ADC_INJ_IsConversionOngoing>:
  * @rmtoll CR       JADSTART       LL_ADC_INJ_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
{
 800d6b8:	b480      	push	{r7}
 800d6ba:	b083      	sub	sp, #12
 800d6bc:	af00      	add	r7, sp, #0
 800d6be:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 800d6c0:	687b      	ldr	r3, [r7, #4]
 800d6c2:	689b      	ldr	r3, [r3, #8]
 800d6c4:	f003 0308 	and.w	r3, r3, #8
 800d6c8:	2b08      	cmp	r3, #8
 800d6ca:	d101      	bne.n	800d6d0 <LL_ADC_INJ_IsConversionOngoing+0x18>
 800d6cc:	2301      	movs	r3, #1
 800d6ce:	e000      	b.n	800d6d2 <LL_ADC_INJ_IsConversionOngoing+0x1a>
 800d6d0:	2300      	movs	r3, #0
}
 800d6d2:	4618      	mov	r0, r3
 800d6d4:	370c      	adds	r7, #12
 800d6d6:	46bd      	mov	sp, r7
 800d6d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d6dc:	4770      	bx	lr
	...

0800d6e0 <HAL_ADC_Init>:
  *         of structure "ADC_InitTypeDef".
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 800d6e0:	b580      	push	{r7, lr}
 800d6e2:	b088      	sub	sp, #32
 800d6e4:	af00      	add	r7, sp, #0
 800d6e6:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800d6e8:	2300      	movs	r3, #0
 800d6ea:	77fb      	strb	r3, [r7, #31]
  uint32_t tmpCFGR = 0UL;
 800d6ec:	2300      	movs	r3, #0
 800d6ee:	61bb      	str	r3, [r7, #24]
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 800d6f0:	2300      	movs	r3, #0
 800d6f2:	60bb      	str	r3, [r7, #8]
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;
#endif

  /* Check ADC handle */
  if (hadc == NULL)
 800d6f4:	687b      	ldr	r3, [r7, #4]
 800d6f6:	2b00      	cmp	r3, #0
 800d6f8:	d101      	bne.n	800d6fe <HAL_ADC_Init+0x1e>
  {
    return HAL_ERROR;
 800d6fa:	2301      	movs	r3, #1
 800d6fc:	e12c      	b.n	800d958 <HAL_ADC_Init+0x278>
    }
  }
#else
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));

  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 800d6fe:	687b      	ldr	r3, [r7, #4]
 800d700:	691b      	ldr	r3, [r3, #16]
 800d702:	2b00      	cmp	r3, #0
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
#endif /* ADC_SUPPORT_2_5_MSPS */

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 800d704:	687b      	ldr	r3, [r7, #4]
 800d706:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800d708:	2b00      	cmp	r3, #0
 800d70a:	d109      	bne.n	800d720 <HAL_ADC_Init+0x40>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 800d70c:	6878      	ldr	r0, [r7, #4]
 800d70e:	f7ff fad9 	bl	800ccc4 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 800d712:	687b      	ldr	r3, [r7, #4]
 800d714:	2200      	movs	r2, #0
 800d716:	659a      	str	r2, [r3, #88]	; 0x58

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 800d718:	687b      	ldr	r3, [r7, #4]
 800d71a:	2200      	movs	r2, #0
 800d71c:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* - Exit from deep power-down mode and ADC voltage regulator enable        */
#if defined (ADC_SUPPORT_2_5_MSPS)
  /* Feature "deep power-down" not available on ADC peripheral of this STM32WB device */
#else
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 800d720:	687b      	ldr	r3, [r7, #4]
 800d722:	681b      	ldr	r3, [r3, #0]
 800d724:	4618      	mov	r0, r3
 800d726:	f7ff ff65 	bl	800d5f4 <LL_ADC_IsDeepPowerDownEnabled>
 800d72a:	4603      	mov	r3, r0
 800d72c:	2b00      	cmp	r3, #0
 800d72e:	d004      	beq.n	800d73a <HAL_ADC_Init+0x5a>
  {
    /* Disable ADC deep power down mode */
    LL_ADC_DisableDeepPowerDown(hadc->Instance);
 800d730:	687b      	ldr	r3, [r7, #4]
 800d732:	681b      	ldr	r3, [r3, #0]
 800d734:	4618      	mov	r0, r3
 800d736:	f7ff ff4b 	bl	800d5d0 <LL_ADC_DisableDeepPowerDown>
     be relaunched or a previously saved calibration factor
     re-applied once the ADC voltage regulator is enabled */
  }
#endif

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 800d73a:	687b      	ldr	r3, [r7, #4]
 800d73c:	681b      	ldr	r3, [r3, #0]
 800d73e:	4618      	mov	r0, r3
 800d740:	f7ff ff80 	bl	800d644 <LL_ADC_IsInternalRegulatorEnabled>
 800d744:	4603      	mov	r3, r0
 800d746:	2b00      	cmp	r3, #0
 800d748:	d113      	bne.n	800d772 <HAL_ADC_Init+0x92>
  {
    /* Enable ADC internal voltage regulator */
    LL_ADC_EnableInternalRegulator(hadc->Instance);
 800d74a:	687b      	ldr	r3, [r7, #4]
 800d74c:	681b      	ldr	r3, [r3, #0]
 800d74e:	4618      	mov	r0, r3
 800d750:	f7ff ff64 	bl	800d61c <LL_ADC_EnableInternalRegulator>

    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 800d754:	4b82      	ldr	r3, [pc, #520]	; (800d960 <HAL_ADC_Init+0x280>)
 800d756:	681b      	ldr	r3, [r3, #0]
 800d758:	099b      	lsrs	r3, r3, #6
 800d75a:	4a82      	ldr	r2, [pc, #520]	; (800d964 <HAL_ADC_Init+0x284>)
 800d75c:	fba2 2303 	umull	r2, r3, r2, r3
 800d760:	099b      	lsrs	r3, r3, #6
 800d762:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 800d764:	e002      	b.n	800d76c <HAL_ADC_Init+0x8c>
    {
      wait_loop_index--;
 800d766:	68bb      	ldr	r3, [r7, #8]
 800d768:	3b01      	subs	r3, #1
 800d76a:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 800d76c:	68bb      	ldr	r3, [r7, #8]
 800d76e:	2b00      	cmp	r3, #0
 800d770:	d1f9      	bne.n	800d766 <HAL_ADC_Init+0x86>
  }

  /* Verification that ADC voltage regulator is correctly enabled, whether    */
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 800d772:	687b      	ldr	r3, [r7, #4]
 800d774:	681b      	ldr	r3, [r3, #0]
 800d776:	4618      	mov	r0, r3
 800d778:	f7ff ff64 	bl	800d644 <LL_ADC_IsInternalRegulatorEnabled>
 800d77c:	4603      	mov	r3, r0
 800d77e:	2b00      	cmp	r3, #0
 800d780:	d10d      	bne.n	800d79e <HAL_ADC_Init+0xbe>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800d782:	687b      	ldr	r3, [r7, #4]
 800d784:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800d786:	f043 0210 	orr.w	r2, r3, #16
 800d78a:	687b      	ldr	r3, [r7, #4]
 800d78c:	655a      	str	r2, [r3, #84]	; 0x54

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800d78e:	687b      	ldr	r3, [r7, #4]
 800d790:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800d792:	f043 0201 	orr.w	r2, r3, #1
 800d796:	687b      	ldr	r3, [r7, #4]
 800d798:	659a      	str	r2, [r3, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
 800d79a:	2301      	movs	r3, #1
 800d79c:	77fb      	strb	r3, [r7, #31]

  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 800d79e:	687b      	ldr	r3, [r7, #4]
 800d7a0:	681b      	ldr	r3, [r3, #0]
 800d7a2:	4618      	mov	r0, r3
 800d7a4:	f7ff ff75 	bl	800d692 <LL_ADC_REG_IsConversionOngoing>
 800d7a8:	6178      	str	r0, [r7, #20]

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 800d7aa:	687b      	ldr	r3, [r7, #4]
 800d7ac:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800d7ae:	f003 0310 	and.w	r3, r3, #16
 800d7b2:	2b00      	cmp	r3, #0
 800d7b4:	f040 80c7 	bne.w	800d946 <HAL_ADC_Init+0x266>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
 800d7b8:	697b      	ldr	r3, [r7, #20]
 800d7ba:	2b00      	cmp	r3, #0
 800d7bc:	f040 80c3 	bne.w	800d946 <HAL_ADC_Init+0x266>
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 800d7c0:	687b      	ldr	r3, [r7, #4]
 800d7c2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800d7c4:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 800d7c8:	f043 0202 	orr.w	r2, r3, #2
 800d7cc:	687b      	ldr	r3, [r7, #4]
 800d7ce:	655a      	str	r2, [r3, #84]	; 0x54
    /* Configuration of common ADC parameters                                 */

    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - clock configuration                                                 */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 800d7d0:	687b      	ldr	r3, [r7, #4]
 800d7d2:	681b      	ldr	r3, [r3, #0]
 800d7d4:	4618      	mov	r0, r3
 800d7d6:	f7ff ff49 	bl	800d66c <LL_ADC_IsEnabled>
 800d7da:	4603      	mov	r3, r0
 800d7dc:	2b00      	cmp	r3, #0
 800d7de:	d10b      	bne.n	800d7f8 <HAL_ADC_Init+0x118>
    {
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 800d7e0:	4861      	ldr	r0, [pc, #388]	; (800d968 <HAL_ADC_Init+0x288>)
 800d7e2:	f7ff ff43 	bl	800d66c <LL_ADC_IsEnabled>
 800d7e6:	4603      	mov	r3, r0
 800d7e8:	2b00      	cmp	r3, #0
 800d7ea:	d105      	bne.n	800d7f8 <HAL_ADC_Init+0x118>
        /*     parameters: MDMA, DMACFG, DELAY, DUAL (set by API                */
        /*     HAL_ADCEx_MultiModeConfigChannel() )                             */
        /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
        /*     (set into HAL_ADC_ConfigChannel() or                             */
        /*     HAL_ADCEx_InjectedConfigChannel() )                              */
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 800d7ec:	687b      	ldr	r3, [r7, #4]
 800d7ee:	685b      	ldr	r3, [r3, #4]
 800d7f0:	4619      	mov	r1, r3
 800d7f2:	485e      	ldr	r0, [pc, #376]	; (800d96c <HAL_ADC_Init+0x28c>)
 800d7f4:	f7ff fde8 	bl	800d3c8 <LL_ADC_SetCommonClock>
    /*  - external trigger polarity                Init.ExternalTrigConvEdge  */
    /*  - continuous conversion mode               Init.ContinuousConvMode    */
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
    tmpCFGR |= (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 800d7f8:	687b      	ldr	r3, [r7, #4]
 800d7fa:	7e5b      	ldrb	r3, [r3, #25]
 800d7fc:	035a      	lsls	r2, r3, #13
                hadc->Init.Overrun                                                     |
 800d7fe:	687b      	ldr	r3, [r7, #4]
 800d800:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    tmpCFGR |= (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 800d802:	431a      	orrs	r2, r3
                hadc->Init.DataAlign                                                   |
 800d804:	687b      	ldr	r3, [r7, #4]
 800d806:	68db      	ldr	r3, [r3, #12]
                hadc->Init.Overrun                                                     |
 800d808:	431a      	orrs	r2, r3
                hadc->Init.Resolution                                                  |
 800d80a:	687b      	ldr	r3, [r7, #4]
 800d80c:	689b      	ldr	r3, [r3, #8]
                hadc->Init.DataAlign                                                   |
 800d80e:	431a      	orrs	r2, r3
                ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 800d810:	687b      	ldr	r3, [r7, #4]
 800d812:	f893 3020 	ldrb.w	r3, [r3, #32]
 800d816:	041b      	lsls	r3, r3, #16
                hadc->Init.Resolution                                                  |
 800d818:	4313      	orrs	r3, r2
    tmpCFGR |= (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 800d81a:	69ba      	ldr	r2, [r7, #24]
 800d81c:	4313      	orrs	r3, r2
 800d81e:	61bb      	str	r3, [r7, #24]

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 800d820:	687b      	ldr	r3, [r7, #4]
 800d822:	f893 3020 	ldrb.w	r3, [r3, #32]
 800d826:	2b01      	cmp	r3, #1
 800d828:	d106      	bne.n	800d838 <HAL_ADC_Init+0x158>
    {
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 800d82a:	687b      	ldr	r3, [r7, #4]
 800d82c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d82e:	3b01      	subs	r3, #1
 800d830:	045b      	lsls	r3, r3, #17
 800d832:	69ba      	ldr	r2, [r7, #24]
 800d834:	4313      	orrs	r3, r2
 800d836:	61bb      	str	r3, [r7, #24]
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 800d838:	687b      	ldr	r3, [r7, #4]
 800d83a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d83c:	2b00      	cmp	r3, #0
 800d83e:	d009      	beq.n	800d854 <HAL_ADC_Init+0x174>
    {
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 800d840:	687b      	ldr	r3, [r7, #4]
 800d842:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d844:	f403 7270 	and.w	r2, r3, #960	; 0x3c0
                  | hadc->Init.ExternalTrigConvEdge
 800d848:	687b      	ldr	r3, [r7, #4]
 800d84a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d84c:	4313      	orrs	r3, r2
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 800d84e:	69ba      	ldr	r2, [r7, #24]
 800d850:	4313      	orrs	r3, r2
 800d852:	61bb      	str	r3, [r7, #24]
                 );
    }

    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
 800d854:	687b      	ldr	r3, [r7, #4]
 800d856:	681b      	ldr	r3, [r3, #0]
 800d858:	68da      	ldr	r2, [r3, #12]
 800d85a:	4b45      	ldr	r3, [pc, #276]	; (800d970 <HAL_ADC_Init+0x290>)
 800d85c:	4013      	ands	r3, r2
 800d85e:	687a      	ldr	r2, [r7, #4]
 800d860:	6812      	ldr	r2, [r2, #0]
 800d862:	69b9      	ldr	r1, [r7, #24]
 800d864:	430b      	orrs	r3, r1
 800d866:	60d3      	str	r3, [r2, #12]
    /* Parameters that can be updated when ADC is disabled or enabled without */
    /* conversion on going on regular and injected groups:                    */
    /*  - DMA continuous request          Init.DMAContinuousRequests          */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 800d868:	687b      	ldr	r3, [r7, #4]
 800d86a:	681b      	ldr	r3, [r3, #0]
 800d86c:	4618      	mov	r0, r3
 800d86e:	f7ff ff10 	bl	800d692 <LL_ADC_REG_IsConversionOngoing>
 800d872:	6138      	str	r0, [r7, #16]
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 800d874:	687b      	ldr	r3, [r7, #4]
 800d876:	681b      	ldr	r3, [r3, #0]
 800d878:	4618      	mov	r0, r3
 800d87a:	f7ff ff1d 	bl	800d6b8 <LL_ADC_INJ_IsConversionOngoing>
 800d87e:	60f8      	str	r0, [r7, #12]
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 800d880:	693b      	ldr	r3, [r7, #16]
 800d882:	2b00      	cmp	r3, #0
 800d884:	d13d      	bne.n	800d902 <HAL_ADC_Init+0x222>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 800d886:	68fb      	ldr	r3, [r7, #12]
 800d888:	2b00      	cmp	r3, #0
 800d88a:	d13a      	bne.n	800d902 <HAL_ADC_Init+0x222>
       )
    {
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
                 ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 800d88c:	687b      	ldr	r3, [r7, #4]
 800d88e:	7e1b      	ldrb	r3, [r3, #24]
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 800d890:	039a      	lsls	r2, r3, #14
                 ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 800d892:	687b      	ldr	r3, [r7, #4]
 800d894:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800d898:	005b      	lsls	r3, r3, #1
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 800d89a:	4313      	orrs	r3, r2
 800d89c:	61bb      	str	r3, [r7, #24]

      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 800d89e:	687b      	ldr	r3, [r7, #4]
 800d8a0:	681b      	ldr	r3, [r3, #0]
 800d8a2:	68db      	ldr	r3, [r3, #12]
 800d8a4:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800d8a8:	f023 0302 	bic.w	r3, r3, #2
 800d8ac:	687a      	ldr	r2, [r7, #4]
 800d8ae:	6812      	ldr	r2, [r2, #0]
 800d8b0:	69b9      	ldr	r1, [r7, #24]
 800d8b2:	430b      	orrs	r3, r1
 800d8b4:	60d3      	str	r3, [r2, #12]

      if (hadc->Init.OversamplingMode == ENABLE)
 800d8b6:	687b      	ldr	r3, [r7, #4]
 800d8b8:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 800d8bc:	2b01      	cmp	r3, #1
 800d8be:	d118      	bne.n	800d8f2 <HAL_ADC_Init+0x212>
        /* Configuration of Oversampler:                                      */
        /*  - Oversampling Ratio                                              */
        /*  - Right bit shift                                                 */
        /*  - Triggered mode                                                  */
        /*  - Oversampling mode (continued/resumed)                           */
        MODIFY_REG(hadc->Instance->CFGR2,
 800d8c0:	687b      	ldr	r3, [r7, #4]
 800d8c2:	681b      	ldr	r3, [r3, #0]
 800d8c4:	691b      	ldr	r3, [r3, #16]
 800d8c6:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 800d8ca:	f023 0304 	bic.w	r3, r3, #4
 800d8ce:	687a      	ldr	r2, [r7, #4]
 800d8d0:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
 800d8d2:	687a      	ldr	r2, [r7, #4]
 800d8d4:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800d8d6:	4311      	orrs	r1, r2
 800d8d8:	687a      	ldr	r2, [r7, #4]
 800d8da:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800d8dc:	4311      	orrs	r1, r2
 800d8de:	687a      	ldr	r2, [r7, #4]
 800d8e0:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800d8e2:	430a      	orrs	r2, r1
 800d8e4:	431a      	orrs	r2, r3
 800d8e6:	687b      	ldr	r3, [r7, #4]
 800d8e8:	681b      	ldr	r3, [r3, #0]
 800d8ea:	f042 0201 	orr.w	r2, r2, #1
 800d8ee:	611a      	str	r2, [r3, #16]
 800d8f0:	e007      	b.n	800d902 <HAL_ADC_Init+0x222>
                  );
      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 800d8f2:	687b      	ldr	r3, [r7, #4]
 800d8f4:	681b      	ldr	r3, [r3, #0]
 800d8f6:	691a      	ldr	r2, [r3, #16]
 800d8f8:	687b      	ldr	r3, [r7, #4]
 800d8fa:	681b      	ldr	r3, [r3, #0]
 800d8fc:	f022 0201 	bic.w	r2, r2, #1
 800d900:	611a      	str	r2, [r3, #16]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 800d902:	687b      	ldr	r3, [r7, #4]
 800d904:	691b      	ldr	r3, [r3, #16]
 800d906:	2b01      	cmp	r3, #1
 800d908:	d10c      	bne.n	800d924 <HAL_ADC_Init+0x244>
    {
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 800d90a:	687b      	ldr	r3, [r7, #4]
 800d90c:	681b      	ldr	r3, [r3, #0]
 800d90e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d910:	f023 010f 	bic.w	r1, r3, #15
 800d914:	687b      	ldr	r3, [r7, #4]
 800d916:	69db      	ldr	r3, [r3, #28]
 800d918:	1e5a      	subs	r2, r3, #1
 800d91a:	687b      	ldr	r3, [r7, #4]
 800d91c:	681b      	ldr	r3, [r3, #0]
 800d91e:	430a      	orrs	r2, r1
 800d920:	631a      	str	r2, [r3, #48]	; 0x30
 800d922:	e007      	b.n	800d934 <HAL_ADC_Init+0x254>
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 800d924:	687b      	ldr	r3, [r7, #4]
 800d926:	681b      	ldr	r3, [r3, #0]
 800d928:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800d92a:	687b      	ldr	r3, [r7, #4]
 800d92c:	681b      	ldr	r3, [r3, #0]
 800d92e:	f022 020f 	bic.w	r2, r2, #15
 800d932:	631a      	str	r2, [r3, #48]	; 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 800d934:	687b      	ldr	r3, [r7, #4]
 800d936:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800d938:	f023 0303 	bic.w	r3, r3, #3
 800d93c:	f043 0201 	orr.w	r2, r3, #1
 800d940:	687b      	ldr	r3, [r7, #4]
 800d942:	655a      	str	r2, [r3, #84]	; 0x54
 800d944:	e007      	b.n	800d956 <HAL_ADC_Init+0x276>
#endif /* ADC_SUPPORT_2_5_MSPS */
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800d946:	687b      	ldr	r3, [r7, #4]
 800d948:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800d94a:	f043 0210 	orr.w	r2, r3, #16
 800d94e:	687b      	ldr	r3, [r7, #4]
 800d950:	655a      	str	r2, [r3, #84]	; 0x54

    tmp_hal_status = HAL_ERROR;
 800d952:	2301      	movs	r3, #1
 800d954:	77fb      	strb	r3, [r7, #31]
  }

  /* Return function status */
  return tmp_hal_status;
 800d956:	7ffb      	ldrb	r3, [r7, #31]
}
 800d958:	4618      	mov	r0, r3
 800d95a:	3720      	adds	r7, #32
 800d95c:	46bd      	mov	sp, r7
 800d95e:	bd80      	pop	{r7, pc}
 800d960:	20000004 	.word	0x20000004
 800d964:	053e2d63 	.word	0x053e2d63
 800d968:	50040000 	.word	0x50040000
 800d96c:	50040300 	.word	0x50040300
 800d970:	fff0c007 	.word	0xfff0c007

0800d974 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *sConfig)
{
 800d974:	b580      	push	{r7, lr}
 800d976:	b0b6      	sub	sp, #216	; 0xd8
 800d978:	af00      	add	r7, sp, #0
 800d97a:	6078      	str	r0, [r7, #4]
 800d97c:	6039      	str	r1, [r7, #0]
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
  
#else
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800d97e:	2300      	movs	r3, #0
 800d980:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7
  uint32_t tmpOffsetShifted;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0;
 800d984:	2300      	movs	r3, #0
 800d986:	60fb      	str	r3, [r7, #12]
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfig->Channel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 800d988:	687b      	ldr	r3, [r7, #4]
 800d98a:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800d98e:	2b01      	cmp	r3, #1
 800d990:	d101      	bne.n	800d996 <HAL_ADC_ConfigChannel+0x22>
 800d992:	2302      	movs	r3, #2
 800d994:	e39e      	b.n	800e0d4 <HAL_ADC_ConfigChannel+0x760>
 800d996:	687b      	ldr	r3, [r7, #4]
 800d998:	2201      	movs	r2, #1
 800d99a:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 800d99e:	687b      	ldr	r3, [r7, #4]
 800d9a0:	681b      	ldr	r3, [r3, #0]
 800d9a2:	4618      	mov	r0, r3
 800d9a4:	f7ff fe75 	bl	800d692 <LL_ADC_REG_IsConversionOngoing>
 800d9a8:	4603      	mov	r3, r0
 800d9aa:	2b00      	cmp	r3, #0
 800d9ac:	f040 8383 	bne.w	800e0b6 <HAL_ADC_ConfigChannel+0x742>
  {
    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 800d9b0:	687b      	ldr	r3, [r7, #4]
 800d9b2:	6818      	ldr	r0, [r3, #0]
 800d9b4:	683b      	ldr	r3, [r7, #0]
 800d9b6:	6859      	ldr	r1, [r3, #4]
 800d9b8:	683b      	ldr	r3, [r7, #0]
 800d9ba:	681b      	ldr	r3, [r3, #0]
 800d9bc:	461a      	mov	r2, r3
 800d9be:	f7ff fd8c 	bl	800d4da <LL_ADC_REG_SetSequencerRanks>
    /*  - Channel sampling time                                                 */
    /*  - Channel offset                                                        */
#if defined (ADC_SUPPORT_2_5_MSPS)
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
#else
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 800d9c2:	687b      	ldr	r3, [r7, #4]
 800d9c4:	681b      	ldr	r3, [r3, #0]
 800d9c6:	4618      	mov	r0, r3
 800d9c8:	f7ff fe63 	bl	800d692 <LL_ADC_REG_IsConversionOngoing>
 800d9cc:	f8c7 00d0 	str.w	r0, [r7, #208]	; 0xd0
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 800d9d0:	687b      	ldr	r3, [r7, #4]
 800d9d2:	681b      	ldr	r3, [r3, #0]
 800d9d4:	4618      	mov	r0, r3
 800d9d6:	f7ff fe6f 	bl	800d6b8 <LL_ADC_INJ_IsConversionOngoing>
 800d9da:	f8c7 00cc 	str.w	r0, [r7, #204]	; 0xcc
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 800d9de:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 800d9e2:	2b00      	cmp	r3, #0
 800d9e4:	f040 81a6 	bne.w	800dd34 <HAL_ADC_ConfigChannel+0x3c0>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 800d9e8:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800d9ec:	2b00      	cmp	r3, #0
 800d9ee:	f040 81a1 	bne.w	800dd34 <HAL_ADC_ConfigChannel+0x3c0>
       )
#endif /* ADC_SUPPORT_2_5_MSPS */
    {
      /* Set sampling time of the selected ADC channel */
      LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 800d9f2:	687b      	ldr	r3, [r7, #4]
 800d9f4:	6818      	ldr	r0, [r3, #0]
 800d9f6:	683b      	ldr	r3, [r7, #0]
 800d9f8:	6819      	ldr	r1, [r3, #0]
 800d9fa:	683b      	ldr	r3, [r7, #0]
 800d9fc:	689b      	ldr	r3, [r3, #8]
 800d9fe:	461a      	mov	r2, r3
 800da00:	f7ff fd97 	bl	800d532 <LL_ADC_SetChannelSamplingTime>

      /* Configure the offset: offset enable/disable, channel, offset value */

      /* Shift the offset with respect to the selected ADC resolution. */
      /* Offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0 */
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 800da04:	683b      	ldr	r3, [r7, #0]
 800da06:	695a      	ldr	r2, [r3, #20]
 800da08:	687b      	ldr	r3, [r7, #4]
 800da0a:	681b      	ldr	r3, [r3, #0]
 800da0c:	68db      	ldr	r3, [r3, #12]
 800da0e:	08db      	lsrs	r3, r3, #3
 800da10:	f003 0303 	and.w	r3, r3, #3
 800da14:	005b      	lsls	r3, r3, #1
 800da16:	fa02 f303 	lsl.w	r3, r2, r3
 800da1a:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8

      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 800da1e:	683b      	ldr	r3, [r7, #0]
 800da20:	691b      	ldr	r3, [r3, #16]
 800da22:	2b04      	cmp	r3, #4
 800da24:	d00a      	beq.n	800da3c <HAL_ADC_ConfigChannel+0xc8>
      {
        /* Set ADC selected offset number */
        LL_ADC_SetOffset(hadc->Instance, sConfig->OffsetNumber, sConfig->Channel, tmpOffsetShifted);
 800da26:	687b      	ldr	r3, [r7, #4]
 800da28:	6818      	ldr	r0, [r3, #0]
 800da2a:	683b      	ldr	r3, [r7, #0]
 800da2c:	6919      	ldr	r1, [r3, #16]
 800da2e:	683b      	ldr	r3, [r7, #0]
 800da30:	681a      	ldr	r2, [r3, #0]
 800da32:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800da36:	f7ff fcfb 	bl	800d430 <LL_ADC_SetOffset>
 800da3a:	e17b      	b.n	800dd34 <HAL_ADC_ConfigChannel+0x3c0>
      }
      else
      {
        /* Scan each offset register to check if the selected channel is targeted. */
        /* If this is the case, the corresponding offset number is disabled.       */
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800da3c:	687b      	ldr	r3, [r7, #4]
 800da3e:	681b      	ldr	r3, [r3, #0]
 800da40:	2100      	movs	r1, #0
 800da42:	4618      	mov	r0, r3
 800da44:	f7ff fd18 	bl	800d478 <LL_ADC_GetOffsetChannel>
 800da48:	4603      	mov	r3, r0
 800da4a:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800da4e:	2b00      	cmp	r3, #0
 800da50:	d10a      	bne.n	800da68 <HAL_ADC_ConfigChannel+0xf4>
 800da52:	687b      	ldr	r3, [r7, #4]
 800da54:	681b      	ldr	r3, [r3, #0]
 800da56:	2100      	movs	r1, #0
 800da58:	4618      	mov	r0, r3
 800da5a:	f7ff fd0d 	bl	800d478 <LL_ADC_GetOffsetChannel>
 800da5e:	4603      	mov	r3, r0
 800da60:	0e9b      	lsrs	r3, r3, #26
 800da62:	f003 021f 	and.w	r2, r3, #31
 800da66:	e01e      	b.n	800daa6 <HAL_ADC_ConfigChannel+0x132>
 800da68:	687b      	ldr	r3, [r7, #4]
 800da6a:	681b      	ldr	r3, [r3, #0]
 800da6c:	2100      	movs	r1, #0
 800da6e:	4618      	mov	r0, r3
 800da70:	f7ff fd02 	bl	800d478 <LL_ADC_GetOffsetChannel>
 800da74:	4603      	mov	r3, r0
 800da76:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800da7a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800da7e:	fa93 f3a3 	rbit	r3, r3
 800da82:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
  return result;
 800da86:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800da8a:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
  if (value == 0U)
 800da8e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800da92:	2b00      	cmp	r3, #0
 800da94:	d101      	bne.n	800da9a <HAL_ADC_ConfigChannel+0x126>
    return 32U;
 800da96:	2320      	movs	r3, #32
 800da98:	e004      	b.n	800daa4 <HAL_ADC_ConfigChannel+0x130>
  return __builtin_clz(value);
 800da9a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800da9e:	fab3 f383 	clz	r3, r3
 800daa2:	b2db      	uxtb	r3, r3
 800daa4:	461a      	mov	r2, r3
 800daa6:	683b      	ldr	r3, [r7, #0]
 800daa8:	681b      	ldr	r3, [r3, #0]
 800daaa:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800daae:	2b00      	cmp	r3, #0
 800dab0:	d105      	bne.n	800dabe <HAL_ADC_ConfigChannel+0x14a>
 800dab2:	683b      	ldr	r3, [r7, #0]
 800dab4:	681b      	ldr	r3, [r3, #0]
 800dab6:	0e9b      	lsrs	r3, r3, #26
 800dab8:	f003 031f 	and.w	r3, r3, #31
 800dabc:	e018      	b.n	800daf0 <HAL_ADC_ConfigChannel+0x17c>
 800dabe:	683b      	ldr	r3, [r7, #0]
 800dac0:	681b      	ldr	r3, [r3, #0]
 800dac2:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800dac6:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800daca:	fa93 f3a3 	rbit	r3, r3
 800dace:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  return result;
 800dad2:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800dad6:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  if (value == 0U)
 800dada:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800dade:	2b00      	cmp	r3, #0
 800dae0:	d101      	bne.n	800dae6 <HAL_ADC_ConfigChannel+0x172>
    return 32U;
 800dae2:	2320      	movs	r3, #32
 800dae4:	e004      	b.n	800daf0 <HAL_ADC_ConfigChannel+0x17c>
  return __builtin_clz(value);
 800dae6:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800daea:	fab3 f383 	clz	r3, r3
 800daee:	b2db      	uxtb	r3, r3
 800daf0:	429a      	cmp	r2, r3
 800daf2:	d106      	bne.n	800db02 <HAL_ADC_ConfigChannel+0x18e>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_1, LL_ADC_OFFSET_DISABLE);
 800daf4:	687b      	ldr	r3, [r7, #4]
 800daf6:	681b      	ldr	r3, [r3, #0]
 800daf8:	2200      	movs	r2, #0
 800dafa:	2100      	movs	r1, #0
 800dafc:	4618      	mov	r0, r3
 800dafe:	f7ff fcd1 	bl	800d4a4 <LL_ADC_SetOffsetState>
        }
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800db02:	687b      	ldr	r3, [r7, #4]
 800db04:	681b      	ldr	r3, [r3, #0]
 800db06:	2101      	movs	r1, #1
 800db08:	4618      	mov	r0, r3
 800db0a:	f7ff fcb5 	bl	800d478 <LL_ADC_GetOffsetChannel>
 800db0e:	4603      	mov	r3, r0
 800db10:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800db14:	2b00      	cmp	r3, #0
 800db16:	d10a      	bne.n	800db2e <HAL_ADC_ConfigChannel+0x1ba>
 800db18:	687b      	ldr	r3, [r7, #4]
 800db1a:	681b      	ldr	r3, [r3, #0]
 800db1c:	2101      	movs	r1, #1
 800db1e:	4618      	mov	r0, r3
 800db20:	f7ff fcaa 	bl	800d478 <LL_ADC_GetOffsetChannel>
 800db24:	4603      	mov	r3, r0
 800db26:	0e9b      	lsrs	r3, r3, #26
 800db28:	f003 021f 	and.w	r2, r3, #31
 800db2c:	e01e      	b.n	800db6c <HAL_ADC_ConfigChannel+0x1f8>
 800db2e:	687b      	ldr	r3, [r7, #4]
 800db30:	681b      	ldr	r3, [r3, #0]
 800db32:	2101      	movs	r1, #1
 800db34:	4618      	mov	r0, r3
 800db36:	f7ff fc9f 	bl	800d478 <LL_ADC_GetOffsetChannel>
 800db3a:	4603      	mov	r3, r0
 800db3c:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800db40:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800db44:	fa93 f3a3 	rbit	r3, r3
 800db48:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  return result;
 800db4c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800db50:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
  if (value == 0U)
 800db54:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800db58:	2b00      	cmp	r3, #0
 800db5a:	d101      	bne.n	800db60 <HAL_ADC_ConfigChannel+0x1ec>
    return 32U;
 800db5c:	2320      	movs	r3, #32
 800db5e:	e004      	b.n	800db6a <HAL_ADC_ConfigChannel+0x1f6>
  return __builtin_clz(value);
 800db60:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800db64:	fab3 f383 	clz	r3, r3
 800db68:	b2db      	uxtb	r3, r3
 800db6a:	461a      	mov	r2, r3
 800db6c:	683b      	ldr	r3, [r7, #0]
 800db6e:	681b      	ldr	r3, [r3, #0]
 800db70:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800db74:	2b00      	cmp	r3, #0
 800db76:	d105      	bne.n	800db84 <HAL_ADC_ConfigChannel+0x210>
 800db78:	683b      	ldr	r3, [r7, #0]
 800db7a:	681b      	ldr	r3, [r3, #0]
 800db7c:	0e9b      	lsrs	r3, r3, #26
 800db7e:	f003 031f 	and.w	r3, r3, #31
 800db82:	e018      	b.n	800dbb6 <HAL_ADC_ConfigChannel+0x242>
 800db84:	683b      	ldr	r3, [r7, #0]
 800db86:	681b      	ldr	r3, [r3, #0]
 800db88:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800db8c:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800db90:	fa93 f3a3 	rbit	r3, r3
 800db94:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
  return result;
 800db98:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800db9c:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  if (value == 0U)
 800dba0:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800dba4:	2b00      	cmp	r3, #0
 800dba6:	d101      	bne.n	800dbac <HAL_ADC_ConfigChannel+0x238>
    return 32U;
 800dba8:	2320      	movs	r3, #32
 800dbaa:	e004      	b.n	800dbb6 <HAL_ADC_ConfigChannel+0x242>
  return __builtin_clz(value);
 800dbac:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800dbb0:	fab3 f383 	clz	r3, r3
 800dbb4:	b2db      	uxtb	r3, r3
 800dbb6:	429a      	cmp	r2, r3
 800dbb8:	d106      	bne.n	800dbc8 <HAL_ADC_ConfigChannel+0x254>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_2, LL_ADC_OFFSET_DISABLE);
 800dbba:	687b      	ldr	r3, [r7, #4]
 800dbbc:	681b      	ldr	r3, [r3, #0]
 800dbbe:	2200      	movs	r2, #0
 800dbc0:	2101      	movs	r1, #1
 800dbc2:	4618      	mov	r0, r3
 800dbc4:	f7ff fc6e 	bl	800d4a4 <LL_ADC_SetOffsetState>
        }
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800dbc8:	687b      	ldr	r3, [r7, #4]
 800dbca:	681b      	ldr	r3, [r3, #0]
 800dbcc:	2102      	movs	r1, #2
 800dbce:	4618      	mov	r0, r3
 800dbd0:	f7ff fc52 	bl	800d478 <LL_ADC_GetOffsetChannel>
 800dbd4:	4603      	mov	r3, r0
 800dbd6:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800dbda:	2b00      	cmp	r3, #0
 800dbdc:	d10a      	bne.n	800dbf4 <HAL_ADC_ConfigChannel+0x280>
 800dbde:	687b      	ldr	r3, [r7, #4]
 800dbe0:	681b      	ldr	r3, [r3, #0]
 800dbe2:	2102      	movs	r1, #2
 800dbe4:	4618      	mov	r0, r3
 800dbe6:	f7ff fc47 	bl	800d478 <LL_ADC_GetOffsetChannel>
 800dbea:	4603      	mov	r3, r0
 800dbec:	0e9b      	lsrs	r3, r3, #26
 800dbee:	f003 021f 	and.w	r2, r3, #31
 800dbf2:	e01e      	b.n	800dc32 <HAL_ADC_ConfigChannel+0x2be>
 800dbf4:	687b      	ldr	r3, [r7, #4]
 800dbf6:	681b      	ldr	r3, [r3, #0]
 800dbf8:	2102      	movs	r1, #2
 800dbfa:	4618      	mov	r0, r3
 800dbfc:	f7ff fc3c 	bl	800d478 <LL_ADC_GetOffsetChannel>
 800dc00:	4603      	mov	r3, r0
 800dc02:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800dc06:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800dc0a:	fa93 f3a3 	rbit	r3, r3
 800dc0e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  return result;
 800dc12:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800dc16:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  if (value == 0U)
 800dc1a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800dc1e:	2b00      	cmp	r3, #0
 800dc20:	d101      	bne.n	800dc26 <HAL_ADC_ConfigChannel+0x2b2>
    return 32U;
 800dc22:	2320      	movs	r3, #32
 800dc24:	e004      	b.n	800dc30 <HAL_ADC_ConfigChannel+0x2bc>
  return __builtin_clz(value);
 800dc26:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800dc2a:	fab3 f383 	clz	r3, r3
 800dc2e:	b2db      	uxtb	r3, r3
 800dc30:	461a      	mov	r2, r3
 800dc32:	683b      	ldr	r3, [r7, #0]
 800dc34:	681b      	ldr	r3, [r3, #0]
 800dc36:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800dc3a:	2b00      	cmp	r3, #0
 800dc3c:	d105      	bne.n	800dc4a <HAL_ADC_ConfigChannel+0x2d6>
 800dc3e:	683b      	ldr	r3, [r7, #0]
 800dc40:	681b      	ldr	r3, [r3, #0]
 800dc42:	0e9b      	lsrs	r3, r3, #26
 800dc44:	f003 031f 	and.w	r3, r3, #31
 800dc48:	e016      	b.n	800dc78 <HAL_ADC_ConfigChannel+0x304>
 800dc4a:	683b      	ldr	r3, [r7, #0]
 800dc4c:	681b      	ldr	r3, [r3, #0]
 800dc4e:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800dc52:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800dc56:	fa93 f3a3 	rbit	r3, r3
 800dc5a:	67fb      	str	r3, [r7, #124]	; 0x7c
  return result;
 800dc5c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800dc5e:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  if (value == 0U)
 800dc62:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800dc66:	2b00      	cmp	r3, #0
 800dc68:	d101      	bne.n	800dc6e <HAL_ADC_ConfigChannel+0x2fa>
    return 32U;
 800dc6a:	2320      	movs	r3, #32
 800dc6c:	e004      	b.n	800dc78 <HAL_ADC_ConfigChannel+0x304>
  return __builtin_clz(value);
 800dc6e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800dc72:	fab3 f383 	clz	r3, r3
 800dc76:	b2db      	uxtb	r3, r3
 800dc78:	429a      	cmp	r2, r3
 800dc7a:	d106      	bne.n	800dc8a <HAL_ADC_ConfigChannel+0x316>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_3, LL_ADC_OFFSET_DISABLE);
 800dc7c:	687b      	ldr	r3, [r7, #4]
 800dc7e:	681b      	ldr	r3, [r3, #0]
 800dc80:	2200      	movs	r2, #0
 800dc82:	2102      	movs	r1, #2
 800dc84:	4618      	mov	r0, r3
 800dc86:	f7ff fc0d 	bl	800d4a4 <LL_ADC_SetOffsetState>
        }
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800dc8a:	687b      	ldr	r3, [r7, #4]
 800dc8c:	681b      	ldr	r3, [r3, #0]
 800dc8e:	2103      	movs	r1, #3
 800dc90:	4618      	mov	r0, r3
 800dc92:	f7ff fbf1 	bl	800d478 <LL_ADC_GetOffsetChannel>
 800dc96:	4603      	mov	r3, r0
 800dc98:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800dc9c:	2b00      	cmp	r3, #0
 800dc9e:	d10a      	bne.n	800dcb6 <HAL_ADC_ConfigChannel+0x342>
 800dca0:	687b      	ldr	r3, [r7, #4]
 800dca2:	681b      	ldr	r3, [r3, #0]
 800dca4:	2103      	movs	r1, #3
 800dca6:	4618      	mov	r0, r3
 800dca8:	f7ff fbe6 	bl	800d478 <LL_ADC_GetOffsetChannel>
 800dcac:	4603      	mov	r3, r0
 800dcae:	0e9b      	lsrs	r3, r3, #26
 800dcb0:	f003 021f 	and.w	r2, r3, #31
 800dcb4:	e017      	b.n	800dce6 <HAL_ADC_ConfigChannel+0x372>
 800dcb6:	687b      	ldr	r3, [r7, #4]
 800dcb8:	681b      	ldr	r3, [r3, #0]
 800dcba:	2103      	movs	r1, #3
 800dcbc:	4618      	mov	r0, r3
 800dcbe:	f7ff fbdb 	bl	800d478 <LL_ADC_GetOffsetChannel>
 800dcc2:	4603      	mov	r3, r0
 800dcc4:	677b      	str	r3, [r7, #116]	; 0x74
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800dcc6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800dcc8:	fa93 f3a3 	rbit	r3, r3
 800dccc:	673b      	str	r3, [r7, #112]	; 0x70
  return result;
 800dcce:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800dcd0:	67bb      	str	r3, [r7, #120]	; 0x78
  if (value == 0U)
 800dcd2:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800dcd4:	2b00      	cmp	r3, #0
 800dcd6:	d101      	bne.n	800dcdc <HAL_ADC_ConfigChannel+0x368>
    return 32U;
 800dcd8:	2320      	movs	r3, #32
 800dcda:	e003      	b.n	800dce4 <HAL_ADC_ConfigChannel+0x370>
  return __builtin_clz(value);
 800dcdc:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800dcde:	fab3 f383 	clz	r3, r3
 800dce2:	b2db      	uxtb	r3, r3
 800dce4:	461a      	mov	r2, r3
 800dce6:	683b      	ldr	r3, [r7, #0]
 800dce8:	681b      	ldr	r3, [r3, #0]
 800dcea:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800dcee:	2b00      	cmp	r3, #0
 800dcf0:	d105      	bne.n	800dcfe <HAL_ADC_ConfigChannel+0x38a>
 800dcf2:	683b      	ldr	r3, [r7, #0]
 800dcf4:	681b      	ldr	r3, [r3, #0]
 800dcf6:	0e9b      	lsrs	r3, r3, #26
 800dcf8:	f003 031f 	and.w	r3, r3, #31
 800dcfc:	e011      	b.n	800dd22 <HAL_ADC_ConfigChannel+0x3ae>
 800dcfe:	683b      	ldr	r3, [r7, #0]
 800dd00:	681b      	ldr	r3, [r3, #0]
 800dd02:	66bb      	str	r3, [r7, #104]	; 0x68
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800dd04:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800dd06:	fa93 f3a3 	rbit	r3, r3
 800dd0a:	667b      	str	r3, [r7, #100]	; 0x64
  return result;
 800dd0c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800dd0e:	66fb      	str	r3, [r7, #108]	; 0x6c
  if (value == 0U)
 800dd10:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800dd12:	2b00      	cmp	r3, #0
 800dd14:	d101      	bne.n	800dd1a <HAL_ADC_ConfigChannel+0x3a6>
    return 32U;
 800dd16:	2320      	movs	r3, #32
 800dd18:	e003      	b.n	800dd22 <HAL_ADC_ConfigChannel+0x3ae>
  return __builtin_clz(value);
 800dd1a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800dd1c:	fab3 f383 	clz	r3, r3
 800dd20:	b2db      	uxtb	r3, r3
 800dd22:	429a      	cmp	r2, r3
 800dd24:	d106      	bne.n	800dd34 <HAL_ADC_ConfigChannel+0x3c0>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_4, LL_ADC_OFFSET_DISABLE);
 800dd26:	687b      	ldr	r3, [r7, #4]
 800dd28:	681b      	ldr	r3, [r3, #0]
 800dd2a:	2200      	movs	r2, #0
 800dd2c:	2103      	movs	r1, #3
 800dd2e:	4618      	mov	r0, r3
 800dd30:	f7ff fbb8 	bl	800d4a4 <LL_ADC_SetOffsetState>

    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    /*  - Internal measurement channels: Vbat/VrefInt/TempSensor                */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 800dd34:	687b      	ldr	r3, [r7, #4]
 800dd36:	681b      	ldr	r3, [r3, #0]
 800dd38:	4618      	mov	r0, r3
 800dd3a:	f7ff fc97 	bl	800d66c <LL_ADC_IsEnabled>
 800dd3e:	4603      	mov	r3, r0
 800dd40:	2b00      	cmp	r3, #0
 800dd42:	f040 81c1 	bne.w	800e0c8 <HAL_ADC_ConfigChannel+0x754>
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 800dd46:	687b      	ldr	r3, [r7, #4]
 800dd48:	6818      	ldr	r0, [r3, #0]
 800dd4a:	683b      	ldr	r3, [r7, #0]
 800dd4c:	6819      	ldr	r1, [r3, #0]
 800dd4e:	683b      	ldr	r3, [r7, #0]
 800dd50:	68db      	ldr	r3, [r3, #12]
 800dd52:	461a      	mov	r2, r3
 800dd54:	f7ff fc18 	bl	800d588 <LL_ADC_SetChannelSingleDiff>

      /* Configuration of differential mode */
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 800dd58:	683b      	ldr	r3, [r7, #0]
 800dd5a:	68db      	ldr	r3, [r3, #12]
 800dd5c:	4a8e      	ldr	r2, [pc, #568]	; (800df98 <HAL_ADC_ConfigChannel+0x624>)
 800dd5e:	4293      	cmp	r3, r2
 800dd60:	f040 8130 	bne.w	800dfc4 <HAL_ADC_ConfigChannel+0x650>
      {
        /* Set sampling time of the selected ADC channel */
        /* Note: ADC channel number masked with value "0x1F" to ensure shift value within 32 bits range */
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800dd64:	687b      	ldr	r3, [r7, #4]
 800dd66:	6818      	ldr	r0, [r3, #0]
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 800dd68:	683b      	ldr	r3, [r7, #0]
 800dd6a:	681b      	ldr	r3, [r3, #0]
 800dd6c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800dd70:	2b00      	cmp	r3, #0
 800dd72:	d10b      	bne.n	800dd8c <HAL_ADC_ConfigChannel+0x418>
 800dd74:	683b      	ldr	r3, [r7, #0]
 800dd76:	681b      	ldr	r3, [r3, #0]
 800dd78:	0e9b      	lsrs	r3, r3, #26
 800dd7a:	3301      	adds	r3, #1
 800dd7c:	f003 031f 	and.w	r3, r3, #31
 800dd80:	2b09      	cmp	r3, #9
 800dd82:	bf94      	ite	ls
 800dd84:	2301      	movls	r3, #1
 800dd86:	2300      	movhi	r3, #0
 800dd88:	b2db      	uxtb	r3, r3
 800dd8a:	e019      	b.n	800ddc0 <HAL_ADC_ConfigChannel+0x44c>
 800dd8c:	683b      	ldr	r3, [r7, #0]
 800dd8e:	681b      	ldr	r3, [r3, #0]
 800dd90:	65fb      	str	r3, [r7, #92]	; 0x5c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800dd92:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800dd94:	fa93 f3a3 	rbit	r3, r3
 800dd98:	65bb      	str	r3, [r7, #88]	; 0x58
  return result;
 800dd9a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800dd9c:	663b      	str	r3, [r7, #96]	; 0x60
  if (value == 0U)
 800dd9e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800dda0:	2b00      	cmp	r3, #0
 800dda2:	d101      	bne.n	800dda8 <HAL_ADC_ConfigChannel+0x434>
    return 32U;
 800dda4:	2320      	movs	r3, #32
 800dda6:	e003      	b.n	800ddb0 <HAL_ADC_ConfigChannel+0x43c>
  return __builtin_clz(value);
 800dda8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800ddaa:	fab3 f383 	clz	r3, r3
 800ddae:	b2db      	uxtb	r3, r3
 800ddb0:	3301      	adds	r3, #1
 800ddb2:	f003 031f 	and.w	r3, r3, #31
 800ddb6:	2b09      	cmp	r3, #9
 800ddb8:	bf94      	ite	ls
 800ddba:	2301      	movls	r3, #1
 800ddbc:	2300      	movhi	r3, #0
 800ddbe:	b2db      	uxtb	r3, r3
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800ddc0:	2b00      	cmp	r3, #0
 800ddc2:	d079      	beq.n	800deb8 <HAL_ADC_ConfigChannel+0x544>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 800ddc4:	683b      	ldr	r3, [r7, #0]
 800ddc6:	681b      	ldr	r3, [r3, #0]
 800ddc8:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800ddcc:	2b00      	cmp	r3, #0
 800ddce:	d107      	bne.n	800dde0 <HAL_ADC_ConfigChannel+0x46c>
 800ddd0:	683b      	ldr	r3, [r7, #0]
 800ddd2:	681b      	ldr	r3, [r3, #0]
 800ddd4:	0e9b      	lsrs	r3, r3, #26
 800ddd6:	3301      	adds	r3, #1
 800ddd8:	069b      	lsls	r3, r3, #26
 800ddda:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 800ddde:	e015      	b.n	800de0c <HAL_ADC_ConfigChannel+0x498>
 800dde0:	683b      	ldr	r3, [r7, #0]
 800dde2:	681b      	ldr	r3, [r3, #0]
 800dde4:	653b      	str	r3, [r7, #80]	; 0x50
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800dde6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800dde8:	fa93 f3a3 	rbit	r3, r3
 800ddec:	64fb      	str	r3, [r7, #76]	; 0x4c
  return result;
 800ddee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ddf0:	657b      	str	r3, [r7, #84]	; 0x54
  if (value == 0U)
 800ddf2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ddf4:	2b00      	cmp	r3, #0
 800ddf6:	d101      	bne.n	800ddfc <HAL_ADC_ConfigChannel+0x488>
    return 32U;
 800ddf8:	2320      	movs	r3, #32
 800ddfa:	e003      	b.n	800de04 <HAL_ADC_ConfigChannel+0x490>
  return __builtin_clz(value);
 800ddfc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ddfe:	fab3 f383 	clz	r3, r3
 800de02:	b2db      	uxtb	r3, r3
 800de04:	3301      	adds	r3, #1
 800de06:	069b      	lsls	r3, r3, #26
 800de08:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 800de0c:	683b      	ldr	r3, [r7, #0]
 800de0e:	681b      	ldr	r3, [r3, #0]
 800de10:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800de14:	2b00      	cmp	r3, #0
 800de16:	d109      	bne.n	800de2c <HAL_ADC_ConfigChannel+0x4b8>
 800de18:	683b      	ldr	r3, [r7, #0]
 800de1a:	681b      	ldr	r3, [r3, #0]
 800de1c:	0e9b      	lsrs	r3, r3, #26
 800de1e:	3301      	adds	r3, #1
 800de20:	f003 031f 	and.w	r3, r3, #31
 800de24:	2101      	movs	r1, #1
 800de26:	fa01 f303 	lsl.w	r3, r1, r3
 800de2a:	e017      	b.n	800de5c <HAL_ADC_ConfigChannel+0x4e8>
 800de2c:	683b      	ldr	r3, [r7, #0]
 800de2e:	681b      	ldr	r3, [r3, #0]
 800de30:	647b      	str	r3, [r7, #68]	; 0x44
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800de32:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800de34:	fa93 f3a3 	rbit	r3, r3
 800de38:	643b      	str	r3, [r7, #64]	; 0x40
  return result;
 800de3a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800de3c:	64bb      	str	r3, [r7, #72]	; 0x48
  if (value == 0U)
 800de3e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800de40:	2b00      	cmp	r3, #0
 800de42:	d101      	bne.n	800de48 <HAL_ADC_ConfigChannel+0x4d4>
    return 32U;
 800de44:	2320      	movs	r3, #32
 800de46:	e003      	b.n	800de50 <HAL_ADC_ConfigChannel+0x4dc>
  return __builtin_clz(value);
 800de48:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800de4a:	fab3 f383 	clz	r3, r3
 800de4e:	b2db      	uxtb	r3, r3
 800de50:	3301      	adds	r3, #1
 800de52:	f003 031f 	and.w	r3, r3, #31
 800de56:	2101      	movs	r1, #1
 800de58:	fa01 f303 	lsl.w	r3, r1, r3
 800de5c:	ea42 0103 	orr.w	r1, r2, r3
 800de60:	683b      	ldr	r3, [r7, #0]
 800de62:	681b      	ldr	r3, [r3, #0]
 800de64:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800de68:	2b00      	cmp	r3, #0
 800de6a:	d10a      	bne.n	800de82 <HAL_ADC_ConfigChannel+0x50e>
 800de6c:	683b      	ldr	r3, [r7, #0]
 800de6e:	681b      	ldr	r3, [r3, #0]
 800de70:	0e9b      	lsrs	r3, r3, #26
 800de72:	3301      	adds	r3, #1
 800de74:	f003 021f 	and.w	r2, r3, #31
 800de78:	4613      	mov	r3, r2
 800de7a:	005b      	lsls	r3, r3, #1
 800de7c:	4413      	add	r3, r2
 800de7e:	051b      	lsls	r3, r3, #20
 800de80:	e018      	b.n	800deb4 <HAL_ADC_ConfigChannel+0x540>
 800de82:	683b      	ldr	r3, [r7, #0]
 800de84:	681b      	ldr	r3, [r3, #0]
 800de86:	63bb      	str	r3, [r7, #56]	; 0x38
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800de88:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800de8a:	fa93 f3a3 	rbit	r3, r3
 800de8e:	637b      	str	r3, [r7, #52]	; 0x34
  return result;
 800de90:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800de92:	63fb      	str	r3, [r7, #60]	; 0x3c
  if (value == 0U)
 800de94:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800de96:	2b00      	cmp	r3, #0
 800de98:	d101      	bne.n	800de9e <HAL_ADC_ConfigChannel+0x52a>
    return 32U;
 800de9a:	2320      	movs	r3, #32
 800de9c:	e003      	b.n	800dea6 <HAL_ADC_ConfigChannel+0x532>
  return __builtin_clz(value);
 800de9e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800dea0:	fab3 f383 	clz	r3, r3
 800dea4:	b2db      	uxtb	r3, r3
 800dea6:	3301      	adds	r3, #1
 800dea8:	f003 021f 	and.w	r2, r3, #31
 800deac:	4613      	mov	r3, r2
 800deae:	005b      	lsls	r3, r3, #1
 800deb0:	4413      	add	r3, r2
 800deb2:	051b      	lsls	r3, r3, #20
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800deb4:	430b      	orrs	r3, r1
 800deb6:	e080      	b.n	800dfba <HAL_ADC_ConfigChannel+0x646>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 800deb8:	683b      	ldr	r3, [r7, #0]
 800deba:	681b      	ldr	r3, [r3, #0]
 800debc:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800dec0:	2b00      	cmp	r3, #0
 800dec2:	d107      	bne.n	800ded4 <HAL_ADC_ConfigChannel+0x560>
 800dec4:	683b      	ldr	r3, [r7, #0]
 800dec6:	681b      	ldr	r3, [r3, #0]
 800dec8:	0e9b      	lsrs	r3, r3, #26
 800deca:	3301      	adds	r3, #1
 800decc:	069b      	lsls	r3, r3, #26
 800dece:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 800ded2:	e015      	b.n	800df00 <HAL_ADC_ConfigChannel+0x58c>
 800ded4:	683b      	ldr	r3, [r7, #0]
 800ded6:	681b      	ldr	r3, [r3, #0]
 800ded8:	62fb      	str	r3, [r7, #44]	; 0x2c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800deda:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800dedc:	fa93 f3a3 	rbit	r3, r3
 800dee0:	62bb      	str	r3, [r7, #40]	; 0x28
  return result;
 800dee2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dee4:	633b      	str	r3, [r7, #48]	; 0x30
  if (value == 0U)
 800dee6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800dee8:	2b00      	cmp	r3, #0
 800deea:	d101      	bne.n	800def0 <HAL_ADC_ConfigChannel+0x57c>
    return 32U;
 800deec:	2320      	movs	r3, #32
 800deee:	e003      	b.n	800def8 <HAL_ADC_ConfigChannel+0x584>
  return __builtin_clz(value);
 800def0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800def2:	fab3 f383 	clz	r3, r3
 800def6:	b2db      	uxtb	r3, r3
 800def8:	3301      	adds	r3, #1
 800defa:	069b      	lsls	r3, r3, #26
 800defc:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 800df00:	683b      	ldr	r3, [r7, #0]
 800df02:	681b      	ldr	r3, [r3, #0]
 800df04:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800df08:	2b00      	cmp	r3, #0
 800df0a:	d109      	bne.n	800df20 <HAL_ADC_ConfigChannel+0x5ac>
 800df0c:	683b      	ldr	r3, [r7, #0]
 800df0e:	681b      	ldr	r3, [r3, #0]
 800df10:	0e9b      	lsrs	r3, r3, #26
 800df12:	3301      	adds	r3, #1
 800df14:	f003 031f 	and.w	r3, r3, #31
 800df18:	2101      	movs	r1, #1
 800df1a:	fa01 f303 	lsl.w	r3, r1, r3
 800df1e:	e017      	b.n	800df50 <HAL_ADC_ConfigChannel+0x5dc>
 800df20:	683b      	ldr	r3, [r7, #0]
 800df22:	681b      	ldr	r3, [r3, #0]
 800df24:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800df26:	6a3b      	ldr	r3, [r7, #32]
 800df28:	fa93 f3a3 	rbit	r3, r3
 800df2c:	61fb      	str	r3, [r7, #28]
  return result;
 800df2e:	69fb      	ldr	r3, [r7, #28]
 800df30:	627b      	str	r3, [r7, #36]	; 0x24
  if (value == 0U)
 800df32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800df34:	2b00      	cmp	r3, #0
 800df36:	d101      	bne.n	800df3c <HAL_ADC_ConfigChannel+0x5c8>
    return 32U;
 800df38:	2320      	movs	r3, #32
 800df3a:	e003      	b.n	800df44 <HAL_ADC_ConfigChannel+0x5d0>
  return __builtin_clz(value);
 800df3c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800df3e:	fab3 f383 	clz	r3, r3
 800df42:	b2db      	uxtb	r3, r3
 800df44:	3301      	adds	r3, #1
 800df46:	f003 031f 	and.w	r3, r3, #31
 800df4a:	2101      	movs	r1, #1
 800df4c:	fa01 f303 	lsl.w	r3, r1, r3
 800df50:	ea42 0103 	orr.w	r1, r2, r3
 800df54:	683b      	ldr	r3, [r7, #0]
 800df56:	681b      	ldr	r3, [r3, #0]
 800df58:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800df5c:	2b00      	cmp	r3, #0
 800df5e:	d10d      	bne.n	800df7c <HAL_ADC_ConfigChannel+0x608>
 800df60:	683b      	ldr	r3, [r7, #0]
 800df62:	681b      	ldr	r3, [r3, #0]
 800df64:	0e9b      	lsrs	r3, r3, #26
 800df66:	3301      	adds	r3, #1
 800df68:	f003 021f 	and.w	r2, r3, #31
 800df6c:	4613      	mov	r3, r2
 800df6e:	005b      	lsls	r3, r3, #1
 800df70:	4413      	add	r3, r2
 800df72:	3b1e      	subs	r3, #30
 800df74:	051b      	lsls	r3, r3, #20
 800df76:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800df7a:	e01d      	b.n	800dfb8 <HAL_ADC_ConfigChannel+0x644>
 800df7c:	683b      	ldr	r3, [r7, #0]
 800df7e:	681b      	ldr	r3, [r3, #0]
 800df80:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800df82:	697b      	ldr	r3, [r7, #20]
 800df84:	fa93 f3a3 	rbit	r3, r3
 800df88:	613b      	str	r3, [r7, #16]
  return result;
 800df8a:	693b      	ldr	r3, [r7, #16]
 800df8c:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 800df8e:	69bb      	ldr	r3, [r7, #24]
 800df90:	2b00      	cmp	r3, #0
 800df92:	d103      	bne.n	800df9c <HAL_ADC_ConfigChannel+0x628>
    return 32U;
 800df94:	2320      	movs	r3, #32
 800df96:	e005      	b.n	800dfa4 <HAL_ADC_ConfigChannel+0x630>
 800df98:	407f0000 	.word	0x407f0000
  return __builtin_clz(value);
 800df9c:	69bb      	ldr	r3, [r7, #24]
 800df9e:	fab3 f383 	clz	r3, r3
 800dfa2:	b2db      	uxtb	r3, r3
 800dfa4:	3301      	adds	r3, #1
 800dfa6:	f003 021f 	and.w	r2, r3, #31
 800dfaa:	4613      	mov	r3, r2
 800dfac:	005b      	lsls	r3, r3, #1
 800dfae:	4413      	add	r3, r2
 800dfb0:	3b1e      	subs	r3, #30
 800dfb2:	051b      	lsls	r3, r3, #20
 800dfb4:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800dfb8:	430b      	orrs	r3, r1
 800dfba:	683a      	ldr	r2, [r7, #0]
 800dfbc:	6892      	ldr	r2, [r2, #8]
 800dfbe:	4619      	mov	r1, r3
 800dfc0:	f7ff fab7 	bl	800d532 <LL_ADC_SetChannelSamplingTime>
      /* If internal channel selected, enable dedicated internal buffers and    */
      /* paths.                                                                 */
      /* Note: these internal measurement paths can be disabled using           */
      /* HAL_ADC_DeInit().                                                      */

      if(__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 800dfc4:	683b      	ldr	r3, [r7, #0]
 800dfc6:	681a      	ldr	r2, [r3, #0]
 800dfc8:	4b44      	ldr	r3, [pc, #272]	; (800e0dc <HAL_ADC_ConfigChannel+0x768>)
 800dfca:	4013      	ands	r3, r2
 800dfcc:	2b00      	cmp	r3, #0
 800dfce:	d07b      	beq.n	800e0c8 <HAL_ADC_ConfigChannel+0x754>
      {
        /* Configuration of common ADC parameters                                 */

        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 800dfd0:	4843      	ldr	r0, [pc, #268]	; (800e0e0 <HAL_ADC_ConfigChannel+0x76c>)
 800dfd2:	f7ff fa1f 	bl	800d414 <LL_ADC_GetCommonPathInternalCh>
 800dfd6:	f8c7 00c4 	str.w	r0, [r7, #196]	; 0xc4

        /* Software is allowed to change common parameters only when all ADCs   */
        /* of the common group are disabled.                                    */
        if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 800dfda:	4842      	ldr	r0, [pc, #264]	; (800e0e4 <HAL_ADC_ConfigChannel+0x770>)
 800dfdc:	f7ff fb46 	bl	800d66c <LL_ADC_IsEnabled>
 800dfe0:	4603      	mov	r3, r0
 800dfe2:	2b00      	cmp	r3, #0
 800dfe4:	d15d      	bne.n	800e0a2 <HAL_ADC_ConfigChannel+0x72e>
        {
          /* If the requested internal measurement path has already been enabled, */
          /* bypass the configuration processing.                                 */
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 800dfe6:	683b      	ldr	r3, [r7, #0]
 800dfe8:	681b      	ldr	r3, [r3, #0]
 800dfea:	4a3f      	ldr	r2, [pc, #252]	; (800e0e8 <HAL_ADC_ConfigChannel+0x774>)
 800dfec:	4293      	cmp	r3, r2
 800dfee:	d126      	bne.n	800e03e <HAL_ADC_ConfigChannel+0x6ca>
 800dff0:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800dff4:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800dff8:	2b00      	cmp	r3, #0
 800dffa:	d120      	bne.n	800e03e <HAL_ADC_ConfigChannel+0x6ca>
          {
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 800dffc:	687b      	ldr	r3, [r7, #4]
 800dffe:	681b      	ldr	r3, [r3, #0]
 800e000:	4a38      	ldr	r2, [pc, #224]	; (800e0e4 <HAL_ADC_ConfigChannel+0x770>)
 800e002:	4293      	cmp	r3, r2
 800e004:	d160      	bne.n	800e0c8 <HAL_ADC_ConfigChannel+0x754>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_TEMPSENSOR | tmp_config_internal_channel);
 800e006:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e00a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800e00e:	4619      	mov	r1, r3
 800e010:	4833      	ldr	r0, [pc, #204]	; (800e0e0 <HAL_ADC_ConfigChannel+0x76c>)
 800e012:	f7ff f9ec 	bl	800d3ee <LL_ADC_SetCommonPathInternalCh>
              /* Delay for temperature sensor stabilization time */
              /* Wait loop initialization and execution */
              /* Note: Variable divided by 2 to compensate partially              */
              /*       CPU processing cycles, scaling in us split to not          */
              /*       exceed 32 bits register capacity and handle low frequency. */
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 800e016:	4b35      	ldr	r3, [pc, #212]	; (800e0ec <HAL_ADC_ConfigChannel+0x778>)
 800e018:	681b      	ldr	r3, [r3, #0]
 800e01a:	099b      	lsrs	r3, r3, #6
 800e01c:	4a34      	ldr	r2, [pc, #208]	; (800e0f0 <HAL_ADC_ConfigChannel+0x77c>)
 800e01e:	fba2 2303 	umull	r2, r3, r2, r3
 800e022:	099a      	lsrs	r2, r3, #6
 800e024:	4613      	mov	r3, r2
 800e026:	005b      	lsls	r3, r3, #1
 800e028:	4413      	add	r3, r2
 800e02a:	009b      	lsls	r3, r3, #2
 800e02c:	60fb      	str	r3, [r7, #12]
              while(wait_loop_index != 0UL)
 800e02e:	e002      	b.n	800e036 <HAL_ADC_ConfigChannel+0x6c2>
              {
                wait_loop_index--;
 800e030:	68fb      	ldr	r3, [r7, #12]
 800e032:	3b01      	subs	r3, #1
 800e034:	60fb      	str	r3, [r7, #12]
              while(wait_loop_index != 0UL)
 800e036:	68fb      	ldr	r3, [r7, #12]
 800e038:	2b00      	cmp	r3, #0
 800e03a:	d1f9      	bne.n	800e030 <HAL_ADC_ConfigChannel+0x6bc>
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 800e03c:	e044      	b.n	800e0c8 <HAL_ADC_ConfigChannel+0x754>
              }
            }
          }
          else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 800e03e:	683b      	ldr	r3, [r7, #0]
 800e040:	681b      	ldr	r3, [r3, #0]
 800e042:	4a2c      	ldr	r2, [pc, #176]	; (800e0f4 <HAL_ADC_ConfigChannel+0x780>)
 800e044:	4293      	cmp	r3, r2
 800e046:	d113      	bne.n	800e070 <HAL_ADC_ConfigChannel+0x6fc>
 800e048:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e04c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 800e050:	2b00      	cmp	r3, #0
 800e052:	d10d      	bne.n	800e070 <HAL_ADC_ConfigChannel+0x6fc>
          {
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 800e054:	687b      	ldr	r3, [r7, #4]
 800e056:	681b      	ldr	r3, [r3, #0]
 800e058:	4a22      	ldr	r2, [pc, #136]	; (800e0e4 <HAL_ADC_ConfigChannel+0x770>)
 800e05a:	4293      	cmp	r3, r2
 800e05c:	d134      	bne.n	800e0c8 <HAL_ADC_ConfigChannel+0x754>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
 800e05e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e062:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800e066:	4619      	mov	r1, r3
 800e068:	481d      	ldr	r0, [pc, #116]	; (800e0e0 <HAL_ADC_ConfigChannel+0x76c>)
 800e06a:	f7ff f9c0 	bl	800d3ee <LL_ADC_SetCommonPathInternalCh>
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 800e06e:	e02b      	b.n	800e0c8 <HAL_ADC_ConfigChannel+0x754>
            }
          }
          else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 800e070:	683b      	ldr	r3, [r7, #0]
 800e072:	681b      	ldr	r3, [r3, #0]
 800e074:	4a20      	ldr	r2, [pc, #128]	; (800e0f8 <HAL_ADC_ConfigChannel+0x784>)
 800e076:	4293      	cmp	r3, r2
 800e078:	d126      	bne.n	800e0c8 <HAL_ADC_ConfigChannel+0x754>
 800e07a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e07e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800e082:	2b00      	cmp	r3, #0
 800e084:	d120      	bne.n	800e0c8 <HAL_ADC_ConfigChannel+0x754>
          {
            if (ADC_VREFINT_INSTANCE(hadc))
 800e086:	687b      	ldr	r3, [r7, #4]
 800e088:	681b      	ldr	r3, [r3, #0]
 800e08a:	4a16      	ldr	r2, [pc, #88]	; (800e0e4 <HAL_ADC_ConfigChannel+0x770>)
 800e08c:	4293      	cmp	r3, r2
 800e08e:	d11b      	bne.n	800e0c8 <HAL_ADC_ConfigChannel+0x754>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_internal_channel);
 800e090:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e094:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800e098:	4619      	mov	r1, r3
 800e09a:	4811      	ldr	r0, [pc, #68]	; (800e0e0 <HAL_ADC_ConfigChannel+0x76c>)
 800e09c:	f7ff f9a7 	bl	800d3ee <LL_ADC_SetCommonPathInternalCh>
 800e0a0:	e012      	b.n	800e0c8 <HAL_ADC_ConfigChannel+0x754>
        /* enabled and other ADC of the common group are enabled, internal      */
        /* measurement paths cannot be enabled.                                 */
        else
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800e0a2:	687b      	ldr	r3, [r7, #4]
 800e0a4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800e0a6:	f043 0220 	orr.w	r2, r3, #32
 800e0aa:	687b      	ldr	r3, [r7, #4]
 800e0ac:	655a      	str	r2, [r3, #84]	; 0x54

          tmp_hal_status = HAL_ERROR;
 800e0ae:	2301      	movs	r3, #1
 800e0b0:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7
 800e0b4:	e008      	b.n	800e0c8 <HAL_ADC_ConfigChannel+0x754>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800e0b6:	687b      	ldr	r3, [r7, #4]
 800e0b8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800e0ba:	f043 0220 	orr.w	r2, r3, #32
 800e0be:	687b      	ldr	r3, [r7, #4]
 800e0c0:	655a      	str	r2, [r3, #84]	; 0x54

    tmp_hal_status = HAL_ERROR;
 800e0c2:	2301      	movs	r3, #1
 800e0c4:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 800e0c8:	687b      	ldr	r3, [r7, #4]
 800e0ca:	2200      	movs	r2, #0
 800e0cc:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
#endif /* ADC_SUPPORT_2_5_MSPS */

  /* Return function status */
  return tmp_hal_status;
 800e0d0:	f897 30d7 	ldrb.w	r3, [r7, #215]	; 0xd7
}
 800e0d4:	4618      	mov	r0, r3
 800e0d6:	37d8      	adds	r7, #216	; 0xd8
 800e0d8:	46bd      	mov	sp, r7
 800e0da:	bd80      	pop	{r7, pc}
 800e0dc:	80080000 	.word	0x80080000
 800e0e0:	50040300 	.word	0x50040300
 800e0e4:	50040000 	.word	0x50040000
 800e0e8:	c7520000 	.word	0xc7520000
 800e0ec:	20000004 	.word	0x20000004
 800e0f0:	053e2d63 	.word	0x053e2d63
 800e0f4:	cb840000 	.word	0xcb840000
 800e0f8:	80000001 	.word	0x80000001

0800e0fc <LL_ADC_SetCommonPathInternalCh>:
{
 800e0fc:	b480      	push	{r7}
 800e0fe:	b083      	sub	sp, #12
 800e100:	af00      	add	r7, sp, #0
 800e102:	6078      	str	r0, [r7, #4]
 800e104:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 800e106:	687b      	ldr	r3, [r7, #4]
 800e108:	689b      	ldr	r3, [r3, #8]
 800e10a:	f023 72e0 	bic.w	r2, r3, #29360128	; 0x1c00000
 800e10e:	683b      	ldr	r3, [r7, #0]
 800e110:	431a      	orrs	r2, r3
 800e112:	687b      	ldr	r3, [r7, #4]
 800e114:	609a      	str	r2, [r3, #8]
}
 800e116:	bf00      	nop
 800e118:	370c      	adds	r7, #12
 800e11a:	46bd      	mov	sp, r7
 800e11c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e120:	4770      	bx	lr

0800e122 <LL_ADC_GetCommonPathInternalCh>:
{
 800e122:	b480      	push	{r7}
 800e124:	b083      	sub	sp, #12
 800e126:	af00      	add	r7, sp, #0
 800e128:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 800e12a:	687b      	ldr	r3, [r7, #4]
 800e12c:	689b      	ldr	r3, [r3, #8]
 800e12e:	f003 73e0 	and.w	r3, r3, #29360128	; 0x1c00000
}
 800e132:	4618      	mov	r0, r3
 800e134:	370c      	adds	r7, #12
 800e136:	46bd      	mov	sp, r7
 800e138:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e13c:	4770      	bx	lr
	...

0800e140 <LL_ADC_SetOffset>:
{
 800e140:	b480      	push	{r7}
 800e142:	b087      	sub	sp, #28
 800e144:	af00      	add	r7, sp, #0
 800e146:	60f8      	str	r0, [r7, #12]
 800e148:	60b9      	str	r1, [r7, #8]
 800e14a:	607a      	str	r2, [r7, #4]
 800e14c:	603b      	str	r3, [r7, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800e14e:	68fb      	ldr	r3, [r7, #12]
 800e150:	3360      	adds	r3, #96	; 0x60
 800e152:	461a      	mov	r2, r3
 800e154:	68bb      	ldr	r3, [r7, #8]
 800e156:	009b      	lsls	r3, r3, #2
 800e158:	4413      	add	r3, r2
 800e15a:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg,
 800e15c:	697b      	ldr	r3, [r7, #20]
 800e15e:	681a      	ldr	r2, [r3, #0]
 800e160:	4b08      	ldr	r3, [pc, #32]	; (800e184 <LL_ADC_SetOffset+0x44>)
 800e162:	4013      	ands	r3, r2
 800e164:	687a      	ldr	r2, [r7, #4]
 800e166:	f002 41f8 	and.w	r1, r2, #2080374784	; 0x7c000000
 800e16a:	683a      	ldr	r2, [r7, #0]
 800e16c:	430a      	orrs	r2, r1
 800e16e:	4313      	orrs	r3, r2
 800e170:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 800e174:	697b      	ldr	r3, [r7, #20]
 800e176:	601a      	str	r2, [r3, #0]
}
 800e178:	bf00      	nop
 800e17a:	371c      	adds	r7, #28
 800e17c:	46bd      	mov	sp, r7
 800e17e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e182:	4770      	bx	lr
 800e184:	03fff000 	.word	0x03fff000

0800e188 <LL_ADC_GetOffsetChannel>:
{
 800e188:	b480      	push	{r7}
 800e18a:	b085      	sub	sp, #20
 800e18c:	af00      	add	r7, sp, #0
 800e18e:	6078      	str	r0, [r7, #4]
 800e190:	6039      	str	r1, [r7, #0]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800e192:	687b      	ldr	r3, [r7, #4]
 800e194:	3360      	adds	r3, #96	; 0x60
 800e196:	461a      	mov	r2, r3
 800e198:	683b      	ldr	r3, [r7, #0]
 800e19a:	009b      	lsls	r3, r3, #2
 800e19c:	4413      	add	r3, r2
 800e19e:	60fb      	str	r3, [r7, #12]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800e1a0:	68fb      	ldr	r3, [r7, #12]
 800e1a2:	681b      	ldr	r3, [r3, #0]
 800e1a4:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
}
 800e1a8:	4618      	mov	r0, r3
 800e1aa:	3714      	adds	r7, #20
 800e1ac:	46bd      	mov	sp, r7
 800e1ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e1b2:	4770      	bx	lr

0800e1b4 <LL_ADC_SetOffsetState>:
{
 800e1b4:	b480      	push	{r7}
 800e1b6:	b087      	sub	sp, #28
 800e1b8:	af00      	add	r7, sp, #0
 800e1ba:	60f8      	str	r0, [r7, #12]
 800e1bc:	60b9      	str	r1, [r7, #8]
 800e1be:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800e1c0:	68fb      	ldr	r3, [r7, #12]
 800e1c2:	3360      	adds	r3, #96	; 0x60
 800e1c4:	461a      	mov	r2, r3
 800e1c6:	68bb      	ldr	r3, [r7, #8]
 800e1c8:	009b      	lsls	r3, r3, #2
 800e1ca:	4413      	add	r3, r2
 800e1cc:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg,
 800e1ce:	697b      	ldr	r3, [r7, #20]
 800e1d0:	681b      	ldr	r3, [r3, #0]
 800e1d2:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 800e1d6:	687b      	ldr	r3, [r7, #4]
 800e1d8:	431a      	orrs	r2, r3
 800e1da:	697b      	ldr	r3, [r7, #20]
 800e1dc:	601a      	str	r2, [r3, #0]
}
 800e1de:	bf00      	nop
 800e1e0:	371c      	adds	r7, #28
 800e1e2:	46bd      	mov	sp, r7
 800e1e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e1e8:	4770      	bx	lr

0800e1ea <LL_ADC_INJ_SetQueueMode>:
{
 800e1ea:	b480      	push	{r7}
 800e1ec:	b083      	sub	sp, #12
 800e1ee:	af00      	add	r7, sp, #0
 800e1f0:	6078      	str	r0, [r7, #4]
 800e1f2:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_JQM | ADC_CFGR_JQDIS, QueueMode);
 800e1f4:	687b      	ldr	r3, [r7, #4]
 800e1f6:	68db      	ldr	r3, [r3, #12]
 800e1f8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800e1fc:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800e200:	683a      	ldr	r2, [r7, #0]
 800e202:	431a      	orrs	r2, r3
 800e204:	687b      	ldr	r3, [r7, #4]
 800e206:	60da      	str	r2, [r3, #12]
}
 800e208:	bf00      	nop
 800e20a:	370c      	adds	r7, #12
 800e20c:	46bd      	mov	sp, r7
 800e20e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e212:	4770      	bx	lr

0800e214 <LL_ADC_SetChannelSamplingTime>:
{
 800e214:	b480      	push	{r7}
 800e216:	b087      	sub	sp, #28
 800e218:	af00      	add	r7, sp, #0
 800e21a:	60f8      	str	r0, [r7, #12]
 800e21c:	60b9      	str	r1, [r7, #8]
 800e21e:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 800e220:	68fb      	ldr	r3, [r7, #12]
 800e222:	3314      	adds	r3, #20
 800e224:	461a      	mov	r2, r3
 800e226:	68bb      	ldr	r3, [r7, #8]
 800e228:	0e5b      	lsrs	r3, r3, #25
 800e22a:	009b      	lsls	r3, r3, #2
 800e22c:	f003 0304 	and.w	r3, r3, #4
 800e230:	4413      	add	r3, r2
 800e232:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg,
 800e234:	697b      	ldr	r3, [r7, #20]
 800e236:	681a      	ldr	r2, [r3, #0]
 800e238:	68bb      	ldr	r3, [r7, #8]
 800e23a:	0d1b      	lsrs	r3, r3, #20
 800e23c:	f003 031f 	and.w	r3, r3, #31
 800e240:	2107      	movs	r1, #7
 800e242:	fa01 f303 	lsl.w	r3, r1, r3
 800e246:	43db      	mvns	r3, r3
 800e248:	401a      	ands	r2, r3
 800e24a:	68bb      	ldr	r3, [r7, #8]
 800e24c:	0d1b      	lsrs	r3, r3, #20
 800e24e:	f003 031f 	and.w	r3, r3, #31
 800e252:	6879      	ldr	r1, [r7, #4]
 800e254:	fa01 f303 	lsl.w	r3, r1, r3
 800e258:	431a      	orrs	r2, r3
 800e25a:	697b      	ldr	r3, [r7, #20]
 800e25c:	601a      	str	r2, [r3, #0]
}
 800e25e:	bf00      	nop
 800e260:	371c      	adds	r7, #28
 800e262:	46bd      	mov	sp, r7
 800e264:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e268:	4770      	bx	lr
	...

0800e26c <LL_ADC_SetChannelSingleDiff>:
{
 800e26c:	b480      	push	{r7}
 800e26e:	b085      	sub	sp, #20
 800e270:	af00      	add	r7, sp, #0
 800e272:	60f8      	str	r0, [r7, #12]
 800e274:	60b9      	str	r1, [r7, #8]
 800e276:	607a      	str	r2, [r7, #4]
  MODIFY_REG(ADCx->DIFSEL,
 800e278:	68fb      	ldr	r3, [r7, #12]
 800e27a:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
 800e27e:	68bb      	ldr	r3, [r7, #8]
 800e280:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800e284:	43db      	mvns	r3, r3
 800e286:	401a      	ands	r2, r3
 800e288:	687b      	ldr	r3, [r7, #4]
 800e28a:	f003 0318 	and.w	r3, r3, #24
 800e28e:	4908      	ldr	r1, [pc, #32]	; (800e2b0 <LL_ADC_SetChannelSingleDiff+0x44>)
 800e290:	40d9      	lsrs	r1, r3
 800e292:	68bb      	ldr	r3, [r7, #8]
 800e294:	400b      	ands	r3, r1
 800e296:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800e29a:	431a      	orrs	r2, r3
 800e29c:	68fb      	ldr	r3, [r7, #12]
 800e29e:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
}
 800e2a2:	bf00      	nop
 800e2a4:	3714      	adds	r7, #20
 800e2a6:	46bd      	mov	sp, r7
 800e2a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e2ac:	4770      	bx	lr
 800e2ae:	bf00      	nop
 800e2b0:	0007ffff 	.word	0x0007ffff

0800e2b4 <LL_ADC_IsEnabled>:
{
 800e2b4:	b480      	push	{r7}
 800e2b6:	b083      	sub	sp, #12
 800e2b8:	af00      	add	r7, sp, #0
 800e2ba:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 800e2bc:	687b      	ldr	r3, [r7, #4]
 800e2be:	689b      	ldr	r3, [r3, #8]
 800e2c0:	f003 0301 	and.w	r3, r3, #1
 800e2c4:	2b01      	cmp	r3, #1
 800e2c6:	d101      	bne.n	800e2cc <LL_ADC_IsEnabled+0x18>
 800e2c8:	2301      	movs	r3, #1
 800e2ca:	e000      	b.n	800e2ce <LL_ADC_IsEnabled+0x1a>
 800e2cc:	2300      	movs	r3, #0
}
 800e2ce:	4618      	mov	r0, r3
 800e2d0:	370c      	adds	r7, #12
 800e2d2:	46bd      	mov	sp, r7
 800e2d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e2d8:	4770      	bx	lr

0800e2da <LL_ADC_REG_IsConversionOngoing>:
{
 800e2da:	b480      	push	{r7}
 800e2dc:	b083      	sub	sp, #12
 800e2de:	af00      	add	r7, sp, #0
 800e2e0:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 800e2e2:	687b      	ldr	r3, [r7, #4]
 800e2e4:	689b      	ldr	r3, [r3, #8]
 800e2e6:	f003 0304 	and.w	r3, r3, #4
 800e2ea:	2b04      	cmp	r3, #4
 800e2ec:	d101      	bne.n	800e2f2 <LL_ADC_REG_IsConversionOngoing+0x18>
 800e2ee:	2301      	movs	r3, #1
 800e2f0:	e000      	b.n	800e2f4 <LL_ADC_REG_IsConversionOngoing+0x1a>
 800e2f2:	2300      	movs	r3, #0
}
 800e2f4:	4618      	mov	r0, r3
 800e2f6:	370c      	adds	r7, #12
 800e2f8:	46bd      	mov	sp, r7
 800e2fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e2fe:	4770      	bx	lr

0800e300 <LL_ADC_INJ_IsConversionOngoing>:
{
 800e300:	b480      	push	{r7}
 800e302:	b083      	sub	sp, #12
 800e304:	af00      	add	r7, sp, #0
 800e306:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 800e308:	687b      	ldr	r3, [r7, #4]
 800e30a:	689b      	ldr	r3, [r3, #8]
 800e30c:	f003 0308 	and.w	r3, r3, #8
 800e310:	2b08      	cmp	r3, #8
 800e312:	d101      	bne.n	800e318 <LL_ADC_INJ_IsConversionOngoing+0x18>
 800e314:	2301      	movs	r3, #1
 800e316:	e000      	b.n	800e31a <LL_ADC_INJ_IsConversionOngoing+0x1a>
 800e318:	2300      	movs	r3, #0
}
 800e31a:	4618      	mov	r0, r3
 800e31c:	370c      	adds	r7, #12
 800e31e:	46bd      	mov	sp, r7
 800e320:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e324:	4770      	bx	lr
	...

0800e328 <HAL_ADCEx_InjectedConfigChannel>:
  * @param sConfigInjected Structure of ADC injected group and ADC channel for
  *         injected group.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef *hadc, ADC_InjectionConfTypeDef *sConfigInjected)
{
 800e328:	b580      	push	{r7, lr}
 800e32a:	b0b6      	sub	sp, #216	; 0xd8
 800e32c:	af00      	add	r7, sp, #0
 800e32e:	6078      	str	r0, [r7, #4]
 800e330:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800e332:	2300      	movs	r3, #0
 800e334:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7
  uint32_t tmpOffsetShifted;
  uint32_t tmp_config_internal_channel;
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;
  __IO uint32_t wait_loop_index = 0;
 800e338:	2300      	movs	r3, #0
 800e33a:	60bb      	str	r3, [r7, #8]

  uint32_t tmp_JSQR_ContextQueueBeingBuilt = 0U;
 800e33c:	2300      	movs	r3, #0
 800e33e:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfigInjected->InjectedChannel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 800e342:	687b      	ldr	r3, [r7, #4]
 800e344:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800e348:	2b01      	cmp	r3, #1
 800e34a:	d102      	bne.n	800e352 <HAL_ADCEx_InjectedConfigChannel+0x2a>
 800e34c:	2302      	movs	r3, #2
 800e34e:	f000 bc85 	b.w	800ec5c <HAL_ADCEx_InjectedConfigChannel+0x934>
 800e352:	687b      	ldr	r3, [r7, #4]
 800e354:	2201      	movs	r2, #1
 800e356:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  /*      injected channel rank. It is entered into queue only when all       */
  /*      injected ranks have been set.                                       */
  /*   Note: Scan mode is not present by hardware on this device, but used    */
  /*   by software for alignment over all STM32 devices.                      */

  if ((hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)  ||
 800e35a:	687b      	ldr	r3, [r7, #4]
 800e35c:	691b      	ldr	r3, [r3, #16]
 800e35e:	2b00      	cmp	r3, #0
 800e360:	d003      	beq.n	800e36a <HAL_ADCEx_InjectedConfigChannel+0x42>
      (sConfigInjected->InjectedNbrOfConversion == 1U))
 800e362:	683b      	ldr	r3, [r7, #0]
 800e364:	699b      	ldr	r3, [r3, #24]
  if ((hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)  ||
 800e366:	2b01      	cmp	r3, #1
 800e368:	d130      	bne.n	800e3cc <HAL_ADCEx_InjectedConfigChannel+0xa4>
    /*    (scan mode disabled, only rank 1 used)                              */
    /*  - external trigger to start conversion                                */
    /*  - external trigger polarity                                           */
    /*  - channel set to rank 1 (scan mode disabled, only rank 1 can be used) */

    if (sConfigInjected->InjectedRank == ADC_INJECTED_RANK_1)
 800e36a:	683b      	ldr	r3, [r7, #0]
 800e36c:	685b      	ldr	r3, [r3, #4]
 800e36e:	2b08      	cmp	r3, #8
 800e370:	d179      	bne.n	800e466 <HAL_ADCEx_InjectedConfigChannel+0x13e>
      /* Enable external trigger if trigger selection is different of         */
      /* software start.                                                      */
      /* Note: This configuration keeps the hardware feature of parameter     */
      /*       ExternalTrigInjecConvEdge "trigger edge none" equivalent to    */
      /*       software start.                                                */
      if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 800e372:	683b      	ldr	r3, [r7, #0]
 800e374:	6a1b      	ldr	r3, [r3, #32]
 800e376:	2b00      	cmp	r3, #0
 800e378:	d010      	beq.n	800e39c <HAL_ADCEx_InjectedConfigChannel+0x74>
      {
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 800e37a:	683b      	ldr	r3, [r7, #0]
 800e37c:	681b      	ldr	r3, [r3, #0]
 800e37e:	0e9b      	lsrs	r3, r3, #26
 800e380:	021b      	lsls	r3, r3, #8
 800e382:	f403 52f8 	and.w	r2, r3, #7936	; 0x1f00
                                           | (sConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
 800e386:	683b      	ldr	r3, [r7, #0]
 800e388:	6a1b      	ldr	r3, [r3, #32]
 800e38a:	f003 033c 	and.w	r3, r3, #60	; 0x3c
 800e38e:	431a      	orrs	r2, r3
                                           | sConfigInjected->ExternalTrigInjecConvEdge
 800e390:	683b      	ldr	r3, [r7, #0]
 800e392:	6a5b      	ldr	r3, [r3, #36]	; 0x24
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1)
 800e394:	4313      	orrs	r3, r2
 800e396:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 800e39a:	e007      	b.n	800e3ac <HAL_ADCEx_InjectedConfigChannel+0x84>
                                          );
      }
      else
      {
        tmp_JSQR_ContextQueueBeingBuilt = (ADC_JSQR_RK(sConfigInjected->InjectedChannel, ADC_INJECTED_RANK_1));
 800e39c:	683b      	ldr	r3, [r7, #0]
 800e39e:	681b      	ldr	r3, [r3, #0]
 800e3a0:	0e9b      	lsrs	r3, r3, #26
 800e3a2:	021b      	lsls	r3, r3, #8
 800e3a4:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
 800e3a8:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
      }

      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, tmp_JSQR_ContextQueueBeingBuilt);
 800e3ac:	687b      	ldr	r3, [r7, #4]
 800e3ae:	681b      	ldr	r3, [r3, #0]
 800e3b0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800e3b2:	4ba0      	ldr	r3, [pc, #640]	; (800e634 <HAL_ADCEx_InjectedConfigChannel+0x30c>)
 800e3b4:	4013      	ands	r3, r2
 800e3b6:	687a      	ldr	r2, [r7, #4]
 800e3b8:	6812      	ldr	r2, [r2, #0]
 800e3ba:	f8d7 10d0 	ldr.w	r1, [r7, #208]	; 0xd0
 800e3be:	430b      	orrs	r3, r1
 800e3c0:	64d3      	str	r3, [r2, #76]	; 0x4c
      /* For debug and informative reasons, hadc handle saves JSQR setting */
      hadc->InjectionConfig.ContextQueue = tmp_JSQR_ContextQueueBeingBuilt;
 800e3c2:	687b      	ldr	r3, [r7, #4]
 800e3c4:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 800e3c8:	65da      	str	r2, [r3, #92]	; 0x5c
    if (sConfigInjected->InjectedRank == ADC_INJECTED_RANK_1)
 800e3ca:	e04c      	b.n	800e466 <HAL_ADCEx_InjectedConfigChannel+0x13e>
    /* 1. Start new context and set parameters related to all injected        */
    /*    channels: injected sequence length and trigger.                     */

    /* if hadc->InjectionConfig.ChannelCount is equal to 0, this is the first */
    /*   call of the context under setting                                    */
    if (hadc->InjectionConfig.ChannelCount == 0U)
 800e3cc:	687b      	ldr	r3, [r7, #4]
 800e3ce:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800e3d0:	2b00      	cmp	r3, #0
 800e3d2:	d11d      	bne.n	800e410 <HAL_ADCEx_InjectedConfigChannel+0xe8>
    {
      /* Initialize number of channels that will be configured on the context */
      /*  being built                                                         */
      hadc->InjectionConfig.ChannelCount = sConfigInjected->InjectedNbrOfConversion;
 800e3d4:	683b      	ldr	r3, [r7, #0]
 800e3d6:	699a      	ldr	r2, [r3, #24]
 800e3d8:	687b      	ldr	r3, [r7, #4]
 800e3da:	661a      	str	r2, [r3, #96]	; 0x60
      /* Handle hadc saves the context under build up over each HAL_ADCEx_InjectedConfigChannel()
         call, this context will be written in JSQR register at the last call.
         At this point, the context is merely reset  */
      hadc->InjectionConfig.ContextQueue = 0x00000000U;
 800e3dc:	687b      	ldr	r3, [r7, #4]
 800e3de:	2200      	movs	r2, #0
 800e3e0:	65da      	str	r2, [r3, #92]	; 0x5c
      /* Enable external trigger if trigger selection is different of         */
      /* software start.                                                      */
      /* Note: This configuration keeps the hardware feature of parameter     */
      /*       ExternalTrigInjecConvEdge "trigger edge none" equivalent to    */
      /*       software start.                                                */
      if (sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
 800e3e2:	683b      	ldr	r3, [r7, #0]
 800e3e4:	6a1b      	ldr	r3, [r3, #32]
 800e3e6:	2b00      	cmp	r3, #0
 800e3e8:	d00d      	beq.n	800e406 <HAL_ADCEx_InjectedConfigChannel+0xde>
      {
        tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U)
 800e3ea:	683b      	ldr	r3, [r7, #0]
 800e3ec:	699b      	ldr	r3, [r3, #24]
 800e3ee:	1e5a      	subs	r2, r3, #1
                                           | (sConfigInjected->ExternalTrigInjecConv & ADC_JSQR_JEXTSEL)
 800e3f0:	683b      	ldr	r3, [r7, #0]
 800e3f2:	6a1b      	ldr	r3, [r3, #32]
 800e3f4:	f003 033c 	and.w	r3, r3, #60	; 0x3c
 800e3f8:	431a      	orrs	r2, r3
                                           | sConfigInjected->ExternalTrigInjecConvEdge
 800e3fa:	683b      	ldr	r3, [r7, #0]
 800e3fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
        tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U)
 800e3fe:	4313      	orrs	r3, r2
 800e400:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 800e404:	e004      	b.n	800e410 <HAL_ADCEx_InjectedConfigChannel+0xe8>
                                          );
      }
      else
      {
        tmp_JSQR_ContextQueueBeingBuilt = ((sConfigInjected->InjectedNbrOfConversion - 1U));
 800e406:	683b      	ldr	r3, [r7, #0]
 800e408:	699b      	ldr	r3, [r3, #24]
 800e40a:	3b01      	subs	r3, #1
 800e40c:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
    /*    related to each channel: channel rank sequence                    */
    /* Clear the old JSQx bits for the selected rank */
    tmp_JSQR_ContextQueueBeingBuilt &= ~ADC_JSQR_RK(ADC_SQR3_SQ10, sConfigInjected->InjectedRank);

    /* Set the JSQx bits for the selected rank */
    tmp_JSQR_ContextQueueBeingBuilt |= ADC_JSQR_RK(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank);
 800e410:	683b      	ldr	r3, [r7, #0]
 800e412:	681b      	ldr	r3, [r3, #0]
 800e414:	0e9b      	lsrs	r3, r3, #26
 800e416:	f003 021f 	and.w	r2, r3, #31
 800e41a:	683b      	ldr	r3, [r7, #0]
 800e41c:	685b      	ldr	r3, [r3, #4]
 800e41e:	f003 031f 	and.w	r3, r3, #31
 800e422:	fa02 f303 	lsl.w	r3, r2, r3
 800e426:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 800e42a:	4313      	orrs	r3, r2
 800e42c:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0

    /* Decrease channel count  */
    hadc->InjectionConfig.ChannelCount--;
 800e430:	687b      	ldr	r3, [r7, #4]
 800e432:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800e434:	1e5a      	subs	r2, r3, #1
 800e436:	687b      	ldr	r3, [r7, #4]
 800e438:	661a      	str	r2, [r3, #96]	; 0x60

    /* 3. tmp_JSQR_ContextQueueBeingBuilt is fully built for this HAL_ADCEx_InjectedConfigChannel()
          call, aggregate the setting to those already built during the previous
          HAL_ADCEx_InjectedConfigChannel() calls (for the same context of course)  */
    hadc->InjectionConfig.ContextQueue |= tmp_JSQR_ContextQueueBeingBuilt;
 800e43a:	687b      	ldr	r3, [r7, #4]
 800e43c:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800e43e:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 800e442:	431a      	orrs	r2, r3
 800e444:	687b      	ldr	r3, [r7, #4]
 800e446:	65da      	str	r2, [r3, #92]	; 0x5c

    /* 4. End of context setting: if this is the last channel set, then write context
        into register JSQR and make it enter into queue                   */
    if (hadc->InjectionConfig.ChannelCount == 0U)
 800e448:	687b      	ldr	r3, [r7, #4]
 800e44a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800e44c:	2b00      	cmp	r3, #0
 800e44e:	d10a      	bne.n	800e466 <HAL_ADCEx_InjectedConfigChannel+0x13e>
    {
      MODIFY_REG(hadc->Instance->JSQR, ADC_JSQR_FIELDS, hadc->InjectionConfig.ContextQueue);
 800e450:	687b      	ldr	r3, [r7, #4]
 800e452:	681b      	ldr	r3, [r3, #0]
 800e454:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800e456:	4b77      	ldr	r3, [pc, #476]	; (800e634 <HAL_ADCEx_InjectedConfigChannel+0x30c>)
 800e458:	4013      	ands	r3, r2
 800e45a:	687a      	ldr	r2, [r7, #4]
 800e45c:	6dd1      	ldr	r1, [r2, #92]	; 0x5c
 800e45e:	687a      	ldr	r2, [r7, #4]
 800e460:	6812      	ldr	r2, [r2, #0]
 800e462:	430b      	orrs	r3, r1
 800e464:	64d3      	str	r3, [r2, #76]	; 0x4c
  /* conversion on going on injected group:                                   */
  /*  - Injected context queue: Queue disable (active context is kept) or     */
  /*    enable (context decremented, up to 2 contexts queued)                 */
  /*  - Injected discontinuous mode: can be enabled only if auto-injected     */
  /*    mode is disabled.                                                     */
  if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
 800e466:	687b      	ldr	r3, [r7, #4]
 800e468:	681b      	ldr	r3, [r3, #0]
 800e46a:	4618      	mov	r0, r3
 800e46c:	f7ff ff48 	bl	800e300 <LL_ADC_INJ_IsConversionOngoing>
 800e470:	4603      	mov	r3, r0
 800e472:	2b00      	cmp	r3, #0
 800e474:	d120      	bne.n	800e4b8 <HAL_ADCEx_InjectedConfigChannel+0x190>
  {
    /* If auto-injected mode is disabled: no constraint                       */
    if (sConfigInjected->AutoInjectedConv == DISABLE)
 800e476:	683b      	ldr	r3, [r7, #0]
 800e478:	7f5b      	ldrb	r3, [r3, #29]
 800e47a:	2b00      	cmp	r3, #0
 800e47c:	d110      	bne.n	800e4a0 <HAL_ADCEx_InjectedConfigChannel+0x178>
    {
      MODIFY_REG(hadc->Instance->CFGR,
 800e47e:	687b      	ldr	r3, [r7, #4]
 800e480:	681b      	ldr	r3, [r3, #0]
 800e482:	68db      	ldr	r3, [r3, #12]
 800e484:	f423 1140 	bic.w	r1, r3, #3145728	; 0x300000
 800e488:	683b      	ldr	r3, [r7, #0]
 800e48a:	7f9b      	ldrb	r3, [r3, #30]
 800e48c:	055a      	lsls	r2, r3, #21
 800e48e:	683b      	ldr	r3, [r7, #0]
 800e490:	7f1b      	ldrb	r3, [r3, #28]
 800e492:	051b      	lsls	r3, r3, #20
 800e494:	431a      	orrs	r2, r3
 800e496:	687b      	ldr	r3, [r7, #4]
 800e498:	681b      	ldr	r3, [r3, #0]
 800e49a:	430a      	orrs	r2, r1
 800e49c:	60da      	str	r2, [r3, #12]
 800e49e:	e00b      	b.n	800e4b8 <HAL_ADCEx_InjectedConfigChannel+0x190>
    }
    /* If auto-injected mode is enabled: Injected discontinuous setting is    */
    /* discarded.                                                             */
    else
    {
      MODIFY_REG(hadc->Instance->CFGR,
 800e4a0:	687b      	ldr	r3, [r7, #4]
 800e4a2:	681b      	ldr	r3, [r3, #0]
 800e4a4:	68db      	ldr	r3, [r3, #12]
 800e4a6:	f423 1140 	bic.w	r1, r3, #3145728	; 0x300000
 800e4aa:	683b      	ldr	r3, [r7, #0]
 800e4ac:	7f9b      	ldrb	r3, [r3, #30]
 800e4ae:	055a      	lsls	r2, r3, #21
 800e4b0:	687b      	ldr	r3, [r7, #4]
 800e4b2:	681b      	ldr	r3, [r3, #0]
 800e4b4:	430a      	orrs	r2, r1
 800e4b6:	60da      	str	r2, [r3, #12]
  /* conversion on going on regular and injected groups:                      */
  /*  - Automatic injected conversion: can be enabled if injected group       */
  /*    external triggers are disabled.                                       */
  /*  - Channel sampling time                                                 */
  /*  - Channel offset                                                        */
  tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 800e4b8:	687b      	ldr	r3, [r7, #4]
 800e4ba:	681b      	ldr	r3, [r3, #0]
 800e4bc:	4618      	mov	r0, r3
 800e4be:	f7ff ff0c 	bl	800e2da <LL_ADC_REG_IsConversionOngoing>
 800e4c2:	f8c7 00cc 	str.w	r0, [r7, #204]	; 0xcc
  tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 800e4c6:	687b      	ldr	r3, [r7, #4]
 800e4c8:	681b      	ldr	r3, [r3, #0]
 800e4ca:	4618      	mov	r0, r3
 800e4cc:	f7ff ff18 	bl	800e300 <LL_ADC_INJ_IsConversionOngoing>
 800e4d0:	f8c7 00c8 	str.w	r0, [r7, #200]	; 0xc8

  if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 800e4d4:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 800e4d8:	2b00      	cmp	r3, #0
 800e4da:	f040 81f8 	bne.w	800e8ce <HAL_ADCEx_InjectedConfigChannel+0x5a6>
      && (tmp_adc_is_conversion_on_going_injected == 0UL)
 800e4de:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 800e4e2:	2b00      	cmp	r3, #0
 800e4e4:	f040 81f3 	bne.w	800e8ce <HAL_ADCEx_InjectedConfigChannel+0x5a6>
     )
  {
    /* If injected group external triggers are disabled (set to injected      */
    /* software start): no constraint                                         */
    if ((sConfigInjected->ExternalTrigInjecConv == ADC_INJECTED_SOFTWARE_START)
 800e4e8:	683b      	ldr	r3, [r7, #0]
 800e4ea:	6a1b      	ldr	r3, [r3, #32]
 800e4ec:	2b00      	cmp	r3, #0
 800e4ee:	d003      	beq.n	800e4f8 <HAL_ADCEx_InjectedConfigChannel+0x1d0>
        || (sConfigInjected->ExternalTrigInjecConvEdge == ADC_EXTERNALTRIGINJECCONV_EDGE_NONE))
 800e4f0:	683b      	ldr	r3, [r7, #0]
 800e4f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e4f4:	2b00      	cmp	r3, #0
 800e4f6:	d115      	bne.n	800e524 <HAL_ADCEx_InjectedConfigChannel+0x1fc>
    {
      if (sConfigInjected->AutoInjectedConv == ENABLE)
 800e4f8:	683b      	ldr	r3, [r7, #0]
 800e4fa:	7f5b      	ldrb	r3, [r3, #29]
 800e4fc:	2b01      	cmp	r3, #1
 800e4fe:	d108      	bne.n	800e512 <HAL_ADCEx_InjectedConfigChannel+0x1ea>
      {
        SET_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 800e500:	687b      	ldr	r3, [r7, #4]
 800e502:	681b      	ldr	r3, [r3, #0]
 800e504:	68da      	ldr	r2, [r3, #12]
 800e506:	687b      	ldr	r3, [r7, #4]
 800e508:	681b      	ldr	r3, [r3, #0]
 800e50a:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 800e50e:	60da      	str	r2, [r3, #12]
      if (sConfigInjected->AutoInjectedConv == ENABLE)
 800e510:	e01e      	b.n	800e550 <HAL_ADCEx_InjectedConfigChannel+0x228>
      }
      else
      {
        CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 800e512:	687b      	ldr	r3, [r7, #4]
 800e514:	681b      	ldr	r3, [r3, #0]
 800e516:	68da      	ldr	r2, [r3, #12]
 800e518:	687b      	ldr	r3, [r7, #4]
 800e51a:	681b      	ldr	r3, [r3, #0]
 800e51c:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
 800e520:	60da      	str	r2, [r3, #12]
      if (sConfigInjected->AutoInjectedConv == ENABLE)
 800e522:	e015      	b.n	800e550 <HAL_ADCEx_InjectedConfigChannel+0x228>
    }
    /* If Automatic injected conversion was intended to be set and could not  */
    /* due to injected group external triggers enabled, error is reported.    */
    else
    {
      if (sConfigInjected->AutoInjectedConv == ENABLE)
 800e524:	683b      	ldr	r3, [r7, #0]
 800e526:	7f5b      	ldrb	r3, [r3, #29]
 800e528:	2b01      	cmp	r3, #1
 800e52a:	d109      	bne.n	800e540 <HAL_ADCEx_InjectedConfigChannel+0x218>
      {
        /* Update ADC state machine to error */
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800e52c:	687b      	ldr	r3, [r7, #4]
 800e52e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800e530:	f043 0220 	orr.w	r2, r3, #32
 800e534:	687b      	ldr	r3, [r7, #4]
 800e536:	655a      	str	r2, [r3, #84]	; 0x54

        tmp_hal_status = HAL_ERROR;
 800e538:	2301      	movs	r3, #1
 800e53a:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7
 800e53e:	e007      	b.n	800e550 <HAL_ADCEx_InjectedConfigChannel+0x228>
      }
      else
      {
        CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO);
 800e540:	687b      	ldr	r3, [r7, #4]
 800e542:	681b      	ldr	r3, [r3, #0]
 800e544:	68da      	ldr	r2, [r3, #12]
 800e546:	687b      	ldr	r3, [r7, #4]
 800e548:	681b      	ldr	r3, [r3, #0]
 800e54a:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
 800e54e:	60da      	str	r2, [r3, #12]
      }
    }

    if (sConfigInjected->InjecOversamplingMode == ENABLE)
 800e550:	683b      	ldr	r3, [r7, #0]
 800e552:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 800e556:	2b01      	cmp	r3, #1
 800e558:	d110      	bne.n	800e57c <HAL_ADCEx_InjectedConfigChannel+0x254>
      /* Configuration of Injected Oversampler:                                 */
      /*  - Oversampling Ratio                                                  */
      /*  - Right bit shift                                                     */

      /* Enable OverSampling mode */
      MODIFY_REG(hadc->Instance->CFGR2,
 800e55a:	687b      	ldr	r3, [r7, #4]
 800e55c:	681b      	ldr	r3, [r3, #0]
 800e55e:	691b      	ldr	r3, [r3, #16]
 800e560:	f423 72ff 	bic.w	r2, r3, #510	; 0x1fe
 800e564:	683b      	ldr	r3, [r7, #0]
 800e566:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 800e568:	683b      	ldr	r3, [r7, #0]
 800e56a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e56c:	430b      	orrs	r3, r1
 800e56e:	431a      	orrs	r2, r3
 800e570:	687b      	ldr	r3, [r7, #4]
 800e572:	681b      	ldr	r3, [r3, #0]
 800e574:	f042 0202 	orr.w	r2, r2, #2
 800e578:	611a      	str	r2, [r3, #16]
 800e57a:	e007      	b.n	800e58c <HAL_ADCEx_InjectedConfigChannel+0x264>
                );
    }
    else
    {
      /* Disable Regular OverSampling */
      CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_JOVSE);
 800e57c:	687b      	ldr	r3, [r7, #4]
 800e57e:	681b      	ldr	r3, [r3, #0]
 800e580:	691a      	ldr	r2, [r3, #16]
 800e582:	687b      	ldr	r3, [r7, #4]
 800e584:	681b      	ldr	r3, [r3, #0]
 800e586:	f022 0202 	bic.w	r2, r2, #2
 800e58a:	611a      	str	r2, [r3, #16]
    }

      /* Set sampling time of the selected ADC channel */
      LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfigInjected->InjectedChannel, sConfigInjected->InjectedSamplingTime);
 800e58c:	687b      	ldr	r3, [r7, #4]
 800e58e:	6818      	ldr	r0, [r3, #0]
 800e590:	683b      	ldr	r3, [r7, #0]
 800e592:	6819      	ldr	r1, [r3, #0]
 800e594:	683b      	ldr	r3, [r7, #0]
 800e596:	689b      	ldr	r3, [r3, #8]
 800e598:	461a      	mov	r2, r3
 800e59a:	f7ff fe3b 	bl	800e214 <LL_ADC_SetChannelSamplingTime>

    /* Configure the offset: offset enable/disable, channel, offset value */

    /* Shift the offset with respect to the selected ADC resolution. */
    /* Offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0 */
    tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfigInjected->InjectedOffset);
 800e59e:	683b      	ldr	r3, [r7, #0]
 800e5a0:	695a      	ldr	r2, [r3, #20]
 800e5a2:	687b      	ldr	r3, [r7, #4]
 800e5a4:	681b      	ldr	r3, [r3, #0]
 800e5a6:	68db      	ldr	r3, [r3, #12]
 800e5a8:	08db      	lsrs	r3, r3, #3
 800e5aa:	f003 0303 	and.w	r3, r3, #3
 800e5ae:	005b      	lsls	r3, r3, #1
 800e5b0:	fa02 f303 	lsl.w	r3, r2, r3
 800e5b4:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

    if (sConfigInjected->InjectedOffsetNumber != ADC_OFFSET_NONE)
 800e5b8:	683b      	ldr	r3, [r7, #0]
 800e5ba:	691b      	ldr	r3, [r3, #16]
 800e5bc:	2b04      	cmp	r3, #4
 800e5be:	d00a      	beq.n	800e5d6 <HAL_ADCEx_InjectedConfigChannel+0x2ae>
    {
      /* Set ADC selected offset number */
      LL_ADC_SetOffset(hadc->Instance, sConfigInjected->InjectedOffsetNumber, sConfigInjected->InjectedChannel,
 800e5c0:	687b      	ldr	r3, [r7, #4]
 800e5c2:	6818      	ldr	r0, [r3, #0]
 800e5c4:	683b      	ldr	r3, [r7, #0]
 800e5c6:	6919      	ldr	r1, [r3, #16]
 800e5c8:	683b      	ldr	r3, [r7, #0]
 800e5ca:	681a      	ldr	r2, [r3, #0]
 800e5cc:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e5d0:	f7ff fdb6 	bl	800e140 <LL_ADC_SetOffset>
 800e5d4:	e17b      	b.n	800e8ce <HAL_ADCEx_InjectedConfigChannel+0x5a6>
    }
    else
    {
      /* Scan each offset register to check if the selected channel is targeted. */
      /* If this is the case, the corresponding offset number is disabled.       */
      if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 800e5d6:	687b      	ldr	r3, [r7, #4]
 800e5d8:	681b      	ldr	r3, [r3, #0]
 800e5da:	2100      	movs	r1, #0
 800e5dc:	4618      	mov	r0, r3
 800e5de:	f7ff fdd3 	bl	800e188 <LL_ADC_GetOffsetChannel>
 800e5e2:	4603      	mov	r3, r0
 800e5e4:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800e5e8:	2b00      	cmp	r3, #0
 800e5ea:	d10a      	bne.n	800e602 <HAL_ADCEx_InjectedConfigChannel+0x2da>
 800e5ec:	687b      	ldr	r3, [r7, #4]
 800e5ee:	681b      	ldr	r3, [r3, #0]
 800e5f0:	2100      	movs	r1, #0
 800e5f2:	4618      	mov	r0, r3
 800e5f4:	f7ff fdc8 	bl	800e188 <LL_ADC_GetOffsetChannel>
 800e5f8:	4603      	mov	r3, r0
 800e5fa:	0e9b      	lsrs	r3, r3, #26
 800e5fc:	f003 021f 	and.w	r2, r3, #31
 800e600:	e020      	b.n	800e644 <HAL_ADCEx_InjectedConfigChannel+0x31c>
 800e602:	687b      	ldr	r3, [r7, #4]
 800e604:	681b      	ldr	r3, [r3, #0]
 800e606:	2100      	movs	r1, #0
 800e608:	4618      	mov	r0, r3
 800e60a:	f7ff fdbd 	bl	800e188 <LL_ADC_GetOffsetChannel>
 800e60e:	4603      	mov	r3, r0
 800e610:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e614:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800e618:	fa93 f3a3 	rbit	r3, r3
 800e61c:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  return result;
 800e620:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800e624:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
  if (value == 0U)
 800e628:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800e62c:	2b00      	cmp	r3, #0
 800e62e:	d103      	bne.n	800e638 <HAL_ADCEx_InjectedConfigChannel+0x310>
    return 32U;
 800e630:	2320      	movs	r3, #32
 800e632:	e006      	b.n	800e642 <HAL_ADCEx_InjectedConfigChannel+0x31a>
 800e634:	82082000 	.word	0x82082000
  return __builtin_clz(value);
 800e638:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800e63c:	fab3 f383 	clz	r3, r3
 800e640:	b2db      	uxtb	r3, r3
 800e642:	461a      	mov	r2, r3
 800e644:	683b      	ldr	r3, [r7, #0]
 800e646:	681b      	ldr	r3, [r3, #0]
 800e648:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800e64c:	2b00      	cmp	r3, #0
 800e64e:	d105      	bne.n	800e65c <HAL_ADCEx_InjectedConfigChannel+0x334>
 800e650:	683b      	ldr	r3, [r7, #0]
 800e652:	681b      	ldr	r3, [r3, #0]
 800e654:	0e9b      	lsrs	r3, r3, #26
 800e656:	f003 031f 	and.w	r3, r3, #31
 800e65a:	e018      	b.n	800e68e <HAL_ADCEx_InjectedConfigChannel+0x366>
 800e65c:	683b      	ldr	r3, [r7, #0]
 800e65e:	681b      	ldr	r3, [r3, #0]
 800e660:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e664:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e668:	fa93 f3a3 	rbit	r3, r3
 800e66c:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
  return result;
 800e670:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 800e674:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
  if (value == 0U)
 800e678:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800e67c:	2b00      	cmp	r3, #0
 800e67e:	d101      	bne.n	800e684 <HAL_ADCEx_InjectedConfigChannel+0x35c>
    return 32U;
 800e680:	2320      	movs	r3, #32
 800e682:	e004      	b.n	800e68e <HAL_ADCEx_InjectedConfigChannel+0x366>
  return __builtin_clz(value);
 800e684:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800e688:	fab3 f383 	clz	r3, r3
 800e68c:	b2db      	uxtb	r3, r3
 800e68e:	429a      	cmp	r2, r3
 800e690:	d106      	bne.n	800e6a0 <HAL_ADCEx_InjectedConfigChannel+0x378>
      {
        LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_1, LL_ADC_OFFSET_DISABLE);
 800e692:	687b      	ldr	r3, [r7, #4]
 800e694:	681b      	ldr	r3, [r3, #0]
 800e696:	2200      	movs	r2, #0
 800e698:	2100      	movs	r1, #0
 800e69a:	4618      	mov	r0, r3
 800e69c:	f7ff fd8a 	bl	800e1b4 <LL_ADC_SetOffsetState>
      }
      if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 800e6a0:	687b      	ldr	r3, [r7, #4]
 800e6a2:	681b      	ldr	r3, [r3, #0]
 800e6a4:	2101      	movs	r1, #1
 800e6a6:	4618      	mov	r0, r3
 800e6a8:	f7ff fd6e 	bl	800e188 <LL_ADC_GetOffsetChannel>
 800e6ac:	4603      	mov	r3, r0
 800e6ae:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800e6b2:	2b00      	cmp	r3, #0
 800e6b4:	d10a      	bne.n	800e6cc <HAL_ADCEx_InjectedConfigChannel+0x3a4>
 800e6b6:	687b      	ldr	r3, [r7, #4]
 800e6b8:	681b      	ldr	r3, [r3, #0]
 800e6ba:	2101      	movs	r1, #1
 800e6bc:	4618      	mov	r0, r3
 800e6be:	f7ff fd63 	bl	800e188 <LL_ADC_GetOffsetChannel>
 800e6c2:	4603      	mov	r3, r0
 800e6c4:	0e9b      	lsrs	r3, r3, #26
 800e6c6:	f003 021f 	and.w	r2, r3, #31
 800e6ca:	e01e      	b.n	800e70a <HAL_ADCEx_InjectedConfigChannel+0x3e2>
 800e6cc:	687b      	ldr	r3, [r7, #4]
 800e6ce:	681b      	ldr	r3, [r3, #0]
 800e6d0:	2101      	movs	r1, #1
 800e6d2:	4618      	mov	r0, r3
 800e6d4:	f7ff fd58 	bl	800e188 <LL_ADC_GetOffsetChannel>
 800e6d8:	4603      	mov	r3, r0
 800e6da:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e6de:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800e6e2:	fa93 f3a3 	rbit	r3, r3
 800e6e6:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  return result;
 800e6ea:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800e6ee:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  if (value == 0U)
 800e6f2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800e6f6:	2b00      	cmp	r3, #0
 800e6f8:	d101      	bne.n	800e6fe <HAL_ADCEx_InjectedConfigChannel+0x3d6>
    return 32U;
 800e6fa:	2320      	movs	r3, #32
 800e6fc:	e004      	b.n	800e708 <HAL_ADCEx_InjectedConfigChannel+0x3e0>
  return __builtin_clz(value);
 800e6fe:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800e702:	fab3 f383 	clz	r3, r3
 800e706:	b2db      	uxtb	r3, r3
 800e708:	461a      	mov	r2, r3
 800e70a:	683b      	ldr	r3, [r7, #0]
 800e70c:	681b      	ldr	r3, [r3, #0]
 800e70e:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800e712:	2b00      	cmp	r3, #0
 800e714:	d105      	bne.n	800e722 <HAL_ADCEx_InjectedConfigChannel+0x3fa>
 800e716:	683b      	ldr	r3, [r7, #0]
 800e718:	681b      	ldr	r3, [r3, #0]
 800e71a:	0e9b      	lsrs	r3, r3, #26
 800e71c:	f003 031f 	and.w	r3, r3, #31
 800e720:	e018      	b.n	800e754 <HAL_ADCEx_InjectedConfigChannel+0x42c>
 800e722:	683b      	ldr	r3, [r7, #0]
 800e724:	681b      	ldr	r3, [r3, #0]
 800e726:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e72a:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800e72e:	fa93 f3a3 	rbit	r3, r3
 800e732:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  return result;
 800e736:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e73a:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
  if (value == 0U)
 800e73e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e742:	2b00      	cmp	r3, #0
 800e744:	d101      	bne.n	800e74a <HAL_ADCEx_InjectedConfigChannel+0x422>
    return 32U;
 800e746:	2320      	movs	r3, #32
 800e748:	e004      	b.n	800e754 <HAL_ADCEx_InjectedConfigChannel+0x42c>
  return __builtin_clz(value);
 800e74a:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e74e:	fab3 f383 	clz	r3, r3
 800e752:	b2db      	uxtb	r3, r3
 800e754:	429a      	cmp	r2, r3
 800e756:	d106      	bne.n	800e766 <HAL_ADCEx_InjectedConfigChannel+0x43e>
      {
        LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_2, LL_ADC_OFFSET_DISABLE);
 800e758:	687b      	ldr	r3, [r7, #4]
 800e75a:	681b      	ldr	r3, [r3, #0]
 800e75c:	2200      	movs	r2, #0
 800e75e:	2101      	movs	r1, #1
 800e760:	4618      	mov	r0, r3
 800e762:	f7ff fd27 	bl	800e1b4 <LL_ADC_SetOffsetState>
      }
      if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 800e766:	687b      	ldr	r3, [r7, #4]
 800e768:	681b      	ldr	r3, [r3, #0]
 800e76a:	2102      	movs	r1, #2
 800e76c:	4618      	mov	r0, r3
 800e76e:	f7ff fd0b 	bl	800e188 <LL_ADC_GetOffsetChannel>
 800e772:	4603      	mov	r3, r0
 800e774:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800e778:	2b00      	cmp	r3, #0
 800e77a:	d10a      	bne.n	800e792 <HAL_ADCEx_InjectedConfigChannel+0x46a>
 800e77c:	687b      	ldr	r3, [r7, #4]
 800e77e:	681b      	ldr	r3, [r3, #0]
 800e780:	2102      	movs	r1, #2
 800e782:	4618      	mov	r0, r3
 800e784:	f7ff fd00 	bl	800e188 <LL_ADC_GetOffsetChannel>
 800e788:	4603      	mov	r3, r0
 800e78a:	0e9b      	lsrs	r3, r3, #26
 800e78c:	f003 021f 	and.w	r2, r3, #31
 800e790:	e01e      	b.n	800e7d0 <HAL_ADCEx_InjectedConfigChannel+0x4a8>
 800e792:	687b      	ldr	r3, [r7, #4]
 800e794:	681b      	ldr	r3, [r3, #0]
 800e796:	2102      	movs	r1, #2
 800e798:	4618      	mov	r0, r3
 800e79a:	f7ff fcf5 	bl	800e188 <LL_ADC_GetOffsetChannel>
 800e79e:	4603      	mov	r3, r0
 800e7a0:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e7a4:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800e7a8:	fa93 f3a3 	rbit	r3, r3
 800e7ac:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  return result;
 800e7b0:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800e7b4:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  if (value == 0U)
 800e7b8:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800e7bc:	2b00      	cmp	r3, #0
 800e7be:	d101      	bne.n	800e7c4 <HAL_ADCEx_InjectedConfigChannel+0x49c>
    return 32U;
 800e7c0:	2320      	movs	r3, #32
 800e7c2:	e004      	b.n	800e7ce <HAL_ADCEx_InjectedConfigChannel+0x4a6>
  return __builtin_clz(value);
 800e7c4:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800e7c8:	fab3 f383 	clz	r3, r3
 800e7cc:	b2db      	uxtb	r3, r3
 800e7ce:	461a      	mov	r2, r3
 800e7d0:	683b      	ldr	r3, [r7, #0]
 800e7d2:	681b      	ldr	r3, [r3, #0]
 800e7d4:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800e7d8:	2b00      	cmp	r3, #0
 800e7da:	d105      	bne.n	800e7e8 <HAL_ADCEx_InjectedConfigChannel+0x4c0>
 800e7dc:	683b      	ldr	r3, [r7, #0]
 800e7de:	681b      	ldr	r3, [r3, #0]
 800e7e0:	0e9b      	lsrs	r3, r3, #26
 800e7e2:	f003 031f 	and.w	r3, r3, #31
 800e7e6:	e014      	b.n	800e812 <HAL_ADCEx_InjectedConfigChannel+0x4ea>
 800e7e8:	683b      	ldr	r3, [r7, #0]
 800e7ea:	681b      	ldr	r3, [r3, #0]
 800e7ec:	67fb      	str	r3, [r7, #124]	; 0x7c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e7ee:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800e7f0:	fa93 f3a3 	rbit	r3, r3
 800e7f4:	67bb      	str	r3, [r7, #120]	; 0x78
  return result;
 800e7f6:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800e7f8:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  if (value == 0U)
 800e7fc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800e800:	2b00      	cmp	r3, #0
 800e802:	d101      	bne.n	800e808 <HAL_ADCEx_InjectedConfigChannel+0x4e0>
    return 32U;
 800e804:	2320      	movs	r3, #32
 800e806:	e004      	b.n	800e812 <HAL_ADCEx_InjectedConfigChannel+0x4ea>
  return __builtin_clz(value);
 800e808:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800e80c:	fab3 f383 	clz	r3, r3
 800e810:	b2db      	uxtb	r3, r3
 800e812:	429a      	cmp	r2, r3
 800e814:	d106      	bne.n	800e824 <HAL_ADCEx_InjectedConfigChannel+0x4fc>
      {
        LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_3, LL_ADC_OFFSET_DISABLE);
 800e816:	687b      	ldr	r3, [r7, #4]
 800e818:	681b      	ldr	r3, [r3, #0]
 800e81a:	2200      	movs	r2, #0
 800e81c:	2102      	movs	r1, #2
 800e81e:	4618      	mov	r0, r3
 800e820:	f7ff fcc8 	bl	800e1b4 <LL_ADC_SetOffsetState>
      }
      if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfigInjected->InjectedChannel))
 800e824:	687b      	ldr	r3, [r7, #4]
 800e826:	681b      	ldr	r3, [r3, #0]
 800e828:	2103      	movs	r1, #3
 800e82a:	4618      	mov	r0, r3
 800e82c:	f7ff fcac 	bl	800e188 <LL_ADC_GetOffsetChannel>
 800e830:	4603      	mov	r3, r0
 800e832:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800e836:	2b00      	cmp	r3, #0
 800e838:	d10a      	bne.n	800e850 <HAL_ADCEx_InjectedConfigChannel+0x528>
 800e83a:	687b      	ldr	r3, [r7, #4]
 800e83c:	681b      	ldr	r3, [r3, #0]
 800e83e:	2103      	movs	r1, #3
 800e840:	4618      	mov	r0, r3
 800e842:	f7ff fca1 	bl	800e188 <LL_ADC_GetOffsetChannel>
 800e846:	4603      	mov	r3, r0
 800e848:	0e9b      	lsrs	r3, r3, #26
 800e84a:	f003 021f 	and.w	r2, r3, #31
 800e84e:	e017      	b.n	800e880 <HAL_ADCEx_InjectedConfigChannel+0x558>
 800e850:	687b      	ldr	r3, [r7, #4]
 800e852:	681b      	ldr	r3, [r3, #0]
 800e854:	2103      	movs	r1, #3
 800e856:	4618      	mov	r0, r3
 800e858:	f7ff fc96 	bl	800e188 <LL_ADC_GetOffsetChannel>
 800e85c:	4603      	mov	r3, r0
 800e85e:	673b      	str	r3, [r7, #112]	; 0x70
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e860:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800e862:	fa93 f3a3 	rbit	r3, r3
 800e866:	66fb      	str	r3, [r7, #108]	; 0x6c
  return result;
 800e868:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800e86a:	677b      	str	r3, [r7, #116]	; 0x74
  if (value == 0U)
 800e86c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800e86e:	2b00      	cmp	r3, #0
 800e870:	d101      	bne.n	800e876 <HAL_ADCEx_InjectedConfigChannel+0x54e>
    return 32U;
 800e872:	2320      	movs	r3, #32
 800e874:	e003      	b.n	800e87e <HAL_ADCEx_InjectedConfigChannel+0x556>
  return __builtin_clz(value);
 800e876:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800e878:	fab3 f383 	clz	r3, r3
 800e87c:	b2db      	uxtb	r3, r3
 800e87e:	461a      	mov	r2, r3
 800e880:	683b      	ldr	r3, [r7, #0]
 800e882:	681b      	ldr	r3, [r3, #0]
 800e884:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800e888:	2b00      	cmp	r3, #0
 800e88a:	d105      	bne.n	800e898 <HAL_ADCEx_InjectedConfigChannel+0x570>
 800e88c:	683b      	ldr	r3, [r7, #0]
 800e88e:	681b      	ldr	r3, [r3, #0]
 800e890:	0e9b      	lsrs	r3, r3, #26
 800e892:	f003 031f 	and.w	r3, r3, #31
 800e896:	e011      	b.n	800e8bc <HAL_ADCEx_InjectedConfigChannel+0x594>
 800e898:	683b      	ldr	r3, [r7, #0]
 800e89a:	681b      	ldr	r3, [r3, #0]
 800e89c:	667b      	str	r3, [r7, #100]	; 0x64
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e89e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e8a0:	fa93 f3a3 	rbit	r3, r3
 800e8a4:	663b      	str	r3, [r7, #96]	; 0x60
  return result;
 800e8a6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800e8a8:	66bb      	str	r3, [r7, #104]	; 0x68
  if (value == 0U)
 800e8aa:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e8ac:	2b00      	cmp	r3, #0
 800e8ae:	d101      	bne.n	800e8b4 <HAL_ADCEx_InjectedConfigChannel+0x58c>
    return 32U;
 800e8b0:	2320      	movs	r3, #32
 800e8b2:	e003      	b.n	800e8bc <HAL_ADCEx_InjectedConfigChannel+0x594>
  return __builtin_clz(value);
 800e8b4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e8b6:	fab3 f383 	clz	r3, r3
 800e8ba:	b2db      	uxtb	r3, r3
 800e8bc:	429a      	cmp	r2, r3
 800e8be:	d106      	bne.n	800e8ce <HAL_ADCEx_InjectedConfigChannel+0x5a6>
      {
        LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_4, LL_ADC_OFFSET_DISABLE);
 800e8c0:	687b      	ldr	r3, [r7, #4]
 800e8c2:	681b      	ldr	r3, [r3, #0]
 800e8c4:	2200      	movs	r2, #0
 800e8c6:	2103      	movs	r1, #3
 800e8c8:	4618      	mov	r0, r3
 800e8ca:	f7ff fc73 	bl	800e1b4 <LL_ADC_SetOffsetState>

  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated only when ADC is disabled:                */
  /*  - Single or differential mode                                           */
  /*  - Internal measurement channels: Vbat/VrefInt/TempSensor                */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 800e8ce:	687b      	ldr	r3, [r7, #4]
 800e8d0:	681b      	ldr	r3, [r3, #0]
 800e8d2:	4618      	mov	r0, r3
 800e8d4:	f7ff fcee 	bl	800e2b4 <LL_ADC_IsEnabled>
 800e8d8:	4603      	mov	r3, r0
 800e8da:	2b00      	cmp	r3, #0
 800e8dc:	f040 81b8 	bne.w	800ec50 <HAL_ADCEx_InjectedConfigChannel+0x928>
  {
    /* Set mode single-ended or differential input of the selected ADC channel */
    LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfigInjected->InjectedChannel, sConfigInjected->InjectedSingleDiff);
 800e8e0:	687b      	ldr	r3, [r7, #4]
 800e8e2:	6818      	ldr	r0, [r3, #0]
 800e8e4:	683b      	ldr	r3, [r7, #0]
 800e8e6:	6819      	ldr	r1, [r3, #0]
 800e8e8:	683b      	ldr	r3, [r7, #0]
 800e8ea:	68db      	ldr	r3, [r3, #12]
 800e8ec:	461a      	mov	r2, r3
 800e8ee:	f7ff fcbd 	bl	800e26c <LL_ADC_SetChannelSingleDiff>

    /* Configuration of differential mode */
    /* Note: ADC channel number masked with value "0x1F" to ensure shift value within 32 bits range */
    if (sConfigInjected->InjectedSingleDiff == ADC_DIFFERENTIAL_ENDED)
 800e8f2:	683b      	ldr	r3, [r7, #0]
 800e8f4:	68db      	ldr	r3, [r3, #12]
 800e8f6:	4a8f      	ldr	r2, [pc, #572]	; (800eb34 <HAL_ADCEx_InjectedConfigChannel+0x80c>)
 800e8f8:	4293      	cmp	r3, r2
 800e8fa:	f040 8131 	bne.w	800eb60 <HAL_ADCEx_InjectedConfigChannel+0x838>
    {
      /* Set sampling time of the selected ADC channel */
      LL_ADC_SetChannelSamplingTime(hadc->Instance, (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfigInjected->InjectedChannel) + 1UL) & 0x1FUL)), sConfigInjected->InjectedSamplingTime);
 800e8fe:	687b      	ldr	r3, [r7, #4]
 800e900:	6818      	ldr	r0, [r3, #0]
 800e902:	683b      	ldr	r3, [r7, #0]
 800e904:	681b      	ldr	r3, [r3, #0]
 800e906:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800e90a:	2b00      	cmp	r3, #0
 800e90c:	d10b      	bne.n	800e926 <HAL_ADCEx_InjectedConfigChannel+0x5fe>
 800e90e:	683b      	ldr	r3, [r7, #0]
 800e910:	681b      	ldr	r3, [r3, #0]
 800e912:	0e9b      	lsrs	r3, r3, #26
 800e914:	3301      	adds	r3, #1
 800e916:	f003 031f 	and.w	r3, r3, #31
 800e91a:	2b09      	cmp	r3, #9
 800e91c:	bf94      	ite	ls
 800e91e:	2301      	movls	r3, #1
 800e920:	2300      	movhi	r3, #0
 800e922:	b2db      	uxtb	r3, r3
 800e924:	e019      	b.n	800e95a <HAL_ADCEx_InjectedConfigChannel+0x632>
 800e926:	683b      	ldr	r3, [r7, #0]
 800e928:	681b      	ldr	r3, [r3, #0]
 800e92a:	65bb      	str	r3, [r7, #88]	; 0x58
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e92c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800e92e:	fa93 f3a3 	rbit	r3, r3
 800e932:	657b      	str	r3, [r7, #84]	; 0x54
  return result;
 800e934:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e936:	65fb      	str	r3, [r7, #92]	; 0x5c
  if (value == 0U)
 800e938:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800e93a:	2b00      	cmp	r3, #0
 800e93c:	d101      	bne.n	800e942 <HAL_ADCEx_InjectedConfigChannel+0x61a>
    return 32U;
 800e93e:	2320      	movs	r3, #32
 800e940:	e003      	b.n	800e94a <HAL_ADCEx_InjectedConfigChannel+0x622>
  return __builtin_clz(value);
 800e942:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800e944:	fab3 f383 	clz	r3, r3
 800e948:	b2db      	uxtb	r3, r3
 800e94a:	3301      	adds	r3, #1
 800e94c:	f003 031f 	and.w	r3, r3, #31
 800e950:	2b09      	cmp	r3, #9
 800e952:	bf94      	ite	ls
 800e954:	2301      	movls	r3, #1
 800e956:	2300      	movhi	r3, #0
 800e958:	b2db      	uxtb	r3, r3
 800e95a:	2b00      	cmp	r3, #0
 800e95c:	d079      	beq.n	800ea52 <HAL_ADCEx_InjectedConfigChannel+0x72a>
 800e95e:	683b      	ldr	r3, [r7, #0]
 800e960:	681b      	ldr	r3, [r3, #0]
 800e962:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800e966:	2b00      	cmp	r3, #0
 800e968:	d107      	bne.n	800e97a <HAL_ADCEx_InjectedConfigChannel+0x652>
 800e96a:	683b      	ldr	r3, [r7, #0]
 800e96c:	681b      	ldr	r3, [r3, #0]
 800e96e:	0e9b      	lsrs	r3, r3, #26
 800e970:	3301      	adds	r3, #1
 800e972:	069b      	lsls	r3, r3, #26
 800e974:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 800e978:	e015      	b.n	800e9a6 <HAL_ADCEx_InjectedConfigChannel+0x67e>
 800e97a:	683b      	ldr	r3, [r7, #0]
 800e97c:	681b      	ldr	r3, [r3, #0]
 800e97e:	64fb      	str	r3, [r7, #76]	; 0x4c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e980:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e982:	fa93 f3a3 	rbit	r3, r3
 800e986:	64bb      	str	r3, [r7, #72]	; 0x48
  return result;
 800e988:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e98a:	653b      	str	r3, [r7, #80]	; 0x50
  if (value == 0U)
 800e98c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e98e:	2b00      	cmp	r3, #0
 800e990:	d101      	bne.n	800e996 <HAL_ADCEx_InjectedConfigChannel+0x66e>
    return 32U;
 800e992:	2320      	movs	r3, #32
 800e994:	e003      	b.n	800e99e <HAL_ADCEx_InjectedConfigChannel+0x676>
  return __builtin_clz(value);
 800e996:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e998:	fab3 f383 	clz	r3, r3
 800e99c:	b2db      	uxtb	r3, r3
 800e99e:	3301      	adds	r3, #1
 800e9a0:	069b      	lsls	r3, r3, #26
 800e9a2:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 800e9a6:	683b      	ldr	r3, [r7, #0]
 800e9a8:	681b      	ldr	r3, [r3, #0]
 800e9aa:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800e9ae:	2b00      	cmp	r3, #0
 800e9b0:	d109      	bne.n	800e9c6 <HAL_ADCEx_InjectedConfigChannel+0x69e>
 800e9b2:	683b      	ldr	r3, [r7, #0]
 800e9b4:	681b      	ldr	r3, [r3, #0]
 800e9b6:	0e9b      	lsrs	r3, r3, #26
 800e9b8:	3301      	adds	r3, #1
 800e9ba:	f003 031f 	and.w	r3, r3, #31
 800e9be:	2101      	movs	r1, #1
 800e9c0:	fa01 f303 	lsl.w	r3, r1, r3
 800e9c4:	e017      	b.n	800e9f6 <HAL_ADCEx_InjectedConfigChannel+0x6ce>
 800e9c6:	683b      	ldr	r3, [r7, #0]
 800e9c8:	681b      	ldr	r3, [r3, #0]
 800e9ca:	643b      	str	r3, [r7, #64]	; 0x40
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800e9cc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e9ce:	fa93 f3a3 	rbit	r3, r3
 800e9d2:	63fb      	str	r3, [r7, #60]	; 0x3c
  return result;
 800e9d4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e9d6:	647b      	str	r3, [r7, #68]	; 0x44
  if (value == 0U)
 800e9d8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e9da:	2b00      	cmp	r3, #0
 800e9dc:	d101      	bne.n	800e9e2 <HAL_ADCEx_InjectedConfigChannel+0x6ba>
    return 32U;
 800e9de:	2320      	movs	r3, #32
 800e9e0:	e003      	b.n	800e9ea <HAL_ADCEx_InjectedConfigChannel+0x6c2>
  return __builtin_clz(value);
 800e9e2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e9e4:	fab3 f383 	clz	r3, r3
 800e9e8:	b2db      	uxtb	r3, r3
 800e9ea:	3301      	adds	r3, #1
 800e9ec:	f003 031f 	and.w	r3, r3, #31
 800e9f0:	2101      	movs	r1, #1
 800e9f2:	fa01 f303 	lsl.w	r3, r1, r3
 800e9f6:	ea42 0103 	orr.w	r1, r2, r3
 800e9fa:	683b      	ldr	r3, [r7, #0]
 800e9fc:	681b      	ldr	r3, [r3, #0]
 800e9fe:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800ea02:	2b00      	cmp	r3, #0
 800ea04:	d10a      	bne.n	800ea1c <HAL_ADCEx_InjectedConfigChannel+0x6f4>
 800ea06:	683b      	ldr	r3, [r7, #0]
 800ea08:	681b      	ldr	r3, [r3, #0]
 800ea0a:	0e9b      	lsrs	r3, r3, #26
 800ea0c:	3301      	adds	r3, #1
 800ea0e:	f003 021f 	and.w	r2, r3, #31
 800ea12:	4613      	mov	r3, r2
 800ea14:	005b      	lsls	r3, r3, #1
 800ea16:	4413      	add	r3, r2
 800ea18:	051b      	lsls	r3, r3, #20
 800ea1a:	e018      	b.n	800ea4e <HAL_ADCEx_InjectedConfigChannel+0x726>
 800ea1c:	683b      	ldr	r3, [r7, #0]
 800ea1e:	681b      	ldr	r3, [r3, #0]
 800ea20:	637b      	str	r3, [r7, #52]	; 0x34
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800ea22:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ea24:	fa93 f3a3 	rbit	r3, r3
 800ea28:	633b      	str	r3, [r7, #48]	; 0x30
  return result;
 800ea2a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ea2c:	63bb      	str	r3, [r7, #56]	; 0x38
  if (value == 0U)
 800ea2e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ea30:	2b00      	cmp	r3, #0
 800ea32:	d101      	bne.n	800ea38 <HAL_ADCEx_InjectedConfigChannel+0x710>
    return 32U;
 800ea34:	2320      	movs	r3, #32
 800ea36:	e003      	b.n	800ea40 <HAL_ADCEx_InjectedConfigChannel+0x718>
  return __builtin_clz(value);
 800ea38:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ea3a:	fab3 f383 	clz	r3, r3
 800ea3e:	b2db      	uxtb	r3, r3
 800ea40:	3301      	adds	r3, #1
 800ea42:	f003 021f 	and.w	r2, r3, #31
 800ea46:	4613      	mov	r3, r2
 800ea48:	005b      	lsls	r3, r3, #1
 800ea4a:	4413      	add	r3, r2
 800ea4c:	051b      	lsls	r3, r3, #20
 800ea4e:	430b      	orrs	r3, r1
 800ea50:	e081      	b.n	800eb56 <HAL_ADCEx_InjectedConfigChannel+0x82e>
 800ea52:	683b      	ldr	r3, [r7, #0]
 800ea54:	681b      	ldr	r3, [r3, #0]
 800ea56:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800ea5a:	2b00      	cmp	r3, #0
 800ea5c:	d107      	bne.n	800ea6e <HAL_ADCEx_InjectedConfigChannel+0x746>
 800ea5e:	683b      	ldr	r3, [r7, #0]
 800ea60:	681b      	ldr	r3, [r3, #0]
 800ea62:	0e9b      	lsrs	r3, r3, #26
 800ea64:	3301      	adds	r3, #1
 800ea66:	069b      	lsls	r3, r3, #26
 800ea68:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 800ea6c:	e015      	b.n	800ea9a <HAL_ADCEx_InjectedConfigChannel+0x772>
 800ea6e:	683b      	ldr	r3, [r7, #0]
 800ea70:	681b      	ldr	r3, [r3, #0]
 800ea72:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800ea74:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ea76:	fa93 f3a3 	rbit	r3, r3
 800ea7a:	627b      	str	r3, [r7, #36]	; 0x24
  return result;
 800ea7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ea7e:	62fb      	str	r3, [r7, #44]	; 0x2c
  if (value == 0U)
 800ea80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ea82:	2b00      	cmp	r3, #0
 800ea84:	d101      	bne.n	800ea8a <HAL_ADCEx_InjectedConfigChannel+0x762>
    return 32U;
 800ea86:	2320      	movs	r3, #32
 800ea88:	e003      	b.n	800ea92 <HAL_ADCEx_InjectedConfigChannel+0x76a>
  return __builtin_clz(value);
 800ea8a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ea8c:	fab3 f383 	clz	r3, r3
 800ea90:	b2db      	uxtb	r3, r3
 800ea92:	3301      	adds	r3, #1
 800ea94:	069b      	lsls	r3, r3, #26
 800ea96:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 800ea9a:	683b      	ldr	r3, [r7, #0]
 800ea9c:	681b      	ldr	r3, [r3, #0]
 800ea9e:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800eaa2:	2b00      	cmp	r3, #0
 800eaa4:	d109      	bne.n	800eaba <HAL_ADCEx_InjectedConfigChannel+0x792>
 800eaa6:	683b      	ldr	r3, [r7, #0]
 800eaa8:	681b      	ldr	r3, [r3, #0]
 800eaaa:	0e9b      	lsrs	r3, r3, #26
 800eaac:	3301      	adds	r3, #1
 800eaae:	f003 031f 	and.w	r3, r3, #31
 800eab2:	2101      	movs	r1, #1
 800eab4:	fa01 f303 	lsl.w	r3, r1, r3
 800eab8:	e017      	b.n	800eaea <HAL_ADCEx_InjectedConfigChannel+0x7c2>
 800eaba:	683b      	ldr	r3, [r7, #0]
 800eabc:	681b      	ldr	r3, [r3, #0]
 800eabe:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800eac0:	69fb      	ldr	r3, [r7, #28]
 800eac2:	fa93 f3a3 	rbit	r3, r3
 800eac6:	61bb      	str	r3, [r7, #24]
  return result;
 800eac8:	69bb      	ldr	r3, [r7, #24]
 800eaca:	623b      	str	r3, [r7, #32]
  if (value == 0U)
 800eacc:	6a3b      	ldr	r3, [r7, #32]
 800eace:	2b00      	cmp	r3, #0
 800ead0:	d101      	bne.n	800ead6 <HAL_ADCEx_InjectedConfigChannel+0x7ae>
    return 32U;
 800ead2:	2320      	movs	r3, #32
 800ead4:	e003      	b.n	800eade <HAL_ADCEx_InjectedConfigChannel+0x7b6>
  return __builtin_clz(value);
 800ead6:	6a3b      	ldr	r3, [r7, #32]
 800ead8:	fab3 f383 	clz	r3, r3
 800eadc:	b2db      	uxtb	r3, r3
 800eade:	3301      	adds	r3, #1
 800eae0:	f003 031f 	and.w	r3, r3, #31
 800eae4:	2101      	movs	r1, #1
 800eae6:	fa01 f303 	lsl.w	r3, r1, r3
 800eaea:	ea42 0103 	orr.w	r1, r2, r3
 800eaee:	683b      	ldr	r3, [r7, #0]
 800eaf0:	681b      	ldr	r3, [r3, #0]
 800eaf2:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800eaf6:	2b00      	cmp	r3, #0
 800eaf8:	d10d      	bne.n	800eb16 <HAL_ADCEx_InjectedConfigChannel+0x7ee>
 800eafa:	683b      	ldr	r3, [r7, #0]
 800eafc:	681b      	ldr	r3, [r3, #0]
 800eafe:	0e9b      	lsrs	r3, r3, #26
 800eb00:	3301      	adds	r3, #1
 800eb02:	f003 021f 	and.w	r2, r3, #31
 800eb06:	4613      	mov	r3, r2
 800eb08:	005b      	lsls	r3, r3, #1
 800eb0a:	4413      	add	r3, r2
 800eb0c:	3b1e      	subs	r3, #30
 800eb0e:	051b      	lsls	r3, r3, #20
 800eb10:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800eb14:	e01e      	b.n	800eb54 <HAL_ADCEx_InjectedConfigChannel+0x82c>
 800eb16:	683b      	ldr	r3, [r7, #0]
 800eb18:	681b      	ldr	r3, [r3, #0]
 800eb1a:	613b      	str	r3, [r7, #16]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800eb1c:	693b      	ldr	r3, [r7, #16]
 800eb1e:	fa93 f3a3 	rbit	r3, r3
 800eb22:	60fb      	str	r3, [r7, #12]
  return result;
 800eb24:	68fb      	ldr	r3, [r7, #12]
 800eb26:	617b      	str	r3, [r7, #20]
  if (value == 0U)
 800eb28:	697b      	ldr	r3, [r7, #20]
 800eb2a:	2b00      	cmp	r3, #0
 800eb2c:	d104      	bne.n	800eb38 <HAL_ADCEx_InjectedConfigChannel+0x810>
    return 32U;
 800eb2e:	2320      	movs	r3, #32
 800eb30:	e006      	b.n	800eb40 <HAL_ADCEx_InjectedConfigChannel+0x818>
 800eb32:	bf00      	nop
 800eb34:	407f0000 	.word	0x407f0000
  return __builtin_clz(value);
 800eb38:	697b      	ldr	r3, [r7, #20]
 800eb3a:	fab3 f383 	clz	r3, r3
 800eb3e:	b2db      	uxtb	r3, r3
 800eb40:	3301      	adds	r3, #1
 800eb42:	f003 021f 	and.w	r2, r3, #31
 800eb46:	4613      	mov	r3, r2
 800eb48:	005b      	lsls	r3, r3, #1
 800eb4a:	4413      	add	r3, r2
 800eb4c:	3b1e      	subs	r3, #30
 800eb4e:	051b      	lsls	r3, r3, #20
 800eb50:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800eb54:	430b      	orrs	r3, r1
 800eb56:	683a      	ldr	r2, [r7, #0]
 800eb58:	6892      	ldr	r2, [r2, #8]
 800eb5a:	4619      	mov	r1, r3
 800eb5c:	f7ff fb5a 	bl	800e214 <LL_ADC_SetChannelSamplingTime>
    /* internal measurement paths enable: If internal channel selected,       */
    /* enable dedicated internal buffers and path.                            */
    /* Note: these internal measurement paths can be disabled using           */
    /* HAL_ADC_DeInit().                                                      */

    if(__LL_ADC_IS_CHANNEL_INTERNAL(sConfigInjected->InjectedChannel))
 800eb60:	683b      	ldr	r3, [r7, #0]
 800eb62:	681a      	ldr	r2, [r3, #0]
 800eb64:	4b3f      	ldr	r3, [pc, #252]	; (800ec64 <HAL_ADCEx_InjectedConfigChannel+0x93c>)
 800eb66:	4013      	ands	r3, r2
 800eb68:	2b00      	cmp	r3, #0
 800eb6a:	d071      	beq.n	800ec50 <HAL_ADCEx_InjectedConfigChannel+0x928>
    {
      /* Configuration of common ADC parameters (continuation)                */
      /* Software is allowed to change common parameters only when all ADCs   */
      /* of the common group are disabled.                                    */
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 800eb6c:	483e      	ldr	r0, [pc, #248]	; (800ec68 <HAL_ADCEx_InjectedConfigChannel+0x940>)
 800eb6e:	f7ff fba1 	bl	800e2b4 <LL_ADC_IsEnabled>
 800eb72:	4603      	mov	r3, r0
 800eb74:	2b00      	cmp	r3, #0
 800eb76:	d162      	bne.n	800ec3e <HAL_ADCEx_InjectedConfigChannel+0x916>
      {
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 800eb78:	483c      	ldr	r0, [pc, #240]	; (800ec6c <HAL_ADCEx_InjectedConfigChannel+0x944>)
 800eb7a:	f7ff fad2 	bl	800e122 <LL_ADC_GetCommonPathInternalCh>
 800eb7e:	f8c7 00c0 	str.w	r0, [r7, #192]	; 0xc0

        /* If the requested internal measurement path has already been enabled, */
        /* bypass the configuration processing.                                 */
        if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 800eb82:	683b      	ldr	r3, [r7, #0]
 800eb84:	681b      	ldr	r3, [r3, #0]
 800eb86:	4a3a      	ldr	r2, [pc, #232]	; (800ec70 <HAL_ADCEx_InjectedConfigChannel+0x948>)
 800eb88:	4293      	cmp	r3, r2
 800eb8a:	d126      	bne.n	800ebda <HAL_ADCEx_InjectedConfigChannel+0x8b2>
 800eb8c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800eb90:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800eb94:	2b00      	cmp	r3, #0
 800eb96:	d120      	bne.n	800ebda <HAL_ADCEx_InjectedConfigChannel+0x8b2>
        {
          if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 800eb98:	687b      	ldr	r3, [r7, #4]
 800eb9a:	681b      	ldr	r3, [r3, #0]
 800eb9c:	4a32      	ldr	r2, [pc, #200]	; (800ec68 <HAL_ADCEx_InjectedConfigChannel+0x940>)
 800eb9e:	4293      	cmp	r3, r2
 800eba0:	d156      	bne.n	800ec50 <HAL_ADCEx_InjectedConfigChannel+0x928>
          {
            LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_TEMPSENSOR | tmp_config_internal_channel);
 800eba2:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800eba6:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800ebaa:	4619      	mov	r1, r3
 800ebac:	482f      	ldr	r0, [pc, #188]	; (800ec6c <HAL_ADCEx_InjectedConfigChannel+0x944>)
 800ebae:	f7ff faa5 	bl	800e0fc <LL_ADC_SetCommonPathInternalCh>
            /* Delay for temperature sensor stabilization time */
            /* Wait loop initialization and execution */
            /* Note: Variable divided by 2 to compensate partially              */
            /*       CPU processing cycles, scaling in us split to not          */
            /*       exceed 32 bits register capacity and handle low frequency. */
            wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 800ebb2:	4b30      	ldr	r3, [pc, #192]	; (800ec74 <HAL_ADCEx_InjectedConfigChannel+0x94c>)
 800ebb4:	681b      	ldr	r3, [r3, #0]
 800ebb6:	099b      	lsrs	r3, r3, #6
 800ebb8:	4a2f      	ldr	r2, [pc, #188]	; (800ec78 <HAL_ADCEx_InjectedConfigChannel+0x950>)
 800ebba:	fba2 2303 	umull	r2, r3, r2, r3
 800ebbe:	099a      	lsrs	r2, r3, #6
 800ebc0:	4613      	mov	r3, r2
 800ebc2:	005b      	lsls	r3, r3, #1
 800ebc4:	4413      	add	r3, r2
 800ebc6:	009b      	lsls	r3, r3, #2
 800ebc8:	60bb      	str	r3, [r7, #8]
            while(wait_loop_index != 0UL)
 800ebca:	e002      	b.n	800ebd2 <HAL_ADCEx_InjectedConfigChannel+0x8aa>
            {
              wait_loop_index--;
 800ebcc:	68bb      	ldr	r3, [r7, #8]
 800ebce:	3b01      	subs	r3, #1
 800ebd0:	60bb      	str	r3, [r7, #8]
            while(wait_loop_index != 0UL)
 800ebd2:	68bb      	ldr	r3, [r7, #8]
 800ebd4:	2b00      	cmp	r3, #0
 800ebd6:	d1f9      	bne.n	800ebcc <HAL_ADCEx_InjectedConfigChannel+0x8a4>
          if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 800ebd8:	e03a      	b.n	800ec50 <HAL_ADCEx_InjectedConfigChannel+0x928>
            }
          }
        }
        else if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 800ebda:	683b      	ldr	r3, [r7, #0]
 800ebdc:	681b      	ldr	r3, [r3, #0]
 800ebde:	4a27      	ldr	r2, [pc, #156]	; (800ec7c <HAL_ADCEx_InjectedConfigChannel+0x954>)
 800ebe0:	4293      	cmp	r3, r2
 800ebe2:	d113      	bne.n	800ec0c <HAL_ADCEx_InjectedConfigChannel+0x8e4>
 800ebe4:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800ebe8:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 800ebec:	2b00      	cmp	r3, #0
 800ebee:	d10d      	bne.n	800ec0c <HAL_ADCEx_InjectedConfigChannel+0x8e4>
        {
          if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 800ebf0:	687b      	ldr	r3, [r7, #4]
 800ebf2:	681b      	ldr	r3, [r3, #0]
 800ebf4:	4a1c      	ldr	r2, [pc, #112]	; (800ec68 <HAL_ADCEx_InjectedConfigChannel+0x940>)
 800ebf6:	4293      	cmp	r3, r2
 800ebf8:	d12a      	bne.n	800ec50 <HAL_ADCEx_InjectedConfigChannel+0x928>
          {
            LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
 800ebfa:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800ebfe:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800ec02:	4619      	mov	r1, r3
 800ec04:	4819      	ldr	r0, [pc, #100]	; (800ec6c <HAL_ADCEx_InjectedConfigChannel+0x944>)
 800ec06:	f7ff fa79 	bl	800e0fc <LL_ADC_SetCommonPathInternalCh>
          if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 800ec0a:	e021      	b.n	800ec50 <HAL_ADCEx_InjectedConfigChannel+0x928>
          }
        }
        else if ((sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 800ec0c:	683b      	ldr	r3, [r7, #0]
 800ec0e:	681b      	ldr	r3, [r3, #0]
 800ec10:	4a1b      	ldr	r2, [pc, #108]	; (800ec80 <HAL_ADCEx_InjectedConfigChannel+0x958>)
 800ec12:	4293      	cmp	r3, r2
 800ec14:	d11c      	bne.n	800ec50 <HAL_ADCEx_InjectedConfigChannel+0x928>
 800ec16:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800ec1a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800ec1e:	2b00      	cmp	r3, #0
 800ec20:	d116      	bne.n	800ec50 <HAL_ADCEx_InjectedConfigChannel+0x928>
        {
          if (ADC_VREFINT_INSTANCE(hadc))
 800ec22:	687b      	ldr	r3, [r7, #4]
 800ec24:	681b      	ldr	r3, [r3, #0]
 800ec26:	4a10      	ldr	r2, [pc, #64]	; (800ec68 <HAL_ADCEx_InjectedConfigChannel+0x940>)
 800ec28:	4293      	cmp	r3, r2
 800ec2a:	d111      	bne.n	800ec50 <HAL_ADCEx_InjectedConfigChannel+0x928>
          {
            LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_internal_channel);
 800ec2c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800ec30:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800ec34:	4619      	mov	r1, r3
 800ec36:	480d      	ldr	r0, [pc, #52]	; (800ec6c <HAL_ADCEx_InjectedConfigChannel+0x944>)
 800ec38:	f7ff fa60 	bl	800e0fc <LL_ADC_SetCommonPathInternalCh>
 800ec3c:	e008      	b.n	800ec50 <HAL_ADCEx_InjectedConfigChannel+0x928>
      /* and other ADC of the common group are enabled, internal              */
      /* measurement paths cannot be enabled.                                 */
      else
      {
        /* Update ADC state machine to error */
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800ec3e:	687b      	ldr	r3, [r7, #4]
 800ec40:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ec42:	f043 0220 	orr.w	r2, r3, #32
 800ec46:	687b      	ldr	r3, [r7, #4]
 800ec48:	655a      	str	r2, [r3, #84]	; 0x54

        tmp_hal_status = HAL_ERROR;
 800ec4a:	2301      	movs	r3, #1
 800ec4c:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7
    }

  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 800ec50:	687b      	ldr	r3, [r7, #4]
 800ec52:	2200      	movs	r2, #0
 800ec54:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* Return function status */
  return tmp_hal_status;
 800ec58:	f897 30d7 	ldrb.w	r3, [r7, #215]	; 0xd7
}
 800ec5c:	4618      	mov	r0, r3
 800ec5e:	37d8      	adds	r7, #216	; 0xd8
 800ec60:	46bd      	mov	sp, r7
 800ec62:	bd80      	pop	{r7, pc}
 800ec64:	80080000 	.word	0x80080000
 800ec68:	50040000 	.word	0x50040000
 800ec6c:	50040300 	.word	0x50040300
 800ec70:	c7520000 	.word	0xc7520000
 800ec74:	20000004 	.word	0x20000004
 800ec78:	053e2d63 	.word	0x053e2d63
 800ec7c:	cb840000 	.word	0xcb840000
 800ec80:	80000001 	.word	0x80000001

0800ec84 <HAL_ADCEx_DisableInjectedQueue>:
  *         conversion is ongoing.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_DisableInjectedQueue(ADC_HandleTypeDef *hadc)
{
 800ec84:	b580      	push	{r7, lr}
 800ec86:	b086      	sub	sp, #24
 800ec88:	af00      	add	r7, sp, #0
 800ec8a:	6078      	str	r0, [r7, #4]
  uint32_t tmp_adc_is_conversion_on_going_injected;

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 800ec8c:	687b      	ldr	r3, [r7, #4]
 800ec8e:	681b      	ldr	r3, [r3, #0]
 800ec90:	4618      	mov	r0, r3
 800ec92:	f7ff fb22 	bl	800e2da <LL_ADC_REG_IsConversionOngoing>
 800ec96:	6138      	str	r0, [r7, #16]
  tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 800ec98:	687b      	ldr	r3, [r7, #4]
 800ec9a:	681b      	ldr	r3, [r3, #0]
 800ec9c:	4618      	mov	r0, r3
 800ec9e:	f7ff fb2f 	bl	800e300 <LL_ADC_INJ_IsConversionOngoing>
 800eca2:	60f8      	str	r0, [r7, #12]

  /* Parameter can be set only if no conversion is on-going */
  if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 800eca4:	693b      	ldr	r3, [r7, #16]
 800eca6:	2b00      	cmp	r3, #0
 800eca8:	d10c      	bne.n	800ecc4 <HAL_ADCEx_DisableInjectedQueue+0x40>
      && (tmp_adc_is_conversion_on_going_injected == 0UL)
 800ecaa:	68fb      	ldr	r3, [r7, #12]
 800ecac:	2b00      	cmp	r3, #0
 800ecae:	d109      	bne.n	800ecc4 <HAL_ADCEx_DisableInjectedQueue+0x40>
     )
  {
    LL_ADC_INJ_SetQueueMode(hadc->Instance, LL_ADC_INJ_QUEUE_DISABLE);
 800ecb0:	687b      	ldr	r3, [r7, #4]
 800ecb2:	681b      	ldr	r3, [r3, #0]
 800ecb4:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 800ecb8:	4618      	mov	r0, r3
 800ecba:	f7ff fa96 	bl	800e1ea <LL_ADC_INJ_SetQueueMode>
    tmp_hal_status = HAL_OK;
 800ecbe:	2300      	movs	r3, #0
 800ecc0:	75fb      	strb	r3, [r7, #23]
 800ecc2:	e001      	b.n	800ecc8 <HAL_ADCEx_DisableInjectedQueue+0x44>
  }
  else
  {
    tmp_hal_status = HAL_ERROR;
 800ecc4:	2301      	movs	r3, #1
 800ecc6:	75fb      	strb	r3, [r7, #23]
  }

  return tmp_hal_status;
 800ecc8:	7dfb      	ldrb	r3, [r7, #23]
}
 800ecca:	4618      	mov	r0, r3
 800eccc:	3718      	adds	r7, #24
 800ecce:	46bd      	mov	sp, r7
 800ecd0:	bd80      	pop	{r7, pc}
	...

0800ecd4 <LL_EXTI_EnableIT_0_31>:
{
 800ecd4:	b480      	push	{r7}
 800ecd6:	b083      	sub	sp, #12
 800ecd8:	af00      	add	r7, sp, #0
 800ecda:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->IMR1, ExtiLine);
 800ecdc:	4b06      	ldr	r3, [pc, #24]	; (800ecf8 <LL_EXTI_EnableIT_0_31+0x24>)
 800ecde:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 800ece2:	4905      	ldr	r1, [pc, #20]	; (800ecf8 <LL_EXTI_EnableIT_0_31+0x24>)
 800ece4:	687b      	ldr	r3, [r7, #4]
 800ece6:	4313      	orrs	r3, r2
 800ece8:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
}
 800ecec:	bf00      	nop
 800ecee:	370c      	adds	r7, #12
 800ecf0:	46bd      	mov	sp, r7
 800ecf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ecf6:	4770      	bx	lr
 800ecf8:	58000800 	.word	0x58000800

0800ecfc <LL_EXTI_DisableIT_0_31>:
{
 800ecfc:	b480      	push	{r7}
 800ecfe:	b083      	sub	sp, #12
 800ed00:	af00      	add	r7, sp, #0
 800ed02:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(EXTI->IMR1, ExtiLine);
 800ed04:	4b07      	ldr	r3, [pc, #28]	; (800ed24 <LL_EXTI_DisableIT_0_31+0x28>)
 800ed06:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 800ed0a:	687b      	ldr	r3, [r7, #4]
 800ed0c:	43db      	mvns	r3, r3
 800ed0e:	4905      	ldr	r1, [pc, #20]	; (800ed24 <LL_EXTI_DisableIT_0_31+0x28>)
 800ed10:	4013      	ands	r3, r2
 800ed12:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
}
 800ed16:	bf00      	nop
 800ed18:	370c      	adds	r7, #12
 800ed1a:	46bd      	mov	sp, r7
 800ed1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ed20:	4770      	bx	lr
 800ed22:	bf00      	nop
 800ed24:	58000800 	.word	0x58000800

0800ed28 <LL_EXTI_EnableEvent_0_31>:
{
 800ed28:	b480      	push	{r7}
 800ed2a:	b083      	sub	sp, #12
 800ed2c:	af00      	add	r7, sp, #0
 800ed2e:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->EMR1, ExtiLine);
 800ed30:	4b06      	ldr	r3, [pc, #24]	; (800ed4c <LL_EXTI_EnableEvent_0_31+0x24>)
 800ed32:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 800ed36:	4905      	ldr	r1, [pc, #20]	; (800ed4c <LL_EXTI_EnableEvent_0_31+0x24>)
 800ed38:	687b      	ldr	r3, [r7, #4]
 800ed3a:	4313      	orrs	r3, r2
 800ed3c:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
}
 800ed40:	bf00      	nop
 800ed42:	370c      	adds	r7, #12
 800ed44:	46bd      	mov	sp, r7
 800ed46:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ed4a:	4770      	bx	lr
 800ed4c:	58000800 	.word	0x58000800

0800ed50 <LL_EXTI_DisableEvent_0_31>:
{
 800ed50:	b480      	push	{r7}
 800ed52:	b083      	sub	sp, #12
 800ed54:	af00      	add	r7, sp, #0
 800ed56:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(EXTI->EMR1, ExtiLine);
 800ed58:	4b07      	ldr	r3, [pc, #28]	; (800ed78 <LL_EXTI_DisableEvent_0_31+0x28>)
 800ed5a:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 800ed5e:	687b      	ldr	r3, [r7, #4]
 800ed60:	43db      	mvns	r3, r3
 800ed62:	4905      	ldr	r1, [pc, #20]	; (800ed78 <LL_EXTI_DisableEvent_0_31+0x28>)
 800ed64:	4013      	ands	r3, r2
 800ed66:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
}
 800ed6a:	bf00      	nop
 800ed6c:	370c      	adds	r7, #12
 800ed6e:	46bd      	mov	sp, r7
 800ed70:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ed74:	4770      	bx	lr
 800ed76:	bf00      	nop
 800ed78:	58000800 	.word	0x58000800

0800ed7c <LL_EXTI_EnableRisingTrig_0_31>:
{
 800ed7c:	b480      	push	{r7}
 800ed7e:	b083      	sub	sp, #12
 800ed80:	af00      	add	r7, sp, #0
 800ed82:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->RTSR1, ExtiLine);
 800ed84:	4b05      	ldr	r3, [pc, #20]	; (800ed9c <LL_EXTI_EnableRisingTrig_0_31+0x20>)
 800ed86:	681a      	ldr	r2, [r3, #0]
 800ed88:	4904      	ldr	r1, [pc, #16]	; (800ed9c <LL_EXTI_EnableRisingTrig_0_31+0x20>)
 800ed8a:	687b      	ldr	r3, [r7, #4]
 800ed8c:	4313      	orrs	r3, r2
 800ed8e:	600b      	str	r3, [r1, #0]
}
 800ed90:	bf00      	nop
 800ed92:	370c      	adds	r7, #12
 800ed94:	46bd      	mov	sp, r7
 800ed96:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ed9a:	4770      	bx	lr
 800ed9c:	58000800 	.word	0x58000800

0800eda0 <LL_EXTI_DisableRisingTrig_0_31>:
  *         @arg @ref LL_EXTI_LINE_31 (*)
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableRisingTrig_0_31(uint32_t ExtiLine)
{
 800eda0:	b480      	push	{r7}
 800eda2:	b083      	sub	sp, #12
 800eda4:	af00      	add	r7, sp, #0
 800eda6:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(EXTI->RTSR1, ExtiLine);
 800eda8:	4b06      	ldr	r3, [pc, #24]	; (800edc4 <LL_EXTI_DisableRisingTrig_0_31+0x24>)
 800edaa:	681a      	ldr	r2, [r3, #0]
 800edac:	687b      	ldr	r3, [r7, #4]
 800edae:	43db      	mvns	r3, r3
 800edb0:	4904      	ldr	r1, [pc, #16]	; (800edc4 <LL_EXTI_DisableRisingTrig_0_31+0x24>)
 800edb2:	4013      	ands	r3, r2
 800edb4:	600b      	str	r3, [r1, #0]

}
 800edb6:	bf00      	nop
 800edb8:	370c      	adds	r7, #12
 800edba:	46bd      	mov	sp, r7
 800edbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800edc0:	4770      	bx	lr
 800edc2:	bf00      	nop
 800edc4:	58000800 	.word	0x58000800

0800edc8 <LL_EXTI_EnableFallingTrig_0_31>:
  *         (*) value not defined in all devices
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableFallingTrig_0_31(uint32_t ExtiLine)
{
 800edc8:	b480      	push	{r7}
 800edca:	b083      	sub	sp, #12
 800edcc:	af00      	add	r7, sp, #0
 800edce:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->FTSR1, ExtiLine);
 800edd0:	4b05      	ldr	r3, [pc, #20]	; (800ede8 <LL_EXTI_EnableFallingTrig_0_31+0x20>)
 800edd2:	685a      	ldr	r2, [r3, #4]
 800edd4:	4904      	ldr	r1, [pc, #16]	; (800ede8 <LL_EXTI_EnableFallingTrig_0_31+0x20>)
 800edd6:	687b      	ldr	r3, [r7, #4]
 800edd8:	4313      	orrs	r3, r2
 800edda:	604b      	str	r3, [r1, #4]
}
 800eddc:	bf00      	nop
 800edde:	370c      	adds	r7, #12
 800ede0:	46bd      	mov	sp, r7
 800ede2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ede6:	4770      	bx	lr
 800ede8:	58000800 	.word	0x58000800

0800edec <LL_EXTI_DisableFallingTrig_0_31>:
  *         (*) value not defined in all devices
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableFallingTrig_0_31(uint32_t ExtiLine)
{
 800edec:	b480      	push	{r7}
 800edee:	b083      	sub	sp, #12
 800edf0:	af00      	add	r7, sp, #0
 800edf2:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(EXTI->FTSR1, ExtiLine);
 800edf4:	4b06      	ldr	r3, [pc, #24]	; (800ee10 <LL_EXTI_DisableFallingTrig_0_31+0x24>)
 800edf6:	685a      	ldr	r2, [r3, #4]
 800edf8:	687b      	ldr	r3, [r7, #4]
 800edfa:	43db      	mvns	r3, r3
 800edfc:	4904      	ldr	r1, [pc, #16]	; (800ee10 <LL_EXTI_DisableFallingTrig_0_31+0x24>)
 800edfe:	4013      	ands	r3, r2
 800ee00:	604b      	str	r3, [r1, #4]
}
 800ee02:	bf00      	nop
 800ee04:	370c      	adds	r7, #12
 800ee06:	46bd      	mov	sp, r7
 800ee08:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ee0c:	4770      	bx	lr
 800ee0e:	bf00      	nop
 800ee10:	58000800 	.word	0x58000800

0800ee14 <LL_EXTI_IsActiveFlag_0_31>:
  *         @arg @ref LL_EXTI_LINE_31 (*)
  *         (*) value not defined in all devices
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_EXTI_IsActiveFlag_0_31(uint32_t ExtiLine)
{
 800ee14:	b480      	push	{r7}
 800ee16:	b083      	sub	sp, #12
 800ee18:	af00      	add	r7, sp, #0
 800ee1a:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(EXTI->PR1, ExtiLine) == (ExtiLine)) ? 1UL : 0UL);
 800ee1c:	4b07      	ldr	r3, [pc, #28]	; (800ee3c <LL_EXTI_IsActiveFlag_0_31+0x28>)
 800ee1e:	68da      	ldr	r2, [r3, #12]
 800ee20:	687b      	ldr	r3, [r7, #4]
 800ee22:	4013      	ands	r3, r2
 800ee24:	687a      	ldr	r2, [r7, #4]
 800ee26:	429a      	cmp	r2, r3
 800ee28:	d101      	bne.n	800ee2e <LL_EXTI_IsActiveFlag_0_31+0x1a>
 800ee2a:	2301      	movs	r3, #1
 800ee2c:	e000      	b.n	800ee30 <LL_EXTI_IsActiveFlag_0_31+0x1c>
 800ee2e:	2300      	movs	r3, #0
}
 800ee30:	4618      	mov	r0, r3
 800ee32:	370c      	adds	r7, #12
 800ee34:	46bd      	mov	sp, r7
 800ee36:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ee3a:	4770      	bx	lr
 800ee3c:	58000800 	.word	0x58000800

0800ee40 <LL_EXTI_ClearFlag_0_31>:
  *         @arg @ref LL_EXTI_LINE_31 (*)
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_ClearFlag_0_31(uint32_t ExtiLine)
{
 800ee40:	b480      	push	{r7}
 800ee42:	b083      	sub	sp, #12
 800ee44:	af00      	add	r7, sp, #0
 800ee46:	6078      	str	r0, [r7, #4]
  WRITE_REG(EXTI->PR1, ExtiLine);
 800ee48:	4a04      	ldr	r2, [pc, #16]	; (800ee5c <LL_EXTI_ClearFlag_0_31+0x1c>)
 800ee4a:	687b      	ldr	r3, [r7, #4]
 800ee4c:	60d3      	str	r3, [r2, #12]
}
 800ee4e:	bf00      	nop
 800ee50:	370c      	adds	r7, #12
 800ee52:	46bd      	mov	sp, r7
 800ee54:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ee58:	4770      	bx	lr
 800ee5a:	bf00      	nop
 800ee5c:	58000800 	.word	0x58000800

0800ee60 <HAL_COMP_Init>:
  *         To unlock the configuration, perform a system reset.
  * @param  hcomp  COMP handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_COMP_Init(COMP_HandleTypeDef *hcomp)
{
 800ee60:	b580      	push	{r7, lr}
 800ee62:	b088      	sub	sp, #32
 800ee64:	af00      	add	r7, sp, #0
 800ee66:	6078      	str	r0, [r7, #4]
  uint32_t tmp_csr;
  uint32_t exti_line;
  uint32_t comp_voltage_scaler_initialized; /* Value "0" if comparator voltage scaler is not initialized */
  __IO uint32_t wait_loop_index = 0UL;
 800ee68:	2300      	movs	r3, #0
 800ee6a:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef status = HAL_OK;
 800ee6c:	2300      	movs	r3, #0
 800ee6e:	77fb      	strb	r3, [r7, #31]

  /* Check the COMP handle allocation and lock status */
  if(hcomp == NULL)
 800ee70:	687b      	ldr	r3, [r7, #4]
 800ee72:	2b00      	cmp	r3, #0
 800ee74:	d102      	bne.n	800ee7c <HAL_COMP_Init+0x1c>
  {
    status = HAL_ERROR;
 800ee76:	2301      	movs	r3, #1
 800ee78:	77fb      	strb	r3, [r7, #31]
 800ee7a:	e0c4      	b.n	800f006 <HAL_COMP_Init+0x1a6>
  }
  else if(__HAL_COMP_IS_LOCKED(hcomp))
 800ee7c:	687b      	ldr	r3, [r7, #4]
 800ee7e:	681b      	ldr	r3, [r3, #0]
 800ee80:	681b      	ldr	r3, [r3, #0]
 800ee82:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 800ee86:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 800ee8a:	d102      	bne.n	800ee92 <HAL_COMP_Init+0x32>
  {
    status = HAL_ERROR;
 800ee8c:	2301      	movs	r3, #1
 800ee8e:	77fb      	strb	r3, [r7, #31]
 800ee90:	e0b9      	b.n	800f006 <HAL_COMP_Init+0x1a6>
    assert_param(IS_COMP_TRIGGERMODE(hcomp->Init.TriggerMode));
#if defined(COMP2)
    assert_param(IS_COMP_WINDOWMODE(hcomp->Init.WindowMode));
#endif

    if(hcomp->State == HAL_COMP_STATE_RESET)
 800ee92:	687b      	ldr	r3, [r7, #4]
 800ee94:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 800ee98:	b2db      	uxtb	r3, r3
 800ee9a:	2b00      	cmp	r3, #0
 800ee9c:	d109      	bne.n	800eeb2 <HAL_COMP_Init+0x52>
    {
      /* Allocate lock resource and initialize it */
      hcomp->Lock = HAL_UNLOCKED;
 800ee9e:	687b      	ldr	r3, [r7, #4]
 800eea0:	2200      	movs	r2, #0
 800eea2:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

      /* Set COMP error code to none */
      COMP_CLEAR_ERRORCODE(hcomp);
 800eea6:	687b      	ldr	r3, [r7, #4]
 800eea8:	2200      	movs	r2, #0
 800eeaa:	629a      	str	r2, [r3, #40]	; 0x28
#else
      /* Init the low level hardware */
      /* Note: Internal control clock of the comparators must                 */
      /*       be enabled in "HAL_COMP_MspInit()"                             */
      /*       using "__HAL_RCC_SYSCFG_CLK_ENABLE()".                         */
      HAL_COMP_MspInit(hcomp);
 800eeac:	6878      	ldr	r0, [r7, #4]
 800eeae:	f7fd ff65 	bl	800cd7c <HAL_COMP_MspInit>
#endif /* USE_HAL_COMP_REGISTER_CALLBACKS */
    }

    /* Memorize voltage scaler state before initialization */
    comp_voltage_scaler_initialized = READ_BIT(hcomp->Instance->CSR, COMP_CSR_SCALEN);
 800eeb2:	687b      	ldr	r3, [r7, #4]
 800eeb4:	681b      	ldr	r3, [r3, #0]
 800eeb6:	681b      	ldr	r3, [r3, #0]
 800eeb8:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800eebc:	61bb      	str	r3, [r7, #24]

    /* Set COMP parameters */
    tmp_csr = (  hcomp->Init.InputMinus
 800eebe:	687b      	ldr	r3, [r7, #4]
 800eec0:	691a      	ldr	r2, [r3, #16]
               | hcomp->Init.InputPlus
 800eec2:	687b      	ldr	r3, [r7, #4]
 800eec4:	68db      	ldr	r3, [r3, #12]
 800eec6:	431a      	orrs	r2, r3
               | hcomp->Init.BlankingSrce
 800eec8:	687b      	ldr	r3, [r7, #4]
 800eeca:	69db      	ldr	r3, [r3, #28]
 800eecc:	431a      	orrs	r2, r3
               | hcomp->Init.Hysteresis
 800eece:	687b      	ldr	r3, [r7, #4]
 800eed0:	695b      	ldr	r3, [r3, #20]
 800eed2:	431a      	orrs	r2, r3
               | hcomp->Init.OutputPol
 800eed4:	687b      	ldr	r3, [r7, #4]
 800eed6:	699b      	ldr	r3, [r3, #24]
 800eed8:	431a      	orrs	r2, r3
               | hcomp->Init.Mode
 800eeda:	687b      	ldr	r3, [r7, #4]
 800eedc:	689b      	ldr	r3, [r3, #8]
    tmp_csr = (  hcomp->Init.InputMinus
 800eede:	4313      	orrs	r3, r2
 800eee0:	617b      	str	r3, [r7, #20]
              );

    /* Set parameters in COMP register */
    /* Note: Update all bits except read-only, lock and enable bits */
#if defined (COMP_CSR_WINMODE)
    MODIFY_REG(hcomp->Instance->CSR,
 800eee2:	687b      	ldr	r3, [r7, #4]
 800eee4:	681b      	ldr	r3, [r3, #0]
 800eee6:	681a      	ldr	r2, [r3, #0]
 800eee8:	4b49      	ldr	r3, [pc, #292]	; (800f010 <HAL_COMP_Init+0x1b0>)
 800eeea:	4013      	ands	r3, r2
 800eeec:	687a      	ldr	r2, [r7, #4]
 800eeee:	6812      	ldr	r2, [r2, #0]
 800eef0:	6979      	ldr	r1, [r7, #20]
 800eef2:	430b      	orrs	r3, r1
 800eef4:	6013      	str	r3, [r2, #0]
#if defined(COMP2)
    /* Set window mode */
    /* Note: Window mode bit is located into 1 out of the 2 pairs of COMP     */
    /*       instances. Therefore, this function can update another COMP      */
    /*       instance that the one currently selected.                        */
    if(hcomp->Init.WindowMode == COMP_WINDOWMODE_COMP1_INPUT_PLUS_COMMON)
 800eef6:	687b      	ldr	r3, [r7, #4]
 800eef8:	685b      	ldr	r3, [r3, #4]
 800eefa:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800eefe:	d106      	bne.n	800ef0e <HAL_COMP_Init+0xae>
    {
      SET_BIT(COMP12_COMMON->CSR, COMP_CSR_WINMODE);
 800ef00:	4b44      	ldr	r3, [pc, #272]	; (800f014 <HAL_COMP_Init+0x1b4>)
 800ef02:	681b      	ldr	r3, [r3, #0]
 800ef04:	4a43      	ldr	r2, [pc, #268]	; (800f014 <HAL_COMP_Init+0x1b4>)
 800ef06:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800ef0a:	6013      	str	r3, [r2, #0]
 800ef0c:	e005      	b.n	800ef1a <HAL_COMP_Init+0xba>
    }
    else
    {
      CLEAR_BIT(COMP12_COMMON->CSR, COMP_CSR_WINMODE);
 800ef0e:	4b41      	ldr	r3, [pc, #260]	; (800f014 <HAL_COMP_Init+0x1b4>)
 800ef10:	681b      	ldr	r3, [r3, #0]
 800ef12:	4a40      	ldr	r2, [pc, #256]	; (800f014 <HAL_COMP_Init+0x1b4>)
 800ef14:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800ef18:	6013      	str	r3, [r2, #0]
    }
#endif /* COMP2 */

    /* Delay for COMP scaler bridge voltage stabilization */
    /* Apply the delay if voltage scaler bridge is required and not already enabled */
    if ((READ_BIT(hcomp->Instance->CSR, COMP_CSR_SCALEN) != 0UL) &&
 800ef1a:	687b      	ldr	r3, [r7, #4]
 800ef1c:	681b      	ldr	r3, [r3, #0]
 800ef1e:	681b      	ldr	r3, [r3, #0]
 800ef20:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800ef24:	2b00      	cmp	r3, #0
 800ef26:	d015      	beq.n	800ef54 <HAL_COMP_Init+0xf4>
 800ef28:	69bb      	ldr	r3, [r7, #24]
 800ef2a:	2b00      	cmp	r3, #0
 800ef2c:	d112      	bne.n	800ef54 <HAL_COMP_Init+0xf4>
    {
      /* Wait loop initialization and execution */
      /* Note: Variable divided by 2 to compensate partially              */
      /*       CPU processing cycles, scaling in us split to not          */
      /*       exceed 32 bits register capacity and handle low frequency. */
      wait_loop_index = ((COMP_DELAY_VOLTAGE_SCALER_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 800ef2e:	4b3a      	ldr	r3, [pc, #232]	; (800f018 <HAL_COMP_Init+0x1b8>)
 800ef30:	681b      	ldr	r3, [r3, #0]
 800ef32:	099b      	lsrs	r3, r3, #6
 800ef34:	4a39      	ldr	r2, [pc, #228]	; (800f01c <HAL_COMP_Init+0x1bc>)
 800ef36:	fba2 2303 	umull	r2, r3, r2, r3
 800ef3a:	099a      	lsrs	r2, r3, #6
 800ef3c:	4613      	mov	r3, r2
 800ef3e:	009b      	lsls	r3, r3, #2
 800ef40:	4413      	add	r3, r2
 800ef42:	009b      	lsls	r3, r3, #2
 800ef44:	60fb      	str	r3, [r7, #12]
      while(wait_loop_index != 0UL)
 800ef46:	e002      	b.n	800ef4e <HAL_COMP_Init+0xee>
      {
        wait_loop_index--;
 800ef48:	68fb      	ldr	r3, [r7, #12]
 800ef4a:	3b01      	subs	r3, #1
 800ef4c:	60fb      	str	r3, [r7, #12]
      while(wait_loop_index != 0UL)
 800ef4e:	68fb      	ldr	r3, [r7, #12]
 800ef50:	2b00      	cmp	r3, #0
 800ef52:	d1f9      	bne.n	800ef48 <HAL_COMP_Init+0xe8>
      }
    }

    /* Get the EXTI line corresponding to the selected COMP instance */
    exti_line = COMP_GET_EXTI_LINE(hcomp->Instance);
 800ef54:	687b      	ldr	r3, [r7, #4]
 800ef56:	681b      	ldr	r3, [r3, #0]
 800ef58:	4a31      	ldr	r2, [pc, #196]	; (800f020 <HAL_COMP_Init+0x1c0>)
 800ef5a:	4293      	cmp	r3, r2
 800ef5c:	d102      	bne.n	800ef64 <HAL_COMP_Init+0x104>
 800ef5e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800ef62:	e001      	b.n	800ef68 <HAL_COMP_Init+0x108>
 800ef64:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800ef68:	613b      	str	r3, [r7, #16]

    /* Manage EXTI settings */
    if((hcomp->Init.TriggerMode & (COMP_EXTI_IT | COMP_EXTI_EVENT)) != 0UL)
 800ef6a:	687b      	ldr	r3, [r7, #4]
 800ef6c:	6a1b      	ldr	r3, [r3, #32]
 800ef6e:	f003 0303 	and.w	r3, r3, #3
 800ef72:	2b00      	cmp	r3, #0
 800ef74:	d037      	beq.n	800efe6 <HAL_COMP_Init+0x186>
    {
      /* Configure EXTI rising edge */
      if((hcomp->Init.TriggerMode & COMP_EXTI_RISING) != 0UL)
 800ef76:	687b      	ldr	r3, [r7, #4]
 800ef78:	6a1b      	ldr	r3, [r3, #32]
 800ef7a:	f003 0310 	and.w	r3, r3, #16
 800ef7e:	2b00      	cmp	r3, #0
 800ef80:	d003      	beq.n	800ef8a <HAL_COMP_Init+0x12a>
      {
        LL_EXTI_EnableRisingTrig_0_31(exti_line);
 800ef82:	6938      	ldr	r0, [r7, #16]
 800ef84:	f7ff fefa 	bl	800ed7c <LL_EXTI_EnableRisingTrig_0_31>
 800ef88:	e002      	b.n	800ef90 <HAL_COMP_Init+0x130>
      }
      else
      {
        LL_EXTI_DisableRisingTrig_0_31(exti_line);
 800ef8a:	6938      	ldr	r0, [r7, #16]
 800ef8c:	f7ff ff08 	bl	800eda0 <LL_EXTI_DisableRisingTrig_0_31>
      }

      /* Configure EXTI falling edge */
      if((hcomp->Init.TriggerMode & COMP_EXTI_FALLING) != 0UL)
 800ef90:	687b      	ldr	r3, [r7, #4]
 800ef92:	6a1b      	ldr	r3, [r3, #32]
 800ef94:	f003 0320 	and.w	r3, r3, #32
 800ef98:	2b00      	cmp	r3, #0
 800ef9a:	d003      	beq.n	800efa4 <HAL_COMP_Init+0x144>
      {
        LL_EXTI_EnableFallingTrig_0_31(exti_line);
 800ef9c:	6938      	ldr	r0, [r7, #16]
 800ef9e:	f7ff ff13 	bl	800edc8 <LL_EXTI_EnableFallingTrig_0_31>
 800efa2:	e002      	b.n	800efaa <HAL_COMP_Init+0x14a>
      }
      else
      {
        LL_EXTI_DisableFallingTrig_0_31(exti_line);
 800efa4:	6938      	ldr	r0, [r7, #16]
 800efa6:	f7ff ff21 	bl	800edec <LL_EXTI_DisableFallingTrig_0_31>
      }

      /* Clear COMP EXTI pending bit (if any) */
      LL_EXTI_ClearFlag_0_31(exti_line);
 800efaa:	6938      	ldr	r0, [r7, #16]
 800efac:	f7ff ff48 	bl	800ee40 <LL_EXTI_ClearFlag_0_31>

      /* Configure EXTI event mode */
      if((hcomp->Init.TriggerMode & COMP_EXTI_EVENT) != 0UL)
 800efb0:	687b      	ldr	r3, [r7, #4]
 800efb2:	6a1b      	ldr	r3, [r3, #32]
 800efb4:	f003 0302 	and.w	r3, r3, #2
 800efb8:	2b00      	cmp	r3, #0
 800efba:	d003      	beq.n	800efc4 <HAL_COMP_Init+0x164>
      {
        LL_EXTI_EnableEvent_0_31(exti_line);
 800efbc:	6938      	ldr	r0, [r7, #16]
 800efbe:	f7ff feb3 	bl	800ed28 <LL_EXTI_EnableEvent_0_31>
 800efc2:	e002      	b.n	800efca <HAL_COMP_Init+0x16a>
      }
      else
      {
        LL_EXTI_DisableEvent_0_31(exti_line);
 800efc4:	6938      	ldr	r0, [r7, #16]
 800efc6:	f7ff fec3 	bl	800ed50 <LL_EXTI_DisableEvent_0_31>
      }

      /* Configure EXTI interrupt mode */
      if((hcomp->Init.TriggerMode & COMP_EXTI_IT) != 0UL)
 800efca:	687b      	ldr	r3, [r7, #4]
 800efcc:	6a1b      	ldr	r3, [r3, #32]
 800efce:	f003 0301 	and.w	r3, r3, #1
 800efd2:	2b00      	cmp	r3, #0
 800efd4:	d003      	beq.n	800efde <HAL_COMP_Init+0x17e>
      {
        LL_EXTI_EnableIT_0_31(exti_line);
 800efd6:	6938      	ldr	r0, [r7, #16]
 800efd8:	f7ff fe7c 	bl	800ecd4 <LL_EXTI_EnableIT_0_31>
 800efdc:	e009      	b.n	800eff2 <HAL_COMP_Init+0x192>
      }
      else
      {
        LL_EXTI_DisableIT_0_31(exti_line);
 800efde:	6938      	ldr	r0, [r7, #16]
 800efe0:	f7ff fe8c 	bl	800ecfc <LL_EXTI_DisableIT_0_31>
 800efe4:	e005      	b.n	800eff2 <HAL_COMP_Init+0x192>
      }
    }
    else
    {
      /* Disable EXTI event mode */
      LL_EXTI_DisableEvent_0_31(exti_line);
 800efe6:	6938      	ldr	r0, [r7, #16]
 800efe8:	f7ff feb2 	bl	800ed50 <LL_EXTI_DisableEvent_0_31>

      /* Disable EXTI interrupt mode */
      LL_EXTI_DisableIT_0_31(exti_line);
 800efec:	6938      	ldr	r0, [r7, #16]
 800efee:	f7ff fe85 	bl	800ecfc <LL_EXTI_DisableIT_0_31>
    }

    /* Set HAL COMP handle state */
    /* Note: Transition from state reset to state ready,                      */
    /*       otherwise (coming from state ready or busy) no state update.     */
    if (hcomp->State == HAL_COMP_STATE_RESET)
 800eff2:	687b      	ldr	r3, [r7, #4]
 800eff4:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 800eff8:	b2db      	uxtb	r3, r3
 800effa:	2b00      	cmp	r3, #0
 800effc:	d103      	bne.n	800f006 <HAL_COMP_Init+0x1a6>
    {
      hcomp->State = HAL_COMP_STATE_READY;
 800effe:	687b      	ldr	r3, [r7, #4]
 800f000:	2201      	movs	r2, #1
 800f002:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
    }
  }

  return status;
 800f006:	7ffb      	ldrb	r3, [r7, #31]
}
 800f008:	4618      	mov	r0, r3
 800f00a:	3720      	adds	r7, #32
 800f00c:	46bd      	mov	sp, r7
 800f00e:	bd80      	pop	{r7, pc}
 800f010:	f9207c03 	.word	0xf9207c03
 800f014:	40010204 	.word	0x40010204
 800f018:	20000004 	.word	0x20000004
 800f01c:	053e2d63 	.word	0x053e2d63
 800f020:	40010200 	.word	0x40010200

0800f024 <HAL_COMP_IRQHandler>:
  * @brief  Comparator IRQ handler.
  * @param  hcomp  COMP handle
  * @retval None
  */
void HAL_COMP_IRQHandler(COMP_HandleTypeDef *hcomp)
{
 800f024:	b580      	push	{r7, lr}
 800f026:	b084      	sub	sp, #16
 800f028:	af00      	add	r7, sp, #0
 800f02a:	6078      	str	r0, [r7, #4]
  /* Get the EXTI line corresponding to the selected COMP instance */
  uint32_t exti_line = COMP_GET_EXTI_LINE(hcomp->Instance);
 800f02c:	687b      	ldr	r3, [r7, #4]
 800f02e:	681b      	ldr	r3, [r3, #0]
 800f030:	4a11      	ldr	r2, [pc, #68]	; (800f078 <HAL_COMP_IRQHandler+0x54>)
 800f032:	4293      	cmp	r3, r2
 800f034:	d102      	bne.n	800f03c <HAL_COMP_IRQHandler+0x18>
 800f036:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800f03a:	e001      	b.n	800f040 <HAL_COMP_IRQHandler+0x1c>
 800f03c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800f040:	60fb      	str	r3, [r7, #12]

  /* Check COMP EXTI flag */
  if(LL_EXTI_IsActiveFlag_0_31(exti_line) != 0UL)
 800f042:	68f8      	ldr	r0, [r7, #12]
 800f044:	f7ff fee6 	bl	800ee14 <LL_EXTI_IsActiveFlag_0_31>
 800f048:	4603      	mov	r3, r0
 800f04a:	2b00      	cmp	r3, #0
 800f04c:	d010      	beq.n	800f070 <HAL_COMP_IRQHandler+0x4c>
  {
#if defined(COMP2)
    /* Check whether comparator is in independent or window mode */
    if(READ_BIT(COMP12_COMMON->CSR, COMP_CSR_WINMODE) != 0UL)
 800f04e:	4b0b      	ldr	r3, [pc, #44]	; (800f07c <HAL_COMP_IRQHandler+0x58>)
 800f050:	681b      	ldr	r3, [r3, #0]
 800f052:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800f056:	2b00      	cmp	r3, #0
 800f058:	d004      	beq.n	800f064 <HAL_COMP_IRQHandler+0x40>
      /* Note: Pair of comparators in window mode can both trig IRQ when      */
      /*       input voltage is changing from "out of window" area            */
      /*       (low or high ) to the other "out of window" area (high or low).*/
      /*       Both flags must be cleared to call comparator trigger          */
      /*       callback is called once.                                       */
      LL_EXTI_ClearFlag_0_31((COMP_EXTI_LINE_COMP1 | COMP_EXTI_LINE_COMP2));
 800f05a:	f44f 1040 	mov.w	r0, #3145728	; 0x300000
 800f05e:	f7ff feef 	bl	800ee40 <LL_EXTI_ClearFlag_0_31>
 800f062:	e002      	b.n	800f06a <HAL_COMP_IRQHandler+0x46>
    }
    else
#endif /* COMP2 */
    {
      /* Clear COMP EXTI line pending bit */
      LL_EXTI_ClearFlag_0_31(exti_line);
 800f064:	68f8      	ldr	r0, [r7, #12]
 800f066:	f7ff feeb 	bl	800ee40 <LL_EXTI_ClearFlag_0_31>

    /* COMP trigger user callback */
#if (USE_HAL_COMP_REGISTER_CALLBACKS == 1)
    hcomp->TriggerCallback(hcomp);
#else
    HAL_COMP_TriggerCallback(hcomp);
 800f06a:	6878      	ldr	r0, [r7, #4]
 800f06c:	f000 f808 	bl	800f080 <HAL_COMP_TriggerCallback>
#endif /* USE_HAL_COMP_REGISTER_CALLBACKS */
  }
}
 800f070:	bf00      	nop
 800f072:	3710      	adds	r7, #16
 800f074:	46bd      	mov	sp, r7
 800f076:	bd80      	pop	{r7, pc}
 800f078:	40010200 	.word	0x40010200
 800f07c:	40010204 	.word	0x40010204

0800f080 <HAL_COMP_TriggerCallback>:
  * @brief  Comparator trigger callback.
  * @param  hcomp  COMP handle
  * @retval None
  */
__weak void HAL_COMP_TriggerCallback(COMP_HandleTypeDef *hcomp)
{
 800f080:	b480      	push	{r7}
 800f082:	b083      	sub	sp, #12
 800f084:	af00      	add	r7, sp, #0
 800f086:	6078      	str	r0, [r7, #4]
  UNUSED(hcomp);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_COMP_TriggerCallback should be implemented in the user file
   */
}
 800f088:	bf00      	nop
 800f08a:	370c      	adds	r7, #12
 800f08c:	46bd      	mov	sp, r7
 800f08e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f092:	4770      	bx	lr

0800f094 <__NVIC_SetPriorityGrouping>:
{
 800f094:	b480      	push	{r7}
 800f096:	b085      	sub	sp, #20
 800f098:	af00      	add	r7, sp, #0
 800f09a:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800f09c:	687b      	ldr	r3, [r7, #4]
 800f09e:	f003 0307 	and.w	r3, r3, #7
 800f0a2:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800f0a4:	4b0c      	ldr	r3, [pc, #48]	; (800f0d8 <__NVIC_SetPriorityGrouping+0x44>)
 800f0a6:	68db      	ldr	r3, [r3, #12]
 800f0a8:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800f0aa:	68ba      	ldr	r2, [r7, #8]
 800f0ac:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800f0b0:	4013      	ands	r3, r2
 800f0b2:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800f0b4:	68fb      	ldr	r3, [r7, #12]
 800f0b6:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800f0b8:	68bb      	ldr	r3, [r7, #8]
 800f0ba:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800f0bc:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800f0c0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800f0c4:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 800f0c6:	4a04      	ldr	r2, [pc, #16]	; (800f0d8 <__NVIC_SetPriorityGrouping+0x44>)
 800f0c8:	68bb      	ldr	r3, [r7, #8]
 800f0ca:	60d3      	str	r3, [r2, #12]
}
 800f0cc:	bf00      	nop
 800f0ce:	3714      	adds	r7, #20
 800f0d0:	46bd      	mov	sp, r7
 800f0d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f0d6:	4770      	bx	lr
 800f0d8:	e000ed00 	.word	0xe000ed00

0800f0dc <__NVIC_GetPriorityGrouping>:
{
 800f0dc:	b480      	push	{r7}
 800f0de:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800f0e0:	4b04      	ldr	r3, [pc, #16]	; (800f0f4 <__NVIC_GetPriorityGrouping+0x18>)
 800f0e2:	68db      	ldr	r3, [r3, #12]
 800f0e4:	0a1b      	lsrs	r3, r3, #8
 800f0e6:	f003 0307 	and.w	r3, r3, #7
}
 800f0ea:	4618      	mov	r0, r3
 800f0ec:	46bd      	mov	sp, r7
 800f0ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f0f2:	4770      	bx	lr
 800f0f4:	e000ed00 	.word	0xe000ed00

0800f0f8 <__NVIC_EnableIRQ>:
{
 800f0f8:	b480      	push	{r7}
 800f0fa:	b083      	sub	sp, #12
 800f0fc:	af00      	add	r7, sp, #0
 800f0fe:	4603      	mov	r3, r0
 800f100:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800f102:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f106:	2b00      	cmp	r3, #0
 800f108:	db0b      	blt.n	800f122 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800f10a:	79fb      	ldrb	r3, [r7, #7]
 800f10c:	f003 021f 	and.w	r2, r3, #31
 800f110:	4907      	ldr	r1, [pc, #28]	; (800f130 <__NVIC_EnableIRQ+0x38>)
 800f112:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f116:	095b      	lsrs	r3, r3, #5
 800f118:	2001      	movs	r0, #1
 800f11a:	fa00 f202 	lsl.w	r2, r0, r2
 800f11e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800f122:	bf00      	nop
 800f124:	370c      	adds	r7, #12
 800f126:	46bd      	mov	sp, r7
 800f128:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f12c:	4770      	bx	lr
 800f12e:	bf00      	nop
 800f130:	e000e100 	.word	0xe000e100

0800f134 <__NVIC_DisableIRQ>:
{
 800f134:	b480      	push	{r7}
 800f136:	b083      	sub	sp, #12
 800f138:	af00      	add	r7, sp, #0
 800f13a:	4603      	mov	r3, r0
 800f13c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800f13e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f142:	2b00      	cmp	r3, #0
 800f144:	db12      	blt.n	800f16c <__NVIC_DisableIRQ+0x38>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800f146:	79fb      	ldrb	r3, [r7, #7]
 800f148:	f003 021f 	and.w	r2, r3, #31
 800f14c:	490a      	ldr	r1, [pc, #40]	; (800f178 <__NVIC_DisableIRQ+0x44>)
 800f14e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f152:	095b      	lsrs	r3, r3, #5
 800f154:	2001      	movs	r0, #1
 800f156:	fa00 f202 	lsl.w	r2, r0, r2
 800f15a:	3320      	adds	r3, #32
 800f15c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 800f160:	f3bf 8f4f 	dsb	sy
}
 800f164:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 800f166:	f3bf 8f6f 	isb	sy
}
 800f16a:	bf00      	nop
}
 800f16c:	bf00      	nop
 800f16e:	370c      	adds	r7, #12
 800f170:	46bd      	mov	sp, r7
 800f172:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f176:	4770      	bx	lr
 800f178:	e000e100 	.word	0xe000e100

0800f17c <__NVIC_SetPendingIRQ>:
{
 800f17c:	b480      	push	{r7}
 800f17e:	b083      	sub	sp, #12
 800f180:	af00      	add	r7, sp, #0
 800f182:	4603      	mov	r3, r0
 800f184:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800f186:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f18a:	2b00      	cmp	r3, #0
 800f18c:	db0c      	blt.n	800f1a8 <__NVIC_SetPendingIRQ+0x2c>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800f18e:	79fb      	ldrb	r3, [r7, #7]
 800f190:	f003 021f 	and.w	r2, r3, #31
 800f194:	4907      	ldr	r1, [pc, #28]	; (800f1b4 <__NVIC_SetPendingIRQ+0x38>)
 800f196:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f19a:	095b      	lsrs	r3, r3, #5
 800f19c:	2001      	movs	r0, #1
 800f19e:	fa00 f202 	lsl.w	r2, r0, r2
 800f1a2:	3340      	adds	r3, #64	; 0x40
 800f1a4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800f1a8:	bf00      	nop
 800f1aa:	370c      	adds	r7, #12
 800f1ac:	46bd      	mov	sp, r7
 800f1ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f1b2:	4770      	bx	lr
 800f1b4:	e000e100 	.word	0xe000e100

0800f1b8 <__NVIC_ClearPendingIRQ>:
{
 800f1b8:	b480      	push	{r7}
 800f1ba:	b083      	sub	sp, #12
 800f1bc:	af00      	add	r7, sp, #0
 800f1be:	4603      	mov	r3, r0
 800f1c0:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800f1c2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f1c6:	2b00      	cmp	r3, #0
 800f1c8:	db0c      	blt.n	800f1e4 <__NVIC_ClearPendingIRQ+0x2c>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800f1ca:	79fb      	ldrb	r3, [r7, #7]
 800f1cc:	f003 021f 	and.w	r2, r3, #31
 800f1d0:	4907      	ldr	r1, [pc, #28]	; (800f1f0 <__NVIC_ClearPendingIRQ+0x38>)
 800f1d2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f1d6:	095b      	lsrs	r3, r3, #5
 800f1d8:	2001      	movs	r0, #1
 800f1da:	fa00 f202 	lsl.w	r2, r0, r2
 800f1de:	3360      	adds	r3, #96	; 0x60
 800f1e0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800f1e4:	bf00      	nop
 800f1e6:	370c      	adds	r7, #12
 800f1e8:	46bd      	mov	sp, r7
 800f1ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f1ee:	4770      	bx	lr
 800f1f0:	e000e100 	.word	0xe000e100

0800f1f4 <__NVIC_SetPriority>:
{
 800f1f4:	b480      	push	{r7}
 800f1f6:	b083      	sub	sp, #12
 800f1f8:	af00      	add	r7, sp, #0
 800f1fa:	4603      	mov	r3, r0
 800f1fc:	6039      	str	r1, [r7, #0]
 800f1fe:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800f200:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f204:	2b00      	cmp	r3, #0
 800f206:	db0a      	blt.n	800f21e <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800f208:	683b      	ldr	r3, [r7, #0]
 800f20a:	b2da      	uxtb	r2, r3
 800f20c:	490c      	ldr	r1, [pc, #48]	; (800f240 <__NVIC_SetPriority+0x4c>)
 800f20e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f212:	0112      	lsls	r2, r2, #4
 800f214:	b2d2      	uxtb	r2, r2
 800f216:	440b      	add	r3, r1
 800f218:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 800f21c:	e00a      	b.n	800f234 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800f21e:	683b      	ldr	r3, [r7, #0]
 800f220:	b2da      	uxtb	r2, r3
 800f222:	4908      	ldr	r1, [pc, #32]	; (800f244 <__NVIC_SetPriority+0x50>)
 800f224:	79fb      	ldrb	r3, [r7, #7]
 800f226:	f003 030f 	and.w	r3, r3, #15
 800f22a:	3b04      	subs	r3, #4
 800f22c:	0112      	lsls	r2, r2, #4
 800f22e:	b2d2      	uxtb	r2, r2
 800f230:	440b      	add	r3, r1
 800f232:	761a      	strb	r2, [r3, #24]
}
 800f234:	bf00      	nop
 800f236:	370c      	adds	r7, #12
 800f238:	46bd      	mov	sp, r7
 800f23a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f23e:	4770      	bx	lr
 800f240:	e000e100 	.word	0xe000e100
 800f244:	e000ed00 	.word	0xe000ed00

0800f248 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800f248:	b480      	push	{r7}
 800f24a:	b089      	sub	sp, #36	; 0x24
 800f24c:	af00      	add	r7, sp, #0
 800f24e:	60f8      	str	r0, [r7, #12]
 800f250:	60b9      	str	r1, [r7, #8]
 800f252:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800f254:	68fb      	ldr	r3, [r7, #12]
 800f256:	f003 0307 	and.w	r3, r3, #7
 800f25a:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800f25c:	69fb      	ldr	r3, [r7, #28]
 800f25e:	f1c3 0307 	rsb	r3, r3, #7
 800f262:	2b04      	cmp	r3, #4
 800f264:	bf28      	it	cs
 800f266:	2304      	movcs	r3, #4
 800f268:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800f26a:	69fb      	ldr	r3, [r7, #28]
 800f26c:	3304      	adds	r3, #4
 800f26e:	2b06      	cmp	r3, #6
 800f270:	d902      	bls.n	800f278 <NVIC_EncodePriority+0x30>
 800f272:	69fb      	ldr	r3, [r7, #28]
 800f274:	3b03      	subs	r3, #3
 800f276:	e000      	b.n	800f27a <NVIC_EncodePriority+0x32>
 800f278:	2300      	movs	r3, #0
 800f27a:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800f27c:	f04f 32ff 	mov.w	r2, #4294967295
 800f280:	69bb      	ldr	r3, [r7, #24]
 800f282:	fa02 f303 	lsl.w	r3, r2, r3
 800f286:	43da      	mvns	r2, r3
 800f288:	68bb      	ldr	r3, [r7, #8]
 800f28a:	401a      	ands	r2, r3
 800f28c:	697b      	ldr	r3, [r7, #20]
 800f28e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800f290:	f04f 31ff 	mov.w	r1, #4294967295
 800f294:	697b      	ldr	r3, [r7, #20]
 800f296:	fa01 f303 	lsl.w	r3, r1, r3
 800f29a:	43d9      	mvns	r1, r3
 800f29c:	687b      	ldr	r3, [r7, #4]
 800f29e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800f2a0:	4313      	orrs	r3, r2
         );
}
 800f2a2:	4618      	mov	r0, r3
 800f2a4:	3724      	adds	r7, #36	; 0x24
 800f2a6:	46bd      	mov	sp, r7
 800f2a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f2ac:	4770      	bx	lr
	...

0800f2b0 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 800f2b0:	b580      	push	{r7, lr}
 800f2b2:	b082      	sub	sp, #8
 800f2b4:	af00      	add	r7, sp, #0
 800f2b6:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800f2b8:	687b      	ldr	r3, [r7, #4]
 800f2ba:	3b01      	subs	r3, #1
 800f2bc:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 800f2c0:	d301      	bcc.n	800f2c6 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 800f2c2:	2301      	movs	r3, #1
 800f2c4:	e00f      	b.n	800f2e6 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800f2c6:	4a0a      	ldr	r2, [pc, #40]	; (800f2f0 <SysTick_Config+0x40>)
 800f2c8:	687b      	ldr	r3, [r7, #4]
 800f2ca:	3b01      	subs	r3, #1
 800f2cc:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800f2ce:	210f      	movs	r1, #15
 800f2d0:	f04f 30ff 	mov.w	r0, #4294967295
 800f2d4:	f7ff ff8e 	bl	800f1f4 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800f2d8:	4b05      	ldr	r3, [pc, #20]	; (800f2f0 <SysTick_Config+0x40>)
 800f2da:	2200      	movs	r2, #0
 800f2dc:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800f2de:	4b04      	ldr	r3, [pc, #16]	; (800f2f0 <SysTick_Config+0x40>)
 800f2e0:	2207      	movs	r2, #7
 800f2e2:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800f2e4:	2300      	movs	r3, #0
}
 800f2e6:	4618      	mov	r0, r3
 800f2e8:	3708      	adds	r7, #8
 800f2ea:	46bd      	mov	sp, r7
 800f2ec:	bd80      	pop	{r7, pc}
 800f2ee:	bf00      	nop
 800f2f0:	e000e010 	.word	0xe000e010

0800f2f4 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800f2f4:	b580      	push	{r7, lr}
 800f2f6:	b082      	sub	sp, #8
 800f2f8:	af00      	add	r7, sp, #0
 800f2fa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 800f2fc:	6878      	ldr	r0, [r7, #4]
 800f2fe:	f7ff fec9 	bl	800f094 <__NVIC_SetPriorityGrouping>
}
 800f302:	bf00      	nop
 800f304:	3708      	adds	r7, #8
 800f306:	46bd      	mov	sp, r7
 800f308:	bd80      	pop	{r7, pc}

0800f30a <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800f30a:	b580      	push	{r7, lr}
 800f30c:	b086      	sub	sp, #24
 800f30e:	af00      	add	r7, sp, #0
 800f310:	4603      	mov	r3, r0
 800f312:	60b9      	str	r1, [r7, #8]
 800f314:	607a      	str	r2, [r7, #4]
 800f316:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 800f318:	f7ff fee0 	bl	800f0dc <__NVIC_GetPriorityGrouping>
 800f31c:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 800f31e:	687a      	ldr	r2, [r7, #4]
 800f320:	68b9      	ldr	r1, [r7, #8]
 800f322:	6978      	ldr	r0, [r7, #20]
 800f324:	f7ff ff90 	bl	800f248 <NVIC_EncodePriority>
 800f328:	4602      	mov	r2, r0
 800f32a:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800f32e:	4611      	mov	r1, r2
 800f330:	4618      	mov	r0, r3
 800f332:	f7ff ff5f 	bl	800f1f4 <__NVIC_SetPriority>
}
 800f336:	bf00      	nop
 800f338:	3718      	adds	r7, #24
 800f33a:	46bd      	mov	sp, r7
 800f33c:	bd80      	pop	{r7, pc}

0800f33e <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32wbxxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800f33e:	b580      	push	{r7, lr}
 800f340:	b082      	sub	sp, #8
 800f342:	af00      	add	r7, sp, #0
 800f344:	4603      	mov	r3, r0
 800f346:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800f348:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f34c:	4618      	mov	r0, r3
 800f34e:	f7ff fed3 	bl	800f0f8 <__NVIC_EnableIRQ>
}
 800f352:	bf00      	nop
 800f354:	3708      	adds	r7, #8
 800f356:	46bd      	mov	sp, r7
 800f358:	bd80      	pop	{r7, pc}

0800f35a <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32wbxxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 800f35a:	b580      	push	{r7, lr}
 800f35c:	b082      	sub	sp, #8
 800f35e:	af00      	add	r7, sp, #0
 800f360:	4603      	mov	r3, r0
 800f362:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
 800f364:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f368:	4618      	mov	r0, r3
 800f36a:	f7ff fee3 	bl	800f134 <__NVIC_DisableIRQ>
}
 800f36e:	bf00      	nop
 800f370:	3708      	adds	r7, #8
 800f372:	46bd      	mov	sp, r7
 800f374:	bd80      	pop	{r7, pc}

0800f376 <HAL_SYSTICK_Config>:
  * @param TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800f376:	b580      	push	{r7, lr}
 800f378:	b082      	sub	sp, #8
 800f37a:	af00      	add	r7, sp, #0
 800f37c:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 800f37e:	6878      	ldr	r0, [r7, #4]
 800f380:	f7ff ff96 	bl	800f2b0 <SysTick_Config>
 800f384:	4603      	mov	r3, r0
}
 800f386:	4618      	mov	r0, r3
 800f388:	3708      	adds	r7, #8
 800f38a:	46bd      	mov	sp, r7
 800f38c:	bd80      	pop	{r7, pc}

0800f38e <HAL_NVIC_SetPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32wbxxxx.h))
  * @retval None
  */
void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
 800f38e:	b580      	push	{r7, lr}
 800f390:	b082      	sub	sp, #8
 800f392:	af00      	add	r7, sp, #0
 800f394:	4603      	mov	r3, r0
 800f396:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Set interrupt pending */
  NVIC_SetPendingIRQ(IRQn);
 800f398:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f39c:	4618      	mov	r0, r3
 800f39e:	f7ff feed 	bl	800f17c <__NVIC_SetPendingIRQ>
}
 800f3a2:	bf00      	nop
 800f3a4:	3708      	adds	r7, #8
 800f3a6:	46bd      	mov	sp, r7
 800f3a8:	bd80      	pop	{r7, pc}

0800f3aa <HAL_NVIC_ClearPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32wbxxxx.h))
  * @retval None
  */
void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
 800f3aa:	b580      	push	{r7, lr}
 800f3ac:	b082      	sub	sp, #8
 800f3ae:	af00      	add	r7, sp, #0
 800f3b0:	4603      	mov	r3, r0
 800f3b2:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Clear pending interrupt */
  NVIC_ClearPendingIRQ(IRQn);
 800f3b4:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f3b8:	4618      	mov	r0, r3
 800f3ba:	f7ff fefd 	bl	800f1b8 <__NVIC_ClearPendingIRQ>
}
 800f3be:	bf00      	nop
 800f3c0:	3708      	adds	r7, #8
 800f3c2:	46bd      	mov	sp, r7
 800f3c4:	bd80      	pop	{r7, pc}
	...

0800f3c8 <HAL_DMA_Init>:
  * @param hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 800f3c8:	b580      	push	{r7, lr}
 800f3ca:	b084      	sub	sp, #16
 800f3cc:	af00      	add	r7, sp, #0
 800f3ce:	6078      	str	r0, [r7, #4]
  uint32_t tmp;

  /* Check the DMA handle allocation */
  if (hdma == NULL)
 800f3d0:	687b      	ldr	r3, [r7, #4]
 800f3d2:	2b00      	cmp	r3, #0
 800f3d4:	d101      	bne.n	800f3da <HAL_DMA_Init+0x12>
  {
    return HAL_ERROR;
 800f3d6:	2301      	movs	r3, #1
 800f3d8:	e08e      	b.n	800f4f8 <HAL_DMA_Init+0x130>

  assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));

#if defined(DMA2)
  /* Compute the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 800f3da:	687b      	ldr	r3, [r7, #4]
 800f3dc:	681b      	ldr	r3, [r3, #0]
 800f3de:	461a      	mov	r2, r3
 800f3e0:	4b47      	ldr	r3, [pc, #284]	; (800f500 <HAL_DMA_Init+0x138>)
 800f3e2:	429a      	cmp	r2, r3
 800f3e4:	d80f      	bhi.n	800f406 <HAL_DMA_Init+0x3e>
  {
    /* DMA1 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 800f3e6:	687b      	ldr	r3, [r7, #4]
 800f3e8:	681b      	ldr	r3, [r3, #0]
 800f3ea:	461a      	mov	r2, r3
 800f3ec:	4b45      	ldr	r3, [pc, #276]	; (800f504 <HAL_DMA_Init+0x13c>)
 800f3ee:	4413      	add	r3, r2
 800f3f0:	4a45      	ldr	r2, [pc, #276]	; (800f508 <HAL_DMA_Init+0x140>)
 800f3f2:	fba2 2303 	umull	r2, r3, r2, r3
 800f3f6:	091b      	lsrs	r3, r3, #4
 800f3f8:	009a      	lsls	r2, r3, #2
 800f3fa:	687b      	ldr	r3, [r7, #4]
 800f3fc:	645a      	str	r2, [r3, #68]	; 0x44
    hdma->DmaBaseAddress = DMA1;
 800f3fe:	687b      	ldr	r3, [r7, #4]
 800f400:	4a42      	ldr	r2, [pc, #264]	; (800f50c <HAL_DMA_Init+0x144>)
 800f402:	641a      	str	r2, [r3, #64]	; 0x40
 800f404:	e00e      	b.n	800f424 <HAL_DMA_Init+0x5c>
  }
  else
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 800f406:	687b      	ldr	r3, [r7, #4]
 800f408:	681b      	ldr	r3, [r3, #0]
 800f40a:	461a      	mov	r2, r3
 800f40c:	4b40      	ldr	r3, [pc, #256]	; (800f510 <HAL_DMA_Init+0x148>)
 800f40e:	4413      	add	r3, r2
 800f410:	4a3d      	ldr	r2, [pc, #244]	; (800f508 <HAL_DMA_Init+0x140>)
 800f412:	fba2 2303 	umull	r2, r3, r2, r3
 800f416:	091b      	lsrs	r3, r3, #4
 800f418:	009a      	lsls	r2, r3, #2
 800f41a:	687b      	ldr	r3, [r7, #4]
 800f41c:	645a      	str	r2, [r3, #68]	; 0x44
    hdma->DmaBaseAddress = DMA2;
 800f41e:	687b      	ldr	r3, [r7, #4]
 800f420:	4a3c      	ldr	r2, [pc, #240]	; (800f514 <HAL_DMA_Init+0x14c>)
 800f422:	641a      	str	r2, [r3, #64]	; 0x40
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
  hdma->DmaBaseAddress = DMA1;
#endif

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 800f424:	687b      	ldr	r3, [r7, #4]
 800f426:	2202      	movs	r2, #2
 800f428:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 800f42c:	687b      	ldr	r3, [r7, #4]
 800f42e:	681b      	ldr	r3, [r3, #0]
 800f430:	681b      	ldr	r3, [r3, #0]
 800f432:	60fb      	str	r3, [r7, #12]

  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR and MEM2MEM bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 800f434:	68fb      	ldr	r3, [r7, #12]
 800f436:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 800f43a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800f43e:	60fb      	str	r3, [r7, #12]
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   |
                      DMA_CCR_DIR   | DMA_CCR_MEM2MEM));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 800f440:	687b      	ldr	r3, [r7, #4]
 800f442:	689a      	ldr	r2, [r3, #8]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800f444:	687b      	ldr	r3, [r7, #4]
 800f446:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Direction        |
 800f448:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800f44a:	687b      	ldr	r3, [r7, #4]
 800f44c:	691b      	ldr	r3, [r3, #16]
 800f44e:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800f450:	687b      	ldr	r3, [r7, #4]
 800f452:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800f454:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800f456:	687b      	ldr	r3, [r7, #4]
 800f458:	699b      	ldr	r3, [r3, #24]
 800f45a:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 800f45c:	687b      	ldr	r3, [r7, #4]
 800f45e:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800f460:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 800f462:	687b      	ldr	r3, [r7, #4]
 800f464:	6a1b      	ldr	r3, [r3, #32]
 800f466:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Direction        |
 800f468:	68fa      	ldr	r2, [r7, #12]
 800f46a:	4313      	orrs	r3, r2
 800f46c:	60fb      	str	r3, [r7, #12]

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;
 800f46e:	687b      	ldr	r3, [r7, #4]
 800f470:	681b      	ldr	r3, [r3, #0]
 800f472:	68fa      	ldr	r2, [r7, #12]
 800f474:	601a      	str	r2, [r3, #0]

  /* Initialize parameters for DMAMUX channel :
     DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask
  */
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 800f476:	6878      	ldr	r0, [r7, #4]
 800f478:	f000 f8fe 	bl	800f678 <DMA_CalcDMAMUXChannelBaseAndMask>

  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 800f47c:	687b      	ldr	r3, [r7, #4]
 800f47e:	689b      	ldr	r3, [r3, #8]
 800f480:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800f484:	d102      	bne.n	800f48c <HAL_DMA_Init+0xc4>
  {
    /* if memory to memory force the request to 0*/
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 800f486:	687b      	ldr	r3, [r7, #4]
 800f488:	2200      	movs	r2, #0
 800f48a:	605a      	str	r2, [r3, #4]
  }

  /* Set peripheral request  to DMAMUX channel */
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 800f48c:	687b      	ldr	r3, [r7, #4]
 800f48e:	685a      	ldr	r2, [r3, #4]
 800f490:	687b      	ldr	r3, [r7, #4]
 800f492:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800f494:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 800f498:	601a      	str	r2, [r3, #0]

  /* Clear the DMAMUX synchro overrun flag */
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800f49a:	687b      	ldr	r3, [r7, #4]
 800f49c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800f49e:	687a      	ldr	r2, [r7, #4]
 800f4a0:	6d12      	ldr	r2, [r2, #80]	; 0x50
 800f4a2:	605a      	str	r2, [r3, #4]

  if (((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 800f4a4:	687b      	ldr	r3, [r7, #4]
 800f4a6:	685b      	ldr	r3, [r3, #4]
 800f4a8:	2b00      	cmp	r3, #0
 800f4aa:	d010      	beq.n	800f4ce <HAL_DMA_Init+0x106>
 800f4ac:	687b      	ldr	r3, [r7, #4]
 800f4ae:	685b      	ldr	r3, [r3, #4]
 800f4b0:	2b04      	cmp	r3, #4
 800f4b2:	d80c      	bhi.n	800f4ce <HAL_DMA_Init+0x106>
  {
    /* Initialize parameters for DMAMUX request generator :
       DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask
    */
    DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
 800f4b4:	6878      	ldr	r0, [r7, #4]
 800f4b6:	f000 f91d 	bl	800f6f4 <DMA_CalcDMAMUXRequestGenBaseAndMask>

    /* Reset the DMAMUX request generator register*/
    hdma->DMAmuxRequestGen->RGCR = 0U;
 800f4ba:	687b      	ldr	r3, [r7, #4]
 800f4bc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800f4be:	2200      	movs	r2, #0
 800f4c0:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX request generator overrun flag */
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800f4c2:	687b      	ldr	r3, [r7, #4]
 800f4c4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800f4c6:	687a      	ldr	r2, [r7, #4]
 800f4c8:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 800f4ca:	605a      	str	r2, [r3, #4]
 800f4cc:	e008      	b.n	800f4e0 <HAL_DMA_Init+0x118>
  }
  else
  {
    hdma->DMAmuxRequestGen = 0U;
 800f4ce:	687b      	ldr	r3, [r7, #4]
 800f4d0:	2200      	movs	r2, #0
 800f4d2:	655a      	str	r2, [r3, #84]	; 0x54
    hdma->DMAmuxRequestGenStatus = 0U;
 800f4d4:	687b      	ldr	r3, [r7, #4]
 800f4d6:	2200      	movs	r2, #0
 800f4d8:	659a      	str	r2, [r3, #88]	; 0x58
    hdma->DMAmuxRequestGenStatusMask = 0U;
 800f4da:	687b      	ldr	r3, [r7, #4]
 800f4dc:	2200      	movs	r2, #0
 800f4de:	65da      	str	r2, [r3, #92]	; 0x5c
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800f4e0:	687b      	ldr	r3, [r7, #4]
 800f4e2:	2200      	movs	r2, #0
 800f4e4:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Initialize the DMA state*/
  hdma->State  = HAL_DMA_STATE_READY;
 800f4e6:	687b      	ldr	r3, [r7, #4]
 800f4e8:	2201      	movs	r2, #1
 800f4ea:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  /* Allocate lock resource and initialize it */
  hdma->Lock = HAL_UNLOCKED;
 800f4ee:	687b      	ldr	r3, [r7, #4]
 800f4f0:	2200      	movs	r2, #0
 800f4f2:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  return HAL_OK;
 800f4f6:	2300      	movs	r3, #0
}
 800f4f8:	4618      	mov	r0, r3
 800f4fa:	3710      	adds	r7, #16
 800f4fc:	46bd      	mov	sp, r7
 800f4fe:	bd80      	pop	{r7, pc}
 800f500:	40020407 	.word	0x40020407
 800f504:	bffdfff8 	.word	0xbffdfff8
 800f508:	cccccccd 	.word	0xcccccccd
 800f50c:	40020000 	.word	0x40020000
 800f510:	bffdfbf8 	.word	0xbffdfbf8
 800f514:	40020400 	.word	0x40020400

0800f518 <HAL_DMA_IRQHandler>:
  * @param hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 800f518:	b580      	push	{r7, lr}
 800f51a:	b084      	sub	sp, #16
 800f51c:	af00      	add	r7, sp, #0
 800f51e:	6078      	str	r0, [r7, #4]
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 800f520:	687b      	ldr	r3, [r7, #4]
 800f522:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f524:	681b      	ldr	r3, [r3, #0]
 800f526:	60fb      	str	r3, [r7, #12]
  uint32_t source_it = hdma->Instance->CCR;
 800f528:	687b      	ldr	r3, [r7, #4]
 800f52a:	681b      	ldr	r3, [r3, #0]
 800f52c:	681b      	ldr	r3, [r3, #0]
 800f52e:	60bb      	str	r3, [r7, #8]

  /* Half Transfer Complete Interrupt management ******************************/
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1cU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 800f530:	687b      	ldr	r3, [r7, #4]
 800f532:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f534:	f003 031c 	and.w	r3, r3, #28
 800f538:	2204      	movs	r2, #4
 800f53a:	409a      	lsls	r2, r3
 800f53c:	68fb      	ldr	r3, [r7, #12]
 800f53e:	4013      	ands	r3, r2
 800f540:	2b00      	cmp	r3, #0
 800f542:	d026      	beq.n	800f592 <HAL_DMA_IRQHandler+0x7a>
 800f544:	68bb      	ldr	r3, [r7, #8]
 800f546:	f003 0304 	and.w	r3, r3, #4
 800f54a:	2b00      	cmp	r3, #0
 800f54c:	d021      	beq.n	800f592 <HAL_DMA_IRQHandler+0x7a>
  {
    /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 800f54e:	687b      	ldr	r3, [r7, #4]
 800f550:	681b      	ldr	r3, [r3, #0]
 800f552:	681b      	ldr	r3, [r3, #0]
 800f554:	f003 0320 	and.w	r3, r3, #32
 800f558:	2b00      	cmp	r3, #0
 800f55a:	d107      	bne.n	800f56c <HAL_DMA_IRQHandler+0x54>
    {
      /* Disable the half transfer interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 800f55c:	687b      	ldr	r3, [r7, #4]
 800f55e:	681b      	ldr	r3, [r3, #0]
 800f560:	681a      	ldr	r2, [r3, #0]
 800f562:	687b      	ldr	r3, [r7, #4]
 800f564:	681b      	ldr	r3, [r3, #0]
 800f566:	f022 0204 	bic.w	r2, r2, #4
 800f56a:	601a      	str	r2, [r3, #0]
    }
    /* Clear the half transfer complete flag */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1CU));
 800f56c:	687b      	ldr	r3, [r7, #4]
 800f56e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f570:	f003 021c 	and.w	r2, r3, #28
 800f574:	687b      	ldr	r3, [r7, #4]
 800f576:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f578:	2104      	movs	r1, #4
 800f57a:	fa01 f202 	lsl.w	r2, r1, r2
 800f57e:	605a      	str	r2, [r3, #4]

    /* DMA peripheral state is not updated in Half Transfer */
    /* but in Transfer Complete case */

    if (hdma->XferHalfCpltCallback != NULL)
 800f580:	687b      	ldr	r3, [r7, #4]
 800f582:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f584:	2b00      	cmp	r3, #0
 800f586:	d071      	beq.n	800f66c <HAL_DMA_IRQHandler+0x154>
    {
      /* Half transfer callback */
      hdma->XferHalfCpltCallback(hdma);
 800f588:	687b      	ldr	r3, [r7, #4]
 800f58a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f58c:	6878      	ldr	r0, [r7, #4]
 800f58e:	4798      	blx	r3
    if (hdma->XferHalfCpltCallback != NULL)
 800f590:	e06c      	b.n	800f66c <HAL_DMA_IRQHandler+0x154>
    }
  }

  /* Transfer Complete Interrupt management ***********************************/
  else if (((flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1cU))) != 0U) && ((source_it & DMA_IT_TC) != 0U))
 800f592:	687b      	ldr	r3, [r7, #4]
 800f594:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f596:	f003 031c 	and.w	r3, r3, #28
 800f59a:	2202      	movs	r2, #2
 800f59c:	409a      	lsls	r2, r3
 800f59e:	68fb      	ldr	r3, [r7, #12]
 800f5a0:	4013      	ands	r3, r2
 800f5a2:	2b00      	cmp	r3, #0
 800f5a4:	d02e      	beq.n	800f604 <HAL_DMA_IRQHandler+0xec>
 800f5a6:	68bb      	ldr	r3, [r7, #8]
 800f5a8:	f003 0302 	and.w	r3, r3, #2
 800f5ac:	2b00      	cmp	r3, #0
 800f5ae:	d029      	beq.n	800f604 <HAL_DMA_IRQHandler+0xec>
  {
    if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 800f5b0:	687b      	ldr	r3, [r7, #4]
 800f5b2:	681b      	ldr	r3, [r3, #0]
 800f5b4:	681b      	ldr	r3, [r3, #0]
 800f5b6:	f003 0320 	and.w	r3, r3, #32
 800f5ba:	2b00      	cmp	r3, #0
 800f5bc:	d10b      	bne.n	800f5d6 <HAL_DMA_IRQHandler+0xbe>
    {
      /* Disable the transfer complete and error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 800f5be:	687b      	ldr	r3, [r7, #4]
 800f5c0:	681b      	ldr	r3, [r3, #0]
 800f5c2:	681a      	ldr	r2, [r3, #0]
 800f5c4:	687b      	ldr	r3, [r7, #4]
 800f5c6:	681b      	ldr	r3, [r3, #0]
 800f5c8:	f022 020a 	bic.w	r2, r2, #10
 800f5cc:	601a      	str	r2, [r3, #0]

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 800f5ce:	687b      	ldr	r3, [r7, #4]
 800f5d0:	2201      	movs	r2, #1
 800f5d2:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
    }
    /* Clear the transfer complete flag */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_TCIF1 << (hdma->ChannelIndex & 0x1cU));
 800f5d6:	687b      	ldr	r3, [r7, #4]
 800f5d8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f5da:	f003 021c 	and.w	r2, r3, #28
 800f5de:	687b      	ldr	r3, [r7, #4]
 800f5e0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f5e2:	2102      	movs	r1, #2
 800f5e4:	fa01 f202 	lsl.w	r2, r1, r2
 800f5e8:	605a      	str	r2, [r3, #4]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 800f5ea:	687b      	ldr	r3, [r7, #4]
 800f5ec:	2200      	movs	r2, #0
 800f5ee:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    if (hdma->XferCpltCallback != NULL)
 800f5f2:	687b      	ldr	r3, [r7, #4]
 800f5f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800f5f6:	2b00      	cmp	r3, #0
 800f5f8:	d038      	beq.n	800f66c <HAL_DMA_IRQHandler+0x154>
    {
      /* Transfer complete callback */
      hdma->XferCpltCallback(hdma);
 800f5fa:	687b      	ldr	r3, [r7, #4]
 800f5fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800f5fe:	6878      	ldr	r0, [r7, #4]
 800f600:	4798      	blx	r3
    if (hdma->XferCpltCallback != NULL)
 800f602:	e033      	b.n	800f66c <HAL_DMA_IRQHandler+0x154>
    }
  }

  /* Transfer Error Interrupt management **************************************/
  else if (((flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1cU)))!= 0U) && ((source_it & DMA_IT_TE) != 0U))
 800f604:	687b      	ldr	r3, [r7, #4]
 800f606:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f608:	f003 031c 	and.w	r3, r3, #28
 800f60c:	2208      	movs	r2, #8
 800f60e:	409a      	lsls	r2, r3
 800f610:	68fb      	ldr	r3, [r7, #12]
 800f612:	4013      	ands	r3, r2
 800f614:	2b00      	cmp	r3, #0
 800f616:	d02a      	beq.n	800f66e <HAL_DMA_IRQHandler+0x156>
 800f618:	68bb      	ldr	r3, [r7, #8]
 800f61a:	f003 0308 	and.w	r3, r3, #8
 800f61e:	2b00      	cmp	r3, #0
 800f620:	d025      	beq.n	800f66e <HAL_DMA_IRQHandler+0x156>
  {
    /* When a DMA transfer error occurs */
    /* A hardware clear of its EN bits is performed */
    /* Disable ALL DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 800f622:	687b      	ldr	r3, [r7, #4]
 800f624:	681b      	ldr	r3, [r3, #0]
 800f626:	681a      	ldr	r2, [r3, #0]
 800f628:	687b      	ldr	r3, [r7, #4]
 800f62a:	681b      	ldr	r3, [r3, #0]
 800f62c:	f022 020e 	bic.w	r2, r2, #14
 800f630:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 800f632:	687b      	ldr	r3, [r7, #4]
 800f634:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f636:	f003 021c 	and.w	r2, r3, #28
 800f63a:	687b      	ldr	r3, [r7, #4]
 800f63c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f63e:	2101      	movs	r1, #1
 800f640:	fa01 f202 	lsl.w	r2, r1, r2
 800f644:	605a      	str	r2, [r3, #4]

    /* Update error code */
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 800f646:	687b      	ldr	r3, [r7, #4]
 800f648:	2201      	movs	r2, #1
 800f64a:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 800f64c:	687b      	ldr	r3, [r7, #4]
 800f64e:	2201      	movs	r2, #1
 800f650:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 800f654:	687b      	ldr	r3, [r7, #4]
 800f656:	2200      	movs	r2, #0
 800f658:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    if (hdma->XferErrorCallback != NULL)
 800f65c:	687b      	ldr	r3, [r7, #4]
 800f65e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f660:	2b00      	cmp	r3, #0
 800f662:	d004      	beq.n	800f66e <HAL_DMA_IRQHandler+0x156>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 800f664:	687b      	ldr	r3, [r7, #4]
 800f666:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f668:	6878      	ldr	r0, [r7, #4]
 800f66a:	4798      	blx	r3
  }
  else
  {
    /* Nothing To Do */
  }
  return;
 800f66c:	bf00      	nop
 800f66e:	bf00      	nop
}
 800f670:	3710      	adds	r7, #16
 800f672:	46bd      	mov	sp, r7
 800f674:	bd80      	pop	{r7, pc}
	...

0800f678 <DMA_CalcDMAMUXChannelBaseAndMask>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Channel.
  * @retval None
  */
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
 800f678:	b480      	push	{r7}
 800f67a:	b085      	sub	sp, #20
 800f67c:	af00      	add	r7, sp, #0
 800f67e:	6078      	str	r0, [r7, #4]
  uint32_t channel_number;

  /* check if instance is not outside the DMA channel range */
#if defined(DMA2)
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 800f680:	687b      	ldr	r3, [r7, #4]
 800f682:	681b      	ldr	r3, [r3, #0]
 800f684:	461a      	mov	r2, r3
 800f686:	4b17      	ldr	r3, [pc, #92]	; (800f6e4 <DMA_CalcDMAMUXChannelBaseAndMask+0x6c>)
 800f688:	429a      	cmp	r2, r3
 800f68a:	d80a      	bhi.n	800f6a2 <DMA_CalcDMAMUXChannelBaseAndMask+0x2a>
  {
    /* DMA1 */
    hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
 800f68c:	687b      	ldr	r3, [r7, #4]
 800f68e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f690:	089b      	lsrs	r3, r3, #2
 800f692:	009b      	lsls	r3, r3, #2
 800f694:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800f698:	f503 3302 	add.w	r3, r3, #133120	; 0x20800
 800f69c:	687a      	ldr	r2, [r7, #4]
 800f69e:	6493      	str	r3, [r2, #72]	; 0x48
 800f6a0:	e007      	b.n	800f6b2 <DMA_CalcDMAMUXChannelBaseAndMask+0x3a>
  }
  else
  {
    /* DMA2 */
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 800f6a2:	687b      	ldr	r3, [r7, #4]
 800f6a4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800f6a6:	089b      	lsrs	r3, r3, #2
 800f6a8:	009a      	lsls	r2, r3, #2
 800f6aa:	4b0f      	ldr	r3, [pc, #60]	; (800f6e8 <DMA_CalcDMAMUXChannelBaseAndMask+0x70>)
 800f6ac:	4413      	add	r3, r2
 800f6ae:	687a      	ldr	r2, [r7, #4]
 800f6b0:	6493      	str	r3, [r2, #72]	; 0x48
  }
#else
  /* DMA1 */
  hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
#endif
  channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 800f6b2:	687b      	ldr	r3, [r7, #4]
 800f6b4:	681b      	ldr	r3, [r3, #0]
 800f6b6:	b2db      	uxtb	r3, r3
 800f6b8:	3b08      	subs	r3, #8
 800f6ba:	4a0c      	ldr	r2, [pc, #48]	; (800f6ec <DMA_CalcDMAMUXChannelBaseAndMask+0x74>)
 800f6bc:	fba2 2303 	umull	r2, r3, r2, r3
 800f6c0:	091b      	lsrs	r3, r3, #4
 800f6c2:	60fb      	str	r3, [r7, #12]
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 800f6c4:	687b      	ldr	r3, [r7, #4]
 800f6c6:	4a0a      	ldr	r2, [pc, #40]	; (800f6f0 <DMA_CalcDMAMUXChannelBaseAndMask+0x78>)
 800f6c8:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Initialize the field DMAmuxChannelStatusMask with the corresponding index of the DMAMUX channel selected for the current ChannelIndex */
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 800f6ca:	68fb      	ldr	r3, [r7, #12]
 800f6cc:	f003 031f 	and.w	r3, r3, #31
 800f6d0:	2201      	movs	r2, #1
 800f6d2:	409a      	lsls	r2, r3
 800f6d4:	687b      	ldr	r3, [r7, #4]
 800f6d6:	651a      	str	r2, [r3, #80]	; 0x50
}
 800f6d8:	bf00      	nop
 800f6da:	3714      	adds	r7, #20
 800f6dc:	46bd      	mov	sp, r7
 800f6de:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f6e2:	4770      	bx	lr
 800f6e4:	40020407 	.word	0x40020407
 800f6e8:	4002081c 	.word	0x4002081c
 800f6ec:	cccccccd 	.word	0xcccccccd
 800f6f0:	40020880 	.word	0x40020880

0800f6f4 <DMA_CalcDMAMUXRequestGenBaseAndMask>:
  *                     the configuration information for the specified DMA Channel.
  * @retval None
  */

static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
 800f6f4:	b480      	push	{r7}
 800f6f6:	b085      	sub	sp, #20
 800f6f8:	af00      	add	r7, sp, #0
 800f6fa:	6078      	str	r0, [r7, #4]
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;
 800f6fc:	687b      	ldr	r3, [r7, #4]
 800f6fe:	685b      	ldr	r3, [r3, #4]
 800f700:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800f704:	60fb      	str	r3, [r7, #12]

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 800f706:	68fa      	ldr	r2, [r7, #12]
 800f708:	4b0b      	ldr	r3, [pc, #44]	; (800f738 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x44>)
 800f70a:	4413      	add	r3, r2
 800f70c:	009b      	lsls	r3, r3, #2
 800f70e:	461a      	mov	r2, r3
 800f710:	687b      	ldr	r3, [r7, #4]
 800f712:	655a      	str	r2, [r3, #84]	; 0x54

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 800f714:	687b      	ldr	r3, [r7, #4]
 800f716:	4a09      	ldr	r2, [pc, #36]	; (800f73c <DMA_CalcDMAMUXRequestGenBaseAndMask+0x48>)
 800f718:	659a      	str	r2, [r3, #88]	; 0x58

  /* here "Request" is either DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR3, i.e. <= 4*/
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 800f71a:	68fb      	ldr	r3, [r7, #12]
 800f71c:	3b01      	subs	r3, #1
 800f71e:	f003 0303 	and.w	r3, r3, #3
 800f722:	2201      	movs	r2, #1
 800f724:	409a      	lsls	r2, r3
 800f726:	687b      	ldr	r3, [r7, #4]
 800f728:	65da      	str	r2, [r3, #92]	; 0x5c
}
 800f72a:	bf00      	nop
 800f72c:	3714      	adds	r7, #20
 800f72e:	46bd      	mov	sp, r7
 800f730:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f734:	4770      	bx	lr
 800f736:	bf00      	nop
 800f738:	1000823f 	.word	0x1000823f
 800f73c:	40020940 	.word	0x40020940

0800f740 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800f740:	b480      	push	{r7}
 800f742:	b087      	sub	sp, #28
 800f744:	af00      	add	r7, sp, #0
 800f746:	6078      	str	r0, [r7, #4]
 800f748:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
 800f74a:	2300      	movs	r3, #0
 800f74c:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800f74e:	e14c      	b.n	800f9ea <HAL_GPIO_Init+0x2aa>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 800f750:	683b      	ldr	r3, [r7, #0]
 800f752:	681a      	ldr	r2, [r3, #0]
 800f754:	2101      	movs	r1, #1
 800f756:	697b      	ldr	r3, [r7, #20]
 800f758:	fa01 f303 	lsl.w	r3, r1, r3
 800f75c:	4013      	ands	r3, r2
 800f75e:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
 800f760:	68fb      	ldr	r3, [r7, #12]
 800f762:	2b00      	cmp	r3, #0
 800f764:	f000 813e 	beq.w	800f9e4 <HAL_GPIO_Init+0x2a4>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800f768:	683b      	ldr	r3, [r7, #0]
 800f76a:	685b      	ldr	r3, [r3, #4]
 800f76c:	2b01      	cmp	r3, #1
 800f76e:	d00b      	beq.n	800f788 <HAL_GPIO_Init+0x48>
 800f770:	683b      	ldr	r3, [r7, #0]
 800f772:	685b      	ldr	r3, [r3, #4]
 800f774:	2b02      	cmp	r3, #2
 800f776:	d007      	beq.n	800f788 <HAL_GPIO_Init+0x48>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800f778:	683b      	ldr	r3, [r7, #0]
 800f77a:	685b      	ldr	r3, [r3, #4]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800f77c:	2b11      	cmp	r3, #17
 800f77e:	d003      	beq.n	800f788 <HAL_GPIO_Init+0x48>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800f780:	683b      	ldr	r3, [r7, #0]
 800f782:	685b      	ldr	r3, [r3, #4]
 800f784:	2b12      	cmp	r3, #18
 800f786:	d130      	bne.n	800f7ea <HAL_GPIO_Init+0xaa>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 800f788:	687b      	ldr	r3, [r7, #4]
 800f78a:	689b      	ldr	r3, [r3, #8]
 800f78c:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 800f78e:	697b      	ldr	r3, [r7, #20]
 800f790:	005b      	lsls	r3, r3, #1
 800f792:	2203      	movs	r2, #3
 800f794:	fa02 f303 	lsl.w	r3, r2, r3
 800f798:	43db      	mvns	r3, r3
 800f79a:	693a      	ldr	r2, [r7, #16]
 800f79c:	4013      	ands	r3, r2
 800f79e:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2u));
 800f7a0:	683b      	ldr	r3, [r7, #0]
 800f7a2:	68da      	ldr	r2, [r3, #12]
 800f7a4:	697b      	ldr	r3, [r7, #20]
 800f7a6:	005b      	lsls	r3, r3, #1
 800f7a8:	fa02 f303 	lsl.w	r3, r2, r3
 800f7ac:	693a      	ldr	r2, [r7, #16]
 800f7ae:	4313      	orrs	r3, r2
 800f7b0:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 800f7b2:	687b      	ldr	r3, [r7, #4]
 800f7b4:	693a      	ldr	r2, [r7, #16]
 800f7b6:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800f7b8:	687b      	ldr	r3, [r7, #4]
 800f7ba:	685b      	ldr	r3, [r3, #4]
 800f7bc:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 800f7be:	2201      	movs	r2, #1
 800f7c0:	697b      	ldr	r3, [r7, #20]
 800f7c2:	fa02 f303 	lsl.w	r3, r2, r3
 800f7c6:	43db      	mvns	r3, r3
 800f7c8:	693a      	ldr	r2, [r7, #16]
 800f7ca:	4013      	ands	r3, r2
 800f7cc:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 800f7ce:	683b      	ldr	r3, [r7, #0]
 800f7d0:	685b      	ldr	r3, [r3, #4]
 800f7d2:	091b      	lsrs	r3, r3, #4
 800f7d4:	f003 0201 	and.w	r2, r3, #1
 800f7d8:	697b      	ldr	r3, [r7, #20]
 800f7da:	fa02 f303 	lsl.w	r3, r2, r3
 800f7de:	693a      	ldr	r2, [r7, #16]
 800f7e0:	4313      	orrs	r3, r2
 800f7e2:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 800f7e4:	687b      	ldr	r3, [r7, #4]
 800f7e6:	693a      	ldr	r2, [r7, #16]
 800f7e8:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 800f7ea:	687b      	ldr	r3, [r7, #4]
 800f7ec:	68db      	ldr	r3, [r3, #12]
 800f7ee:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 800f7f0:	697b      	ldr	r3, [r7, #20]
 800f7f2:	005b      	lsls	r3, r3, #1
 800f7f4:	2203      	movs	r2, #3
 800f7f6:	fa02 f303 	lsl.w	r3, r2, r3
 800f7fa:	43db      	mvns	r3, r3
 800f7fc:	693a      	ldr	r2, [r7, #16]
 800f7fe:	4013      	ands	r3, r2
 800f800:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 800f802:	683b      	ldr	r3, [r7, #0]
 800f804:	689a      	ldr	r2, [r3, #8]
 800f806:	697b      	ldr	r3, [r7, #20]
 800f808:	005b      	lsls	r3, r3, #1
 800f80a:	fa02 f303 	lsl.w	r3, r2, r3
 800f80e:	693a      	ldr	r2, [r7, #16]
 800f810:	4313      	orrs	r3, r2
 800f812:	613b      	str	r3, [r7, #16]
      GPIOx->PUPDR = temp;
 800f814:	687b      	ldr	r3, [r7, #4]
 800f816:	693a      	ldr	r2, [r7, #16]
 800f818:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800f81a:	683b      	ldr	r3, [r7, #0]
 800f81c:	685b      	ldr	r3, [r3, #4]
 800f81e:	2b02      	cmp	r3, #2
 800f820:	d003      	beq.n	800f82a <HAL_GPIO_Init+0xea>
 800f822:	683b      	ldr	r3, [r7, #0]
 800f824:	685b      	ldr	r3, [r3, #4]
 800f826:	2b12      	cmp	r3, #18
 800f828:	d123      	bne.n	800f872 <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
 800f82a:	697b      	ldr	r3, [r7, #20]
 800f82c:	08da      	lsrs	r2, r3, #3
 800f82e:	687b      	ldr	r3, [r7, #4]
 800f830:	3208      	adds	r2, #8
 800f832:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800f836:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 800f838:	697b      	ldr	r3, [r7, #20]
 800f83a:	f003 0307 	and.w	r3, r3, #7
 800f83e:	009b      	lsls	r3, r3, #2
 800f840:	220f      	movs	r2, #15
 800f842:	fa02 f303 	lsl.w	r3, r2, r3
 800f846:	43db      	mvns	r3, r3
 800f848:	693a      	ldr	r2, [r7, #16]
 800f84a:	4013      	ands	r3, r2
 800f84c:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 800f84e:	683b      	ldr	r3, [r7, #0]
 800f850:	691a      	ldr	r2, [r3, #16]
 800f852:	697b      	ldr	r3, [r7, #20]
 800f854:	f003 0307 	and.w	r3, r3, #7
 800f858:	009b      	lsls	r3, r3, #2
 800f85a:	fa02 f303 	lsl.w	r3, r2, r3
 800f85e:	693a      	ldr	r2, [r7, #16]
 800f860:	4313      	orrs	r3, r2
 800f862:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
 800f864:	697b      	ldr	r3, [r7, #20]
 800f866:	08da      	lsrs	r2, r3, #3
 800f868:	687b      	ldr	r3, [r7, #4]
 800f86a:	3208      	adds	r2, #8
 800f86c:	6939      	ldr	r1, [r7, #16]
 800f86e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800f872:	687b      	ldr	r3, [r7, #4]
 800f874:	681b      	ldr	r3, [r3, #0]
 800f876:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 800f878:	697b      	ldr	r3, [r7, #20]
 800f87a:	005b      	lsls	r3, r3, #1
 800f87c:	2203      	movs	r2, #3
 800f87e:	fa02 f303 	lsl.w	r3, r2, r3
 800f882:	43db      	mvns	r3, r3
 800f884:	693a      	ldr	r2, [r7, #16]
 800f886:	4013      	ands	r3, r2
 800f888:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 800f88a:	683b      	ldr	r3, [r7, #0]
 800f88c:	685b      	ldr	r3, [r3, #4]
 800f88e:	f003 0203 	and.w	r2, r3, #3
 800f892:	697b      	ldr	r3, [r7, #20]
 800f894:	005b      	lsls	r3, r3, #1
 800f896:	fa02 f303 	lsl.w	r3, r2, r3
 800f89a:	693a      	ldr	r2, [r7, #16]
 800f89c:	4313      	orrs	r3, r2
 800f89e:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 800f8a0:	687b      	ldr	r3, [r7, #4]
 800f8a2:	693a      	ldr	r2, [r7, #16]
 800f8a4:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800f8a6:	683b      	ldr	r3, [r7, #0]
 800f8a8:	685b      	ldr	r3, [r3, #4]
 800f8aa:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800f8ae:	2b00      	cmp	r3, #0
 800f8b0:	f000 8098 	beq.w	800f9e4 <HAL_GPIO_Init+0x2a4>
      {
        temp = SYSCFG->EXTICR[position >> 2u];
 800f8b4:	4a54      	ldr	r2, [pc, #336]	; (800fa08 <HAL_GPIO_Init+0x2c8>)
 800f8b6:	697b      	ldr	r3, [r7, #20]
 800f8b8:	089b      	lsrs	r3, r3, #2
 800f8ba:	3302      	adds	r3, #2
 800f8bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800f8c0:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 800f8c2:	697b      	ldr	r3, [r7, #20]
 800f8c4:	f003 0303 	and.w	r3, r3, #3
 800f8c8:	009b      	lsls	r3, r3, #2
 800f8ca:	220f      	movs	r2, #15
 800f8cc:	fa02 f303 	lsl.w	r3, r2, r3
 800f8d0:	43db      	mvns	r3, r3
 800f8d2:	693a      	ldr	r2, [r7, #16]
 800f8d4:	4013      	ands	r3, r2
 800f8d6:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 800f8d8:	687b      	ldr	r3, [r7, #4]
 800f8da:	f1b3 4f90 	cmp.w	r3, #1207959552	; 0x48000000
 800f8de:	d019      	beq.n	800f914 <HAL_GPIO_Init+0x1d4>
 800f8e0:	687b      	ldr	r3, [r7, #4]
 800f8e2:	4a4a      	ldr	r2, [pc, #296]	; (800fa0c <HAL_GPIO_Init+0x2cc>)
 800f8e4:	4293      	cmp	r3, r2
 800f8e6:	d013      	beq.n	800f910 <HAL_GPIO_Init+0x1d0>
 800f8e8:	687b      	ldr	r3, [r7, #4]
 800f8ea:	4a49      	ldr	r2, [pc, #292]	; (800fa10 <HAL_GPIO_Init+0x2d0>)
 800f8ec:	4293      	cmp	r3, r2
 800f8ee:	d00d      	beq.n	800f90c <HAL_GPIO_Init+0x1cc>
 800f8f0:	687b      	ldr	r3, [r7, #4]
 800f8f2:	4a48      	ldr	r2, [pc, #288]	; (800fa14 <HAL_GPIO_Init+0x2d4>)
 800f8f4:	4293      	cmp	r3, r2
 800f8f6:	d007      	beq.n	800f908 <HAL_GPIO_Init+0x1c8>
 800f8f8:	687b      	ldr	r3, [r7, #4]
 800f8fa:	4a47      	ldr	r2, [pc, #284]	; (800fa18 <HAL_GPIO_Init+0x2d8>)
 800f8fc:	4293      	cmp	r3, r2
 800f8fe:	d101      	bne.n	800f904 <HAL_GPIO_Init+0x1c4>
 800f900:	2304      	movs	r3, #4
 800f902:	e008      	b.n	800f916 <HAL_GPIO_Init+0x1d6>
 800f904:	2307      	movs	r3, #7
 800f906:	e006      	b.n	800f916 <HAL_GPIO_Init+0x1d6>
 800f908:	2303      	movs	r3, #3
 800f90a:	e004      	b.n	800f916 <HAL_GPIO_Init+0x1d6>
 800f90c:	2302      	movs	r3, #2
 800f90e:	e002      	b.n	800f916 <HAL_GPIO_Init+0x1d6>
 800f910:	2301      	movs	r3, #1
 800f912:	e000      	b.n	800f916 <HAL_GPIO_Init+0x1d6>
 800f914:	2300      	movs	r3, #0
 800f916:	697a      	ldr	r2, [r7, #20]
 800f918:	f002 0203 	and.w	r2, r2, #3
 800f91c:	0092      	lsls	r2, r2, #2
 800f91e:	4093      	lsls	r3, r2
 800f920:	693a      	ldr	r2, [r7, #16]
 800f922:	4313      	orrs	r3, r2
 800f924:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2u] = temp;
 800f926:	4938      	ldr	r1, [pc, #224]	; (800fa08 <HAL_GPIO_Init+0x2c8>)
 800f928:	697b      	ldr	r3, [r7, #20]
 800f92a:	089b      	lsrs	r3, r3, #2
 800f92c:	3302      	adds	r3, #2
 800f92e:	693a      	ldr	r2, [r7, #16]
 800f930:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 800f934:	4b39      	ldr	r3, [pc, #228]	; (800fa1c <HAL_GPIO_Init+0x2dc>)
 800f936:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800f93a:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800f93c:	68fb      	ldr	r3, [r7, #12]
 800f93e:	43db      	mvns	r3, r3
 800f940:	693a      	ldr	r2, [r7, #16]
 800f942:	4013      	ands	r3, r2
 800f944:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800f946:	683b      	ldr	r3, [r7, #0]
 800f948:	685b      	ldr	r3, [r3, #4]
 800f94a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800f94e:	2b00      	cmp	r3, #0
 800f950:	d003      	beq.n	800f95a <HAL_GPIO_Init+0x21a>
        {
          temp |= iocurrent;
 800f952:	693a      	ldr	r2, [r7, #16]
 800f954:	68fb      	ldr	r3, [r7, #12]
 800f956:	4313      	orrs	r3, r2
 800f958:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
 800f95a:	4a30      	ldr	r2, [pc, #192]	; (800fa1c <HAL_GPIO_Init+0x2dc>)
 800f95c:	693b      	ldr	r3, [r7, #16]
 800f95e:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

        temp = EXTI->EMR1;
 800f962:	4b2e      	ldr	r3, [pc, #184]	; (800fa1c <HAL_GPIO_Init+0x2dc>)
 800f964:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800f968:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800f96a:	68fb      	ldr	r3, [r7, #12]
 800f96c:	43db      	mvns	r3, r3
 800f96e:	693a      	ldr	r2, [r7, #16]
 800f970:	4013      	ands	r3, r2
 800f972:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800f974:	683b      	ldr	r3, [r7, #0]
 800f976:	685b      	ldr	r3, [r3, #4]
 800f978:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800f97c:	2b00      	cmp	r3, #0
 800f97e:	d003      	beq.n	800f988 <HAL_GPIO_Init+0x248>
        {
          temp |= iocurrent;
 800f980:	693a      	ldr	r2, [r7, #16]
 800f982:	68fb      	ldr	r3, [r7, #12]
 800f984:	4313      	orrs	r3, r2
 800f986:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
 800f988:	4a24      	ldr	r2, [pc, #144]	; (800fa1c <HAL_GPIO_Init+0x2dc>)
 800f98a:	693b      	ldr	r3, [r7, #16]
 800f98c:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 800f990:	4b22      	ldr	r3, [pc, #136]	; (800fa1c <HAL_GPIO_Init+0x2dc>)
 800f992:	681b      	ldr	r3, [r3, #0]
 800f994:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800f996:	68fb      	ldr	r3, [r7, #12]
 800f998:	43db      	mvns	r3, r3
 800f99a:	693a      	ldr	r2, [r7, #16]
 800f99c:	4013      	ands	r3, r2
 800f99e:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800f9a0:	683b      	ldr	r3, [r7, #0]
 800f9a2:	685b      	ldr	r3, [r3, #4]
 800f9a4:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800f9a8:	2b00      	cmp	r3, #0
 800f9aa:	d003      	beq.n	800f9b4 <HAL_GPIO_Init+0x274>
        {
          temp |= iocurrent;
 800f9ac:	693a      	ldr	r2, [r7, #16]
 800f9ae:	68fb      	ldr	r3, [r7, #12]
 800f9b0:	4313      	orrs	r3, r2
 800f9b2:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
 800f9b4:	4a19      	ldr	r2, [pc, #100]	; (800fa1c <HAL_GPIO_Init+0x2dc>)
 800f9b6:	693b      	ldr	r3, [r7, #16]
 800f9b8:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
 800f9ba:	4b18      	ldr	r3, [pc, #96]	; (800fa1c <HAL_GPIO_Init+0x2dc>)
 800f9bc:	685b      	ldr	r3, [r3, #4]
 800f9be:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800f9c0:	68fb      	ldr	r3, [r7, #12]
 800f9c2:	43db      	mvns	r3, r3
 800f9c4:	693a      	ldr	r2, [r7, #16]
 800f9c6:	4013      	ands	r3, r2
 800f9c8:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800f9ca:	683b      	ldr	r3, [r7, #0]
 800f9cc:	685b      	ldr	r3, [r3, #4]
 800f9ce:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800f9d2:	2b00      	cmp	r3, #0
 800f9d4:	d003      	beq.n	800f9de <HAL_GPIO_Init+0x29e>
        {
          temp |= iocurrent;
 800f9d6:	693a      	ldr	r2, [r7, #16]
 800f9d8:	68fb      	ldr	r3, [r7, #12]
 800f9da:	4313      	orrs	r3, r2
 800f9dc:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
 800f9de:	4a0f      	ldr	r2, [pc, #60]	; (800fa1c <HAL_GPIO_Init+0x2dc>)
 800f9e0:	693b      	ldr	r3, [r7, #16]
 800f9e2:	6053      	str	r3, [r2, #4]
      }
    }
    
    position++;
 800f9e4:	697b      	ldr	r3, [r7, #20]
 800f9e6:	3301      	adds	r3, #1
 800f9e8:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800f9ea:	683b      	ldr	r3, [r7, #0]
 800f9ec:	681a      	ldr	r2, [r3, #0]
 800f9ee:	697b      	ldr	r3, [r7, #20]
 800f9f0:	fa22 f303 	lsr.w	r3, r2, r3
 800f9f4:	2b00      	cmp	r3, #0
 800f9f6:	f47f aeab 	bne.w	800f750 <HAL_GPIO_Init+0x10>
  }
}
 800f9fa:	bf00      	nop
 800f9fc:	bf00      	nop
 800f9fe:	371c      	adds	r7, #28
 800fa00:	46bd      	mov	sp, r7
 800fa02:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fa06:	4770      	bx	lr
 800fa08:	40010000 	.word	0x40010000
 800fa0c:	48000400 	.word	0x48000400
 800fa10:	48000800 	.word	0x48000800
 800fa14:	48000c00 	.word	0x48000c00
 800fa18:	48001000 	.word	0x48001000
 800fa1c:	58000800 	.word	0x58000800

0800fa20 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800fa20:	b480      	push	{r7}
 800fa22:	b083      	sub	sp, #12
 800fa24:	af00      	add	r7, sp, #0
 800fa26:	6078      	str	r0, [r7, #4]
 800fa28:	460b      	mov	r3, r1
 800fa2a:	807b      	strh	r3, [r7, #2]
 800fa2c:	4613      	mov	r3, r2
 800fa2e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 800fa30:	787b      	ldrb	r3, [r7, #1]
 800fa32:	2b00      	cmp	r3, #0
 800fa34:	d003      	beq.n	800fa3e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 800fa36:	887a      	ldrh	r2, [r7, #2]
 800fa38:	687b      	ldr	r3, [r7, #4]
 800fa3a:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 800fa3c:	e002      	b.n	800fa44 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 800fa3e:	887a      	ldrh	r2, [r7, #2]
 800fa40:	687b      	ldr	r3, [r7, #4]
 800fa42:	629a      	str	r2, [r3, #40]	; 0x28
}
 800fa44:	bf00      	nop
 800fa46:	370c      	adds	r7, #12
 800fa48:	46bd      	mov	sp, r7
 800fa4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fa4e:	4770      	bx	lr

0800fa50 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 800fa50:	b580      	push	{r7, lr}
 800fa52:	b082      	sub	sp, #8
 800fa54:	af00      	add	r7, sp, #0
 800fa56:	4603      	mov	r3, r0
 800fa58:	80fb      	strh	r3, [r7, #6]
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 800fa5a:	4b08      	ldr	r3, [pc, #32]	; (800fa7c <HAL_GPIO_EXTI_IRQHandler+0x2c>)
 800fa5c:	68da      	ldr	r2, [r3, #12]
 800fa5e:	88fb      	ldrh	r3, [r7, #6]
 800fa60:	4013      	ands	r3, r2
 800fa62:	2b00      	cmp	r3, #0
 800fa64:	d006      	beq.n	800fa74 <HAL_GPIO_EXTI_IRQHandler+0x24>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 800fa66:	4a05      	ldr	r2, [pc, #20]	; (800fa7c <HAL_GPIO_EXTI_IRQHandler+0x2c>)
 800fa68:	88fb      	ldrh	r3, [r7, #6]
 800fa6a:	60d3      	str	r3, [r2, #12]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 800fa6c:	88fb      	ldrh	r3, [r7, #6]
 800fa6e:	4618      	mov	r0, r3
 800fa70:	f000 f806 	bl	800fa80 <HAL_GPIO_EXTI_Callback>
  }
}
 800fa74:	bf00      	nop
 800fa76:	3708      	adds	r7, #8
 800fa78:	46bd      	mov	sp, r7
 800fa7a:	bd80      	pop	{r7, pc}
 800fa7c:	58000800 	.word	0x58000800

0800fa80 <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callback.
  * @param GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 800fa80:	b480      	push	{r7}
 800fa82:	b083      	sub	sp, #12
 800fa84:	af00      	add	r7, sp, #0
 800fa86:	4603      	mov	r3, r0
 800fa88:	80fb      	strh	r3, [r7, #6]
  UNUSED(GPIO_Pin);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */
}
 800fa8a:	bf00      	nop
 800fa8c:	370c      	adds	r7, #12
 800fa8e:	46bd      	mov	sp, r7
 800fa90:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fa94:	4770      	bx	lr
	...

0800fa98 <HAL_HSEM_IRQHandler>:
/**
  * @brief  This function handles HSEM interrupt request
  * @retval None
  */
void HAL_HSEM_IRQHandler(void)
{
 800fa98:	b580      	push	{r7, lr}
 800fa9a:	b082      	sub	sp, #8
 800fa9c:	af00      	add	r7, sp, #0
  uint32_t statusreg;
  /* Get the list of masked freed semaphores*/
  statusreg = HSEM_COMMON->MISR;
 800fa9e:	4b0a      	ldr	r3, [pc, #40]	; (800fac8 <HAL_HSEM_IRQHandler+0x30>)
 800faa0:	68db      	ldr	r3, [r3, #12]
 800faa2:	607b      	str	r3, [r7, #4]

  /*Disable Interrupts*/
  HSEM_COMMON->IER &= ~((uint32_t)statusreg);
 800faa4:	4b08      	ldr	r3, [pc, #32]	; (800fac8 <HAL_HSEM_IRQHandler+0x30>)
 800faa6:	681a      	ldr	r2, [r3, #0]
 800faa8:	687b      	ldr	r3, [r7, #4]
 800faaa:	43db      	mvns	r3, r3
 800faac:	4906      	ldr	r1, [pc, #24]	; (800fac8 <HAL_HSEM_IRQHandler+0x30>)
 800faae:	4013      	ands	r3, r2
 800fab0:	600b      	str	r3, [r1, #0]

  /*Clear Flags*/
  HSEM_COMMON->ICR = ((uint32_t)statusreg);
 800fab2:	4a05      	ldr	r2, [pc, #20]	; (800fac8 <HAL_HSEM_IRQHandler+0x30>)
 800fab4:	687b      	ldr	r3, [r7, #4]
 800fab6:	6053      	str	r3, [r2, #4]

  /* Call FreeCallback */
  HAL_HSEM_FreeCallback(statusreg);
 800fab8:	6878      	ldr	r0, [r7, #4]
 800faba:	f000 f807 	bl	800facc <HAL_HSEM_FreeCallback>
}
 800fabe:	bf00      	nop
 800fac0:	3708      	adds	r7, #8
 800fac2:	46bd      	mov	sp, r7
 800fac4:	bd80      	pop	{r7, pc}
 800fac6:	bf00      	nop
 800fac8:	58001500 	.word	0x58001500

0800facc <HAL_HSEM_FreeCallback>:
  * @brief Semaphore Released Callback.
  * @param SemMask: Mask of Released semaphores
  * @retval None
  */
__weak void HAL_HSEM_FreeCallback(uint32_t SemMask)
{
 800facc:	b480      	push	{r7}
 800face:	b083      	sub	sp, #12
 800fad0:	af00      	add	r7, sp, #0
 800fad2:	6078      	str	r0, [r7, #4]
  UNUSED(SemMask);

  /* NOTE : This function should not be modified, when the callback is needed,
  the HAL_HSEM_FreeCallback can be implemented in the user file
    */
}
 800fad4:	bf00      	nop
 800fad6:	370c      	adds	r7, #12
 800fad8:	46bd      	mov	sp, r7
 800fada:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fade:	4770      	bx	lr

0800fae0 <HAL_PWR_EnableBkUpAccess>:
  * @note   LSEON bit that switches on and off the LSE crystal belongs as well to the
  *         back-up domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
 800fae0:	b480      	push	{r7}
 800fae2:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 800fae4:	4b05      	ldr	r3, [pc, #20]	; (800fafc <HAL_PWR_EnableBkUpAccess+0x1c>)
 800fae6:	681b      	ldr	r3, [r3, #0]
 800fae8:	4a04      	ldr	r2, [pc, #16]	; (800fafc <HAL_PWR_EnableBkUpAccess+0x1c>)
 800faea:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800faee:	6013      	str	r3, [r2, #0]
}
 800faf0:	bf00      	nop
 800faf2:	46bd      	mov	sp, r7
 800faf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800faf8:	4770      	bx	lr
 800fafa:	bf00      	nop
 800fafc:	58000400 	.word	0x58000400

0800fb00 <HAL_PWREx_GetVoltageRange>:
/**
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_RANGE1 or PWR_REGULATOR_VOLTAGE_RANGE2)
  */  
uint32_t HAL_PWREx_GetVoltageRange(void)
{
 800fb00:	b480      	push	{r7}
 800fb02:	af00      	add	r7, sp, #0
  return  (PWR->CR1 & PWR_CR1_VOS);
 800fb04:	4b04      	ldr	r3, [pc, #16]	; (800fb18 <HAL_PWREx_GetVoltageRange+0x18>)
 800fb06:	681b      	ldr	r3, [r3, #0]
 800fb08:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
}
 800fb0c:	4618      	mov	r0, r3
 800fb0e:	46bd      	mov	sp, r7
 800fb10:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb14:	4770      	bx	lr
 800fb16:	bf00      	nop
 800fb18:	58000400 	.word	0x58000400

0800fb1c <LL_RCC_HSE_IsEnabledDiv2>:
{
 800fb1c:	b480      	push	{r7}
 800fb1e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 800fb20:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fb24:	681b      	ldr	r3, [r3, #0]
 800fb26:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800fb2a:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800fb2e:	d101      	bne.n	800fb34 <LL_RCC_HSE_IsEnabledDiv2+0x18>
 800fb30:	2301      	movs	r3, #1
 800fb32:	e000      	b.n	800fb36 <LL_RCC_HSE_IsEnabledDiv2+0x1a>
 800fb34:	2300      	movs	r3, #0
}
 800fb36:	4618      	mov	r0, r3
 800fb38:	46bd      	mov	sp, r7
 800fb3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb3e:	4770      	bx	lr

0800fb40 <LL_RCC_HSE_Enable>:
{
 800fb40:	b480      	push	{r7}
 800fb42:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 800fb44:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fb48:	681b      	ldr	r3, [r3, #0]
 800fb4a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800fb4e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800fb52:	6013      	str	r3, [r2, #0]
}
 800fb54:	bf00      	nop
 800fb56:	46bd      	mov	sp, r7
 800fb58:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb5c:	4770      	bx	lr

0800fb5e <LL_RCC_HSE_Disable>:
{
 800fb5e:	b480      	push	{r7}
 800fb60:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
 800fb62:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fb66:	681b      	ldr	r3, [r3, #0]
 800fb68:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800fb6c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800fb70:	6013      	str	r3, [r2, #0]
}
 800fb72:	bf00      	nop
 800fb74:	46bd      	mov	sp, r7
 800fb76:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb7a:	4770      	bx	lr

0800fb7c <LL_RCC_HSE_IsReady>:
{
 800fb7c:	b480      	push	{r7}
 800fb7e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 800fb80:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fb84:	681b      	ldr	r3, [r3, #0]
 800fb86:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800fb8a:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800fb8e:	d101      	bne.n	800fb94 <LL_RCC_HSE_IsReady+0x18>
 800fb90:	2301      	movs	r3, #1
 800fb92:	e000      	b.n	800fb96 <LL_RCC_HSE_IsReady+0x1a>
 800fb94:	2300      	movs	r3, #0
}
 800fb96:	4618      	mov	r0, r3
 800fb98:	46bd      	mov	sp, r7
 800fb9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb9e:	4770      	bx	lr

0800fba0 <LL_RCC_HSI_Enable>:
{
 800fba0:	b480      	push	{r7}
 800fba2:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSION);
 800fba4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fba8:	681b      	ldr	r3, [r3, #0]
 800fbaa:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800fbae:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800fbb2:	6013      	str	r3, [r2, #0]
}
 800fbb4:	bf00      	nop
 800fbb6:	46bd      	mov	sp, r7
 800fbb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fbbc:	4770      	bx	lr

0800fbbe <LL_RCC_HSI_Disable>:
{
 800fbbe:	b480      	push	{r7}
 800fbc0:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
 800fbc2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fbc6:	681b      	ldr	r3, [r3, #0]
 800fbc8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800fbcc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800fbd0:	6013      	str	r3, [r2, #0]
}
 800fbd2:	bf00      	nop
 800fbd4:	46bd      	mov	sp, r7
 800fbd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fbda:	4770      	bx	lr

0800fbdc <LL_RCC_HSI_IsReady>:
{
 800fbdc:	b480      	push	{r7}
 800fbde:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 800fbe0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fbe4:	681b      	ldr	r3, [r3, #0]
 800fbe6:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800fbea:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800fbee:	d101      	bne.n	800fbf4 <LL_RCC_HSI_IsReady+0x18>
 800fbf0:	2301      	movs	r3, #1
 800fbf2:	e000      	b.n	800fbf6 <LL_RCC_HSI_IsReady+0x1a>
 800fbf4:	2300      	movs	r3, #0
}
 800fbf6:	4618      	mov	r0, r3
 800fbf8:	46bd      	mov	sp, r7
 800fbfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fbfe:	4770      	bx	lr

0800fc00 <LL_RCC_HSI_SetCalibTrimming>:
{
 800fc00:	b480      	push	{r7}
 800fc02:	b083      	sub	sp, #12
 800fc04:	af00      	add	r7, sp, #0
 800fc06:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 800fc08:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fc0c:	685b      	ldr	r3, [r3, #4]
 800fc0e:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
 800fc12:	687b      	ldr	r3, [r7, #4]
 800fc14:	061b      	lsls	r3, r3, #24
 800fc16:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800fc1a:	4313      	orrs	r3, r2
 800fc1c:	604b      	str	r3, [r1, #4]
}
 800fc1e:	bf00      	nop
 800fc20:	370c      	adds	r7, #12
 800fc22:	46bd      	mov	sp, r7
 800fc24:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fc28:	4770      	bx	lr

0800fc2a <LL_RCC_HSI48_Enable>:
{
 800fc2a:	b480      	push	{r7}
 800fc2c:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON);
 800fc2e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fc32:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800fc36:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800fc3a:	f043 0301 	orr.w	r3, r3, #1
 800fc3e:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
}
 800fc42:	bf00      	nop
 800fc44:	46bd      	mov	sp, r7
 800fc46:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fc4a:	4770      	bx	lr

0800fc4c <LL_RCC_HSI48_Disable>:
{
 800fc4c:	b480      	push	{r7}
 800fc4e:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON);
 800fc50:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fc54:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800fc58:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800fc5c:	f023 0301 	bic.w	r3, r3, #1
 800fc60:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
}
 800fc64:	bf00      	nop
 800fc66:	46bd      	mov	sp, r7
 800fc68:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fc6c:	4770      	bx	lr

0800fc6e <LL_RCC_HSI48_IsReady>:
{
 800fc6e:	b480      	push	{r7}
 800fc70:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == (RCC_CRRCR_HSI48RDY)) ? 1UL : 0UL);
 800fc72:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fc76:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800fc7a:	f003 0302 	and.w	r3, r3, #2
 800fc7e:	2b02      	cmp	r3, #2
 800fc80:	d101      	bne.n	800fc86 <LL_RCC_HSI48_IsReady+0x18>
 800fc82:	2301      	movs	r3, #1
 800fc84:	e000      	b.n	800fc88 <LL_RCC_HSI48_IsReady+0x1a>
 800fc86:	2300      	movs	r3, #0
}
 800fc88:	4618      	mov	r0, r3
 800fc8a:	46bd      	mov	sp, r7
 800fc8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fc90:	4770      	bx	lr

0800fc92 <LL_RCC_LSE_Enable>:
{
 800fc92:	b480      	push	{r7}
 800fc94:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 800fc96:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fc9a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800fc9e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800fca2:	f043 0301 	orr.w	r3, r3, #1
 800fca6:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 800fcaa:	bf00      	nop
 800fcac:	46bd      	mov	sp, r7
 800fcae:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fcb2:	4770      	bx	lr

0800fcb4 <LL_RCC_LSE_Disable>:
{
 800fcb4:	b480      	push	{r7}
 800fcb6:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 800fcb8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fcbc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800fcc0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800fcc4:	f023 0301 	bic.w	r3, r3, #1
 800fcc8:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 800fccc:	bf00      	nop
 800fcce:	46bd      	mov	sp, r7
 800fcd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fcd4:	4770      	bx	lr

0800fcd6 <LL_RCC_LSE_EnableBypass>:
{
 800fcd6:	b480      	push	{r7}
 800fcd8:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 800fcda:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fcde:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800fce2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800fce6:	f043 0304 	orr.w	r3, r3, #4
 800fcea:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 800fcee:	bf00      	nop
 800fcf0:	46bd      	mov	sp, r7
 800fcf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fcf6:	4770      	bx	lr

0800fcf8 <LL_RCC_LSE_DisableBypass>:
{
 800fcf8:	b480      	push	{r7}
 800fcfa:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 800fcfc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fd00:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800fd04:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800fd08:	f023 0304 	bic.w	r3, r3, #4
 800fd0c:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 800fd10:	bf00      	nop
 800fd12:	46bd      	mov	sp, r7
 800fd14:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fd18:	4770      	bx	lr

0800fd1a <LL_RCC_LSE_IsReady>:
{
 800fd1a:	b480      	push	{r7}
 800fd1c:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 800fd1e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fd22:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800fd26:	f003 0302 	and.w	r3, r3, #2
 800fd2a:	2b02      	cmp	r3, #2
 800fd2c:	d101      	bne.n	800fd32 <LL_RCC_LSE_IsReady+0x18>
 800fd2e:	2301      	movs	r3, #1
 800fd30:	e000      	b.n	800fd34 <LL_RCC_LSE_IsReady+0x1a>
 800fd32:	2300      	movs	r3, #0
}
 800fd34:	4618      	mov	r0, r3
 800fd36:	46bd      	mov	sp, r7
 800fd38:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fd3c:	4770      	bx	lr

0800fd3e <LL_RCC_LSI1_Enable>:
{
 800fd3e:	b480      	push	{r7}
 800fd40:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CSR, RCC_CSR_LSI1ON);
 800fd42:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fd46:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800fd4a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800fd4e:	f043 0301 	orr.w	r3, r3, #1
 800fd52:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 800fd56:	bf00      	nop
 800fd58:	46bd      	mov	sp, r7
 800fd5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fd5e:	4770      	bx	lr

0800fd60 <LL_RCC_LSI1_Disable>:
{
 800fd60:	b480      	push	{r7}
 800fd62:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSI1ON);
 800fd64:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fd68:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800fd6c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800fd70:	f023 0301 	bic.w	r3, r3, #1
 800fd74:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 800fd78:	bf00      	nop
 800fd7a:	46bd      	mov	sp, r7
 800fd7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fd80:	4770      	bx	lr

0800fd82 <LL_RCC_LSI1_IsReady>:
{
 800fd82:	b480      	push	{r7}
 800fd84:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI1RDY) == (RCC_CSR_LSI1RDY)) ? 1UL : 0UL);
 800fd86:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fd8a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800fd8e:	f003 0302 	and.w	r3, r3, #2
 800fd92:	2b02      	cmp	r3, #2
 800fd94:	d101      	bne.n	800fd9a <LL_RCC_LSI1_IsReady+0x18>
 800fd96:	2301      	movs	r3, #1
 800fd98:	e000      	b.n	800fd9c <LL_RCC_LSI1_IsReady+0x1a>
 800fd9a:	2300      	movs	r3, #0
}
 800fd9c:	4618      	mov	r0, r3
 800fd9e:	46bd      	mov	sp, r7
 800fda0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fda4:	4770      	bx	lr

0800fda6 <LL_RCC_LSI2_Enable>:
{
 800fda6:	b480      	push	{r7}
 800fda8:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CSR, RCC_CSR_LSI2ON);
 800fdaa:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fdae:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800fdb2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800fdb6:	f043 0304 	orr.w	r3, r3, #4
 800fdba:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 800fdbe:	bf00      	nop
 800fdc0:	46bd      	mov	sp, r7
 800fdc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fdc6:	4770      	bx	lr

0800fdc8 <LL_RCC_LSI2_Disable>:
{
 800fdc8:	b480      	push	{r7}
 800fdca:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSI2ON);
 800fdcc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fdd0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800fdd4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800fdd8:	f023 0304 	bic.w	r3, r3, #4
 800fddc:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 800fde0:	bf00      	nop
 800fde2:	46bd      	mov	sp, r7
 800fde4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fde8:	4770      	bx	lr

0800fdea <LL_RCC_LSI2_IsReady>:
{
 800fdea:	b480      	push	{r7}
 800fdec:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI2RDY) == (RCC_CSR_LSI2RDY)) ? 1UL : 0UL);
 800fdee:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fdf2:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800fdf6:	f003 0308 	and.w	r3, r3, #8
 800fdfa:	2b08      	cmp	r3, #8
 800fdfc:	d101      	bne.n	800fe02 <LL_RCC_LSI2_IsReady+0x18>
 800fdfe:	2301      	movs	r3, #1
 800fe00:	e000      	b.n	800fe04 <LL_RCC_LSI2_IsReady+0x1a>
 800fe02:	2300      	movs	r3, #0
}
 800fe04:	4618      	mov	r0, r3
 800fe06:	46bd      	mov	sp, r7
 800fe08:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fe0c:	4770      	bx	lr

0800fe0e <LL_RCC_LSI2_SetTrimming>:
{
 800fe0e:	b480      	push	{r7}
 800fe10:	b083      	sub	sp, #12
 800fe12:	af00      	add	r7, sp, #0
 800fe14:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CSR, RCC_CSR_LSI2TRIM, Value << RCC_CSR_LSI2TRIM_Pos);
 800fe16:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fe1a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800fe1e:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
 800fe22:	687b      	ldr	r3, [r7, #4]
 800fe24:	021b      	lsls	r3, r3, #8
 800fe26:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800fe2a:	4313      	orrs	r3, r2
 800fe2c:	f8c1 3094 	str.w	r3, [r1, #148]	; 0x94
}
 800fe30:	bf00      	nop
 800fe32:	370c      	adds	r7, #12
 800fe34:	46bd      	mov	sp, r7
 800fe36:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fe3a:	4770      	bx	lr

0800fe3c <LL_RCC_MSI_Enable>:
{
 800fe3c:	b480      	push	{r7}
 800fe3e:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_MSION);
 800fe40:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fe44:	681b      	ldr	r3, [r3, #0]
 800fe46:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800fe4a:	f043 0301 	orr.w	r3, r3, #1
 800fe4e:	6013      	str	r3, [r2, #0]
}
 800fe50:	bf00      	nop
 800fe52:	46bd      	mov	sp, r7
 800fe54:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fe58:	4770      	bx	lr

0800fe5a <LL_RCC_MSI_Disable>:
{
 800fe5a:	b480      	push	{r7}
 800fe5c:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_MSION);
 800fe5e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fe62:	681b      	ldr	r3, [r3, #0]
 800fe64:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800fe68:	f023 0301 	bic.w	r3, r3, #1
 800fe6c:	6013      	str	r3, [r2, #0]
}
 800fe6e:	bf00      	nop
 800fe70:	46bd      	mov	sp, r7
 800fe72:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fe76:	4770      	bx	lr

0800fe78 <LL_RCC_MSI_IsReady>:
{
 800fe78:	b480      	push	{r7}
 800fe7a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 800fe7c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fe80:	681b      	ldr	r3, [r3, #0]
 800fe82:	f003 0302 	and.w	r3, r3, #2
 800fe86:	2b02      	cmp	r3, #2
 800fe88:	d101      	bne.n	800fe8e <LL_RCC_MSI_IsReady+0x16>
 800fe8a:	2301      	movs	r3, #1
 800fe8c:	e000      	b.n	800fe90 <LL_RCC_MSI_IsReady+0x18>
 800fe8e:	2300      	movs	r3, #0
}
 800fe90:	4618      	mov	r0, r3
 800fe92:	46bd      	mov	sp, r7
 800fe94:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fe98:	4770      	bx	lr

0800fe9a <LL_RCC_MSI_SetRange>:
{
 800fe9a:	b480      	push	{r7}
 800fe9c:	b083      	sub	sp, #12
 800fe9e:	af00      	add	r7, sp, #0
 800fea0:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, Range);
 800fea2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fea6:	681b      	ldr	r3, [r3, #0]
 800fea8:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800feac:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800feb0:	687b      	ldr	r3, [r7, #4]
 800feb2:	4313      	orrs	r3, r2
 800feb4:	600b      	str	r3, [r1, #0]
}
 800feb6:	bf00      	nop
 800feb8:	370c      	adds	r7, #12
 800feba:	46bd      	mov	sp, r7
 800febc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fec0:	4770      	bx	lr

0800fec2 <LL_RCC_MSI_GetRange>:
{
 800fec2:	b480      	push	{r7}
 800fec4:	b083      	sub	sp, #12
 800fec6:	af00      	add	r7, sp, #0
  uint32_t msiRange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE);
 800fec8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fecc:	681b      	ldr	r3, [r3, #0]
 800fece:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800fed2:	607b      	str	r3, [r7, #4]
  if (msiRange > LL_RCC_MSIRANGE_11)
 800fed4:	687b      	ldr	r3, [r7, #4]
 800fed6:	2bb0      	cmp	r3, #176	; 0xb0
 800fed8:	d901      	bls.n	800fede <LL_RCC_MSI_GetRange+0x1c>
    msiRange = LL_RCC_MSIRANGE_11;
 800feda:	23b0      	movs	r3, #176	; 0xb0
 800fedc:	607b      	str	r3, [r7, #4]
  return msiRange;
 800fede:	687b      	ldr	r3, [r7, #4]
}
 800fee0:	4618      	mov	r0, r3
 800fee2:	370c      	adds	r7, #12
 800fee4:	46bd      	mov	sp, r7
 800fee6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800feea:	4770      	bx	lr

0800feec <LL_RCC_MSI_SetCalibTrimming>:
{
 800feec:	b480      	push	{r7}
 800feee:	b083      	sub	sp, #12
 800fef0:	af00      	add	r7, sp, #0
 800fef2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 800fef4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800fef8:	685b      	ldr	r3, [r3, #4]
 800fefa:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 800fefe:	687b      	ldr	r3, [r7, #4]
 800ff00:	021b      	lsls	r3, r3, #8
 800ff02:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800ff06:	4313      	orrs	r3, r2
 800ff08:	604b      	str	r3, [r1, #4]
}
 800ff0a:	bf00      	nop
 800ff0c:	370c      	adds	r7, #12
 800ff0e:	46bd      	mov	sp, r7
 800ff10:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ff14:	4770      	bx	lr

0800ff16 <LL_RCC_SetSysClkSource>:
{
 800ff16:	b480      	push	{r7}
 800ff18:	b083      	sub	sp, #12
 800ff1a:	af00      	add	r7, sp, #0
 800ff1c:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 800ff1e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800ff22:	689b      	ldr	r3, [r3, #8]
 800ff24:	f023 0203 	bic.w	r2, r3, #3
 800ff28:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800ff2c:	687b      	ldr	r3, [r7, #4]
 800ff2e:	4313      	orrs	r3, r2
 800ff30:	608b      	str	r3, [r1, #8]
}
 800ff32:	bf00      	nop
 800ff34:	370c      	adds	r7, #12
 800ff36:	46bd      	mov	sp, r7
 800ff38:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ff3c:	4770      	bx	lr

0800ff3e <LL_RCC_GetSysClkSource>:
{
 800ff3e:	b480      	push	{r7}
 800ff40:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 800ff42:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800ff46:	689b      	ldr	r3, [r3, #8]
 800ff48:	f003 030c 	and.w	r3, r3, #12
}
 800ff4c:	4618      	mov	r0, r3
 800ff4e:	46bd      	mov	sp, r7
 800ff50:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ff54:	4770      	bx	lr

0800ff56 <LL_RCC_SetAHBPrescaler>:
{
 800ff56:	b480      	push	{r7}
 800ff58:	b083      	sub	sp, #12
 800ff5a:	af00      	add	r7, sp, #0
 800ff5c:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 800ff5e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800ff62:	689b      	ldr	r3, [r3, #8]
 800ff64:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800ff68:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800ff6c:	687b      	ldr	r3, [r7, #4]
 800ff6e:	4313      	orrs	r3, r2
 800ff70:	608b      	str	r3, [r1, #8]
}
 800ff72:	bf00      	nop
 800ff74:	370c      	adds	r7, #12
 800ff76:	46bd      	mov	sp, r7
 800ff78:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ff7c:	4770      	bx	lr

0800ff7e <LL_C2_RCC_SetAHBPrescaler>:
{
 800ff7e:	b480      	push	{r7}
 800ff80:	b083      	sub	sp, #12
 800ff82:	af00      	add	r7, sp, #0
 800ff84:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE, Prescaler);
 800ff86:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800ff8a:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800ff8e:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 800ff92:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800ff96:	687b      	ldr	r3, [r7, #4]
 800ff98:	4313      	orrs	r3, r2
 800ff9a:	f8c1 3108 	str.w	r3, [r1, #264]	; 0x108
}
 800ff9e:	bf00      	nop
 800ffa0:	370c      	adds	r7, #12
 800ffa2:	46bd      	mov	sp, r7
 800ffa4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ffa8:	4770      	bx	lr

0800ffaa <LL_RCC_SetAHB4Prescaler>:
{
 800ffaa:	b480      	push	{r7}
 800ffac:	b083      	sub	sp, #12
 800ffae:	af00      	add	r7, sp, #0
 800ffb0:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE, Prescaler >> 4);
 800ffb2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800ffb6:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800ffba:	f023 020f 	bic.w	r2, r3, #15
 800ffbe:	687b      	ldr	r3, [r7, #4]
 800ffc0:	091b      	lsrs	r3, r3, #4
 800ffc2:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800ffc6:	4313      	orrs	r3, r2
 800ffc8:	f8c1 3108 	str.w	r3, [r1, #264]	; 0x108
}
 800ffcc:	bf00      	nop
 800ffce:	370c      	adds	r7, #12
 800ffd0:	46bd      	mov	sp, r7
 800ffd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ffd6:	4770      	bx	lr

0800ffd8 <LL_RCC_SetAPB1Prescaler>:
{
 800ffd8:	b480      	push	{r7}
 800ffda:	b083      	sub	sp, #12
 800ffdc:	af00      	add	r7, sp, #0
 800ffde:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 800ffe0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800ffe4:	689b      	ldr	r3, [r3, #8]
 800ffe6:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 800ffea:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800ffee:	687b      	ldr	r3, [r7, #4]
 800fff0:	4313      	orrs	r3, r2
 800fff2:	608b      	str	r3, [r1, #8]
}
 800fff4:	bf00      	nop
 800fff6:	370c      	adds	r7, #12
 800fff8:	46bd      	mov	sp, r7
 800fffa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fffe:	4770      	bx	lr

08010000 <LL_RCC_SetAPB2Prescaler>:
{
 8010000:	b480      	push	{r7}
 8010002:	b083      	sub	sp, #12
 8010004:	af00      	add	r7, sp, #0
 8010006:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 8010008:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801000c:	689b      	ldr	r3, [r3, #8]
 801000e:	f423 5260 	bic.w	r2, r3, #14336	; 0x3800
 8010012:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8010016:	687b      	ldr	r3, [r7, #4]
 8010018:	4313      	orrs	r3, r2
 801001a:	608b      	str	r3, [r1, #8]
}
 801001c:	bf00      	nop
 801001e:	370c      	adds	r7, #12
 8010020:	46bd      	mov	sp, r7
 8010022:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010026:	4770      	bx	lr

08010028 <LL_RCC_GetAHBPrescaler>:
{
 8010028:	b480      	push	{r7}
 801002a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 801002c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010030:	689b      	ldr	r3, [r3, #8]
 8010032:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
}
 8010036:	4618      	mov	r0, r3
 8010038:	46bd      	mov	sp, r7
 801003a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801003e:	4770      	bx	lr

08010040 <LL_RCC_GetAHB4Prescaler>:
{
 8010040:	b480      	push	{r7}
 8010042:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE) << 4);
 8010044:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010048:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 801004c:	011b      	lsls	r3, r3, #4
 801004e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
}
 8010052:	4618      	mov	r0, r3
 8010054:	46bd      	mov	sp, r7
 8010056:	f85d 7b04 	ldr.w	r7, [sp], #4
 801005a:	4770      	bx	lr

0801005c <LL_RCC_PLL_Enable>:
  * @brief  Enable PLL
  * @rmtoll CR           PLLON         LL_RCC_PLL_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL_Enable(void)
{
 801005c:	b480      	push	{r7}
 801005e:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 8010060:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010064:	681b      	ldr	r3, [r3, #0]
 8010066:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 801006a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 801006e:	6013      	str	r3, [r2, #0]
}
 8010070:	bf00      	nop
 8010072:	46bd      	mov	sp, r7
 8010074:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010078:	4770      	bx	lr

0801007a <LL_RCC_PLL_Disable>:
  * @note Cannot be disabled if the PLL clock is used as the system clock
  * @rmtoll CR           PLLON         LL_RCC_PLL_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL_Disable(void)
{
 801007a:	b480      	push	{r7}
 801007c:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 801007e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010082:	681b      	ldr	r3, [r3, #0]
 8010084:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8010088:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 801008c:	6013      	str	r3, [r2, #0]
}
 801008e:	bf00      	nop
 8010090:	46bd      	mov	sp, r7
 8010092:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010096:	4770      	bx	lr

08010098 <LL_RCC_PLL_IsReady>:
  * @brief  Check if PLL Ready
  * @rmtoll CR           PLLRDY        LL_RCC_PLL_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
{
 8010098:	b480      	push	{r7}
 801009a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 801009c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80100a0:	681b      	ldr	r3, [r3, #0]
 80100a2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80100a6:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 80100aa:	d101      	bne.n	80100b0 <LL_RCC_PLL_IsReady+0x18>
 80100ac:	2301      	movs	r3, #1
 80100ae:	e000      	b.n	80100b2 <LL_RCC_PLL_IsReady+0x1a>
 80100b0:	2300      	movs	r3, #0
}
 80100b2:	4618      	mov	r0, r3
 80100b4:	46bd      	mov	sp, r7
 80100b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80100ba:	4770      	bx	lr

080100bc <LL_RCC_PLL_GetN>:
  * @brief  Get Main PLL multiplication factor for VCO
  * @rmtoll PLLCFGR      PLLN          LL_RCC_PLL_GetN
  * @retval Between 6 and 127
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetN(void)
{
 80100bc:	b480      	push	{r7}
 80100be:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 80100c0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80100c4:	68db      	ldr	r3, [r3, #12]
 80100c6:	0a1b      	lsrs	r3, r3, #8
 80100c8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
}
 80100cc:	4618      	mov	r0, r3
 80100ce:	46bd      	mov	sp, r7
 80100d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80100d4:	4770      	bx	lr

080100d6 <LL_RCC_PLL_GetR>:
  *         @arg @ref LL_RCC_PLLR_DIV_6
  *         @arg @ref LL_RCC_PLLR_DIV_7
  *         @arg @ref LL_RCC_PLLR_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetR(void)
{
 80100d6:	b480      	push	{r7}
 80100d8:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 80100da:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80100de:	68db      	ldr	r3, [r3, #12]
 80100e0:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
}
 80100e4:	4618      	mov	r0, r3
 80100e6:	46bd      	mov	sp, r7
 80100e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80100ec:	4770      	bx	lr

080100ee <LL_RCC_PLL_GetDivider>:
  *         @arg @ref LL_RCC_PLLM_DIV_6
  *         @arg @ref LL_RCC_PLLM_DIV_7
  *         @arg @ref LL_RCC_PLLM_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetDivider(void)
{
 80100ee:	b480      	push	{r7}
 80100f0:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 80100f2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80100f6:	68db      	ldr	r3, [r3, #12]
 80100f8:	f003 0370 	and.w	r3, r3, #112	; 0x70
}
 80100fc:	4618      	mov	r0, r3
 80100fe:	46bd      	mov	sp, r7
 8010100:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010104:	4770      	bx	lr

08010106 <LL_RCC_PLL_GetMainSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
 8010106:	b480      	push	{r7}
 8010108:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 801010a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801010e:	68db      	ldr	r3, [r3, #12]
 8010110:	f003 0303 	and.w	r3, r3, #3
}
 8010114:	4618      	mov	r0, r3
 8010116:	46bd      	mov	sp, r7
 8010118:	f85d 7b04 	ldr.w	r7, [sp], #4
 801011c:	4770      	bx	lr

0801011e <LL_RCC_IsActiveFlag_HPRE>:
  * @brief  Check if HCLK1 prescaler flag value has been applied or not
  * @rmtoll CFGR         HPREF       LL_RCC_IsActiveFlag_HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_HPRE(void)
{
 801011e:	b480      	push	{r7}
 8010120:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HPREF) == (RCC_CFGR_HPREF)) ? 1UL : 0UL);
 8010122:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010126:	689b      	ldr	r3, [r3, #8]
 8010128:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 801012c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8010130:	d101      	bne.n	8010136 <LL_RCC_IsActiveFlag_HPRE+0x18>
 8010132:	2301      	movs	r3, #1
 8010134:	e000      	b.n	8010138 <LL_RCC_IsActiveFlag_HPRE+0x1a>
 8010136:	2300      	movs	r3, #0
}
 8010138:	4618      	mov	r0, r3
 801013a:	46bd      	mov	sp, r7
 801013c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010140:	4770      	bx	lr

08010142 <LL_RCC_IsActiveFlag_C2HPRE>:
  * @brief  Check if HCLK2 prescaler flag value has been applied or not
  * @rmtoll EXTCFGR         C2HPREF       LL_RCC_IsActiveFlag_C2HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_C2HPRE(void)
{
 8010142:	b480      	push	{r7}
 8010144:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPREF) == (RCC_EXTCFGR_C2HPREF)) ? 1UL : 0UL);
 8010146:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801014a:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 801014e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8010152:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8010156:	d101      	bne.n	801015c <LL_RCC_IsActiveFlag_C2HPRE+0x1a>
 8010158:	2301      	movs	r3, #1
 801015a:	e000      	b.n	801015e <LL_RCC_IsActiveFlag_C2HPRE+0x1c>
 801015c:	2300      	movs	r3, #0
}
 801015e:	4618      	mov	r0, r3
 8010160:	46bd      	mov	sp, r7
 8010162:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010166:	4770      	bx	lr

08010168 <LL_RCC_IsActiveFlag_SHDHPRE>:
  * @brief  Check if HCLK4 prescaler flag value has been applied or not
  * @rmtoll EXTCFGR         SHDHPREF       LL_RCC_IsActiveFlag_SHDHPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_SHDHPRE(void)
{
 8010168:	b480      	push	{r7}
 801016a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPREF) == (RCC_EXTCFGR_SHDHPREF)) ? 1UL : 0UL);
 801016c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010170:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8010174:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8010178:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 801017c:	d101      	bne.n	8010182 <LL_RCC_IsActiveFlag_SHDHPRE+0x1a>
 801017e:	2301      	movs	r3, #1
 8010180:	e000      	b.n	8010184 <LL_RCC_IsActiveFlag_SHDHPRE+0x1c>
 8010182:	2300      	movs	r3, #0
}
 8010184:	4618      	mov	r0, r3
 8010186:	46bd      	mov	sp, r7
 8010188:	f85d 7b04 	ldr.w	r7, [sp], #4
 801018c:	4770      	bx	lr

0801018e <LL_RCC_IsActiveFlag_PPRE1>:
  * @brief  Check if PLCK1 prescaler flag value has been applied or not
  * @rmtoll CFGR         PPRE1F       LL_RCC_IsActiveFlag_PPRE1
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE1(void)
{
 801018e:	b480      	push	{r7}
 8010190:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1F) == (RCC_CFGR_PPRE1F)) ? 1UL : 0UL);
 8010192:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010196:	689b      	ldr	r3, [r3, #8]
 8010198:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 801019c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 80101a0:	d101      	bne.n	80101a6 <LL_RCC_IsActiveFlag_PPRE1+0x18>
 80101a2:	2301      	movs	r3, #1
 80101a4:	e000      	b.n	80101a8 <LL_RCC_IsActiveFlag_PPRE1+0x1a>
 80101a6:	2300      	movs	r3, #0
}
 80101a8:	4618      	mov	r0, r3
 80101aa:	46bd      	mov	sp, r7
 80101ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80101b0:	4770      	bx	lr

080101b2 <LL_RCC_IsActiveFlag_PPRE2>:
  * @brief  Check if PLCK2 prescaler flag value has been applied or not
  * @rmtoll CFGR         PPRE2F       LL_RCC_IsActiveFlag_PPRE2
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE2(void)
{
 80101b2:	b480      	push	{r7}
 80101b4:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2F) == (RCC_CFGR_PPRE2F)) ? 1UL : 0UL);
 80101b6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80101ba:	689b      	ldr	r3, [r3, #8]
 80101bc:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80101c0:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 80101c4:	d101      	bne.n	80101ca <LL_RCC_IsActiveFlag_PPRE2+0x18>
 80101c6:	2301      	movs	r3, #1
 80101c8:	e000      	b.n	80101cc <LL_RCC_IsActiveFlag_PPRE2+0x1a>
 80101ca:	2300      	movs	r3, #0
}
 80101cc:	4618      	mov	r0, r3
 80101ce:	46bd      	mov	sp, r7
 80101d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80101d4:	4770      	bx	lr
	...

080101d8 <HAL_RCC_OscConfig>:
  * @note   The PLL is not disabled when used as system clock.
  * @note   The PLL source is not updated when used as PLLSAI1 clock source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80101d8:	b590      	push	{r4, r7, lr}
 80101da:	b08d      	sub	sp, #52	; 0x34
 80101dc:	af00      	add	r7, sp, #0
 80101de:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 80101e0:	687b      	ldr	r3, [r7, #4]
 80101e2:	2b00      	cmp	r3, #0
 80101e4:	d101      	bne.n	80101ea <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 80101e6:	2301      	movs	r3, #1
 80101e8:	e37e      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80101ea:	687b      	ldr	r3, [r7, #4]
 80101ec:	681b      	ldr	r3, [r3, #0]
 80101ee:	f003 0320 	and.w	r3, r3, #32
 80101f2:	2b00      	cmp	r3, #0
 80101f4:	f000 8092 	beq.w	801031c <HAL_RCC_OscConfig+0x144>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* When the MSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80101f8:	f7ff fea1 	bl	800ff3e <LL_RCC_GetSysClkSource>
 80101fc:	62f8      	str	r0, [r7, #44]	; 0x2c
    const uint32_t temp_plloscsrc = __HAL_RCC_GET_PLL_OSCSOURCE();
 80101fe:	f7ff ff82 	bl	8010106 <LL_RCC_PLL_GetMainSource>
 8010202:	62b8      	str	r0, [r7, #40]	; 0x28
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 8010204:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010206:	2b00      	cmp	r3, #0
 8010208:	d005      	beq.n	8010216 <HAL_RCC_OscConfig+0x3e>
 801020a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801020c:	2b0c      	cmp	r3, #12
 801020e:	d14c      	bne.n	80102aa <HAL_RCC_OscConfig+0xd2>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_plloscsrc == RCC_PLLSOURCE_MSI)))
 8010210:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010212:	2b01      	cmp	r3, #1
 8010214:	d149      	bne.n	80102aa <HAL_RCC_OscConfig+0xd2>
    {
      if ((LL_RCC_MSI_IsReady() != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8010216:	f7ff fe2f 	bl	800fe78 <LL_RCC_MSI_IsReady>
 801021a:	4603      	mov	r3, r0
 801021c:	2b00      	cmp	r3, #0
 801021e:	d005      	beq.n	801022c <HAL_RCC_OscConfig+0x54>
 8010220:	687b      	ldr	r3, [r7, #4]
 8010222:	69db      	ldr	r3, [r3, #28]
 8010224:	2b00      	cmp	r3, #0
 8010226:	d101      	bne.n	801022c <HAL_RCC_OscConfig+0x54>
      {
        return HAL_ERROR;
 8010228:	2301      	movs	r3, #1
 801022a:	e35d      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the AHB4 clock
           and the supply voltage of the device. */
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 801022c:	687b      	ldr	r3, [r7, #4]
 801022e:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8010230:	f7ff fe47 	bl	800fec2 <LL_RCC_MSI_GetRange>
 8010234:	4603      	mov	r3, r0
 8010236:	429c      	cmp	r4, r3
 8010238:	d914      	bls.n	8010264 <HAL_RCC_OscConfig+0x8c>
        {
          /* First increase number of wait states update if necessary */
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 801023a:	687b      	ldr	r3, [r7, #4]
 801023c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801023e:	4618      	mov	r0, r3
 8010240:	f000 fd16 	bl	8010c70 <RCC_SetFlashLatencyFromMSIRange>
 8010244:	4603      	mov	r3, r0
 8010246:	2b00      	cmp	r3, #0
 8010248:	d001      	beq.n	801024e <HAL_RCC_OscConfig+0x76>
          {
            return HAL_ERROR;
 801024a:	2301      	movs	r3, #1
 801024c:	e34c      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 801024e:	687b      	ldr	r3, [r7, #4]
 8010250:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010252:	4618      	mov	r0, r3
 8010254:	f7ff fe21 	bl	800fe9a <LL_RCC_MSI_SetRange>
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8010258:	687b      	ldr	r3, [r7, #4]
 801025a:	6a1b      	ldr	r3, [r3, #32]
 801025c:	4618      	mov	r0, r3
 801025e:	f7ff fe45 	bl	800feec <LL_RCC_MSI_SetCalibTrimming>
 8010262:	e013      	b.n	801028c <HAL_RCC_OscConfig+0xb4>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8010264:	687b      	ldr	r3, [r7, #4]
 8010266:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010268:	4618      	mov	r0, r3
 801026a:	f7ff fe16 	bl	800fe9a <LL_RCC_MSI_SetRange>
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 801026e:	687b      	ldr	r3, [r7, #4]
 8010270:	6a1b      	ldr	r3, [r3, #32]
 8010272:	4618      	mov	r0, r3
 8010274:	f7ff fe3a 	bl	800feec <LL_RCC_MSI_SetCalibTrimming>

          /* Decrease number of wait states update if necessary */
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8010278:	687b      	ldr	r3, [r7, #4]
 801027a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801027c:	4618      	mov	r0, r3
 801027e:	f000 fcf7 	bl	8010c70 <RCC_SetFlashLatencyFromMSIRange>
 8010282:	4603      	mov	r3, r0
 8010284:	2b00      	cmp	r3, #0
 8010286:	d001      	beq.n	801028c <HAL_RCC_OscConfig+0xb4>
          {
            return HAL_ERROR;
 8010288:	2301      	movs	r3, #1
 801028a:	e32d      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
          }
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 801028c:	f000 fcdc 	bl	8010c48 <HAL_RCC_GetHCLKFreq>
 8010290:	4603      	mov	r3, r0
 8010292:	4ab3      	ldr	r2, [pc, #716]	; (8010560 <HAL_RCC_OscConfig+0x388>)
 8010294:	6013      	str	r3, [r2, #0]
        
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 8010296:	4bb3      	ldr	r3, [pc, #716]	; (8010564 <HAL_RCC_OscConfig+0x38c>)
 8010298:	681b      	ldr	r3, [r3, #0]
 801029a:	4618      	mov	r0, r3
 801029c:	f7fd f80a 	bl	800d2b4 <HAL_InitTick>
 80102a0:	4603      	mov	r3, r0
 80102a2:	2b00      	cmp	r3, #0
 80102a4:	d039      	beq.n	801031a <HAL_RCC_OscConfig+0x142>
        {
          return HAL_ERROR;
 80102a6:	2301      	movs	r3, #1
 80102a8:	e31e      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
      }
    }
    else
    {
      /* Check the MSI State */
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 80102aa:	687b      	ldr	r3, [r7, #4]
 80102ac:	69db      	ldr	r3, [r3, #28]
 80102ae:	2b00      	cmp	r3, #0
 80102b0:	d01e      	beq.n	80102f0 <HAL_RCC_OscConfig+0x118>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 80102b2:	f7ff fdc3 	bl	800fe3c <LL_RCC_MSI_Enable>

        /* Get timeout */
        tickstart = HAL_GetTick();
 80102b6:	f7fd f84b 	bl	800d350 <HAL_GetTick>
 80102ba:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till MSI is ready */
        while (LL_RCC_MSI_IsReady() == 0U)
 80102bc:	e008      	b.n	80102d0 <HAL_RCC_OscConfig+0xf8>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80102be:	f7fd f847 	bl	800d350 <HAL_GetTick>
 80102c2:	4602      	mov	r2, r0
 80102c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80102c6:	1ad3      	subs	r3, r2, r3
 80102c8:	2b02      	cmp	r3, #2
 80102ca:	d901      	bls.n	80102d0 <HAL_RCC_OscConfig+0xf8>
          {
            return HAL_TIMEOUT;
 80102cc:	2303      	movs	r3, #3
 80102ce:	e30b      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_MSI_IsReady() == 0U)
 80102d0:	f7ff fdd2 	bl	800fe78 <LL_RCC_MSI_IsReady>
 80102d4:	4603      	mov	r3, r0
 80102d6:	2b00      	cmp	r3, #0
 80102d8:	d0f1      	beq.n	80102be <HAL_RCC_OscConfig+0xe6>
          }
        }
        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80102da:	687b      	ldr	r3, [r7, #4]
 80102dc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80102de:	4618      	mov	r0, r3
 80102e0:	f7ff fddb 	bl	800fe9a <LL_RCC_MSI_SetRange>
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80102e4:	687b      	ldr	r3, [r7, #4]
 80102e6:	6a1b      	ldr	r3, [r3, #32]
 80102e8:	4618      	mov	r0, r3
 80102ea:	f7ff fdff 	bl	800feec <LL_RCC_MSI_SetCalibTrimming>
 80102ee:	e015      	b.n	801031c <HAL_RCC_OscConfig+0x144>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 80102f0:	f7ff fdb3 	bl	800fe5a <LL_RCC_MSI_Disable>

        /* Get timeout */
        tickstart = HAL_GetTick();
 80102f4:	f7fd f82c 	bl	800d350 <HAL_GetTick>
 80102f8:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till MSI is disabled */
        while (LL_RCC_MSI_IsReady() != 0U)
 80102fa:	e008      	b.n	801030e <HAL_RCC_OscConfig+0x136>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80102fc:	f7fd f828 	bl	800d350 <HAL_GetTick>
 8010300:	4602      	mov	r2, r0
 8010302:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010304:	1ad3      	subs	r3, r2, r3
 8010306:	2b02      	cmp	r3, #2
 8010308:	d901      	bls.n	801030e <HAL_RCC_OscConfig+0x136>
          {
            return HAL_TIMEOUT;
 801030a:	2303      	movs	r3, #3
 801030c:	e2ec      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_MSI_IsReady() != 0U)
 801030e:	f7ff fdb3 	bl	800fe78 <LL_RCC_MSI_IsReady>
 8010312:	4603      	mov	r3, r0
 8010314:	2b00      	cmp	r3, #0
 8010316:	d1f1      	bne.n	80102fc <HAL_RCC_OscConfig+0x124>
 8010318:	e000      	b.n	801031c <HAL_RCC_OscConfig+0x144>
      if ((LL_RCC_MSI_IsReady() != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 801031a:	bf00      	nop
        }
      }
    }
  }
  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 801031c:	687b      	ldr	r3, [r7, #4]
 801031e:	681b      	ldr	r3, [r3, #0]
 8010320:	f003 0301 	and.w	r3, r3, #1
 8010324:	2b00      	cmp	r3, #0
 8010326:	d04e      	beq.n	80103c6 <HAL_RCC_OscConfig+0x1ee>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8010328:	f7ff fe09 	bl	800ff3e <LL_RCC_GetSysClkSource>
 801032c:	6238      	str	r0, [r7, #32]
    const uint32_t temp_plloscsrc = __HAL_RCC_GET_PLL_OSCSOURCE();
 801032e:	f7ff feea 	bl	8010106 <LL_RCC_PLL_GetMainSource>
 8010332:	61f8      	str	r0, [r7, #28]
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 8010334:	6a3b      	ldr	r3, [r7, #32]
 8010336:	2b08      	cmp	r3, #8
 8010338:	d005      	beq.n	8010346 <HAL_RCC_OscConfig+0x16e>
 801033a:	6a3b      	ldr	r3, [r7, #32]
 801033c:	2b0c      	cmp	r3, #12
 801033e:	d10d      	bne.n	801035c <HAL_RCC_OscConfig+0x184>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_plloscsrc == RCC_PLLSOURCE_HSE)))
 8010340:	69fb      	ldr	r3, [r7, #28]
 8010342:	2b03      	cmp	r3, #3
 8010344:	d10a      	bne.n	801035c <HAL_RCC_OscConfig+0x184>
    {
      if ((LL_RCC_HSE_IsReady() != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8010346:	f7ff fc19 	bl	800fb7c <LL_RCC_HSE_IsReady>
 801034a:	4603      	mov	r3, r0
 801034c:	2b00      	cmp	r3, #0
 801034e:	d039      	beq.n	80103c4 <HAL_RCC_OscConfig+0x1ec>
 8010350:	687b      	ldr	r3, [r7, #4]
 8010352:	685b      	ldr	r3, [r3, #4]
 8010354:	2b00      	cmp	r3, #0
 8010356:	d135      	bne.n	80103c4 <HAL_RCC_OscConfig+0x1ec>
      {
        return HAL_ERROR;
 8010358:	2301      	movs	r3, #1
 801035a:	e2c5      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 801035c:	687b      	ldr	r3, [r7, #4]
 801035e:	685b      	ldr	r3, [r3, #4]
 8010360:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8010364:	d102      	bne.n	801036c <HAL_RCC_OscConfig+0x194>
 8010366:	f7ff fbeb 	bl	800fb40 <LL_RCC_HSE_Enable>
 801036a:	e001      	b.n	8010370 <HAL_RCC_OscConfig+0x198>
 801036c:	f7ff fbf7 	bl	800fb5e <LL_RCC_HSE_Disable>

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8010370:	687b      	ldr	r3, [r7, #4]
 8010372:	685b      	ldr	r3, [r3, #4]
 8010374:	2b00      	cmp	r3, #0
 8010376:	d012      	beq.n	801039e <HAL_RCC_OscConfig+0x1c6>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8010378:	f7fc ffea 	bl	800d350 <HAL_GetTick>
 801037c:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is ready */
        while (LL_RCC_HSE_IsReady() == 0U)
 801037e:	e008      	b.n	8010392 <HAL_RCC_OscConfig+0x1ba>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8010380:	f7fc ffe6 	bl	800d350 <HAL_GetTick>
 8010384:	4602      	mov	r2, r0
 8010386:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010388:	1ad3      	subs	r3, r2, r3
 801038a:	2b64      	cmp	r3, #100	; 0x64
 801038c:	d901      	bls.n	8010392 <HAL_RCC_OscConfig+0x1ba>
          {
            return HAL_TIMEOUT;
 801038e:	2303      	movs	r3, #3
 8010390:	e2aa      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_HSE_IsReady() == 0U)
 8010392:	f7ff fbf3 	bl	800fb7c <LL_RCC_HSE_IsReady>
 8010396:	4603      	mov	r3, r0
 8010398:	2b00      	cmp	r3, #0
 801039a:	d0f1      	beq.n	8010380 <HAL_RCC_OscConfig+0x1a8>
 801039c:	e013      	b.n	80103c6 <HAL_RCC_OscConfig+0x1ee>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 801039e:	f7fc ffd7 	bl	800d350 <HAL_GetTick>
 80103a2:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is disabled */
        while (LL_RCC_HSE_IsReady() != 0U)
 80103a4:	e008      	b.n	80103b8 <HAL_RCC_OscConfig+0x1e0>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80103a6:	f7fc ffd3 	bl	800d350 <HAL_GetTick>
 80103aa:	4602      	mov	r2, r0
 80103ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80103ae:	1ad3      	subs	r3, r2, r3
 80103b0:	2b64      	cmp	r3, #100	; 0x64
 80103b2:	d901      	bls.n	80103b8 <HAL_RCC_OscConfig+0x1e0>
          {
            return HAL_TIMEOUT;
 80103b4:	2303      	movs	r3, #3
 80103b6:	e297      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_HSE_IsReady() != 0U)
 80103b8:	f7ff fbe0 	bl	800fb7c <LL_RCC_HSE_IsReady>
 80103bc:	4603      	mov	r3, r0
 80103be:	2b00      	cmp	r3, #0
 80103c0:	d1f1      	bne.n	80103a6 <HAL_RCC_OscConfig+0x1ce>
 80103c2:	e000      	b.n	80103c6 <HAL_RCC_OscConfig+0x1ee>
      if ((LL_RCC_HSE_IsReady() != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80103c4:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80103c6:	687b      	ldr	r3, [r7, #4]
 80103c8:	681b      	ldr	r3, [r3, #0]
 80103ca:	f003 0302 	and.w	r3, r3, #2
 80103ce:	2b00      	cmp	r3, #0
 80103d0:	d051      	beq.n	8010476 <HAL_RCC_OscConfig+0x29e>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80103d2:	f7ff fdb4 	bl	800ff3e <LL_RCC_GetSysClkSource>
 80103d6:	61b8      	str	r0, [r7, #24]
    const uint32_t temp_plloscsrc = __HAL_RCC_GET_PLL_OSCSOURCE();
 80103d8:	f7ff fe95 	bl	8010106 <LL_RCC_PLL_GetMainSource>
 80103dc:	6178      	str	r0, [r7, #20]
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 80103de:	69bb      	ldr	r3, [r7, #24]
 80103e0:	2b04      	cmp	r3, #4
 80103e2:	d005      	beq.n	80103f0 <HAL_RCC_OscConfig+0x218>
 80103e4:	69bb      	ldr	r3, [r7, #24]
 80103e6:	2b0c      	cmp	r3, #12
 80103e8:	d113      	bne.n	8010412 <HAL_RCC_OscConfig+0x23a>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_plloscsrc == RCC_PLLSOURCE_HSI)))
 80103ea:	697b      	ldr	r3, [r7, #20]
 80103ec:	2b02      	cmp	r3, #2
 80103ee:	d110      	bne.n	8010412 <HAL_RCC_OscConfig+0x23a>
    {
      /* When HSI is used as system clock it will not be disabled */
      if ((LL_RCC_HSI_IsReady() != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80103f0:	f7ff fbf4 	bl	800fbdc <LL_RCC_HSI_IsReady>
 80103f4:	4603      	mov	r3, r0
 80103f6:	2b00      	cmp	r3, #0
 80103f8:	d005      	beq.n	8010406 <HAL_RCC_OscConfig+0x22e>
 80103fa:	687b      	ldr	r3, [r7, #4]
 80103fc:	68db      	ldr	r3, [r3, #12]
 80103fe:	2b00      	cmp	r3, #0
 8010400:	d101      	bne.n	8010406 <HAL_RCC_OscConfig+0x22e>
      {
        return HAL_ERROR;
 8010402:	2301      	movs	r3, #1
 8010404:	e270      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8010406:	687b      	ldr	r3, [r7, #4]
 8010408:	691b      	ldr	r3, [r3, #16]
 801040a:	4618      	mov	r0, r3
 801040c:	f7ff fbf8 	bl	800fc00 <LL_RCC_HSI_SetCalibTrimming>
      if ((LL_RCC_HSI_IsReady() != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8010410:	e031      	b.n	8010476 <HAL_RCC_OscConfig+0x29e>
      }
    }
    else
    {
      /* Check the HSI State */
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8010412:	687b      	ldr	r3, [r7, #4]
 8010414:	68db      	ldr	r3, [r3, #12]
 8010416:	2b00      	cmp	r3, #0
 8010418:	d019      	beq.n	801044e <HAL_RCC_OscConfig+0x276>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 801041a:	f7ff fbc1 	bl	800fba0 <LL_RCC_HSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 801041e:	f7fc ff97 	bl	800d350 <HAL_GetTick>
 8010422:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is ready */
        while (LL_RCC_HSI_IsReady() == 0U)
 8010424:	e008      	b.n	8010438 <HAL_RCC_OscConfig+0x260>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8010426:	f7fc ff93 	bl	800d350 <HAL_GetTick>
 801042a:	4602      	mov	r2, r0
 801042c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801042e:	1ad3      	subs	r3, r2, r3
 8010430:	2b02      	cmp	r3, #2
 8010432:	d901      	bls.n	8010438 <HAL_RCC_OscConfig+0x260>
          {
            return HAL_TIMEOUT;
 8010434:	2303      	movs	r3, #3
 8010436:	e257      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_HSI_IsReady() == 0U)
 8010438:	f7ff fbd0 	bl	800fbdc <LL_RCC_HSI_IsReady>
 801043c:	4603      	mov	r3, r0
 801043e:	2b00      	cmp	r3, #0
 8010440:	d0f1      	beq.n	8010426 <HAL_RCC_OscConfig+0x24e>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8010442:	687b      	ldr	r3, [r7, #4]
 8010444:	691b      	ldr	r3, [r3, #16]
 8010446:	4618      	mov	r0, r3
 8010448:	f7ff fbda 	bl	800fc00 <LL_RCC_HSI_SetCalibTrimming>
 801044c:	e013      	b.n	8010476 <HAL_RCC_OscConfig+0x29e>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 801044e:	f7ff fbb6 	bl	800fbbe <LL_RCC_HSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8010452:	f7fc ff7d 	bl	800d350 <HAL_GetTick>
 8010456:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is disabled */
        while (LL_RCC_HSI_IsReady() != 0U)
 8010458:	e008      	b.n	801046c <HAL_RCC_OscConfig+0x294>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 801045a:	f7fc ff79 	bl	800d350 <HAL_GetTick>
 801045e:	4602      	mov	r2, r0
 8010460:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010462:	1ad3      	subs	r3, r2, r3
 8010464:	2b02      	cmp	r3, #2
 8010466:	d901      	bls.n	801046c <HAL_RCC_OscConfig+0x294>
          {
            return HAL_TIMEOUT;
 8010468:	2303      	movs	r3, #3
 801046a:	e23d      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_HSI_IsReady() != 0U)
 801046c:	f7ff fbb6 	bl	800fbdc <LL_RCC_HSI_IsReady>
 8010470:	4603      	mov	r3, r0
 8010472:	2b00      	cmp	r3, #0
 8010474:	d1f1      	bne.n	801045a <HAL_RCC_OscConfig+0x282>
      }
    }
  }
  /*------------------------------ LSI Configuration (LSI1 or LSI2) -------------------------*/

  if ((((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI1) == RCC_OSCILLATORTYPE_LSI1) || \
 8010476:	687b      	ldr	r3, [r7, #4]
 8010478:	681b      	ldr	r3, [r3, #0]
 801047a:	f003 0308 	and.w	r3, r3, #8
 801047e:	2b00      	cmp	r3, #0
 8010480:	d106      	bne.n	8010490 <HAL_RCC_OscConfig+0x2b8>
      (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI2) == RCC_OSCILLATORTYPE_LSI2))
 8010482:	687b      	ldr	r3, [r7, #4]
 8010484:	681b      	ldr	r3, [r3, #0]
 8010486:	f003 0310 	and.w	r3, r3, #16
  if ((((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI1) == RCC_OSCILLATORTYPE_LSI1) || \
 801048a:	2b00      	cmp	r3, #0
 801048c:	f000 80a3 	beq.w	80105d6 <HAL_RCC_OscConfig+0x3fe>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8010490:	687b      	ldr	r3, [r7, #4]
 8010492:	695b      	ldr	r3, [r3, #20]
 8010494:	2b00      	cmp	r3, #0
 8010496:	d076      	beq.n	8010586 <HAL_RCC_OscConfig+0x3ae>
    {
      /*------------------------------ LSI2 selected by default (when Switch ON) -------------------------*/
      if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI2) == RCC_OSCILLATORTYPE_LSI2)
 8010498:	687b      	ldr	r3, [r7, #4]
 801049a:	681b      	ldr	r3, [r3, #0]
 801049c:	f003 0310 	and.w	r3, r3, #16
 80104a0:	2b00      	cmp	r3, #0
 80104a2:	d046      	beq.n	8010532 <HAL_RCC_OscConfig+0x35a>
      {
        assert_param(IS_RCC_LSI2_CALIBRATION_VALUE(RCC_OscInitStruct->LSI2CalibrationValue));

        /* 1. Check LSI1 state and enable if required */
        if (LL_RCC_LSI1_IsReady() == 0U)
 80104a4:	f7ff fc6d 	bl	800fd82 <LL_RCC_LSI1_IsReady>
 80104a8:	4603      	mov	r3, r0
 80104aa:	2b00      	cmp	r3, #0
 80104ac:	d113      	bne.n	80104d6 <HAL_RCC_OscConfig+0x2fe>
        {
          /* This is required to enable LSI1 before enabling LSI2 */
          __HAL_RCC_LSI1_ENABLE();
 80104ae:	f7ff fc46 	bl	800fd3e <LL_RCC_LSI1_Enable>

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 80104b2:	f7fc ff4d 	bl	800d350 <HAL_GetTick>
 80104b6:	6278      	str	r0, [r7, #36]	; 0x24

          /* Wait till LSI1 is ready */
          while (LL_RCC_LSI1_IsReady() == 0U)
 80104b8:	e008      	b.n	80104cc <HAL_RCC_OscConfig+0x2f4>
          {
            if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 80104ba:	f7fc ff49 	bl	800d350 <HAL_GetTick>
 80104be:	4602      	mov	r2, r0
 80104c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80104c2:	1ad3      	subs	r3, r2, r3
 80104c4:	2b02      	cmp	r3, #2
 80104c6:	d901      	bls.n	80104cc <HAL_RCC_OscConfig+0x2f4>
            {
              return HAL_TIMEOUT;
 80104c8:	2303      	movs	r3, #3
 80104ca:	e20d      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
          while (LL_RCC_LSI1_IsReady() == 0U)
 80104cc:	f7ff fc59 	bl	800fd82 <LL_RCC_LSI1_IsReady>
 80104d0:	4603      	mov	r3, r0
 80104d2:	2b00      	cmp	r3, #0
 80104d4:	d0f1      	beq.n	80104ba <HAL_RCC_OscConfig+0x2e2>
            }
          }
        }

        /* 2. Enable the Internal Low Speed oscillator (LSI2) and set trimming value */
        __HAL_RCC_LSI2_ENABLE();
 80104d6:	f7ff fc66 	bl	800fda6 <LL_RCC_LSI2_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80104da:	f7fc ff39 	bl	800d350 <HAL_GetTick>
 80104de:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till LSI2 is ready */
        while (LL_RCC_LSI2_IsReady() == 0U)
 80104e0:	e008      	b.n	80104f4 <HAL_RCC_OscConfig+0x31c>
        {
          if ((HAL_GetTick() - tickstart) > LSI2_TIMEOUT_VALUE)
 80104e2:	f7fc ff35 	bl	800d350 <HAL_GetTick>
 80104e6:	4602      	mov	r2, r0
 80104e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80104ea:	1ad3      	subs	r3, r2, r3
 80104ec:	2b03      	cmp	r3, #3
 80104ee:	d901      	bls.n	80104f4 <HAL_RCC_OscConfig+0x31c>
          {
            return HAL_TIMEOUT;
 80104f0:	2303      	movs	r3, #3
 80104f2:	e1f9      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_LSI2_IsReady() == 0U)
 80104f4:	f7ff fc79 	bl	800fdea <LL_RCC_LSI2_IsReady>
 80104f8:	4603      	mov	r3, r0
 80104fa:	2b00      	cmp	r3, #0
 80104fc:	d0f1      	beq.n	80104e2 <HAL_RCC_OscConfig+0x30a>
          }
        }
        /* Adjusts the Internal Low Spee oscillator (LSI2) calibration value */
        __HAL_RCC_LSI2_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->LSI2CalibrationValue);
 80104fe:	687b      	ldr	r3, [r7, #4]
 8010500:	699b      	ldr	r3, [r3, #24]
 8010502:	4618      	mov	r0, r3
 8010504:	f7ff fc83 	bl	800fe0e <LL_RCC_LSI2_SetTrimming>

        /* 3. Disable LSI1 */

        /* LSI1 was initially not enable, require to disable it */
        __HAL_RCC_LSI1_DISABLE();
 8010508:	f7ff fc2a 	bl	800fd60 <LL_RCC_LSI1_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 801050c:	f7fc ff20 	bl	800d350 <HAL_GetTick>
 8010510:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till LSI1 is disabled */
        while (LL_RCC_LSI1_IsReady() != 0U)
 8010512:	e008      	b.n	8010526 <HAL_RCC_OscConfig+0x34e>
        {
          if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 8010514:	f7fc ff1c 	bl	800d350 <HAL_GetTick>
 8010518:	4602      	mov	r2, r0
 801051a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801051c:	1ad3      	subs	r3, r2, r3
 801051e:	2b02      	cmp	r3, #2
 8010520:	d901      	bls.n	8010526 <HAL_RCC_OscConfig+0x34e>
          {
            return HAL_TIMEOUT;
 8010522:	2303      	movs	r3, #3
 8010524:	e1e0      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_LSI1_IsReady() != 0U)
 8010526:	f7ff fc2c 	bl	800fd82 <LL_RCC_LSI1_IsReady>
 801052a:	4603      	mov	r3, r0
 801052c:	2b00      	cmp	r3, #0
 801052e:	d1f1      	bne.n	8010514 <HAL_RCC_OscConfig+0x33c>
 8010530:	e051      	b.n	80105d6 <HAL_RCC_OscConfig+0x3fe>
      else
      {
        /*------------------------------ LSI1 selected (only if LSI2 OFF)-------------------------*/

        /* 1. Enable the Internal Low Speed oscillator (LSI1). */
        __HAL_RCC_LSI1_ENABLE();
 8010532:	f7ff fc04 	bl	800fd3e <LL_RCC_LSI1_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8010536:	f7fc ff0b 	bl	800d350 <HAL_GetTick>
 801053a:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till LSI1 is ready */
        while (LL_RCC_LSI1_IsReady() == 0U)
 801053c:	e008      	b.n	8010550 <HAL_RCC_OscConfig+0x378>
        {
          if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 801053e:	f7fc ff07 	bl	800d350 <HAL_GetTick>
 8010542:	4602      	mov	r2, r0
 8010544:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010546:	1ad3      	subs	r3, r2, r3
 8010548:	2b02      	cmp	r3, #2
 801054a:	d901      	bls.n	8010550 <HAL_RCC_OscConfig+0x378>
          {
            return HAL_TIMEOUT;
 801054c:	2303      	movs	r3, #3
 801054e:	e1cb      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_LSI1_IsReady() == 0U)
 8010550:	f7ff fc17 	bl	800fd82 <LL_RCC_LSI1_IsReady>
 8010554:	4603      	mov	r3, r0
 8010556:	2b00      	cmp	r3, #0
 8010558:	d0f1      	beq.n	801053e <HAL_RCC_OscConfig+0x366>
          }
        }
        /*2. Switch OFF LSI2*/

        /* Disable the Internal Low Speed oscillator (LSI2). */
        __HAL_RCC_LSI2_DISABLE();
 801055a:	f7ff fc35 	bl	800fdc8 <LL_RCC_LSI2_Disable>

        /* Wait till LSI2 is disabled */
        while (LL_RCC_LSI2_IsReady() != 0U)
 801055e:	e00c      	b.n	801057a <HAL_RCC_OscConfig+0x3a2>
 8010560:	20000004 	.word	0x20000004
 8010564:	20000008 	.word	0x20000008
        {
          if ((HAL_GetTick() - tickstart) > LSI2_TIMEOUT_VALUE)
 8010568:	f7fc fef2 	bl	800d350 <HAL_GetTick>
 801056c:	4602      	mov	r2, r0
 801056e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010570:	1ad3      	subs	r3, r2, r3
 8010572:	2b03      	cmp	r3, #3
 8010574:	d901      	bls.n	801057a <HAL_RCC_OscConfig+0x3a2>
          {
            return HAL_TIMEOUT;
 8010576:	2303      	movs	r3, #3
 8010578:	e1b6      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
        while (LL_RCC_LSI2_IsReady() != 0U)
 801057a:	f7ff fc36 	bl	800fdea <LL_RCC_LSI2_IsReady>
 801057e:	4603      	mov	r3, r0
 8010580:	2b00      	cmp	r3, #0
 8010582:	d1f1      	bne.n	8010568 <HAL_RCC_OscConfig+0x390>
 8010584:	e027      	b.n	80105d6 <HAL_RCC_OscConfig+0x3fe>
    }
    else
    {

      /* Disable the Internal Low Speed oscillator (LSI2). */
      __HAL_RCC_LSI2_DISABLE();
 8010586:	f7ff fc1f 	bl	800fdc8 <LL_RCC_LSI2_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 801058a:	f7fc fee1 	bl	800d350 <HAL_GetTick>
 801058e:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI2 is disabled */
      while (LL_RCC_LSI2_IsReady() != 0U)
 8010590:	e008      	b.n	80105a4 <HAL_RCC_OscConfig+0x3cc>
      {
        if ((HAL_GetTick() - tickstart) > LSI2_TIMEOUT_VALUE)
 8010592:	f7fc fedd 	bl	800d350 <HAL_GetTick>
 8010596:	4602      	mov	r2, r0
 8010598:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801059a:	1ad3      	subs	r3, r2, r3
 801059c:	2b03      	cmp	r3, #3
 801059e:	d901      	bls.n	80105a4 <HAL_RCC_OscConfig+0x3cc>
        {
          return HAL_TIMEOUT;
 80105a0:	2303      	movs	r3, #3
 80105a2:	e1a1      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
      while (LL_RCC_LSI2_IsReady() != 0U)
 80105a4:	f7ff fc21 	bl	800fdea <LL_RCC_LSI2_IsReady>
 80105a8:	4603      	mov	r3, r0
 80105aa:	2b00      	cmp	r3, #0
 80105ac:	d1f1      	bne.n	8010592 <HAL_RCC_OscConfig+0x3ba>
        }
      }

      /* Disable the Internal Low Speed oscillator (LSI1). */
      __HAL_RCC_LSI1_DISABLE();
 80105ae:	f7ff fbd7 	bl	800fd60 <LL_RCC_LSI1_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80105b2:	f7fc fecd 	bl	800d350 <HAL_GetTick>
 80105b6:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI1 is disabled */
      while (LL_RCC_LSI1_IsReady() != 0U)
 80105b8:	e008      	b.n	80105cc <HAL_RCC_OscConfig+0x3f4>
      {
        if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 80105ba:	f7fc fec9 	bl	800d350 <HAL_GetTick>
 80105be:	4602      	mov	r2, r0
 80105c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80105c2:	1ad3      	subs	r3, r2, r3
 80105c4:	2b02      	cmp	r3, #2
 80105c6:	d901      	bls.n	80105cc <HAL_RCC_OscConfig+0x3f4>
        {
          return HAL_TIMEOUT;
 80105c8:	2303      	movs	r3, #3
 80105ca:	e18d      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
      while (LL_RCC_LSI1_IsReady() != 0U)
 80105cc:	f7ff fbd9 	bl	800fd82 <LL_RCC_LSI1_IsReady>
 80105d0:	4603      	mov	r3, r0
 80105d2:	2b00      	cmp	r3, #0
 80105d4:	d1f1      	bne.n	80105ba <HAL_RCC_OscConfig+0x3e2>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80105d6:	687b      	ldr	r3, [r7, #4]
 80105d8:	681b      	ldr	r3, [r3, #0]
 80105da:	f003 0304 	and.w	r3, r3, #4
 80105de:	2b00      	cmp	r3, #0
 80105e0:	d05b      	beq.n	801069a <HAL_RCC_OscConfig+0x4c2>
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80105e2:	4bb5      	ldr	r3, [pc, #724]	; (80108b8 <HAL_RCC_OscConfig+0x6e0>)
 80105e4:	681b      	ldr	r3, [r3, #0]
 80105e6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80105ea:	2b00      	cmp	r3, #0
 80105ec:	d114      	bne.n	8010618 <HAL_RCC_OscConfig+0x440>
    {
      /* Enable write access to Backup domain */
      HAL_PWR_EnableBkUpAccess();
 80105ee:	f7ff fa77 	bl	800fae0 <HAL_PWR_EnableBkUpAccess>

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 80105f2:	f7fc fead 	bl	800d350 <HAL_GetTick>
 80105f6:	6278      	str	r0, [r7, #36]	; 0x24

      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80105f8:	e008      	b.n	801060c <HAL_RCC_OscConfig+0x434>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80105fa:	f7fc fea9 	bl	800d350 <HAL_GetTick>
 80105fe:	4602      	mov	r2, r0
 8010600:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010602:	1ad3      	subs	r3, r2, r3
 8010604:	2b02      	cmp	r3, #2
 8010606:	d901      	bls.n	801060c <HAL_RCC_OscConfig+0x434>
        {
          return HAL_TIMEOUT;
 8010608:	2303      	movs	r3, #3
 801060a:	e16d      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 801060c:	4baa      	ldr	r3, [pc, #680]	; (80108b8 <HAL_RCC_OscConfig+0x6e0>)
 801060e:	681b      	ldr	r3, [r3, #0]
 8010610:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8010614:	2b00      	cmp	r3, #0
 8010616:	d0f0      	beq.n	80105fa <HAL_RCC_OscConfig+0x422>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8010618:	687b      	ldr	r3, [r7, #4]
 801061a:	689b      	ldr	r3, [r3, #8]
 801061c:	2b01      	cmp	r3, #1
 801061e:	d102      	bne.n	8010626 <HAL_RCC_OscConfig+0x44e>
 8010620:	f7ff fb37 	bl	800fc92 <LL_RCC_LSE_Enable>
 8010624:	e00c      	b.n	8010640 <HAL_RCC_OscConfig+0x468>
 8010626:	687b      	ldr	r3, [r7, #4]
 8010628:	689b      	ldr	r3, [r3, #8]
 801062a:	2b05      	cmp	r3, #5
 801062c:	d104      	bne.n	8010638 <HAL_RCC_OscConfig+0x460>
 801062e:	f7ff fb52 	bl	800fcd6 <LL_RCC_LSE_EnableBypass>
 8010632:	f7ff fb2e 	bl	800fc92 <LL_RCC_LSE_Enable>
 8010636:	e003      	b.n	8010640 <HAL_RCC_OscConfig+0x468>
 8010638:	f7ff fb3c 	bl	800fcb4 <LL_RCC_LSE_Disable>
 801063c:	f7ff fb5c 	bl	800fcf8 <LL_RCC_LSE_DisableBypass>

    /* Check the LSE State */
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8010640:	687b      	ldr	r3, [r7, #4]
 8010642:	689b      	ldr	r3, [r3, #8]
 8010644:	2b00      	cmp	r3, #0
 8010646:	d014      	beq.n	8010672 <HAL_RCC_OscConfig+0x49a>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8010648:	f7fc fe82 	bl	800d350 <HAL_GetTick>
 801064c:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is ready */
      while (LL_RCC_LSE_IsReady() == 0U)
 801064e:	e00a      	b.n	8010666 <HAL_RCC_OscConfig+0x48e>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8010650:	f7fc fe7e 	bl	800d350 <HAL_GetTick>
 8010654:	4602      	mov	r2, r0
 8010656:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010658:	1ad3      	subs	r3, r2, r3
 801065a:	f241 3288 	movw	r2, #5000	; 0x1388
 801065e:	4293      	cmp	r3, r2
 8010660:	d901      	bls.n	8010666 <HAL_RCC_OscConfig+0x48e>
        {
          return HAL_TIMEOUT;
 8010662:	2303      	movs	r3, #3
 8010664:	e140      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
      while (LL_RCC_LSE_IsReady() == 0U)
 8010666:	f7ff fb58 	bl	800fd1a <LL_RCC_LSE_IsReady>
 801066a:	4603      	mov	r3, r0
 801066c:	2b00      	cmp	r3, #0
 801066e:	d0ef      	beq.n	8010650 <HAL_RCC_OscConfig+0x478>
 8010670:	e013      	b.n	801069a <HAL_RCC_OscConfig+0x4c2>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8010672:	f7fc fe6d 	bl	800d350 <HAL_GetTick>
 8010676:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is disabled */
      while (LL_RCC_LSE_IsReady() != 0U)
 8010678:	e00a      	b.n	8010690 <HAL_RCC_OscConfig+0x4b8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 801067a:	f7fc fe69 	bl	800d350 <HAL_GetTick>
 801067e:	4602      	mov	r2, r0
 8010680:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010682:	1ad3      	subs	r3, r2, r3
 8010684:	f241 3288 	movw	r2, #5000	; 0x1388
 8010688:	4293      	cmp	r3, r2
 801068a:	d901      	bls.n	8010690 <HAL_RCC_OscConfig+0x4b8>
        {
          return HAL_TIMEOUT;
 801068c:	2303      	movs	r3, #3
 801068e:	e12b      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
      while (LL_RCC_LSE_IsReady() != 0U)
 8010690:	f7ff fb43 	bl	800fd1a <LL_RCC_LSE_IsReady>
 8010694:	4603      	mov	r3, r0
 8010696:	2b00      	cmp	r3, #0
 8010698:	d1ef      	bne.n	801067a <HAL_RCC_OscConfig+0x4a2>
    }

  }
#if defined(RCC_HSI48_SUPPORT)
  /*------------------------------ HSI48 Configuration -----------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 801069a:	687b      	ldr	r3, [r7, #4]
 801069c:	681b      	ldr	r3, [r3, #0]
 801069e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80106a2:	2b00      	cmp	r3, #0
 80106a4:	d02c      	beq.n	8010700 <HAL_RCC_OscConfig+0x528>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the LSI State */
    if (RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 80106a6:	687b      	ldr	r3, [r7, #4]
 80106a8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80106aa:	2b00      	cmp	r3, #0
 80106ac:	d014      	beq.n	80106d8 <HAL_RCC_OscConfig+0x500>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 80106ae:	f7ff fabc 	bl	800fc2a <LL_RCC_HSI48_Enable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80106b2:	f7fc fe4d 	bl	800d350 <HAL_GetTick>
 80106b6:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while (LL_RCC_HSI48_IsReady() == 0U)
 80106b8:	e008      	b.n	80106cc <HAL_RCC_OscConfig+0x4f4>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80106ba:	f7fc fe49 	bl	800d350 <HAL_GetTick>
 80106be:	4602      	mov	r2, r0
 80106c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80106c2:	1ad3      	subs	r3, r2, r3
 80106c4:	2b02      	cmp	r3, #2
 80106c6:	d901      	bls.n	80106cc <HAL_RCC_OscConfig+0x4f4>
        {
          return HAL_TIMEOUT;
 80106c8:	2303      	movs	r3, #3
 80106ca:	e10d      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
      while (LL_RCC_HSI48_IsReady() == 0U)
 80106cc:	f7ff facf 	bl	800fc6e <LL_RCC_HSI48_IsReady>
 80106d0:	4603      	mov	r3, r0
 80106d2:	2b00      	cmp	r3, #0
 80106d4:	d0f1      	beq.n	80106ba <HAL_RCC_OscConfig+0x4e2>
 80106d6:	e013      	b.n	8010700 <HAL_RCC_OscConfig+0x528>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 80106d8:	f7ff fab8 	bl	800fc4c <LL_RCC_HSI48_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80106dc:	f7fc fe38 	bl	800d350 <HAL_GetTick>
 80106e0:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is disabled */
      while (LL_RCC_HSI48_IsReady() != 0U)
 80106e2:	e008      	b.n	80106f6 <HAL_RCC_OscConfig+0x51e>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80106e4:	f7fc fe34 	bl	800d350 <HAL_GetTick>
 80106e8:	4602      	mov	r2, r0
 80106ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80106ec:	1ad3      	subs	r3, r2, r3
 80106ee:	2b02      	cmp	r3, #2
 80106f0:	d901      	bls.n	80106f6 <HAL_RCC_OscConfig+0x51e>
        {
          return HAL_TIMEOUT;
 80106f2:	2303      	movs	r3, #3
 80106f4:	e0f8      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
      while (LL_RCC_HSI48_IsReady() != 0U)
 80106f6:	f7ff faba 	bl	800fc6e <LL_RCC_HSI48_IsReady>
 80106fa:	4603      	mov	r3, r0
 80106fc:	2b00      	cmp	r3, #0
 80106fe:	d1f1      	bne.n	80106e4 <HAL_RCC_OscConfig+0x50c>
#endif
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8010700:	687b      	ldr	r3, [r7, #4]
 8010702:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8010704:	2b00      	cmp	r3, #0
 8010706:	f000 80ee 	beq.w	80108e6 <HAL_RCC_OscConfig+0x70e>
  {
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 801070a:	f7ff fc18 	bl	800ff3e <LL_RCC_GetSysClkSource>
 801070e:	6138      	str	r0, [r7, #16]
    const uint32_t temp_pllconfig = RCC->PLLCFGR;
 8010710:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010714:	68db      	ldr	r3, [r3, #12]
 8010716:	60fb      	str	r3, [r7, #12]
    
    /* PLL On ? */
    if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8010718:	687b      	ldr	r3, [r7, #4]
 801071a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801071c:	2b02      	cmp	r3, #2
 801071e:	f040 80af 	bne.w	8010880 <HAL_RCC_OscConfig+0x6a8>
      assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
      assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
      
      /* Do nothing if PLL configuration is unchanged */
      if ((READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8010722:	68fb      	ldr	r3, [r7, #12]
 8010724:	f003 0203 	and.w	r2, r3, #3
 8010728:	687b      	ldr	r3, [r7, #4]
 801072a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801072c:	429a      	cmp	r2, r3
 801072e:	d123      	bne.n	8010778 <HAL_RCC_OscConfig+0x5a0>
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 8010730:	68fb      	ldr	r3, [r7, #12]
 8010732:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8010736:	687b      	ldr	r3, [r7, #4]
 8010738:	6b5b      	ldr	r3, [r3, #52]	; 0x34
      if ((READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 801073a:	429a      	cmp	r2, r3
 801073c:	d11c      	bne.n	8010778 <HAL_RCC_OscConfig+0x5a0>
          ((READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos) != RCC_OscInitStruct->PLL.PLLN) ||
 801073e:	68fb      	ldr	r3, [r7, #12]
 8010740:	0a1b      	lsrs	r3, r3, #8
 8010742:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8010746:	687b      	ldr	r3, [r7, #4]
 8010748:	6b9b      	ldr	r3, [r3, #56]	; 0x38
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 801074a:	429a      	cmp	r2, r3
 801074c:	d114      	bne.n	8010778 <HAL_RCC_OscConfig+0x5a0>
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 801074e:	68fb      	ldr	r3, [r7, #12]
 8010750:	f403 1278 	and.w	r2, r3, #4063232	; 0x3e0000
 8010754:	687b      	ldr	r3, [r7, #4]
 8010756:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
          ((READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos) != RCC_OscInitStruct->PLL.PLLN) ||
 8010758:	429a      	cmp	r2, r3
 801075a:	d10d      	bne.n	8010778 <HAL_RCC_OscConfig+0x5a0>
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ) ||
 801075c:	68fb      	ldr	r3, [r7, #12]
 801075e:	f003 6260 	and.w	r2, r3, #234881024	; 0xe000000
 8010762:	687b      	ldr	r3, [r7, #4]
 8010764:	6c1b      	ldr	r3, [r3, #64]	; 0x40
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 8010766:	429a      	cmp	r2, r3
 8010768:	d106      	bne.n	8010778 <HAL_RCC_OscConfig+0x5a0>
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLR) != RCC_OscInitStruct->PLL.PLLR))
 801076a:	68fb      	ldr	r3, [r7, #12]
 801076c:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
 8010770:	687b      	ldr	r3, [r7, #4]
 8010772:	6c5b      	ldr	r3, [r3, #68]	; 0x44
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ) ||
 8010774:	429a      	cmp	r2, r3
 8010776:	d05d      	beq.n	8010834 <HAL_RCC_OscConfig+0x65c>
      {
        /* Check if the PLL is used as system clock or not */
        if (temp_sysclksrc != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8010778:	693b      	ldr	r3, [r7, #16]
 801077a:	2b0c      	cmp	r3, #12
 801077c:	d058      	beq.n	8010830 <HAL_RCC_OscConfig+0x658>
        {
#if defined(SAI1)
          /* Check if main PLL can be updated */
          /* Not possible if the source is shared by other enabled PLLSAIx */
          if (READ_BIT(RCC->CR, RCC_CR_PLLSAI1ON) != 0U)
 801077e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010782:	681b      	ldr	r3, [r3, #0]
 8010784:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8010788:	2b00      	cmp	r3, #0
 801078a:	d001      	beq.n	8010790 <HAL_RCC_OscConfig+0x5b8>

          {
            return HAL_ERROR;
 801078c:	2301      	movs	r3, #1
 801078e:	e0ab      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
          }
          else
#endif
          {
            /* Disable the main PLL. */
            __HAL_RCC_PLL_DISABLE();
 8010790:	f7ff fc73 	bl	801007a <LL_RCC_PLL_Disable>
            
            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 8010794:	f7fc fddc 	bl	800d350 <HAL_GetTick>
 8010798:	6278      	str	r0, [r7, #36]	; 0x24
            
            /* Wait till PLL is ready */
            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 801079a:	e008      	b.n	80107ae <HAL_RCC_OscConfig+0x5d6>
            {
              if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 801079c:	f7fc fdd8 	bl	800d350 <HAL_GetTick>
 80107a0:	4602      	mov	r2, r0
 80107a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80107a4:	1ad3      	subs	r3, r2, r3
 80107a6:	2b02      	cmp	r3, #2
 80107a8:	d901      	bls.n	80107ae <HAL_RCC_OscConfig+0x5d6>
              {
                return HAL_TIMEOUT;
 80107aa:	2303      	movs	r3, #3
 80107ac:	e09c      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80107ae:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80107b2:	681b      	ldr	r3, [r3, #0]
 80107b4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80107b8:	2b00      	cmp	r3, #0
 80107ba:	d1ef      	bne.n	801079c <HAL_RCC_OscConfig+0x5c4>
              }
            }
            
            /* Configure the main PLL clock source, multiplication and division factors. */
            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80107bc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80107c0:	68da      	ldr	r2, [r3, #12]
 80107c2:	4b3e      	ldr	r3, [pc, #248]	; (80108bc <HAL_RCC_OscConfig+0x6e4>)
 80107c4:	4013      	ands	r3, r2
 80107c6:	687a      	ldr	r2, [r7, #4]
 80107c8:	6b11      	ldr	r1, [r2, #48]	; 0x30
 80107ca:	687a      	ldr	r2, [r7, #4]
 80107cc:	6b52      	ldr	r2, [r2, #52]	; 0x34
 80107ce:	4311      	orrs	r1, r2
 80107d0:	687a      	ldr	r2, [r7, #4]
 80107d2:	6b92      	ldr	r2, [r2, #56]	; 0x38
 80107d4:	0212      	lsls	r2, r2, #8
 80107d6:	4311      	orrs	r1, r2
 80107d8:	687a      	ldr	r2, [r7, #4]
 80107da:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 80107dc:	4311      	orrs	r1, r2
 80107de:	687a      	ldr	r2, [r7, #4]
 80107e0:	6c12      	ldr	r2, [r2, #64]	; 0x40
 80107e2:	4311      	orrs	r1, r2
 80107e4:	687a      	ldr	r2, [r7, #4]
 80107e6:	6c52      	ldr	r2, [r2, #68]	; 0x44
 80107e8:	430a      	orrs	r2, r1
 80107ea:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80107ee:	4313      	orrs	r3, r2
 80107f0:	60cb      	str	r3, [r1, #12]
                                 RCC_OscInitStruct->PLL.PLLP,
                                 RCC_OscInitStruct->PLL.PLLQ,
                                 RCC_OscInitStruct->PLL.PLLR);
            
            /* Enable the main PLL. */
            __HAL_RCC_PLL_ENABLE();
 80107f2:	f7ff fc33 	bl	801005c <LL_RCC_PLL_Enable>
            
            /* Enable PLL System Clock output. */
            __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 80107f6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80107fa:	68db      	ldr	r3, [r3, #12]
 80107fc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8010800:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8010804:	60d3      	str	r3, [r2, #12]
            
            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 8010806:	f7fc fda3 	bl	800d350 <HAL_GetTick>
 801080a:	6278      	str	r0, [r7, #36]	; 0x24
            
            /* Wait till PLL is ready */
            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 801080c:	e008      	b.n	8010820 <HAL_RCC_OscConfig+0x648>
            {
              if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 801080e:	f7fc fd9f 	bl	800d350 <HAL_GetTick>
 8010812:	4602      	mov	r2, r0
 8010814:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010816:	1ad3      	subs	r3, r2, r3
 8010818:	2b02      	cmp	r3, #2
 801081a:	d901      	bls.n	8010820 <HAL_RCC_OscConfig+0x648>
              {
                return HAL_TIMEOUT;
 801081c:	2303      	movs	r3, #3
 801081e:	e063      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8010820:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010824:	681b      	ldr	r3, [r3, #0]
 8010826:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 801082a:	2b00      	cmp	r3, #0
 801082c:	d0ef      	beq.n	801080e <HAL_RCC_OscConfig+0x636>
        if (temp_sysclksrc != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 801082e:	e05a      	b.n	80108e6 <HAL_RCC_OscConfig+0x70e>
          }
        }
        else
        {
          /* PLL is already used as System core clock */
          return HAL_ERROR;
 8010830:	2301      	movs	r3, #1
 8010832:	e059      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
      }
      else
      {
        /* PLL configuration is unchanged */
        /* Re-enable PLL if it was disabled (ie. low power mode) */
        if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8010834:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010838:	681b      	ldr	r3, [r3, #0]
 801083a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 801083e:	2b00      	cmp	r3, #0
 8010840:	d151      	bne.n	80108e6 <HAL_RCC_OscConfig+0x70e>
        {
          /* Enable the main PLL. */
          __HAL_RCC_PLL_ENABLE();
 8010842:	f7ff fc0b 	bl	801005c <LL_RCC_PLL_Enable>

          /* Enable PLL System Clock output. */
          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8010846:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801084a:	68db      	ldr	r3, [r3, #12]
 801084c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8010850:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8010854:	60d3      	str	r3, [r2, #12]

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 8010856:	f7fc fd7b 	bl	800d350 <HAL_GetTick>
 801085a:	6278      	str	r0, [r7, #36]	; 0x24

          /* Wait till PLL is ready */
          while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 801085c:	e008      	b.n	8010870 <HAL_RCC_OscConfig+0x698>
          {
            if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 801085e:	f7fc fd77 	bl	800d350 <HAL_GetTick>
 8010862:	4602      	mov	r2, r0
 8010864:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010866:	1ad3      	subs	r3, r2, r3
 8010868:	2b02      	cmp	r3, #2
 801086a:	d901      	bls.n	8010870 <HAL_RCC_OscConfig+0x698>
            {
              return HAL_TIMEOUT;
 801086c:	2303      	movs	r3, #3
 801086e:	e03b      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
          while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8010870:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010874:	681b      	ldr	r3, [r3, #0]
 8010876:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 801087a:	2b00      	cmp	r3, #0
 801087c:	d0ef      	beq.n	801085e <HAL_RCC_OscConfig+0x686>
 801087e:	e032      	b.n	80108e6 <HAL_RCC_OscConfig+0x70e>
      }
    }
    else
    {
      /* Check that PLL is not used as system clock or not */
      if (temp_sysclksrc != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8010880:	693b      	ldr	r3, [r7, #16]
 8010882:	2b0c      	cmp	r3, #12
 8010884:	d02d      	beq.n	80108e2 <HAL_RCC_OscConfig+0x70a>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8010886:	f7ff fbf8 	bl	801007a <LL_RCC_PLL_Disable>
        

        /* Disable all PLL outputs to save power */
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
 801088a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801088e:	68db      	ldr	r3, [r3, #12]
 8010890:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8010894:	f023 0303 	bic.w	r3, r3, #3
 8010898:	60d3      	str	r3, [r2, #12]

#if defined(SAI1) && defined(USB)
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_USBCLK | RCC_PLL_SAI1CLK);
 801089a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801089e:	68db      	ldr	r3, [r3, #12]
 80108a0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80108a4:	f023 5388 	bic.w	r3, r3, #285212672	; 0x11000000
 80108a8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80108ac:	60d3      	str	r3, [r2, #12]
#else
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK);
#endif

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80108ae:	f7fc fd4f 	bl	800d350 <HAL_GetTick>
 80108b2:	6278      	str	r0, [r7, #36]	; 0x24
        
        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80108b4:	e00d      	b.n	80108d2 <HAL_RCC_OscConfig+0x6fa>
 80108b6:	bf00      	nop
 80108b8:	58000400 	.word	0x58000400
 80108bc:	11c1808c 	.word	0x11c1808c
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80108c0:	f7fc fd46 	bl	800d350 <HAL_GetTick>
 80108c4:	4602      	mov	r2, r0
 80108c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80108c8:	1ad3      	subs	r3, r2, r3
 80108ca:	2b02      	cmp	r3, #2
 80108cc:	d901      	bls.n	80108d2 <HAL_RCC_OscConfig+0x6fa>
          {
            return HAL_TIMEOUT;
 80108ce:	2303      	movs	r3, #3
 80108d0:	e00a      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80108d2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80108d6:	681b      	ldr	r3, [r3, #0]
 80108d8:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80108dc:	2b00      	cmp	r3, #0
 80108de:	d1ef      	bne.n	80108c0 <HAL_RCC_OscConfig+0x6e8>
 80108e0:	e001      	b.n	80108e6 <HAL_RCC_OscConfig+0x70e>
        }
      }
      else
      {
        /* PLL is already used as System core clock */
        return HAL_ERROR;
 80108e2:	2301      	movs	r3, #1
 80108e4:	e000      	b.n	80108e8 <HAL_RCC_OscConfig+0x710>
      }
    }
  }
  return HAL_OK;
 80108e6:	2300      	movs	r3, #0
}
 80108e8:	4618      	mov	r0, r3
 80108ea:	3734      	adds	r7, #52	; 0x34
 80108ec:	46bd      	mov	sp, r7
 80108ee:	bd90      	pop	{r4, r7, pc}

080108f0 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK1 not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80108f0:	b580      	push	{r7, lr}
 80108f2:	b084      	sub	sp, #16
 80108f4:	af00      	add	r7, sp, #0
 80108f6:	6078      	str	r0, [r7, #4]
 80108f8:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 80108fa:	687b      	ldr	r3, [r7, #4]
 80108fc:	2b00      	cmp	r3, #0
 80108fe:	d101      	bne.n	8010904 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8010900:	2301      	movs	r3, #1
 8010902:	e12d      	b.n	8010b60 <HAL_RCC_ClockConfig+0x270>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the FLASH clock
    (HCLK4) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8010904:	4b98      	ldr	r3, [pc, #608]	; (8010b68 <HAL_RCC_ClockConfig+0x278>)
 8010906:	681b      	ldr	r3, [r3, #0]
 8010908:	f003 0307 	and.w	r3, r3, #7
 801090c:	683a      	ldr	r2, [r7, #0]
 801090e:	429a      	cmp	r2, r3
 8010910:	d91b      	bls.n	801094a <HAL_RCC_ClockConfig+0x5a>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8010912:	4b95      	ldr	r3, [pc, #596]	; (8010b68 <HAL_RCC_ClockConfig+0x278>)
 8010914:	681b      	ldr	r3, [r3, #0]
 8010916:	f023 0207 	bic.w	r2, r3, #7
 801091a:	4993      	ldr	r1, [pc, #588]	; (8010b68 <HAL_RCC_ClockConfig+0x278>)
 801091c:	683b      	ldr	r3, [r7, #0]
 801091e:	4313      	orrs	r3, r2
 8010920:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8010922:	f7fc fd15 	bl	800d350 <HAL_GetTick>
 8010926:	60f8      	str	r0, [r7, #12]

    /* Check that the new number of wait states is taken into account to access the Flash
       memory by reading the FLASH_ACR register */
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8010928:	e008      	b.n	801093c <HAL_RCC_ClockConfig+0x4c>
    {
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 801092a:	f7fc fd11 	bl	800d350 <HAL_GetTick>
 801092e:	4602      	mov	r2, r0
 8010930:	68fb      	ldr	r3, [r7, #12]
 8010932:	1ad3      	subs	r3, r2, r3
 8010934:	2b02      	cmp	r3, #2
 8010936:	d901      	bls.n	801093c <HAL_RCC_ClockConfig+0x4c>
      {
        return HAL_TIMEOUT;
 8010938:	2303      	movs	r3, #3
 801093a:	e111      	b.n	8010b60 <HAL_RCC_ClockConfig+0x270>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 801093c:	4b8a      	ldr	r3, [pc, #552]	; (8010b68 <HAL_RCC_ClockConfig+0x278>)
 801093e:	681b      	ldr	r3, [r3, #0]
 8010940:	f003 0307 	and.w	r3, r3, #7
 8010944:	683a      	ldr	r2, [r7, #0]
 8010946:	429a      	cmp	r2, r3
 8010948:	d1ef      	bne.n	801092a <HAL_RCC_ClockConfig+0x3a>
      }
    }
  }

  /*-------------------------- HCLK1 Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 801094a:	687b      	ldr	r3, [r7, #4]
 801094c:	681b      	ldr	r3, [r3, #0]
 801094e:	f003 0302 	and.w	r3, r3, #2
 8010952:	2b00      	cmp	r3, #0
 8010954:	d016      	beq.n	8010984 <HAL_RCC_ClockConfig+0x94>
  {
    assert_param(IS_RCC_HCLKx(RCC_ClkInitStruct->AHBCLKDivider));
    LL_RCC_SetAHBPrescaler(RCC_ClkInitStruct->AHBCLKDivider);
 8010956:	687b      	ldr	r3, [r7, #4]
 8010958:	689b      	ldr	r3, [r3, #8]
 801095a:	4618      	mov	r0, r3
 801095c:	f7ff fafb 	bl	800ff56 <LL_RCC_SetAHBPrescaler>

    /* HCLK1 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 8010960:	f7fc fcf6 	bl	800d350 <HAL_GetTick>
 8010964:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_HPRE() == 0U)
 8010966:	e008      	b.n	801097a <HAL_RCC_ClockConfig+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8010968:	f7fc fcf2 	bl	800d350 <HAL_GetTick>
 801096c:	4602      	mov	r2, r0
 801096e:	68fb      	ldr	r3, [r7, #12]
 8010970:	1ad3      	subs	r3, r2, r3
 8010972:	2b02      	cmp	r3, #2
 8010974:	d901      	bls.n	801097a <HAL_RCC_ClockConfig+0x8a>
      {
        return HAL_TIMEOUT;
 8010976:	2303      	movs	r3, #3
 8010978:	e0f2      	b.n	8010b60 <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_HPRE() == 0U)
 801097a:	f7ff fbd0 	bl	801011e <LL_RCC_IsActiveFlag_HPRE>
 801097e:	4603      	mov	r3, r0
 8010980:	2b00      	cmp	r3, #0
 8010982:	d0f1      	beq.n	8010968 <HAL_RCC_ClockConfig+0x78>
      }
    }
  }

  /*-------------------------- HCLK2 Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK2) == RCC_CLOCKTYPE_HCLK2)
 8010984:	687b      	ldr	r3, [r7, #4]
 8010986:	681b      	ldr	r3, [r3, #0]
 8010988:	f003 0320 	and.w	r3, r3, #32
 801098c:	2b00      	cmp	r3, #0
 801098e:	d016      	beq.n	80109be <HAL_RCC_ClockConfig+0xce>
  {
    assert_param(IS_RCC_HCLKx(RCC_ClkInitStruct->AHBCLK2Divider));
    LL_C2_RCC_SetAHBPrescaler(RCC_ClkInitStruct->AHBCLK2Divider);
 8010990:	687b      	ldr	r3, [r7, #4]
 8010992:	695b      	ldr	r3, [r3, #20]
 8010994:	4618      	mov	r0, r3
 8010996:	f7ff faf2 	bl	800ff7e <LL_C2_RCC_SetAHBPrescaler>

    /* HCLK2 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 801099a:	f7fc fcd9 	bl	800d350 <HAL_GetTick>
 801099e:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_C2HPRE() == 0U)
 80109a0:	e008      	b.n	80109b4 <HAL_RCC_ClockConfig+0xc4>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 80109a2:	f7fc fcd5 	bl	800d350 <HAL_GetTick>
 80109a6:	4602      	mov	r2, r0
 80109a8:	68fb      	ldr	r3, [r7, #12]
 80109aa:	1ad3      	subs	r3, r2, r3
 80109ac:	2b02      	cmp	r3, #2
 80109ae:	d901      	bls.n	80109b4 <HAL_RCC_ClockConfig+0xc4>
      {
        return HAL_TIMEOUT;
 80109b0:	2303      	movs	r3, #3
 80109b2:	e0d5      	b.n	8010b60 <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_C2HPRE() == 0U)
 80109b4:	f7ff fbc5 	bl	8010142 <LL_RCC_IsActiveFlag_C2HPRE>
 80109b8:	4603      	mov	r3, r0
 80109ba:	2b00      	cmp	r3, #0
 80109bc:	d0f1      	beq.n	80109a2 <HAL_RCC_ClockConfig+0xb2>
      }
    }
  }
  /*-------------------------- HCLK4 Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK4) == RCC_CLOCKTYPE_HCLK4)
 80109be:	687b      	ldr	r3, [r7, #4]
 80109c0:	681b      	ldr	r3, [r3, #0]
 80109c2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80109c6:	2b00      	cmp	r3, #0
 80109c8:	d016      	beq.n	80109f8 <HAL_RCC_ClockConfig+0x108>
  {
    assert_param(IS_RCC_HCLKx(RCC_ClkInitStruct->AHBCLK4Divider));
    LL_RCC_SetAHB4Prescaler(RCC_ClkInitStruct->AHBCLK4Divider);
 80109ca:	687b      	ldr	r3, [r7, #4]
 80109cc:	699b      	ldr	r3, [r3, #24]
 80109ce:	4618      	mov	r0, r3
 80109d0:	f7ff faeb 	bl	800ffaa <LL_RCC_SetAHB4Prescaler>

    /* AHB shared prescaler flag when value applied */
    tickstart = HAL_GetTick();
 80109d4:	f7fc fcbc 	bl	800d350 <HAL_GetTick>
 80109d8:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_SHDHPRE() == 0U)
 80109da:	e008      	b.n	80109ee <HAL_RCC_ClockConfig+0xfe>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 80109dc:	f7fc fcb8 	bl	800d350 <HAL_GetTick>
 80109e0:	4602      	mov	r2, r0
 80109e2:	68fb      	ldr	r3, [r7, #12]
 80109e4:	1ad3      	subs	r3, r2, r3
 80109e6:	2b02      	cmp	r3, #2
 80109e8:	d901      	bls.n	80109ee <HAL_RCC_ClockConfig+0xfe>
      {
        return HAL_TIMEOUT;
 80109ea:	2303      	movs	r3, #3
 80109ec:	e0b8      	b.n	8010b60 <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_SHDHPRE() == 0U)
 80109ee:	f7ff fbbb 	bl	8010168 <LL_RCC_IsActiveFlag_SHDHPRE>
 80109f2:	4603      	mov	r3, r0
 80109f4:	2b00      	cmp	r3, #0
 80109f6:	d0f1      	beq.n	80109dc <HAL_RCC_ClockConfig+0xec>
      }
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80109f8:	687b      	ldr	r3, [r7, #4]
 80109fa:	681b      	ldr	r3, [r3, #0]
 80109fc:	f003 0304 	and.w	r3, r3, #4
 8010a00:	2b00      	cmp	r3, #0
 8010a02:	d016      	beq.n	8010a32 <HAL_RCC_ClockConfig+0x142>
  {
    assert_param(IS_RCC_PCLKx(RCC_ClkInitStruct->APB1CLKDivider));
    LL_RCC_SetAPB1Prescaler(RCC_ClkInitStruct->APB1CLKDivider);
 8010a04:	687b      	ldr	r3, [r7, #4]
 8010a06:	68db      	ldr	r3, [r3, #12]
 8010a08:	4618      	mov	r0, r3
 8010a0a:	f7ff fae5 	bl	800ffd8 <LL_RCC_SetAPB1Prescaler>

    /* APB1 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 8010a0e:	f7fc fc9f 	bl	800d350 <HAL_GetTick>
 8010a12:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_PPRE1() == 0U)
 8010a14:	e008      	b.n	8010a28 <HAL_RCC_ClockConfig+0x138>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8010a16:	f7fc fc9b 	bl	800d350 <HAL_GetTick>
 8010a1a:	4602      	mov	r2, r0
 8010a1c:	68fb      	ldr	r3, [r7, #12]
 8010a1e:	1ad3      	subs	r3, r2, r3
 8010a20:	2b02      	cmp	r3, #2
 8010a22:	d901      	bls.n	8010a28 <HAL_RCC_ClockConfig+0x138>
      {
        return HAL_TIMEOUT;
 8010a24:	2303      	movs	r3, #3
 8010a26:	e09b      	b.n	8010b60 <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_PPRE1() == 0U)
 8010a28:	f7ff fbb1 	bl	801018e <LL_RCC_IsActiveFlag_PPRE1>
 8010a2c:	4603      	mov	r3, r0
 8010a2e:	2b00      	cmp	r3, #0
 8010a30:	d0f1      	beq.n	8010a16 <HAL_RCC_ClockConfig+0x126>
      }
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8010a32:	687b      	ldr	r3, [r7, #4]
 8010a34:	681b      	ldr	r3, [r3, #0]
 8010a36:	f003 0308 	and.w	r3, r3, #8
 8010a3a:	2b00      	cmp	r3, #0
 8010a3c:	d017      	beq.n	8010a6e <HAL_RCC_ClockConfig+0x17e>
  {
    assert_param(IS_RCC_PCLKx(RCC_ClkInitStruct->APB2CLKDivider));
    LL_RCC_SetAPB2Prescaler((RCC_ClkInitStruct->APB2CLKDivider) << 3U);
 8010a3e:	687b      	ldr	r3, [r7, #4]
 8010a40:	691b      	ldr	r3, [r3, #16]
 8010a42:	00db      	lsls	r3, r3, #3
 8010a44:	4618      	mov	r0, r3
 8010a46:	f7ff fadb 	bl	8010000 <LL_RCC_SetAPB2Prescaler>

    /* APB2 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 8010a4a:	f7fc fc81 	bl	800d350 <HAL_GetTick>
 8010a4e:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_PPRE2() == 0U)
 8010a50:	e008      	b.n	8010a64 <HAL_RCC_ClockConfig+0x174>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8010a52:	f7fc fc7d 	bl	800d350 <HAL_GetTick>
 8010a56:	4602      	mov	r2, r0
 8010a58:	68fb      	ldr	r3, [r7, #12]
 8010a5a:	1ad3      	subs	r3, r2, r3
 8010a5c:	2b02      	cmp	r3, #2
 8010a5e:	d901      	bls.n	8010a64 <HAL_RCC_ClockConfig+0x174>
      {
        return HAL_TIMEOUT;
 8010a60:	2303      	movs	r3, #3
 8010a62:	e07d      	b.n	8010b60 <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_PPRE2() == 0U)
 8010a64:	f7ff fba5 	bl	80101b2 <LL_RCC_IsActiveFlag_PPRE2>
 8010a68:	4603      	mov	r3, r0
 8010a6a:	2b00      	cmp	r3, #0
 8010a6c:	d0f1      	beq.n	8010a52 <HAL_RCC_ClockConfig+0x162>
      }
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8010a6e:	687b      	ldr	r3, [r7, #4]
 8010a70:	681b      	ldr	r3, [r3, #0]
 8010a72:	f003 0301 	and.w	r3, r3, #1
 8010a76:	2b00      	cmp	r3, #0
 8010a78:	d043      	beq.n	8010b02 <HAL_RCC_ClockConfig+0x212>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8010a7a:	687b      	ldr	r3, [r7, #4]
 8010a7c:	685b      	ldr	r3, [r3, #4]
 8010a7e:	2b02      	cmp	r3, #2
 8010a80:	d106      	bne.n	8010a90 <HAL_RCC_ClockConfig+0x1a0>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
 8010a82:	f7ff f87b 	bl	800fb7c <LL_RCC_HSE_IsReady>
 8010a86:	4603      	mov	r3, r0
 8010a88:	2b00      	cmp	r3, #0
 8010a8a:	d11e      	bne.n	8010aca <HAL_RCC_ClockConfig+0x1da>
      {
        return HAL_ERROR;
 8010a8c:	2301      	movs	r3, #1
 8010a8e:	e067      	b.n	8010b60 <HAL_RCC_ClockConfig+0x270>
      }
    }
    /* PLL is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8010a90:	687b      	ldr	r3, [r7, #4]
 8010a92:	685b      	ldr	r3, [r3, #4]
 8010a94:	2b03      	cmp	r3, #3
 8010a96:	d106      	bne.n	8010aa6 <HAL_RCC_ClockConfig+0x1b6>
    {
      /* Check the PLL ready flag */
      if (LL_RCC_PLL_IsReady() == 0U)
 8010a98:	f7ff fafe 	bl	8010098 <LL_RCC_PLL_IsReady>
 8010a9c:	4603      	mov	r3, r0
 8010a9e:	2b00      	cmp	r3, #0
 8010aa0:	d113      	bne.n	8010aca <HAL_RCC_ClockConfig+0x1da>
      {
        return HAL_ERROR;
 8010aa2:	2301      	movs	r3, #1
 8010aa4:	e05c      	b.n	8010b60 <HAL_RCC_ClockConfig+0x270>
      }
    }
    /* MSI is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8010aa6:	687b      	ldr	r3, [r7, #4]
 8010aa8:	685b      	ldr	r3, [r3, #4]
 8010aaa:	2b00      	cmp	r3, #0
 8010aac:	d106      	bne.n	8010abc <HAL_RCC_ClockConfig+0x1cc>
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
 8010aae:	f7ff f9e3 	bl	800fe78 <LL_RCC_MSI_IsReady>
 8010ab2:	4603      	mov	r3, r0
 8010ab4:	2b00      	cmp	r3, #0
 8010ab6:	d108      	bne.n	8010aca <HAL_RCC_ClockConfig+0x1da>
      {
        return HAL_ERROR;
 8010ab8:	2301      	movs	r3, #1
 8010aba:	e051      	b.n	8010b60 <HAL_RCC_ClockConfig+0x270>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
 8010abc:	f7ff f88e 	bl	800fbdc <LL_RCC_HSI_IsReady>
 8010ac0:	4603      	mov	r3, r0
 8010ac2:	2b00      	cmp	r3, #0
 8010ac4:	d101      	bne.n	8010aca <HAL_RCC_ClockConfig+0x1da>
      {
        return HAL_ERROR;
 8010ac6:	2301      	movs	r3, #1
 8010ac8:	e04a      	b.n	8010b60 <HAL_RCC_ClockConfig+0x270>
      }

    }

    /* apply system clock switch */
    LL_RCC_SetSysClkSource(RCC_ClkInitStruct->SYSCLKSource);
 8010aca:	687b      	ldr	r3, [r7, #4]
 8010acc:	685b      	ldr	r3, [r3, #4]
 8010ace:	4618      	mov	r0, r3
 8010ad0:	f7ff fa21 	bl	800ff16 <LL_RCC_SetSysClkSource>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8010ad4:	f7fc fc3c 	bl	800d350 <HAL_GetTick>
 8010ad8:	60f8      	str	r0, [r7, #12]

    /* check system clock source switch status */
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8010ada:	e00a      	b.n	8010af2 <HAL_RCC_ClockConfig+0x202>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8010adc:	f7fc fc38 	bl	800d350 <HAL_GetTick>
 8010ae0:	4602      	mov	r2, r0
 8010ae2:	68fb      	ldr	r3, [r7, #12]
 8010ae4:	1ad3      	subs	r3, r2, r3
 8010ae6:	f241 3288 	movw	r2, #5000	; 0x1388
 8010aea:	4293      	cmp	r3, r2
 8010aec:	d901      	bls.n	8010af2 <HAL_RCC_ClockConfig+0x202>
      {
        return HAL_TIMEOUT;
 8010aee:	2303      	movs	r3, #3
 8010af0:	e036      	b.n	8010b60 <HAL_RCC_ClockConfig+0x270>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8010af2:	f7ff fa24 	bl	800ff3e <LL_RCC_GetSysClkSource>
 8010af6:	4602      	mov	r2, r0
 8010af8:	687b      	ldr	r3, [r7, #4]
 8010afa:	685b      	ldr	r3, [r3, #4]
 8010afc:	009b      	lsls	r3, r3, #2
 8010afe:	429a      	cmp	r2, r3
 8010b00:	d1ec      	bne.n	8010adc <HAL_RCC_ClockConfig+0x1ec>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8010b02:	4b19      	ldr	r3, [pc, #100]	; (8010b68 <HAL_RCC_ClockConfig+0x278>)
 8010b04:	681b      	ldr	r3, [r3, #0]
 8010b06:	f003 0307 	and.w	r3, r3, #7
 8010b0a:	683a      	ldr	r2, [r7, #0]
 8010b0c:	429a      	cmp	r2, r3
 8010b0e:	d21b      	bcs.n	8010b48 <HAL_RCC_ClockConfig+0x258>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8010b10:	4b15      	ldr	r3, [pc, #84]	; (8010b68 <HAL_RCC_ClockConfig+0x278>)
 8010b12:	681b      	ldr	r3, [r3, #0]
 8010b14:	f023 0207 	bic.w	r2, r3, #7
 8010b18:	4913      	ldr	r1, [pc, #76]	; (8010b68 <HAL_RCC_ClockConfig+0x278>)
 8010b1a:	683b      	ldr	r3, [r7, #0]
 8010b1c:	4313      	orrs	r3, r2
 8010b1e:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8010b20:	f7fc fc16 	bl	800d350 <HAL_GetTick>
 8010b24:	60f8      	str	r0, [r7, #12]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8010b26:	e008      	b.n	8010b3a <HAL_RCC_ClockConfig+0x24a>
    {
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8010b28:	f7fc fc12 	bl	800d350 <HAL_GetTick>
 8010b2c:	4602      	mov	r2, r0
 8010b2e:	68fb      	ldr	r3, [r7, #12]
 8010b30:	1ad3      	subs	r3, r2, r3
 8010b32:	2b02      	cmp	r3, #2
 8010b34:	d901      	bls.n	8010b3a <HAL_RCC_ClockConfig+0x24a>
      {
        return HAL_TIMEOUT;
 8010b36:	2303      	movs	r3, #3
 8010b38:	e012      	b.n	8010b60 <HAL_RCC_ClockConfig+0x270>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8010b3a:	4b0b      	ldr	r3, [pc, #44]	; (8010b68 <HAL_RCC_ClockConfig+0x278>)
 8010b3c:	681b      	ldr	r3, [r3, #0]
 8010b3e:	f003 0307 	and.w	r3, r3, #7
 8010b42:	683a      	ldr	r2, [r7, #0]
 8010b44:	429a      	cmp	r2, r3
 8010b46:	d1ef      	bne.n	8010b28 <HAL_RCC_ClockConfig+0x238>
  }

  /*---------------------------------------------------------------------------*/

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 8010b48:	f000 f87e 	bl	8010c48 <HAL_RCC_GetHCLKFreq>
 8010b4c:	4603      	mov	r3, r0
 8010b4e:	4a07      	ldr	r2, [pc, #28]	; (8010b6c <HAL_RCC_ClockConfig+0x27c>)
 8010b50:	6013      	str	r3, [r2, #0]
  
  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(HAL_GetTickPrio());
 8010b52:	f7fc fc09 	bl	800d368 <HAL_GetTickPrio>
 8010b56:	4603      	mov	r3, r0
 8010b58:	4618      	mov	r0, r3
 8010b5a:	f7fc fbab 	bl	800d2b4 <HAL_InitTick>
 8010b5e:	4603      	mov	r3, r0
}
 8010b60:	4618      	mov	r0, r3
 8010b62:	3710      	adds	r7, #16
 8010b64:	46bd      	mov	sp, r7
 8010b66:	bd80      	pop	{r7, pc}
 8010b68:	58004000 	.word	0x58004000
 8010b6c:	20000004 	.word	0x20000004

08010b70 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8010b70:	b590      	push	{r4, r7, lr}
 8010b72:	b085      	sub	sp, #20
 8010b74:	af00      	add	r7, sp, #0
  uint32_t pllsource;
  uint32_t sysclockfreq, pllinputfreq;
  const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8010b76:	f7ff f9e2 	bl	800ff3e <LL_RCC_GetSysClkSource>
 8010b7a:	6078      	str	r0, [r7, #4]

  if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI)
 8010b7c:	687b      	ldr	r3, [r7, #4]
 8010b7e:	2b00      	cmp	r3, #0
 8010b80:	d10a      	bne.n	8010b98 <HAL_RCC_GetSysClockFreq+0x28>
  {
    /* Retrieve MSI frequency range in HZ*/
    /* MSI used as system clock source */
    sysclockfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 8010b82:	f7ff f99e 	bl	800fec2 <LL_RCC_MSI_GetRange>
 8010b86:	4603      	mov	r3, r0
 8010b88:	091b      	lsrs	r3, r3, #4
 8010b8a:	f003 030f 	and.w	r3, r3, #15
 8010b8e:	4a2b      	ldr	r2, [pc, #172]	; (8010c3c <HAL_RCC_GetSysClockFreq+0xcc>)
 8010b90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010b94:	60fb      	str	r3, [r7, #12]
 8010b96:	e04b      	b.n	8010c30 <HAL_RCC_GetSysClockFreq+0xc0>
  }
  else if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI)
 8010b98:	687b      	ldr	r3, [r7, #4]
 8010b9a:	2b04      	cmp	r3, #4
 8010b9c:	d102      	bne.n	8010ba4 <HAL_RCC_GetSysClockFreq+0x34>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 8010b9e:	4b28      	ldr	r3, [pc, #160]	; (8010c40 <HAL_RCC_GetSysClockFreq+0xd0>)
 8010ba0:	60fb      	str	r3, [r7, #12]
 8010ba2:	e045      	b.n	8010c30 <HAL_RCC_GetSysClockFreq+0xc0>
  }
  else if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE)
 8010ba4:	687b      	ldr	r3, [r7, #4]
 8010ba6:	2b08      	cmp	r3, #8
 8010ba8:	d10a      	bne.n	8010bc0 <HAL_RCC_GetSysClockFreq+0x50>
  {
    /* HSE used as system clock source */
    if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 8010baa:	f7fe ffb7 	bl	800fb1c <LL_RCC_HSE_IsEnabledDiv2>
 8010bae:	4603      	mov	r3, r0
 8010bb0:	2b01      	cmp	r3, #1
 8010bb2:	d102      	bne.n	8010bba <HAL_RCC_GetSysClockFreq+0x4a>
    {
      sysclockfreq = HSE_VALUE / 2U;
 8010bb4:	4b22      	ldr	r3, [pc, #136]	; (8010c40 <HAL_RCC_GetSysClockFreq+0xd0>)
 8010bb6:	60fb      	str	r3, [r7, #12]
 8010bb8:	e03a      	b.n	8010c30 <HAL_RCC_GetSysClockFreq+0xc0>
    }
    else
    {
      sysclockfreq = HSE_VALUE;
 8010bba:	4b22      	ldr	r3, [pc, #136]	; (8010c44 <HAL_RCC_GetSysClockFreq+0xd4>)
 8010bbc:	60fb      	str	r3, [r7, #12]
 8010bbe:	e037      	b.n	8010c30 <HAL_RCC_GetSysClockFreq+0xc0>
    }
  }
  else
  {
    /* PLL used as system clock  source */
    pllsource = LL_RCC_PLL_GetMainSource();
 8010bc0:	f7ff faa1 	bl	8010106 <LL_RCC_PLL_GetMainSource>
 8010bc4:	6038      	str	r0, [r7, #0]
    switch (pllsource)
 8010bc6:	683b      	ldr	r3, [r7, #0]
 8010bc8:	2b02      	cmp	r3, #2
 8010bca:	d003      	beq.n	8010bd4 <HAL_RCC_GetSysClockFreq+0x64>
 8010bcc:	683b      	ldr	r3, [r7, #0]
 8010bce:	2b03      	cmp	r3, #3
 8010bd0:	d003      	beq.n	8010bda <HAL_RCC_GetSysClockFreq+0x6a>
 8010bd2:	e00d      	b.n	8010bf0 <HAL_RCC_GetSysClockFreq+0x80>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
        pllinputfreq = HSI_VALUE;
 8010bd4:	4b1a      	ldr	r3, [pc, #104]	; (8010c40 <HAL_RCC_GetSysClockFreq+0xd0>)
 8010bd6:	60bb      	str	r3, [r7, #8]
        break;
 8010bd8:	e015      	b.n	8010c06 <HAL_RCC_GetSysClockFreq+0x96>
      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 8010bda:	f7fe ff9f 	bl	800fb1c <LL_RCC_HSE_IsEnabledDiv2>
 8010bde:	4603      	mov	r3, r0
 8010be0:	2b01      	cmp	r3, #1
 8010be2:	d102      	bne.n	8010bea <HAL_RCC_GetSysClockFreq+0x7a>
        {
          pllinputfreq = HSE_VALUE / 2U;
 8010be4:	4b16      	ldr	r3, [pc, #88]	; (8010c40 <HAL_RCC_GetSysClockFreq+0xd0>)
 8010be6:	60bb      	str	r3, [r7, #8]
        }
        else
        {
          pllinputfreq = HSE_VALUE;
        }
        break;
 8010be8:	e00d      	b.n	8010c06 <HAL_RCC_GetSysClockFreq+0x96>
          pllinputfreq = HSE_VALUE;
 8010bea:	4b16      	ldr	r3, [pc, #88]	; (8010c44 <HAL_RCC_GetSysClockFreq+0xd4>)
 8010bec:	60bb      	str	r3, [r7, #8]
        break;
 8010bee:	e00a      	b.n	8010c06 <HAL_RCC_GetSysClockFreq+0x96>
      case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      default:
        pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 8010bf0:	f7ff f967 	bl	800fec2 <LL_RCC_MSI_GetRange>
 8010bf4:	4603      	mov	r3, r0
 8010bf6:	091b      	lsrs	r3, r3, #4
 8010bf8:	f003 030f 	and.w	r3, r3, #15
 8010bfc:	4a0f      	ldr	r2, [pc, #60]	; (8010c3c <HAL_RCC_GetSysClockFreq+0xcc>)
 8010bfe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010c02:	60bb      	str	r3, [r7, #8]
        break;
 8010c04:	bf00      	nop
    }
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(), LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
 8010c06:	f7ff fa59 	bl	80100bc <LL_RCC_PLL_GetN>
 8010c0a:	4602      	mov	r2, r0
 8010c0c:	68bb      	ldr	r3, [r7, #8]
 8010c0e:	fb03 f402 	mul.w	r4, r3, r2
 8010c12:	f7ff fa6c 	bl	80100ee <LL_RCC_PLL_GetDivider>
 8010c16:	4603      	mov	r3, r0
 8010c18:	091b      	lsrs	r3, r3, #4
 8010c1a:	3301      	adds	r3, #1
 8010c1c:	fbb4 f4f3 	udiv	r4, r4, r3
 8010c20:	f7ff fa59 	bl	80100d6 <LL_RCC_PLL_GetR>
 8010c24:	4603      	mov	r3, r0
 8010c26:	0f5b      	lsrs	r3, r3, #29
 8010c28:	3301      	adds	r3, #1
 8010c2a:	fbb4 f3f3 	udiv	r3, r4, r3
 8010c2e:	60fb      	str	r3, [r7, #12]
  }

  return sysclockfreq;
 8010c30:	68fb      	ldr	r3, [r7, #12]
}
 8010c32:	4618      	mov	r0, r3
 8010c34:	3714      	adds	r7, #20
 8010c36:	46bd      	mov	sp, r7
 8010c38:	bd90      	pop	{r4, r7, pc}
 8010c3a:	bf00      	nop
 8010c3c:	08015348 	.word	0x08015348
 8010c40:	00f42400 	.word	0x00f42400
 8010c44:	01e84800 	.word	0x01e84800

08010c48 <HAL_RCC_GetHCLKFreq>:
/**
  * @brief  Return the HCLK frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8010c48:	b598      	push	{r3, r4, r7, lr}
 8010c4a:	af00      	add	r7, sp, #0
  /* Get SysClock and Compute HCLK1 frequency ---------------------------*/
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 8010c4c:	f7ff ff90 	bl	8010b70 <HAL_RCC_GetSysClockFreq>
 8010c50:	4604      	mov	r4, r0
 8010c52:	f7ff f9e9 	bl	8010028 <LL_RCC_GetAHBPrescaler>
 8010c56:	4603      	mov	r3, r0
 8010c58:	091b      	lsrs	r3, r3, #4
 8010c5a:	f003 030f 	and.w	r3, r3, #15
 8010c5e:	4a03      	ldr	r2, [pc, #12]	; (8010c6c <HAL_RCC_GetHCLKFreq+0x24>)
 8010c60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010c64:	fbb4 f3f3 	udiv	r3, r4, r3
}
 8010c68:	4618      	mov	r0, r3
 8010c6a:	bd98      	pop	{r3, r4, r7, pc}
 8010c6c:	08015308 	.word	0x08015308

08010c70 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  MSI_Range  MSI range value from @ref RCC_MSIRANGE_0 to @ref RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSI_Range)
{
 8010c70:	b590      	push	{r4, r7, lr}
 8010c72:	b085      	sub	sp, #20
 8010c74:	af00      	add	r7, sp, #0
 8010c76:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RCC_MSI_CLOCK_RANGE(MSI_Range));

  /* MSI frequency range in Hz */
  if (MSI_Range > RCC_MSIRANGE_11)
 8010c78:	687b      	ldr	r3, [r7, #4]
 8010c7a:	2bb0      	cmp	r3, #176	; 0xb0
 8010c7c:	d903      	bls.n	8010c86 <RCC_SetFlashLatencyFromMSIRange+0x16>
  {
    msifreq = __LL_RCC_CALC_MSI_FREQ(RCC_MSIRANGE_11);
 8010c7e:	4b15      	ldr	r3, [pc, #84]	; (8010cd4 <RCC_SetFlashLatencyFromMSIRange+0x64>)
 8010c80:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8010c82:	60fb      	str	r3, [r7, #12]
 8010c84:	e007      	b.n	8010c96 <RCC_SetFlashLatencyFromMSIRange+0x26>
  }
  else
  {
    msifreq = __LL_RCC_CALC_MSI_FREQ(MSI_Range);
 8010c86:	687b      	ldr	r3, [r7, #4]
 8010c88:	091b      	lsrs	r3, r3, #4
 8010c8a:	f003 030f 	and.w	r3, r3, #15
 8010c8e:	4a11      	ldr	r2, [pc, #68]	; (8010cd4 <RCC_SetFlashLatencyFromMSIRange+0x64>)
 8010c90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010c94:	60fb      	str	r3, [r7, #12]
  }

  flash_clksrcfreq = __LL_RCC_CALC_HCLK4_FREQ(msifreq, LL_RCC_GetAHB4Prescaler());
 8010c96:	f7ff f9d3 	bl	8010040 <LL_RCC_GetAHB4Prescaler>
 8010c9a:	4603      	mov	r3, r0
 8010c9c:	091b      	lsrs	r3, r3, #4
 8010c9e:	f003 030f 	and.w	r3, r3, #15
 8010ca2:	4a0d      	ldr	r2, [pc, #52]	; (8010cd8 <RCC_SetFlashLatencyFromMSIRange+0x68>)
 8010ca4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010ca8:	68fa      	ldr	r2, [r7, #12]
 8010caa:	fbb2 f3f3 	udiv	r3, r2, r3
 8010cae:	60bb      	str	r3, [r7, #8]

#if defined(PWR_CR1_VOS)
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 8010cb0:	68bb      	ldr	r3, [r7, #8]
 8010cb2:	4a0a      	ldr	r2, [pc, #40]	; (8010cdc <RCC_SetFlashLatencyFromMSIRange+0x6c>)
 8010cb4:	fba2 2303 	umull	r2, r3, r2, r3
 8010cb8:	0c9c      	lsrs	r4, r3, #18
 8010cba:	f7fe ff21 	bl	800fb00 <HAL_PWREx_GetVoltageRange>
 8010cbe:	4603      	mov	r3, r0
 8010cc0:	4619      	mov	r1, r3
 8010cc2:	4620      	mov	r0, r4
 8010cc4:	f000 f80c 	bl	8010ce0 <RCC_SetFlashLatency>
 8010cc8:	4603      	mov	r3, r0
#else
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), PWR_REGULATOR_VOLTAGE_SCALE1);
#endif
}
 8010cca:	4618      	mov	r0, r3
 8010ccc:	3714      	adds	r7, #20
 8010cce:	46bd      	mov	sp, r7
 8010cd0:	bd90      	pop	{r4, r7, pc}
 8010cd2:	bf00      	nop
 8010cd4:	08015348 	.word	0x08015348
 8010cd8:	08015308 	.word	0x08015308
 8010cdc:	431bde83 	.word	0x431bde83

08010ce0 <RCC_SetFlashLatency>:
  * @param  Flash_ClkSrcFreq  Flash Clock Source (in MHz)
  * @param  VCORE_Voltage     Current Vcore voltage (PWR_REGULATOR_VOLTAGE_SCALE1 or PWR_REGULATOR_VOLTAGE_SCALE2)
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatency(uint32_t Flash_ClkSrcFreq, uint32_t VCORE_Voltage)
{
 8010ce0:	b590      	push	{r4, r7, lr}
 8010ce2:	b093      	sub	sp, #76	; 0x4c
 8010ce4:	af00      	add	r7, sp, #0
 8010ce6:	6078      	str	r0, [r7, #4]
 8010ce8:	6039      	str	r1, [r7, #0]
  /* Flash Clock source (HCLK4) range in MHz with a VCORE is range1 */
  const uint32_t FLASH_CLK_SRC_RANGE_VOS1[] = {18UL, 36UL, 54UL, 64UL};
 8010cea:	4b39      	ldr	r3, [pc, #228]	; (8010dd0 <RCC_SetFlashLatency+0xf0>)
 8010cec:	f107 0428 	add.w	r4, r7, #40	; 0x28
 8010cf0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8010cf2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
#if defined(PWR_CR1_VOS)
  /* Flash Clock source (HCLK4) range in MHz with a VCORE is range2 */
  const uint32_t FLASH_CLK_SRC_RANGE_VOS2[] = {6UL, 12UL, 16UL};
 8010cf6:	4a37      	ldr	r2, [pc, #220]	; (8010dd4 <RCC_SetFlashLatency+0xf4>)
 8010cf8:	f107 031c 	add.w	r3, r7, #28
 8010cfc:	ca07      	ldmia	r2, {r0, r1, r2}
 8010cfe:	e883 0007 	stmia.w	r3, {r0, r1, r2}
#endif
  /* Flash Latency range */
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2, FLASH_LATENCY_3};
 8010d02:	4b35      	ldr	r3, [pc, #212]	; (8010dd8 <RCC_SetFlashLatency+0xf8>)
 8010d04:	f107 040c 	add.w	r4, r7, #12
 8010d08:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8010d0a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
 8010d0e:	2300      	movs	r3, #0
 8010d10:	647b      	str	r3, [r7, #68]	; 0x44
  uint32_t tickstart;

#if defined(PWR_CR1_VOS)
  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 8010d12:	683b      	ldr	r3, [r7, #0]
 8010d14:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8010d18:	d11c      	bne.n	8010d54 <RCC_SetFlashLatency+0x74>
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS1); index++)
 8010d1a:	2300      	movs	r3, #0
 8010d1c:	643b      	str	r3, [r7, #64]	; 0x40
 8010d1e:	e015      	b.n	8010d4c <RCC_SetFlashLatency+0x6c>
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 8010d20:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010d22:	009b      	lsls	r3, r3, #2
 8010d24:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8010d28:	4413      	add	r3, r2
 8010d2a:	f853 3c20 	ldr.w	r3, [r3, #-32]
 8010d2e:	687a      	ldr	r2, [r7, #4]
 8010d30:	429a      	cmp	r2, r3
 8010d32:	d808      	bhi.n	8010d46 <RCC_SetFlashLatency+0x66>
      {
        latency = FLASH_LATENCY_RANGE[index];
 8010d34:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010d36:	009b      	lsls	r3, r3, #2
 8010d38:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8010d3c:	4413      	add	r3, r2
 8010d3e:	f853 3c3c 	ldr.w	r3, [r3, #-60]
 8010d42:	647b      	str	r3, [r7, #68]	; 0x44
        break;
 8010d44:	e022      	b.n	8010d8c <RCC_SetFlashLatency+0xac>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS1); index++)
 8010d46:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010d48:	3301      	adds	r3, #1
 8010d4a:	643b      	str	r3, [r7, #64]	; 0x40
 8010d4c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010d4e:	2b03      	cmp	r3, #3
 8010d50:	d9e6      	bls.n	8010d20 <RCC_SetFlashLatency+0x40>
 8010d52:	e01b      	b.n	8010d8c <RCC_SetFlashLatency+0xac>
      }
    }
  }
  else  /* PWR_REGULATOR_VOLTAGE_SCALE2 */
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 8010d54:	2300      	movs	r3, #0
 8010d56:	63fb      	str	r3, [r7, #60]	; 0x3c
 8010d58:	e015      	b.n	8010d86 <RCC_SetFlashLatency+0xa6>
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS2[index])
 8010d5a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010d5c:	009b      	lsls	r3, r3, #2
 8010d5e:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8010d62:	4413      	add	r3, r2
 8010d64:	f853 3c2c 	ldr.w	r3, [r3, #-44]
 8010d68:	687a      	ldr	r2, [r7, #4]
 8010d6a:	429a      	cmp	r2, r3
 8010d6c:	d808      	bhi.n	8010d80 <RCC_SetFlashLatency+0xa0>
      {
        latency = FLASH_LATENCY_RANGE[index];
 8010d6e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010d70:	009b      	lsls	r3, r3, #2
 8010d72:	f107 0248 	add.w	r2, r7, #72	; 0x48
 8010d76:	4413      	add	r3, r2
 8010d78:	f853 3c3c 	ldr.w	r3, [r3, #-60]
 8010d7c:	647b      	str	r3, [r7, #68]	; 0x44
        break;
 8010d7e:	e005      	b.n	8010d8c <RCC_SetFlashLatency+0xac>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 8010d80:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010d82:	3301      	adds	r3, #1
 8010d84:	63fb      	str	r3, [r7, #60]	; 0x3c
 8010d86:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010d88:	2b02      	cmp	r3, #2
 8010d8a:	d9e6      	bls.n	8010d5a <RCC_SetFlashLatency+0x7a>
      break;
    }
  }
#endif

  __HAL_FLASH_SET_LATENCY(latency);
 8010d8c:	4b13      	ldr	r3, [pc, #76]	; (8010ddc <RCC_SetFlashLatency+0xfc>)
 8010d8e:	681b      	ldr	r3, [r3, #0]
 8010d90:	f023 0207 	bic.w	r2, r3, #7
 8010d94:	4911      	ldr	r1, [pc, #68]	; (8010ddc <RCC_SetFlashLatency+0xfc>)
 8010d96:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010d98:	4313      	orrs	r3, r2
 8010d9a:	600b      	str	r3, [r1, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8010d9c:	f7fc fad8 	bl	800d350 <HAL_GetTick>
 8010da0:	63b8      	str	r0, [r7, #56]	; 0x38

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  while (__HAL_FLASH_GET_LATENCY() != latency)
 8010da2:	e008      	b.n	8010db6 <RCC_SetFlashLatency+0xd6>
  {
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8010da4:	f7fc fad4 	bl	800d350 <HAL_GetTick>
 8010da8:	4602      	mov	r2, r0
 8010daa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010dac:	1ad3      	subs	r3, r2, r3
 8010dae:	2b02      	cmp	r3, #2
 8010db0:	d901      	bls.n	8010db6 <RCC_SetFlashLatency+0xd6>
    {
      return HAL_TIMEOUT;
 8010db2:	2303      	movs	r3, #3
 8010db4:	e007      	b.n	8010dc6 <RCC_SetFlashLatency+0xe6>
  while (__HAL_FLASH_GET_LATENCY() != latency)
 8010db6:	4b09      	ldr	r3, [pc, #36]	; (8010ddc <RCC_SetFlashLatency+0xfc>)
 8010db8:	681b      	ldr	r3, [r3, #0]
 8010dba:	f003 0307 	and.w	r3, r3, #7
 8010dbe:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8010dc0:	429a      	cmp	r2, r3
 8010dc2:	d1ef      	bne.n	8010da4 <RCC_SetFlashLatency+0xc4>
    }
  }
  return HAL_OK;
 8010dc4:	2300      	movs	r3, #0
}
 8010dc6:	4618      	mov	r0, r3
 8010dc8:	374c      	adds	r7, #76	; 0x4c
 8010dca:	46bd      	mov	sp, r7
 8010dcc:	bd90      	pop	{r4, r7, pc}
 8010dce:	bf00      	nop
 8010dd0:	08014d50 	.word	0x08014d50
 8010dd4:	08014d60 	.word	0x08014d60
 8010dd8:	08014d6c 	.word	0x08014d6c
 8010ddc:	58004000 	.word	0x58004000

08010de0 <LL_RCC_LSE_IsEnabled>:
{
 8010de0:	b480      	push	{r7}
 8010de2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSEON) == (RCC_BDCR_LSEON)) ? 1UL : 0UL);
 8010de4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010de8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8010dec:	f003 0301 	and.w	r3, r3, #1
 8010df0:	2b01      	cmp	r3, #1
 8010df2:	d101      	bne.n	8010df8 <LL_RCC_LSE_IsEnabled+0x18>
 8010df4:	2301      	movs	r3, #1
 8010df6:	e000      	b.n	8010dfa <LL_RCC_LSE_IsEnabled+0x1a>
 8010df8:	2300      	movs	r3, #0
}
 8010dfa:	4618      	mov	r0, r3
 8010dfc:	46bd      	mov	sp, r7
 8010dfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e02:	4770      	bx	lr

08010e04 <LL_RCC_LSE_IsReady>:
{
 8010e04:	b480      	push	{r7}
 8010e06:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 8010e08:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010e0c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8010e10:	f003 0302 	and.w	r3, r3, #2
 8010e14:	2b02      	cmp	r3, #2
 8010e16:	d101      	bne.n	8010e1c <LL_RCC_LSE_IsReady+0x18>
 8010e18:	2301      	movs	r3, #1
 8010e1a:	e000      	b.n	8010e1e <LL_RCC_LSE_IsReady+0x1a>
 8010e1c:	2300      	movs	r3, #0
}
 8010e1e:	4618      	mov	r0, r3
 8010e20:	46bd      	mov	sp, r7
 8010e22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e26:	4770      	bx	lr

08010e28 <LL_RCC_SetRFWKPClockSource>:
{
 8010e28:	b480      	push	{r7}
 8010e2a:	b083      	sub	sp, #12
 8010e2c:	af00      	add	r7, sp, #0
 8010e2e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CSR, RCC_CSR_RFWKPSEL, Source);
 8010e30:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010e34:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8010e38:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
 8010e3c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8010e40:	687b      	ldr	r3, [r7, #4]
 8010e42:	4313      	orrs	r3, r2
 8010e44:	f8c1 3094 	str.w	r3, [r1, #148]	; 0x94
}
 8010e48:	bf00      	nop
 8010e4a:	370c      	adds	r7, #12
 8010e4c:	46bd      	mov	sp, r7
 8010e4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e52:	4770      	bx	lr

08010e54 <LL_RCC_SetSMPSClockSource>:
{
 8010e54:	b480      	push	{r7}
 8010e56:	b083      	sub	sp, #12
 8010e58:	af00      	add	r7, sp, #0
 8010e5a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->SMPSCR, RCC_SMPSCR_SMPSSEL, SMPSSource);
 8010e5c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010e60:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010e62:	f023 0203 	bic.w	r2, r3, #3
 8010e66:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8010e6a:	687b      	ldr	r3, [r7, #4]
 8010e6c:	4313      	orrs	r3, r2
 8010e6e:	624b      	str	r3, [r1, #36]	; 0x24
}
 8010e70:	bf00      	nop
 8010e72:	370c      	adds	r7, #12
 8010e74:	46bd      	mov	sp, r7
 8010e76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e7a:	4770      	bx	lr

08010e7c <LL_RCC_SetSMPSPrescaler>:
{
 8010e7c:	b480      	push	{r7}
 8010e7e:	b083      	sub	sp, #12
 8010e80:	af00      	add	r7, sp, #0
 8010e82:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->SMPSCR, RCC_SMPSCR_SMPSDIV, Prescaler);
 8010e84:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010e88:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010e8a:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 8010e8e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8010e92:	687b      	ldr	r3, [r7, #4]
 8010e94:	4313      	orrs	r3, r2
 8010e96:	624b      	str	r3, [r1, #36]	; 0x24
}
 8010e98:	bf00      	nop
 8010e9a:	370c      	adds	r7, #12
 8010e9c:	46bd      	mov	sp, r7
 8010e9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010ea2:	4770      	bx	lr

08010ea4 <LL_RCC_SetUSARTClockSource>:
{
 8010ea4:	b480      	push	{r7}
 8010ea6:	b083      	sub	sp, #12
 8010ea8:	af00      	add	r7, sp, #0
 8010eaa:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_USART1SEL, USARTxSource);
 8010eac:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010eb0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8010eb4:	f023 0203 	bic.w	r2, r3, #3
 8010eb8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8010ebc:	687b      	ldr	r3, [r7, #4]
 8010ebe:	4313      	orrs	r3, r2
 8010ec0:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8010ec4:	bf00      	nop
 8010ec6:	370c      	adds	r7, #12
 8010ec8:	46bd      	mov	sp, r7
 8010eca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010ece:	4770      	bx	lr

08010ed0 <LL_RCC_SetLPUARTClockSource>:
{
 8010ed0:	b480      	push	{r7}
 8010ed2:	b083      	sub	sp, #12
 8010ed4:	af00      	add	r7, sp, #0
 8010ed6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 8010ed8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010edc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8010ee0:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
 8010ee4:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8010ee8:	687b      	ldr	r3, [r7, #4]
 8010eea:	4313      	orrs	r3, r2
 8010eec:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8010ef0:	bf00      	nop
 8010ef2:	370c      	adds	r7, #12
 8010ef4:	46bd      	mov	sp, r7
 8010ef6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010efa:	4770      	bx	lr

08010efc <LL_RCC_SetI2CClockSource>:
{
 8010efc:	b480      	push	{r7}
 8010efe:	b083      	sub	sp, #12
 8010f00:	af00      	add	r7, sp, #0
 8010f02:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 8010f04:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010f08:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8010f0c:	687b      	ldr	r3, [r7, #4]
 8010f0e:	091b      	lsrs	r3, r3, #4
 8010f10:	f403 237f 	and.w	r3, r3, #1044480	; 0xff000
 8010f14:	43db      	mvns	r3, r3
 8010f16:	401a      	ands	r2, r3
 8010f18:	687b      	ldr	r3, [r7, #4]
 8010f1a:	011b      	lsls	r3, r3, #4
 8010f1c:	f403 237f 	and.w	r3, r3, #1044480	; 0xff000
 8010f20:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8010f24:	4313      	orrs	r3, r2
 8010f26:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8010f2a:	bf00      	nop
 8010f2c:	370c      	adds	r7, #12
 8010f2e:	46bd      	mov	sp, r7
 8010f30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010f34:	4770      	bx	lr

08010f36 <LL_RCC_SetLPTIMClockSource>:
{
 8010f36:	b480      	push	{r7}
 8010f38:	b083      	sub	sp, #12
 8010f3a:	af00      	add	r7, sp, #0
 8010f3c:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 8010f3e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010f42:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8010f46:	687b      	ldr	r3, [r7, #4]
 8010f48:	0c1b      	lsrs	r3, r3, #16
 8010f4a:	041b      	lsls	r3, r3, #16
 8010f4c:	43db      	mvns	r3, r3
 8010f4e:	401a      	ands	r2, r3
 8010f50:	687b      	ldr	r3, [r7, #4]
 8010f52:	041b      	lsls	r3, r3, #16
 8010f54:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8010f58:	4313      	orrs	r3, r2
 8010f5a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8010f5e:	bf00      	nop
 8010f60:	370c      	adds	r7, #12
 8010f62:	46bd      	mov	sp, r7
 8010f64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010f68:	4770      	bx	lr

08010f6a <LL_RCC_SetSAIClockSource>:
{
 8010f6a:	b480      	push	{r7}
 8010f6c:	b083      	sub	sp, #12
 8010f6e:	af00      	add	r7, sp, #0
 8010f70:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_SAI1SEL, SAIxSource);
 8010f72:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010f76:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8010f7a:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 8010f7e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8010f82:	687b      	ldr	r3, [r7, #4]
 8010f84:	4313      	orrs	r3, r2
 8010f86:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8010f8a:	bf00      	nop
 8010f8c:	370c      	adds	r7, #12
 8010f8e:	46bd      	mov	sp, r7
 8010f90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010f94:	4770      	bx	lr

08010f96 <LL_RCC_SetRNGClockSource>:
{
 8010f96:	b480      	push	{r7}
 8010f98:	b083      	sub	sp, #12
 8010f9a:	af00      	add	r7, sp, #0
 8010f9c:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 8010f9e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010fa2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8010fa6:	f023 4240 	bic.w	r2, r3, #3221225472	; 0xc0000000
 8010faa:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8010fae:	687b      	ldr	r3, [r7, #4]
 8010fb0:	4313      	orrs	r3, r2
 8010fb2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8010fb6:	bf00      	nop
 8010fb8:	370c      	adds	r7, #12
 8010fba:	46bd      	mov	sp, r7
 8010fbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010fc0:	4770      	bx	lr

08010fc2 <LL_RCC_SetCLK48ClockSource>:
{
 8010fc2:	b480      	push	{r7}
 8010fc4:	b083      	sub	sp, #12
 8010fc6:	af00      	add	r7, sp, #0
 8010fc8:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_CLK48SEL, CLK48xSource);
 8010fca:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8010fce:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8010fd2:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
 8010fd6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8010fda:	687b      	ldr	r3, [r7, #4]
 8010fdc:	4313      	orrs	r3, r2
 8010fde:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8010fe2:	bf00      	nop
 8010fe4:	370c      	adds	r7, #12
 8010fe6:	46bd      	mov	sp, r7
 8010fe8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010fec:	4770      	bx	lr

08010fee <LL_RCC_SetUSBClockSource>:
{
 8010fee:	b580      	push	{r7, lr}
 8010ff0:	b082      	sub	sp, #8
 8010ff2:	af00      	add	r7, sp, #0
 8010ff4:	6078      	str	r0, [r7, #4]
  LL_RCC_SetCLK48ClockSource(USBxSource);
 8010ff6:	6878      	ldr	r0, [r7, #4]
 8010ff8:	f7ff ffe3 	bl	8010fc2 <LL_RCC_SetCLK48ClockSource>
}
 8010ffc:	bf00      	nop
 8010ffe:	3708      	adds	r7, #8
 8011000:	46bd      	mov	sp, r7
 8011002:	bd80      	pop	{r7, pc}

08011004 <LL_RCC_SetADCClockSource>:
{
 8011004:	b480      	push	{r7}
 8011006:	b083      	sub	sp, #12
 8011008:	af00      	add	r7, sp, #0
 801100a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 801100c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011010:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8011014:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
 8011018:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 801101c:	687b      	ldr	r3, [r7, #4]
 801101e:	4313      	orrs	r3, r2
 8011020:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8011024:	bf00      	nop
 8011026:	370c      	adds	r7, #12
 8011028:	46bd      	mov	sp, r7
 801102a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801102e:	4770      	bx	lr

08011030 <LL_RCC_SetRTCClockSource>:
{
 8011030:	b480      	push	{r7}
 8011032:	b083      	sub	sp, #12
 8011034:	af00      	add	r7, sp, #0
 8011036:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 8011038:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801103c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8011040:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8011044:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8011048:	687b      	ldr	r3, [r7, #4]
 801104a:	4313      	orrs	r3, r2
 801104c:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
}
 8011050:	bf00      	nop
 8011052:	370c      	adds	r7, #12
 8011054:	46bd      	mov	sp, r7
 8011056:	f85d 7b04 	ldr.w	r7, [sp], #4
 801105a:	4770      	bx	lr

0801105c <LL_RCC_GetRTCClockSource>:
{
 801105c:	b480      	push	{r7}
 801105e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 8011060:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011064:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8011068:	f403 7340 	and.w	r3, r3, #768	; 0x300
}
 801106c:	4618      	mov	r0, r3
 801106e:	46bd      	mov	sp, r7
 8011070:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011074:	4770      	bx	lr

08011076 <LL_RCC_ForceBackupDomainReset>:
{
 8011076:	b480      	push	{r7}
 8011078:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 801107a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801107e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8011082:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8011086:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 801108a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 801108e:	bf00      	nop
 8011090:	46bd      	mov	sp, r7
 8011092:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011096:	4770      	bx	lr

08011098 <LL_RCC_ReleaseBackupDomainReset>:
{
 8011098:	b480      	push	{r7}
 801109a:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 801109c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80110a0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80110a4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80110a8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80110ac:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 80110b0:	bf00      	nop
 80110b2:	46bd      	mov	sp, r7
 80110b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80110b8:	4770      	bx	lr

080110ba <LL_RCC_PLLSAI1_Enable>:
{
 80110ba:	b480      	push	{r7}
 80110bc:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_PLLSAI1ON);
 80110be:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80110c2:	681b      	ldr	r3, [r3, #0]
 80110c4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80110c8:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 80110cc:	6013      	str	r3, [r2, #0]
}
 80110ce:	bf00      	nop
 80110d0:	46bd      	mov	sp, r7
 80110d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80110d6:	4770      	bx	lr

080110d8 <LL_RCC_PLLSAI1_Disable>:
{
 80110d8:	b480      	push	{r7}
 80110da:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_PLLSAI1ON);
 80110dc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80110e0:	681b      	ldr	r3, [r3, #0]
 80110e2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80110e6:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 80110ea:	6013      	str	r3, [r2, #0]
}
 80110ec:	bf00      	nop
 80110ee:	46bd      	mov	sp, r7
 80110f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80110f4:	4770      	bx	lr

080110f6 <LL_RCC_PLLSAI1_IsReady>:
{
 80110f6:	b480      	push	{r7}
 80110f8:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == (RCC_CR_PLLSAI1RDY)) ? 1UL : 0UL);
 80110fa:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80110fe:	681b      	ldr	r3, [r3, #0]
 8011100:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8011104:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8011108:	d101      	bne.n	801110e <LL_RCC_PLLSAI1_IsReady+0x18>
 801110a:	2301      	movs	r3, #1
 801110c:	e000      	b.n	8011110 <LL_RCC_PLLSAI1_IsReady+0x1a>
 801110e:	2300      	movs	r3, #0
}
 8011110:	4618      	mov	r0, r3
 8011112:	46bd      	mov	sp, r7
 8011114:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011118:	4770      	bx	lr

0801111a <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 801111a:	b580      	push	{r7, lr}
 801111c:	b088      	sub	sp, #32
 801111e:	af00      	add	r7, sp, #0
 8011120:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef ret     = HAL_OK;      /* Intermediate status */
 8011122:	2300      	movs	r3, #0
 8011124:	77fb      	strb	r3, [r7, #31]
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 8011126:	2300      	movs	r3, #0
 8011128:	77bb      	strb	r3, [r7, #30]
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

#if defined(SAI1)
  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 801112a:	687b      	ldr	r3, [r7, #4]
 801112c:	681b      	ldr	r3, [r3, #0]
 801112e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8011132:	2b00      	cmp	r3, #0
 8011134:	d034      	beq.n	80111a0 <HAL_RCCEx_PeriphCLKConfig+0x86>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));

    switch (PeriphClkInit->Sai1ClockSelection)
 8011136:	687b      	ldr	r3, [r7, #4]
 8011138:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801113a:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 801113e:	d021      	beq.n	8011184 <HAL_RCCEx_PeriphCLKConfig+0x6a>
 8011140:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 8011144:	d81b      	bhi.n	801117e <HAL_RCCEx_PeriphCLKConfig+0x64>
 8011146:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 801114a:	d01d      	beq.n	8011188 <HAL_RCCEx_PeriphCLKConfig+0x6e>
 801114c:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8011150:	d815      	bhi.n	801117e <HAL_RCCEx_PeriphCLKConfig+0x64>
 8011152:	2b00      	cmp	r3, #0
 8011154:	d00b      	beq.n	801116e <HAL_RCCEx_PeriphCLKConfig+0x54>
 8011156:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 801115a:	d110      	bne.n	801117e <HAL_RCCEx_PeriphCLKConfig+0x64>
    {
      case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1 */
        /* Enable SAI1 Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI1CLK);
 801115c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011160:	68db      	ldr	r3, [r3, #12]
 8011162:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8011166:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 801116a:	60d3      	str	r3, [r2, #12]

        /* SAI1 clock source config set later after clock selection check */
        break;
 801116c:	e00d      	b.n	801118a <HAL_RCCEx_PeriphCLKConfig+0x70>

#if defined(SAI1)
      case RCC_SAI1CLKSOURCE_PLLSAI1: /* PLLSAI1 is used as clock source for SAI1 */
        /* PLLSAI1 parameters N & P configuration and clock output (PLLSAI1ClockOut) */
        ret = RCCEx_PLLSAI1_ConfigNP(&(PeriphClkInit->PLLSAI1));
 801116e:	687b      	ldr	r3, [r7, #4]
 8011170:	3304      	adds	r3, #4
 8011172:	4618      	mov	r0, r3
 8011174:	f000 f947 	bl	8011406 <RCCEx_PLLSAI1_ConfigNP>
 8011178:	4603      	mov	r3, r0
 801117a:	77fb      	strb	r3, [r7, #31]
        /* SAI1 clock source config set later after clock selection check */
        break;
 801117c:	e005      	b.n	801118a <HAL_RCCEx_PeriphCLKConfig+0x70>
      case RCC_SAI1CLKSOURCE_HSI:

        break;

      default:
        ret = HAL_ERROR;
 801117e:	2301      	movs	r3, #1
 8011180:	77fb      	strb	r3, [r7, #31]
        break;
 8011182:	e002      	b.n	801118a <HAL_RCCEx_PeriphCLKConfig+0x70>
        break;
 8011184:	bf00      	nop
 8011186:	e000      	b.n	801118a <HAL_RCCEx_PeriphCLKConfig+0x70>
        break;
 8011188:	bf00      	nop
    }

    if (ret == HAL_OK)
 801118a:	7ffb      	ldrb	r3, [r7, #31]
 801118c:	2b00      	cmp	r3, #0
 801118e:	d105      	bne.n	801119c <HAL_RCCEx_PeriphCLKConfig+0x82>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8011190:	687b      	ldr	r3, [r7, #4]
 8011192:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011194:	4618      	mov	r0, r3
 8011196:	f7ff fee8 	bl	8010f6a <LL_RCC_SetSAIClockSource>
 801119a:	e001      	b.n	80111a0 <HAL_RCCEx_PeriphCLKConfig+0x86>
    }
    else
    {
      /* set overall return value */
      status = ret;
 801119c:	7ffb      	ldrb	r3, [r7, #31]
 801119e:	77bb      	strb	r3, [r7, #30]
    }
  }
#endif

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 80111a0:	687b      	ldr	r3, [r7, #4]
 80111a2:	681b      	ldr	r3, [r3, #0]
 80111a4:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80111a8:	2b00      	cmp	r3, #0
 80111aa:	d046      	beq.n	801123a <HAL_RCCEx_PeriphCLKConfig+0x120>
  {
    uint32_t rtcclocksource = LL_RCC_GetRTCClockSource();
 80111ac:	f7ff ff56 	bl	801105c <LL_RCC_GetRTCClockSource>
 80111b0:	61b8      	str	r0, [r7, #24]

    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Configure the clock source only if a different source is expected */
    if (rtcclocksource != PeriphClkInit->RTCClockSelection)
 80111b2:	687b      	ldr	r3, [r7, #4]
 80111b4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80111b6:	69ba      	ldr	r2, [r7, #24]
 80111b8:	429a      	cmp	r2, r3
 80111ba:	d03c      	beq.n	8011236 <HAL_RCCEx_PeriphCLKConfig+0x11c>
    {
      /* Enable write access to Backup domain */
      HAL_PWR_EnableBkUpAccess();
 80111bc:	f7fe fc90 	bl	800fae0 <HAL_PWR_EnableBkUpAccess>

      /* If a clock source is not yet selected */
      if (rtcclocksource == RCC_RTCCLKSOURCE_NONE)
 80111c0:	69bb      	ldr	r3, [r7, #24]
 80111c2:	2b00      	cmp	r3, #0
 80111c4:	d105      	bne.n	80111d2 <HAL_RCCEx_PeriphCLKConfig+0xb8>
      {
        /* Directly set the configuration of the clock source selection */
        LL_RCC_SetRTCClockSource(PeriphClkInit->RTCClockSelection);
 80111c6:	687b      	ldr	r3, [r7, #4]
 80111c8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80111ca:	4618      	mov	r0, r3
 80111cc:	f7ff ff30 	bl	8011030 <LL_RCC_SetRTCClockSource>
 80111d0:	e02e      	b.n	8011230 <HAL_RCCEx_PeriphCLKConfig+0x116>
      }
      else /* A clock source is already selected */
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        uint32_t bdcr = LL_RCC_ReadReg(BDCR);
 80111d2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80111d6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80111da:	617b      	str	r3, [r7, #20]

        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        LL_RCC_ForceBackupDomainReset();
 80111dc:	f7ff ff4b 	bl	8011076 <LL_RCC_ForceBackupDomainReset>
        LL_RCC_ReleaseBackupDomainReset();
 80111e0:	f7ff ff5a 	bl	8011098 <LL_RCC_ReleaseBackupDomainReset>

        /* Set the value of the clock source selection */
        MODIFY_REG(bdcr, RCC_BDCR_RTCSEL, PeriphClkInit->RTCClockSelection);
 80111e4:	697b      	ldr	r3, [r7, #20]
 80111e6:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 80111ea:	687b      	ldr	r3, [r7, #4]
 80111ec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80111ee:	4313      	orrs	r3, r2
 80111f0:	617b      	str	r3, [r7, #20]

        /* Restore the content of BDCR register */
        LL_RCC_WriteReg(BDCR, bdcr);
 80111f2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80111f6:	697b      	ldr	r3, [r7, #20]
 80111f8:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

        /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
        if (LL_RCC_LSE_IsEnabled() == 1U)
 80111fc:	f7ff fdf0 	bl	8010de0 <LL_RCC_LSE_IsEnabled>
 8011200:	4603      	mov	r3, r0
 8011202:	2b01      	cmp	r3, #1
 8011204:	d114      	bne.n	8011230 <HAL_RCCEx_PeriphCLKConfig+0x116>
        {
          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 8011206:	f7fc f8a3 	bl	800d350 <HAL_GetTick>
 801120a:	6138      	str	r0, [r7, #16]

          /* Wait till LSE is ready */
          while (LL_RCC_LSE_IsReady() != 1U)
 801120c:	e00b      	b.n	8011226 <HAL_RCCEx_PeriphCLKConfig+0x10c>
          {
            if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 801120e:	f7fc f89f 	bl	800d350 <HAL_GetTick>
 8011212:	4602      	mov	r2, r0
 8011214:	693b      	ldr	r3, [r7, #16]
 8011216:	1ad3      	subs	r3, r2, r3
 8011218:	f241 3288 	movw	r2, #5000	; 0x1388
 801121c:	4293      	cmp	r3, r2
 801121e:	d902      	bls.n	8011226 <HAL_RCCEx_PeriphCLKConfig+0x10c>
            {
              ret = HAL_TIMEOUT;
 8011220:	2303      	movs	r3, #3
 8011222:	77fb      	strb	r3, [r7, #31]
              break;
 8011224:	e004      	b.n	8011230 <HAL_RCCEx_PeriphCLKConfig+0x116>
          while (LL_RCC_LSE_IsReady() != 1U)
 8011226:	f7ff fded 	bl	8010e04 <LL_RCC_LSE_IsReady>
 801122a:	4603      	mov	r3, r0
 801122c:	2b01      	cmp	r3, #1
 801122e:	d1ee      	bne.n	801120e <HAL_RCCEx_PeriphCLKConfig+0xf4>
          }
        }
      }

      /* set overall return value */
      status = ret;
 8011230:	7ffb      	ldrb	r3, [r7, #31]
 8011232:	77bb      	strb	r3, [r7, #30]
 8011234:	e001      	b.n	801123a <HAL_RCCEx_PeriphCLKConfig+0x120>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8011236:	7ffb      	ldrb	r3, [r7, #31]
 8011238:	77bb      	strb	r3, [r7, #30]
    }

  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 801123a:	687b      	ldr	r3, [r7, #4]
 801123c:	681b      	ldr	r3, [r3, #0]
 801123e:	f003 0301 	and.w	r3, r3, #1
 8011242:	2b00      	cmp	r3, #0
 8011244:	d004      	beq.n	8011250 <HAL_RCCEx_PeriphCLKConfig+0x136>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8011246:	687b      	ldr	r3, [r7, #4]
 8011248:	699b      	ldr	r3, [r3, #24]
 801124a:	4618      	mov	r0, r3
 801124c:	f7ff fe2a 	bl	8010ea4 <LL_RCC_SetUSARTClockSource>
  }

#if defined(LPUART1)
  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8011250:	687b      	ldr	r3, [r7, #4]
 8011252:	681b      	ldr	r3, [r3, #0]
 8011254:	f003 0302 	and.w	r3, r3, #2
 8011258:	2b00      	cmp	r3, #0
 801125a:	d004      	beq.n	8011266 <HAL_RCCEx_PeriphCLKConfig+0x14c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 801125c:	687b      	ldr	r3, [r7, #4]
 801125e:	69db      	ldr	r3, [r3, #28]
 8011260:	4618      	mov	r0, r3
 8011262:	f7ff fe35 	bl	8010ed0 <LL_RCC_SetLPUARTClockSource>
  }
#endif

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8011266:	687b      	ldr	r3, [r7, #4]
 8011268:	681b      	ldr	r3, [r3, #0]
 801126a:	f003 0310 	and.w	r3, r3, #16
 801126e:	2b00      	cmp	r3, #0
 8011270:	d004      	beq.n	801127c <HAL_RCCEx_PeriphCLKConfig+0x162>
  {
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8011272:	687b      	ldr	r3, [r7, #4]
 8011274:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011276:	4618      	mov	r0, r3
 8011278:	f7ff fe5d 	bl	8010f36 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 801127c:	687b      	ldr	r3, [r7, #4]
 801127e:	681b      	ldr	r3, [r3, #0]
 8011280:	f003 0320 	and.w	r3, r3, #32
 8011284:	2b00      	cmp	r3, #0
 8011286:	d004      	beq.n	8011292 <HAL_RCCEx_PeriphCLKConfig+0x178>
  {
    assert_param(IS_RCC_LPTIM2CLK(PeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8011288:	687b      	ldr	r3, [r7, #4]
 801128a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801128c:	4618      	mov	r0, r3
 801128e:	f7ff fe52 	bl	8010f36 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8011292:	687b      	ldr	r3, [r7, #4]
 8011294:	681b      	ldr	r3, [r3, #0]
 8011296:	f003 0304 	and.w	r3, r3, #4
 801129a:	2b00      	cmp	r3, #0
 801129c:	d004      	beq.n	80112a8 <HAL_RCCEx_PeriphCLKConfig+0x18e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 801129e:	687b      	ldr	r3, [r7, #4]
 80112a0:	6a1b      	ldr	r3, [r3, #32]
 80112a2:	4618      	mov	r0, r3
 80112a4:	f7ff fe2a 	bl	8010efc <LL_RCC_SetI2CClockSource>
  }

#if defined(I2C3)
  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 80112a8:	687b      	ldr	r3, [r7, #4]
 80112aa:	681b      	ldr	r3, [r3, #0]
 80112ac:	f003 0308 	and.w	r3, r3, #8
 80112b0:	2b00      	cmp	r3, #0
 80112b2:	d004      	beq.n	80112be <HAL_RCCEx_PeriphCLKConfig+0x1a4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 80112b4:	687b      	ldr	r3, [r7, #4]
 80112b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80112b8:	4618      	mov	r0, r3
 80112ba:	f7ff fe1f 	bl	8010efc <LL_RCC_SetI2CClockSource>
  }
#endif

#if defined(USB)
  /*-------------------------- USB clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 80112be:	687b      	ldr	r3, [r7, #4]
 80112c0:	681b      	ldr	r3, [r3, #0]
 80112c2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80112c6:	2b00      	cmp	r3, #0
 80112c8:	d022      	beq.n	8011310 <HAL_RCCEx_PeriphCLKConfig+0x1f6>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 80112ca:	687b      	ldr	r3, [r7, #4]
 80112cc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80112ce:	4618      	mov	r0, r3
 80112d0:	f7ff fe8d 	bl	8010fee <LL_RCC_SetUSBClockSource>

    if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 80112d4:	687b      	ldr	r3, [r7, #4]
 80112d6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80112d8:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 80112dc:	d107      	bne.n	80112ee <HAL_RCCEx_PeriphCLKConfig+0x1d4>
    {
      /* Enable PLLQ output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_USBCLK);
 80112de:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80112e2:	68db      	ldr	r3, [r3, #12]
 80112e4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80112e8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80112ec:	60d3      	str	r3, [r2, #12]
    }
#if defined(SAI1)
  if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 80112ee:	687b      	ldr	r3, [r7, #4]
 80112f0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80112f2:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 80112f6:	d10b      	bne.n	8011310 <HAL_RCCEx_PeriphCLKConfig+0x1f6>
  {
    /* PLLSAI1 parameters N & Q configuration and clock output (PLLSAI1ClockOut) */
    ret = RCCEx_PLLSAI1_ConfigNQ(&(PeriphClkInit->PLLSAI1));
 80112f8:	687b      	ldr	r3, [r7, #4]
 80112fa:	3304      	adds	r3, #4
 80112fc:	4618      	mov	r0, r3
 80112fe:	f000 f8dd 	bl	80114bc <RCCEx_PLLSAI1_ConfigNQ>
 8011302:	4603      	mov	r3, r0
 8011304:	77fb      	strb	r3, [r7, #31]

    if (ret != HAL_OK)
 8011306:	7ffb      	ldrb	r3, [r7, #31]
 8011308:	2b00      	cmp	r3, #0
 801130a:	d001      	beq.n	8011310 <HAL_RCCEx_PeriphCLKConfig+0x1f6>
    {
      /* set overall return value */
      status = ret;
 801130c:	7ffb      	ldrb	r3, [r7, #31]
 801130e:	77bb      	strb	r3, [r7, #30]
#endif
  }
#endif

  /*-------------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8011310:	687b      	ldr	r3, [r7, #4]
 8011312:	681b      	ldr	r3, [r3, #0]
 8011314:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8011318:	2b00      	cmp	r3, #0
 801131a:	d02b      	beq.n	8011374 <HAL_RCCEx_PeriphCLKConfig+0x25a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));

    /* Configure the RNG clock source */
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 801131c:	687b      	ldr	r3, [r7, #4]
 801131e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8011320:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8011324:	d008      	beq.n	8011338 <HAL_RCCEx_PeriphCLKConfig+0x21e>
 8011326:	687b      	ldr	r3, [r7, #4]
 8011328:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801132a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 801132e:	d003      	beq.n	8011338 <HAL_RCCEx_PeriphCLKConfig+0x21e>
 8011330:	687b      	ldr	r3, [r7, #4]
 8011332:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8011334:	2b00      	cmp	r3, #0
 8011336:	d105      	bne.n	8011344 <HAL_RCCEx_PeriphCLKConfig+0x22a>
 8011338:	687b      	ldr	r3, [r7, #4]
 801133a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801133c:	4618      	mov	r0, r3
 801133e:	f7ff fe2a 	bl	8010f96 <LL_RCC_SetRNGClockSource>
 8011342:	e00a      	b.n	801135a <HAL_RCCEx_PeriphCLKConfig+0x240>
 8011344:	687b      	ldr	r3, [r7, #4]
 8011346:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8011348:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 801134c:	60fb      	str	r3, [r7, #12]
 801134e:	2000      	movs	r0, #0
 8011350:	f7ff fe21 	bl	8010f96 <LL_RCC_SetRNGClockSource>
 8011354:	68f8      	ldr	r0, [r7, #12]
 8011356:	f7ff fe34 	bl	8010fc2 <LL_RCC_SetCLK48ClockSource>

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 801135a:	687b      	ldr	r3, [r7, #4]
 801135c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801135e:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
 8011362:	d107      	bne.n	8011374 <HAL_RCCEx_PeriphCLKConfig+0x25a>
    {
      /* Enable PLLQ output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 8011364:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011368:	68db      	ldr	r3, [r3, #12]
 801136a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 801136e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8011372:	60d3      	str	r3, [r2, #12]
    }
  }

  /*-------------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8011374:	687b      	ldr	r3, [r7, #4]
 8011376:	681b      	ldr	r3, [r3, #0]
 8011378:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801137c:	2b00      	cmp	r3, #0
 801137e:	d022      	beq.n	80113c6 <HAL_RCCEx_PeriphCLKConfig+0x2ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8011380:	687b      	ldr	r3, [r7, #4]
 8011382:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8011384:	4618      	mov	r0, r3
 8011386:	f7ff fe3d 	bl	8011004 <LL_RCC_SetADCClockSource>

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 801138a:	687b      	ldr	r3, [r7, #4]
 801138c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801138e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8011392:	d107      	bne.n	80113a4 <HAL_RCCEx_PeriphCLKConfig+0x28a>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 8011394:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011398:	68db      	ldr	r3, [r3, #12]
 801139a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 801139e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80113a2:	60d3      	str	r3, [r2, #12]
    }

#if defined(SAI1)
  if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 80113a4:	687b      	ldr	r3, [r7, #4]
 80113a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80113a8:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 80113ac:	d10b      	bne.n	80113c6 <HAL_RCCEx_PeriphCLKConfig+0x2ac>
  {
    /* PLLSAI1 parameters N & R configuration and clock output (PLLSAI1ClockOut) */
    ret = RCCEx_PLLSAI1_ConfigNR(&(PeriphClkInit->PLLSAI1));
 80113ae:	687b      	ldr	r3, [r7, #4]
 80113b0:	3304      	adds	r3, #4
 80113b2:	4618      	mov	r0, r3
 80113b4:	f000 f8dd 	bl	8011572 <RCCEx_PLLSAI1_ConfigNR>
 80113b8:	4603      	mov	r3, r0
 80113ba:	77fb      	strb	r3, [r7, #31]

    if (ret != HAL_OK)
 80113bc:	7ffb      	ldrb	r3, [r7, #31]
 80113be:	2b00      	cmp	r3, #0
 80113c0:	d001      	beq.n	80113c6 <HAL_RCCEx_PeriphCLKConfig+0x2ac>
    {
      /* set overall return value */
      status = ret;
 80113c2:	7ffb      	ldrb	r3, [r7, #31]
 80113c4:	77bb      	strb	r3, [r7, #30]
  }
#endif
  }

  /*-------------------------- RFWKP clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RFWAKEUP) == RCC_PERIPHCLK_RFWAKEUP)
 80113c6:	687b      	ldr	r3, [r7, #4]
 80113c8:	681b      	ldr	r3, [r3, #0]
 80113ca:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80113ce:	2b00      	cmp	r3, #0
 80113d0:	d004      	beq.n	80113dc <HAL_RCCEx_PeriphCLKConfig+0x2c2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_RFWKPCLKSOURCE(PeriphClkInit->RFWakeUpClockSelection));

    /* Configure the RFWKP interface clock source */
    __HAL_RCC_RFWAKEUP_CONFIG(PeriphClkInit->RFWakeUpClockSelection);
 80113d2:	687b      	ldr	r3, [r7, #4]
 80113d4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80113d6:	4618      	mov	r0, r3
 80113d8:	f7ff fd26 	bl	8010e28 <LL_RCC_SetRFWKPClockSource>

  }

#if defined(RCC_SMPS_SUPPORT)
  /*-------------------------- SMPS clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SMPS) == RCC_PERIPHCLK_SMPS)
 80113dc:	687b      	ldr	r3, [r7, #4]
 80113de:	681b      	ldr	r3, [r3, #0]
 80113e0:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 80113e4:	2b00      	cmp	r3, #0
 80113e6:	d009      	beq.n	80113fc <HAL_RCCEx_PeriphCLKConfig+0x2e2>
    /* Check the parameters */
    assert_param(IS_RCC_SMPSCLKDIV(PeriphClkInit->SmpsDivSelection));
    assert_param(IS_RCC_SMPSCLKSOURCE(PeriphClkInit->SmpsClockSelection));

    /* Configure the SMPS interface clock division factor */
    __HAL_RCC_SMPS_DIV_CONFIG(PeriphClkInit->SmpsDivSelection);
 80113e8:	687b      	ldr	r3, [r7, #4]
 80113ea:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80113ec:	4618      	mov	r0, r3
 80113ee:	f7ff fd45 	bl	8010e7c <LL_RCC_SetSMPSPrescaler>

    /* Configure the SMPS interface clock source */
    __HAL_RCC_SMPS_CONFIG(PeriphClkInit->SmpsClockSelection);
 80113f2:	687b      	ldr	r3, [r7, #4]
 80113f4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80113f6:	4618      	mov	r0, r3
 80113f8:	f7ff fd2c 	bl	8010e54 <LL_RCC_SetSMPSClockSource>
  }
#endif


  return status;
 80113fc:	7fbb      	ldrb	r3, [r7, #30]
}
 80113fe:	4618      	mov	r0, r3
 8011400:	3720      	adds	r7, #32
 8011402:	46bd      	mov	sp, r7
 8011404:	bd80      	pop	{r7, pc}

08011406 <RCCEx_PLLSAI1_ConfigNP>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNP(RCC_PLLSAI1InitTypeDef *PLLSAI1)
{
 8011406:	b580      	push	{r7, lr}
 8011408:	b084      	sub	sp, #16
 801140a:	af00      	add	r7, sp, #0
 801140c:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 801140e:	2300      	movs	r3, #0
 8011410:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLN_VALUE(PLLSAI1->PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLSAI1->PLLP));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 8011412:	f7ff fe61 	bl	80110d8 <LL_RCC_PLLSAI1_Disable>

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8011416:	f7fb ff9b 	bl	800d350 <HAL_GetTick>
 801141a:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLSAI1 is ready to be updated */
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 801141c:	e009      	b.n	8011432 <RCCEx_PLLSAI1_ConfigNP+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 801141e:	f7fb ff97 	bl	800d350 <HAL_GetTick>
 8011422:	4602      	mov	r2, r0
 8011424:	68bb      	ldr	r3, [r7, #8]
 8011426:	1ad3      	subs	r3, r2, r3
 8011428:	2b02      	cmp	r3, #2
 801142a:	d902      	bls.n	8011432 <RCCEx_PLLSAI1_ConfigNP+0x2c>
    {
      status = HAL_TIMEOUT;
 801142c:	2303      	movs	r3, #3
 801142e:	73fb      	strb	r3, [r7, #15]
      break;
 8011430:	e004      	b.n	801143c <RCCEx_PLLSAI1_ConfigNP+0x36>
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 8011432:	f7ff fe60 	bl	80110f6 <LL_RCC_PLLSAI1_IsReady>
 8011436:	4603      	mov	r3, r0
 8011438:	2b00      	cmp	r3, #0
 801143a:	d1f0      	bne.n	801141e <RCCEx_PLLSAI1_ConfigNP+0x18>
    }
  }

  if (status == HAL_OK)
 801143c:	7bfb      	ldrb	r3, [r7, #15]
 801143e:	2b00      	cmp	r3, #0
 8011440:	d137      	bne.n	80114b2 <RCCEx_PLLSAI1_ConfigNP+0xac>
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PLLSAI1->PLLN);
 8011442:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011446:	691b      	ldr	r3, [r3, #16]
 8011448:	f423 42fe 	bic.w	r2, r3, #32512	; 0x7f00
 801144c:	687b      	ldr	r3, [r7, #4]
 801144e:	681b      	ldr	r3, [r3, #0]
 8011450:	021b      	lsls	r3, r3, #8
 8011452:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8011456:	4313      	orrs	r3, r2
 8011458:	610b      	str	r3, [r1, #16]

    /* Configure the PLLSAI1 Division factor P */
    __HAL_RCC_PLLSAI1_DIVP_CONFIG(PLLSAI1->PLLP);
 801145a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801145e:	691b      	ldr	r3, [r3, #16]
 8011460:	f423 1278 	bic.w	r2, r3, #4063232	; 0x3e0000
 8011464:	687b      	ldr	r3, [r7, #4]
 8011466:	685b      	ldr	r3, [r3, #4]
 8011468:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 801146c:	4313      	orrs	r3, r2
 801146e:	610b      	str	r3, [r1, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 8011470:	f7ff fe23 	bl	80110ba <LL_RCC_PLLSAI1_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8011474:	f7fb ff6c 	bl	800d350 <HAL_GetTick>
 8011478:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI1 is ready */
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 801147a:	e009      	b.n	8011490 <RCCEx_PLLSAI1_ConfigNP+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 801147c:	f7fb ff68 	bl	800d350 <HAL_GetTick>
 8011480:	4602      	mov	r2, r0
 8011482:	68bb      	ldr	r3, [r7, #8]
 8011484:	1ad3      	subs	r3, r2, r3
 8011486:	2b02      	cmp	r3, #2
 8011488:	d902      	bls.n	8011490 <RCCEx_PLLSAI1_ConfigNP+0x8a>
      {
        status = HAL_TIMEOUT;
 801148a:	2303      	movs	r3, #3
 801148c:	73fb      	strb	r3, [r7, #15]
        break;
 801148e:	e004      	b.n	801149a <RCCEx_PLLSAI1_ConfigNP+0x94>
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 8011490:	f7ff fe31 	bl	80110f6 <LL_RCC_PLLSAI1_IsReady>
 8011494:	4603      	mov	r3, r0
 8011496:	2b01      	cmp	r3, #1
 8011498:	d1f0      	bne.n	801147c <RCCEx_PLLSAI1_ConfigNP+0x76>
      }
    }

    if (status == HAL_OK)
 801149a:	7bfb      	ldrb	r3, [r7, #15]
 801149c:	2b00      	cmp	r3, #0
 801149e:	d108      	bne.n	80114b2 <RCCEx_PLLSAI1_ConfigNP+0xac>
    {
      /* Configure the PLLSAI1 Clock output(s) */
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
 80114a0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80114a4:	691a      	ldr	r2, [r3, #16]
 80114a6:	687b      	ldr	r3, [r7, #4]
 80114a8:	691b      	ldr	r3, [r3, #16]
 80114aa:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80114ae:	4313      	orrs	r3, r2
 80114b0:	610b      	str	r3, [r1, #16]
    }
  }

  return status;
 80114b2:	7bfb      	ldrb	r3, [r7, #15]
}
 80114b4:	4618      	mov	r0, r3
 80114b6:	3710      	adds	r7, #16
 80114b8:	46bd      	mov	sp, r7
 80114ba:	bd80      	pop	{r7, pc}

080114bc <RCCEx_PLLSAI1_ConfigNQ>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNQ(RCC_PLLSAI1InitTypeDef *PLLSAI1)
{
 80114bc:	b580      	push	{r7, lr}
 80114be:	b084      	sub	sp, #16
 80114c0:	af00      	add	r7, sp, #0
 80114c2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 80114c4:	2300      	movs	r3, #0
 80114c6:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLN_VALUE(PLLSAI1->PLLN));
  assert_param(IS_RCC_PLLQ_VALUE(PLLSAI1->PLLQ));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 80114c8:	f7ff fe06 	bl	80110d8 <LL_RCC_PLLSAI1_Disable>

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 80114cc:	f7fb ff40 	bl	800d350 <HAL_GetTick>
 80114d0:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLSAI1 is ready to be updated */
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 80114d2:	e009      	b.n	80114e8 <RCCEx_PLLSAI1_ConfigNQ+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80114d4:	f7fb ff3c 	bl	800d350 <HAL_GetTick>
 80114d8:	4602      	mov	r2, r0
 80114da:	68bb      	ldr	r3, [r7, #8]
 80114dc:	1ad3      	subs	r3, r2, r3
 80114de:	2b02      	cmp	r3, #2
 80114e0:	d902      	bls.n	80114e8 <RCCEx_PLLSAI1_ConfigNQ+0x2c>
    {
      status = HAL_TIMEOUT;
 80114e2:	2303      	movs	r3, #3
 80114e4:	73fb      	strb	r3, [r7, #15]
      break;
 80114e6:	e004      	b.n	80114f2 <RCCEx_PLLSAI1_ConfigNQ+0x36>
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 80114e8:	f7ff fe05 	bl	80110f6 <LL_RCC_PLLSAI1_IsReady>
 80114ec:	4603      	mov	r3, r0
 80114ee:	2b00      	cmp	r3, #0
 80114f0:	d1f0      	bne.n	80114d4 <RCCEx_PLLSAI1_ConfigNQ+0x18>
    }
  }

  if (status == HAL_OK)
 80114f2:	7bfb      	ldrb	r3, [r7, #15]
 80114f4:	2b00      	cmp	r3, #0
 80114f6:	d137      	bne.n	8011568 <RCCEx_PLLSAI1_ConfigNQ+0xac>
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PLLSAI1->PLLN);
 80114f8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80114fc:	691b      	ldr	r3, [r3, #16]
 80114fe:	f423 42fe 	bic.w	r2, r3, #32512	; 0x7f00
 8011502:	687b      	ldr	r3, [r7, #4]
 8011504:	681b      	ldr	r3, [r3, #0]
 8011506:	021b      	lsls	r3, r3, #8
 8011508:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 801150c:	4313      	orrs	r3, r2
 801150e:	610b      	str	r3, [r1, #16]
    /* Configure the PLLSAI1 Division factor Q */
    __HAL_RCC_PLLSAI1_DIVQ_CONFIG(PLLSAI1->PLLQ);
 8011510:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011514:	691b      	ldr	r3, [r3, #16]
 8011516:	f023 6260 	bic.w	r2, r3, #234881024	; 0xe000000
 801151a:	687b      	ldr	r3, [r7, #4]
 801151c:	689b      	ldr	r3, [r3, #8]
 801151e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8011522:	4313      	orrs	r3, r2
 8011524:	610b      	str	r3, [r1, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 8011526:	f7ff fdc8 	bl	80110ba <LL_RCC_PLLSAI1_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 801152a:	f7fb ff11 	bl	800d350 <HAL_GetTick>
 801152e:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI1 is ready */
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 8011530:	e009      	b.n	8011546 <RCCEx_PLLSAI1_ConfigNQ+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8011532:	f7fb ff0d 	bl	800d350 <HAL_GetTick>
 8011536:	4602      	mov	r2, r0
 8011538:	68bb      	ldr	r3, [r7, #8]
 801153a:	1ad3      	subs	r3, r2, r3
 801153c:	2b02      	cmp	r3, #2
 801153e:	d902      	bls.n	8011546 <RCCEx_PLLSAI1_ConfigNQ+0x8a>
      {
        status = HAL_TIMEOUT;
 8011540:	2303      	movs	r3, #3
 8011542:	73fb      	strb	r3, [r7, #15]
        break;
 8011544:	e004      	b.n	8011550 <RCCEx_PLLSAI1_ConfigNQ+0x94>
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 8011546:	f7ff fdd6 	bl	80110f6 <LL_RCC_PLLSAI1_IsReady>
 801154a:	4603      	mov	r3, r0
 801154c:	2b01      	cmp	r3, #1
 801154e:	d1f0      	bne.n	8011532 <RCCEx_PLLSAI1_ConfigNQ+0x76>
      }
    }

    if (status == HAL_OK)
 8011550:	7bfb      	ldrb	r3, [r7, #15]
 8011552:	2b00      	cmp	r3, #0
 8011554:	d108      	bne.n	8011568 <RCCEx_PLLSAI1_ConfigNQ+0xac>
    {
      /* Configure the PLLSAI1 Clock output(s) */
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
 8011556:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801155a:	691a      	ldr	r2, [r3, #16]
 801155c:	687b      	ldr	r3, [r7, #4]
 801155e:	691b      	ldr	r3, [r3, #16]
 8011560:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8011564:	4313      	orrs	r3, r2
 8011566:	610b      	str	r3, [r1, #16]
    }
  }

  return status;
 8011568:	7bfb      	ldrb	r3, [r7, #15]
}
 801156a:	4618      	mov	r0, r3
 801156c:	3710      	adds	r7, #16
 801156e:	46bd      	mov	sp, r7
 8011570:	bd80      	pop	{r7, pc}

08011572 <RCCEx_PLLSAI1_ConfigNR>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNR(RCC_PLLSAI1InitTypeDef *PLLSAI1)
{
 8011572:	b580      	push	{r7, lr}
 8011574:	b084      	sub	sp, #16
 8011576:	af00      	add	r7, sp, #0
 8011578:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 801157a:	2300      	movs	r3, #0
 801157c:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLN_VALUE(PLLSAI1->PLLN));
  assert_param(IS_RCC_PLLR_VALUE(PLLSAI1->PLLR));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 801157e:	f7ff fdab 	bl	80110d8 <LL_RCC_PLLSAI1_Disable>

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8011582:	f7fb fee5 	bl	800d350 <HAL_GetTick>
 8011586:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLSAI1 is ready to be updated */
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 8011588:	e009      	b.n	801159e <RCCEx_PLLSAI1_ConfigNR+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 801158a:	f7fb fee1 	bl	800d350 <HAL_GetTick>
 801158e:	4602      	mov	r2, r0
 8011590:	68bb      	ldr	r3, [r7, #8]
 8011592:	1ad3      	subs	r3, r2, r3
 8011594:	2b02      	cmp	r3, #2
 8011596:	d902      	bls.n	801159e <RCCEx_PLLSAI1_ConfigNR+0x2c>
    {
      status = HAL_TIMEOUT;
 8011598:	2303      	movs	r3, #3
 801159a:	73fb      	strb	r3, [r7, #15]
      break;
 801159c:	e004      	b.n	80115a8 <RCCEx_PLLSAI1_ConfigNR+0x36>
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 801159e:	f7ff fdaa 	bl	80110f6 <LL_RCC_PLLSAI1_IsReady>
 80115a2:	4603      	mov	r3, r0
 80115a4:	2b00      	cmp	r3, #0
 80115a6:	d1f0      	bne.n	801158a <RCCEx_PLLSAI1_ConfigNR+0x18>
    }
  }

  if (status == HAL_OK)
 80115a8:	7bfb      	ldrb	r3, [r7, #15]
 80115aa:	2b00      	cmp	r3, #0
 80115ac:	d137      	bne.n	801161e <RCCEx_PLLSAI1_ConfigNR+0xac>
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PLLSAI1->PLLN);
 80115ae:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80115b2:	691b      	ldr	r3, [r3, #16]
 80115b4:	f423 42fe 	bic.w	r2, r3, #32512	; 0x7f00
 80115b8:	687b      	ldr	r3, [r7, #4]
 80115ba:	681b      	ldr	r3, [r3, #0]
 80115bc:	021b      	lsls	r3, r3, #8
 80115be:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80115c2:	4313      	orrs	r3, r2
 80115c4:	610b      	str	r3, [r1, #16]
    /* Configure the PLLSAI1 Division factor R */
    __HAL_RCC_PLLSAI1_DIVR_CONFIG(PLLSAI1->PLLR);
 80115c6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80115ca:	691b      	ldr	r3, [r3, #16]
 80115cc:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
 80115d0:	687b      	ldr	r3, [r7, #4]
 80115d2:	68db      	ldr	r3, [r3, #12]
 80115d4:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80115d8:	4313      	orrs	r3, r2
 80115da:	610b      	str	r3, [r1, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 80115dc:	f7ff fd6d 	bl	80110ba <LL_RCC_PLLSAI1_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80115e0:	f7fb feb6 	bl	800d350 <HAL_GetTick>
 80115e4:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI1 is ready */
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 80115e6:	e009      	b.n	80115fc <RCCEx_PLLSAI1_ConfigNR+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80115e8:	f7fb feb2 	bl	800d350 <HAL_GetTick>
 80115ec:	4602      	mov	r2, r0
 80115ee:	68bb      	ldr	r3, [r7, #8]
 80115f0:	1ad3      	subs	r3, r2, r3
 80115f2:	2b02      	cmp	r3, #2
 80115f4:	d902      	bls.n	80115fc <RCCEx_PLLSAI1_ConfigNR+0x8a>
      {
        status = HAL_TIMEOUT;
 80115f6:	2303      	movs	r3, #3
 80115f8:	73fb      	strb	r3, [r7, #15]
        break;
 80115fa:	e004      	b.n	8011606 <RCCEx_PLLSAI1_ConfigNR+0x94>
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 80115fc:	f7ff fd7b 	bl	80110f6 <LL_RCC_PLLSAI1_IsReady>
 8011600:	4603      	mov	r3, r0
 8011602:	2b01      	cmp	r3, #1
 8011604:	d1f0      	bne.n	80115e8 <RCCEx_PLLSAI1_ConfigNR+0x76>
      }
    }

    if (status == HAL_OK)
 8011606:	7bfb      	ldrb	r3, [r7, #15]
 8011608:	2b00      	cmp	r3, #0
 801160a:	d108      	bne.n	801161e <RCCEx_PLLSAI1_ConfigNR+0xac>
    {
      /* Configure the PLLSAI1 Clock output(s) */
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
 801160c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8011610:	691a      	ldr	r2, [r3, #16]
 8011612:	687b      	ldr	r3, [r7, #4]
 8011614:	691b      	ldr	r3, [r3, #16]
 8011616:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 801161a:	4313      	orrs	r3, r2
 801161c:	610b      	str	r3, [r1, #16]
    }
  }

  return status;
 801161e:	7bfb      	ldrb	r3, [r7, #15]
}
 8011620:	4618      	mov	r0, r3
 8011622:	3710      	adds	r7, #16
 8011624:	46bd      	mov	sp, r7
 8011626:	bd80      	pop	{r7, pc}

08011628 <HAL_RTC_Init>:
  * @brief  Initialize the RTC peripheral
  * @param hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
 8011628:	b580      	push	{r7, lr}
 801162a:	b082      	sub	sp, #8
 801162c:	af00      	add	r7, sp, #0
 801162e:	6078      	str	r0, [r7, #4]
  /* Check the RTC peripheral state */
  if(hrtc == NULL)
 8011630:	687b      	ldr	r3, [r7, #4]
 8011632:	2b00      	cmp	r3, #0
 8011634:	d101      	bne.n	801163a <HAL_RTC_Init+0x12>
  {
     return HAL_ERROR;
 8011636:	2301      	movs	r3, #1
 8011638:	e090      	b.n	801175c <HAL_RTC_Init+0x134>
    {
      hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
    }
  }
#else
  if(hrtc->State == HAL_RTC_STATE_RESET)
 801163a:	687b      	ldr	r3, [r7, #4]
 801163c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8011640:	b2db      	uxtb	r3, r3
 8011642:	2b00      	cmp	r3, #0
 8011644:	d106      	bne.n	8011654 <HAL_RTC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hrtc->Lock = HAL_UNLOCKED;
 8011646:	687b      	ldr	r3, [r7, #4]
 8011648:	2200      	movs	r2, #0
 801164a:	f883 2020 	strb.w	r2, [r3, #32]

    /* Initialize RTC MSP */
    HAL_RTC_MspInit(hrtc);
 801164e:	6878      	ldr	r0, [r7, #4]
 8011650:	f7fb fbc4 	bl	800cddc <HAL_RTC_MspInit>
  }
#endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */

  /* Set RTC state */
  hrtc->State = HAL_RTC_STATE_BUSY;
 8011654:	687b      	ldr	r3, [r7, #4]
 8011656:	2202      	movs	r2, #2
 8011658:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 801165c:	687b      	ldr	r3, [r7, #4]
 801165e:	681b      	ldr	r3, [r3, #0]
 8011660:	22ca      	movs	r2, #202	; 0xca
 8011662:	625a      	str	r2, [r3, #36]	; 0x24
 8011664:	687b      	ldr	r3, [r7, #4]
 8011666:	681b      	ldr	r3, [r3, #0]
 8011668:	2253      	movs	r2, #83	; 0x53
 801166a:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 801166c:	6878      	ldr	r0, [r7, #4]
 801166e:	f000 f89f 	bl	80117b0 <RTC_EnterInitMode>
 8011672:	4603      	mov	r3, r0
 8011674:	2b00      	cmp	r3, #0
 8011676:	d009      	beq.n	801168c <HAL_RTC_Init+0x64>
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8011678:	687b      	ldr	r3, [r7, #4]
 801167a:	681b      	ldr	r3, [r3, #0]
 801167c:	22ff      	movs	r2, #255	; 0xff
 801167e:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_ERROR;
 8011680:	687b      	ldr	r3, [r7, #4]
 8011682:	2204      	movs	r2, #4
 8011684:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

    return HAL_ERROR;
 8011688:	2301      	movs	r3, #1
 801168a:	e067      	b.n	801175c <HAL_RTC_Init+0x134>
  }
  else
  {
    /* Clear RTC_CR FMT, OSEL and POL Bits */
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 801168c:	687b      	ldr	r3, [r7, #4]
 801168e:	681b      	ldr	r3, [r3, #0]
 8011690:	689b      	ldr	r3, [r3, #8]
 8011692:	687a      	ldr	r2, [r7, #4]
 8011694:	6812      	ldr	r2, [r2, #0]
 8011696:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 801169a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801169e:	6093      	str	r3, [r2, #8]
    /* Set RTC_CR register */
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 80116a0:	687b      	ldr	r3, [r7, #4]
 80116a2:	681b      	ldr	r3, [r3, #0]
 80116a4:	6899      	ldr	r1, [r3, #8]
 80116a6:	687b      	ldr	r3, [r7, #4]
 80116a8:	685a      	ldr	r2, [r3, #4]
 80116aa:	687b      	ldr	r3, [r7, #4]
 80116ac:	691b      	ldr	r3, [r3, #16]
 80116ae:	431a      	orrs	r2, r3
 80116b0:	687b      	ldr	r3, [r7, #4]
 80116b2:	699b      	ldr	r3, [r3, #24]
 80116b4:	431a      	orrs	r2, r3
 80116b6:	687b      	ldr	r3, [r7, #4]
 80116b8:	681b      	ldr	r3, [r3, #0]
 80116ba:	430a      	orrs	r2, r1
 80116bc:	609a      	str	r2, [r3, #8]

    /* Configure the RTC PRER */
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 80116be:	687b      	ldr	r3, [r7, #4]
 80116c0:	681b      	ldr	r3, [r3, #0]
 80116c2:	687a      	ldr	r2, [r7, #4]
 80116c4:	68d2      	ldr	r2, [r2, #12]
 80116c6:	611a      	str	r2, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16U);
 80116c8:	687b      	ldr	r3, [r7, #4]
 80116ca:	681b      	ldr	r3, [r3, #0]
 80116cc:	6919      	ldr	r1, [r3, #16]
 80116ce:	687b      	ldr	r3, [r7, #4]
 80116d0:	689b      	ldr	r3, [r3, #8]
 80116d2:	041a      	lsls	r2, r3, #16
 80116d4:	687b      	ldr	r3, [r7, #4]
 80116d6:	681b      	ldr	r3, [r3, #0]
 80116d8:	430a      	orrs	r2, r1
 80116da:	611a      	str	r2, [r3, #16]

    /* Exit Initialization mode */
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 80116dc:	687b      	ldr	r3, [r7, #4]
 80116de:	681b      	ldr	r3, [r3, #0]
 80116e0:	68da      	ldr	r2, [r3, #12]
 80116e2:	687b      	ldr	r3, [r7, #4]
 80116e4:	681b      	ldr	r3, [r3, #0]
 80116e6:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80116ea:	60da      	str	r2, [r3, #12]

    hrtc->Instance->OR &= (uint32_t)~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 80116ec:	687b      	ldr	r3, [r7, #4]
 80116ee:	681b      	ldr	r3, [r3, #0]
 80116f0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80116f2:	687b      	ldr	r3, [r7, #4]
 80116f4:	681b      	ldr	r3, [r3, #0]
 80116f6:	f022 0203 	bic.w	r2, r2, #3
 80116fa:	64da      	str	r2, [r3, #76]	; 0x4c
    hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 80116fc:	687b      	ldr	r3, [r7, #4]
 80116fe:	681b      	ldr	r3, [r3, #0]
 8011700:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8011702:	687b      	ldr	r3, [r7, #4]
 8011704:	69da      	ldr	r2, [r3, #28]
 8011706:	687b      	ldr	r3, [r7, #4]
 8011708:	695b      	ldr	r3, [r3, #20]
 801170a:	431a      	orrs	r2, r3
 801170c:	687b      	ldr	r3, [r7, #4]
 801170e:	681b      	ldr	r3, [r3, #0]
 8011710:	430a      	orrs	r2, r1
 8011712:	64da      	str	r2, [r3, #76]	; 0x4c

    /* If CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == 0U)
 8011714:	687b      	ldr	r3, [r7, #4]
 8011716:	681b      	ldr	r3, [r3, #0]
 8011718:	689b      	ldr	r3, [r3, #8]
 801171a:	f003 0320 	and.w	r3, r3, #32
 801171e:	2b00      	cmp	r3, #0
 8011720:	d113      	bne.n	801174a <HAL_RTC_Init+0x122>
    {
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8011722:	6878      	ldr	r0, [r7, #4]
 8011724:	f000 f81e 	bl	8011764 <HAL_RTC_WaitForSynchro>
 8011728:	4603      	mov	r3, r0
 801172a:	2b00      	cmp	r3, #0
 801172c:	d00d      	beq.n	801174a <HAL_RTC_Init+0x122>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 801172e:	687b      	ldr	r3, [r7, #4]
 8011730:	681b      	ldr	r3, [r3, #0]
 8011732:	22ff      	movs	r2, #255	; 0xff
 8011734:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_ERROR;
 8011736:	687b      	ldr	r3, [r7, #4]
 8011738:	2204      	movs	r2, #4
 801173a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

        /* Process Unlocked */ 
        __HAL_UNLOCK(hrtc);
 801173e:	687b      	ldr	r3, [r7, #4]
 8011740:	2200      	movs	r2, #0
 8011742:	f883 2020 	strb.w	r2, [r3, #32]

        return HAL_ERROR;
 8011746:	2301      	movs	r3, #1
 8011748:	e008      	b.n	801175c <HAL_RTC_Init+0x134>
      }
    }

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 801174a:	687b      	ldr	r3, [r7, #4]
 801174c:	681b      	ldr	r3, [r3, #0]
 801174e:	22ff      	movs	r2, #255	; 0xff
 8011750:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_READY;
 8011752:	687b      	ldr	r3, [r7, #4]
 8011754:	2201      	movs	r2, #1
 8011756:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

    return HAL_OK;
 801175a:	2300      	movs	r3, #0
  }
}
 801175c:	4618      	mov	r0, r3
 801175e:	3708      	adds	r7, #8
 8011760:	46bd      	mov	sp, r7
 8011762:	bd80      	pop	{r7, pc}

08011764 <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
{
 8011764:	b580      	push	{r7, lr}
 8011766:	b084      	sub	sp, #16
 8011768:	af00      	add	r7, sp, #0
 801176a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Clear RSF flag */
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 801176c:	687b      	ldr	r3, [r7, #4]
 801176e:	681b      	ldr	r3, [r3, #0]
 8011770:	68da      	ldr	r2, [r3, #12]
 8011772:	687b      	ldr	r3, [r7, #4]
 8011774:	681b      	ldr	r3, [r3, #0]
 8011776:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 801177a:	60da      	str	r2, [r3, #12]

  tickstart = HAL_GetTick();
 801177c:	f7fb fde8 	bl	800d350 <HAL_GetTick>
 8011780:	60f8      	str	r0, [r7, #12]

  /* Wait the registers to be synchronised */
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 8011782:	e009      	b.n	8011798 <HAL_RTC_WaitForSynchro+0x34>
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8011784:	f7fb fde4 	bl	800d350 <HAL_GetTick>
 8011788:	4602      	mov	r2, r0
 801178a:	68fb      	ldr	r3, [r7, #12]
 801178c:	1ad3      	subs	r3, r2, r3
 801178e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8011792:	d901      	bls.n	8011798 <HAL_RTC_WaitForSynchro+0x34>
    {
      return HAL_TIMEOUT;
 8011794:	2303      	movs	r3, #3
 8011796:	e007      	b.n	80117a8 <HAL_RTC_WaitForSynchro+0x44>
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 8011798:	687b      	ldr	r3, [r7, #4]
 801179a:	681b      	ldr	r3, [r3, #0]
 801179c:	68db      	ldr	r3, [r3, #12]
 801179e:	f003 0320 	and.w	r3, r3, #32
 80117a2:	2b00      	cmp	r3, #0
 80117a4:	d0ee      	beq.n	8011784 <HAL_RTC_WaitForSynchro+0x20>
    }
  }

  return HAL_OK;
 80117a6:	2300      	movs	r3, #0
}
 80117a8:	4618      	mov	r0, r3
 80117aa:	3710      	adds	r7, #16
 80117ac:	46bd      	mov	sp, r7
 80117ae:	bd80      	pop	{r7, pc}

080117b0 <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
{
 80117b0:	b580      	push	{r7, lr}
 80117b2:	b084      	sub	sp, #16
 80117b4:	af00      	add	r7, sp, #0
 80117b6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check if the Initialization mode is set */
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 80117b8:	687b      	ldr	r3, [r7, #4]
 80117ba:	681b      	ldr	r3, [r3, #0]
 80117bc:	68db      	ldr	r3, [r3, #12]
 80117be:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80117c2:	2b00      	cmp	r3, #0
 80117c4:	d119      	bne.n	80117fa <RTC_EnterInitMode+0x4a>
  {
    /* Set the Initialization mode */
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 80117c6:	687b      	ldr	r3, [r7, #4]
 80117c8:	681b      	ldr	r3, [r3, #0]
 80117ca:	f04f 32ff 	mov.w	r2, #4294967295
 80117ce:	60da      	str	r2, [r3, #12]

    tickstart = HAL_GetTick();
 80117d0:	f7fb fdbe 	bl	800d350 <HAL_GetTick>
 80117d4:	60f8      	str	r0, [r7, #12]
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 80117d6:	e009      	b.n	80117ec <RTC_EnterInitMode+0x3c>
    {
      if((HAL_GetTick()  - tickstart ) > RTC_TIMEOUT_VALUE)
 80117d8:	f7fb fdba 	bl	800d350 <HAL_GetTick>
 80117dc:	4602      	mov	r2, r0
 80117de:	68fb      	ldr	r3, [r7, #12]
 80117e0:	1ad3      	subs	r3, r2, r3
 80117e2:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80117e6:	d901      	bls.n	80117ec <RTC_EnterInitMode+0x3c>
      {
        return HAL_TIMEOUT;
 80117e8:	2303      	movs	r3, #3
 80117ea:	e007      	b.n	80117fc <RTC_EnterInitMode+0x4c>
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 80117ec:	687b      	ldr	r3, [r7, #4]
 80117ee:	681b      	ldr	r3, [r3, #0]
 80117f0:	68db      	ldr	r3, [r3, #12]
 80117f2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80117f6:	2b00      	cmp	r3, #0
 80117f8:	d0ee      	beq.n	80117d8 <RTC_EnterInitMode+0x28>
      }
    }
  }

  return HAL_OK;
 80117fa:	2300      	movs	r3, #0
}
 80117fc:	4618      	mov	r0, r3
 80117fe:	3710      	adds	r7, #16
 8011800:	46bd      	mov	sp, r7
 8011802:	bd80      	pop	{r7, pc}

08011804 <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8011804:	b580      	push	{r7, lr}
 8011806:	b084      	sub	sp, #16
 8011808:	af00      	add	r7, sp, #0
 801180a:	6078      	str	r0, [r7, #4]
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 801180c:	687b      	ldr	r3, [r7, #4]
 801180e:	2b00      	cmp	r3, #0
 8011810:	d101      	bne.n	8011816 <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 8011812:	2301      	movs	r3, #1
 8011814:	e095      	b.n	8011942 <HAL_SPI_Init+0x13e>
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
  assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 8011816:	687b      	ldr	r3, [r7, #4]
 8011818:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801181a:	2b00      	cmp	r3, #0
 801181c:	d108      	bne.n	8011830 <HAL_SPI_Init+0x2c>
  {
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));

    if (hspi->Init.Mode == SPI_MODE_MASTER)
 801181e:	687b      	ldr	r3, [r7, #4]
 8011820:	685b      	ldr	r3, [r3, #4]
 8011822:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8011826:	d009      	beq.n	801183c <HAL_SPI_Init+0x38>
      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    }
    else
    {
      /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8011828:	687b      	ldr	r3, [r7, #4]
 801182a:	2200      	movs	r2, #0
 801182c:	61da      	str	r2, [r3, #28]
 801182e:	e005      	b.n	801183c <HAL_SPI_Init+0x38>
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 8011830:	687b      	ldr	r3, [r7, #4]
 8011832:	2200      	movs	r2, #0
 8011834:	611a      	str	r2, [r3, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 8011836:	687b      	ldr	r3, [r7, #4]
 8011838:	2200      	movs	r2, #0
 801183a:	615a      	str	r2, [r3, #20]
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 801183c:	687b      	ldr	r3, [r7, #4]
 801183e:	2200      	movs	r2, #0
 8011840:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 8011842:	687b      	ldr	r3, [r7, #4]
 8011844:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8011848:	b2db      	uxtb	r3, r3
 801184a:	2b00      	cmp	r3, #0
 801184c:	d106      	bne.n	801185c <HAL_SPI_Init+0x58>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 801184e:	687b      	ldr	r3, [r7, #4]
 8011850:	2200      	movs	r2, #0
 8011852:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 8011856:	6878      	ldr	r0, [r7, #4]
 8011858:	f7fb fad6 	bl	800ce08 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 801185c:	687b      	ldr	r3, [r7, #4]
 801185e:	2202      	movs	r2, #2
 8011860:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8011864:	687b      	ldr	r3, [r7, #4]
 8011866:	681b      	ldr	r3, [r3, #0]
 8011868:	681a      	ldr	r2, [r3, #0]
 801186a:	687b      	ldr	r3, [r7, #4]
 801186c:	681b      	ldr	r3, [r3, #0]
 801186e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8011872:	601a      	str	r2, [r3, #0]

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8011874:	687b      	ldr	r3, [r7, #4]
 8011876:	68db      	ldr	r3, [r3, #12]
 8011878:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 801187c:	d902      	bls.n	8011884 <HAL_SPI_Init+0x80>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 801187e:	2300      	movs	r3, #0
 8011880:	60fb      	str	r3, [r7, #12]
 8011882:	e002      	b.n	801188a <HAL_SPI_Init+0x86>
  }
  else
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 8011884:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8011888:	60fb      	str	r3, [r7, #12]
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 801188a:	687b      	ldr	r3, [r7, #4]
 801188c:	68db      	ldr	r3, [r3, #12]
 801188e:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 8011892:	d007      	beq.n	80118a4 <HAL_SPI_Init+0xa0>
 8011894:	687b      	ldr	r3, [r7, #4]
 8011896:	68db      	ldr	r3, [r3, #12]
 8011898:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 801189c:	d002      	beq.n	80118a4 <HAL_SPI_Init+0xa0>
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 801189e:	687b      	ldr	r3, [r7, #4]
 80118a0:	2200      	movs	r2, #0
 80118a2:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80118a4:	687b      	ldr	r3, [r7, #4]
 80118a6:	685b      	ldr	r3, [r3, #4]
 80118a8:	f403 7282 	and.w	r2, r3, #260	; 0x104
 80118ac:	687b      	ldr	r3, [r7, #4]
 80118ae:	689b      	ldr	r3, [r3, #8]
 80118b0:	f403 4304 	and.w	r3, r3, #33792	; 0x8400
 80118b4:	431a      	orrs	r2, r3
 80118b6:	687b      	ldr	r3, [r7, #4]
 80118b8:	691b      	ldr	r3, [r3, #16]
 80118ba:	f003 0302 	and.w	r3, r3, #2
 80118be:	431a      	orrs	r2, r3
 80118c0:	687b      	ldr	r3, [r7, #4]
 80118c2:	695b      	ldr	r3, [r3, #20]
 80118c4:	f003 0301 	and.w	r3, r3, #1
 80118c8:	431a      	orrs	r2, r3
 80118ca:	687b      	ldr	r3, [r7, #4]
 80118cc:	699b      	ldr	r3, [r3, #24]
 80118ce:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80118d2:	431a      	orrs	r2, r3
 80118d4:	687b      	ldr	r3, [r7, #4]
 80118d6:	69db      	ldr	r3, [r3, #28]
 80118d8:	f003 0338 	and.w	r3, r3, #56	; 0x38
 80118dc:	431a      	orrs	r2, r3
 80118de:	687b      	ldr	r3, [r7, #4]
 80118e0:	6a1b      	ldr	r3, [r3, #32]
 80118e2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80118e6:	ea42 0103 	orr.w	r1, r2, r3
 80118ea:	687b      	ldr	r3, [r7, #4]
 80118ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80118ee:	f403 5200 	and.w	r2, r3, #8192	; 0x2000
 80118f2:	687b      	ldr	r3, [r7, #4]
 80118f4:	681b      	ldr	r3, [r3, #0]
 80118f6:	430a      	orrs	r2, r1
 80118f8:	601a      	str	r2, [r3, #0]
    }
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 80118fa:	687b      	ldr	r3, [r7, #4]
 80118fc:	699b      	ldr	r3, [r3, #24]
 80118fe:	0c1b      	lsrs	r3, r3, #16
 8011900:	f003 0204 	and.w	r2, r3, #4
 8011904:	687b      	ldr	r3, [r7, #4]
 8011906:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011908:	f003 0310 	and.w	r3, r3, #16
 801190c:	431a      	orrs	r2, r3
 801190e:	687b      	ldr	r3, [r7, #4]
 8011910:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8011912:	f003 0308 	and.w	r3, r3, #8
 8011916:	431a      	orrs	r2, r3
 8011918:	687b      	ldr	r3, [r7, #4]
 801191a:	68db      	ldr	r3, [r3, #12]
 801191c:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8011920:	ea42 0103 	orr.w	r1, r2, r3
 8011924:	68fb      	ldr	r3, [r7, #12]
 8011926:	f403 5280 	and.w	r2, r3, #4096	; 0x1000
 801192a:	687b      	ldr	r3, [r7, #4]
 801192c:	681b      	ldr	r3, [r3, #0]
 801192e:	430a      	orrs	r2, r1
 8011930:	605a      	str	r2, [r3, #4]
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8011932:	687b      	ldr	r3, [r7, #4]
 8011934:	2200      	movs	r2, #0
 8011936:	661a      	str	r2, [r3, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8011938:	687b      	ldr	r3, [r7, #4]
 801193a:	2201      	movs	r2, #1
 801193c:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

  return HAL_OK;
 8011940:	2300      	movs	r3, #0
}
 8011942:	4618      	mov	r0, r3
 8011944:	3710      	adds	r7, #16
 8011946:	46bd      	mov	sp, r7
 8011948:	bd80      	pop	{r7, pc}

0801194a <aci_gap_set_non_discoverable>:
 */

#include "ble_gap_aci.h"

tBleStatus aci_gap_set_non_discoverable( void )
{
 801194a:	b580      	push	{r7, lr}
 801194c:	b088      	sub	sp, #32
 801194e:	af00      	add	r7, sp, #0
  struct hci_request rq;
  tBleStatus status = 0;
 8011950:	2300      	movs	r3, #0
 8011952:	71fb      	strb	r3, [r7, #7]
  Osal_MemSet( &rq, 0, sizeof(rq) );
 8011954:	f107 0308 	add.w	r3, r7, #8
 8011958:	2218      	movs	r2, #24
 801195a:	2100      	movs	r1, #0
 801195c:	4618      	mov	r0, r3
 801195e:	f000 ff8b 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x3f;
 8011962:	233f      	movs	r3, #63	; 0x3f
 8011964:	813b      	strh	r3, [r7, #8]
  rq.ocf = 0x081;
 8011966:	2381      	movs	r3, #129	; 0x81
 8011968:	817b      	strh	r3, [r7, #10]
  rq.rparam = &status;
 801196a:	1dfb      	adds	r3, r7, #7
 801196c:	61bb      	str	r3, [r7, #24]
  rq.rlen = 1;
 801196e:	2301      	movs	r3, #1
 8011970:	61fb      	str	r3, [r7, #28]
  if ( hci_send_req(&rq, FALSE) < 0 )
 8011972:	f107 0308 	add.w	r3, r7, #8
 8011976:	2100      	movs	r1, #0
 8011978:	4618      	mov	r0, r3
 801197a:	f001 f931 	bl	8012be0 <hci_send_req>
 801197e:	4603      	mov	r3, r0
 8011980:	2b00      	cmp	r3, #0
 8011982:	da01      	bge.n	8011988 <aci_gap_set_non_discoverable+0x3e>
    return BLE_STATUS_TIMEOUT;
 8011984:	23ff      	movs	r3, #255	; 0xff
 8011986:	e000      	b.n	801198a <aci_gap_set_non_discoverable+0x40>
  return status;
 8011988:	79fb      	ldrb	r3, [r7, #7]
}
 801198a:	4618      	mov	r0, r3
 801198c:	3720      	adds	r7, #32
 801198e:	46bd      	mov	sp, r7
 8011990:	bd80      	pop	{r7, pc}

08011992 <aci_gap_set_discoverable>:
                                     const uint8_t* Local_Name,
                                     uint8_t Service_Uuid_length,
                                     const uint8_t* Service_Uuid_List,
                                     uint16_t Slave_Conn_Interval_Min,
                                     uint16_t Slave_Conn_Interval_Max )
{
 8011992:	b5b0      	push	{r4, r5, r7, lr}
 8011994:	b0ce      	sub	sp, #312	; 0x138
 8011996:	af00      	add	r7, sp, #0
 8011998:	4605      	mov	r5, r0
 801199a:	460c      	mov	r4, r1
 801199c:	4610      	mov	r0, r2
 801199e:	4619      	mov	r1, r3
 80119a0:	1dfb      	adds	r3, r7, #7
 80119a2:	462a      	mov	r2, r5
 80119a4:	701a      	strb	r2, [r3, #0]
 80119a6:	1d3b      	adds	r3, r7, #4
 80119a8:	4622      	mov	r2, r4
 80119aa:	801a      	strh	r2, [r3, #0]
 80119ac:	1cbb      	adds	r3, r7, #2
 80119ae:	4602      	mov	r2, r0
 80119b0:	801a      	strh	r2, [r3, #0]
 80119b2:	1dbb      	adds	r3, r7, #6
 80119b4:	460a      	mov	r2, r1
 80119b6:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gap_set_discoverable_cp0 *cp0 = (aci_gap_set_discoverable_cp0*)(cmd_buffer);
 80119b8:	f107 0310 	add.w	r3, r7, #16
 80119bc:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
  aci_gap_set_discoverable_cp1 *cp1 = (aci_gap_set_discoverable_cp1*)(cmd_buffer + 1 + 2 + 2 + 1 + 1 + 1 + Local_Name_Length * (sizeof(uint8_t)));
 80119c0:	f897 314c 	ldrb.w	r3, [r7, #332]	; 0x14c
 80119c4:	3308      	adds	r3, #8
 80119c6:	f107 0210 	add.w	r2, r7, #16
 80119ca:	4413      	add	r3, r2
 80119cc:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
  aci_gap_set_discoverable_cp2 *cp2 = (aci_gap_set_discoverable_cp2*)(cmd_buffer + 1 + 2 + 2 + 1 + 1 + 1 + Local_Name_Length * (sizeof(uint8_t)) + 1 + Service_Uuid_length * (sizeof(uint8_t)));
 80119d0:	f897 214c 	ldrb.w	r2, [r7, #332]	; 0x14c
 80119d4:	f897 3154 	ldrb.w	r3, [r7, #340]	; 0x154
 80119d8:	4413      	add	r3, r2
 80119da:	3309      	adds	r3, #9
 80119dc:	f107 0210 	add.w	r2, r7, #16
 80119e0:	4413      	add	r3, r2
 80119e2:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 80119e6:	f107 030f 	add.w	r3, r7, #15
 80119ea:	2200      	movs	r2, #0
 80119ec:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 80119ee:	2300      	movs	r3, #0
 80119f0:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Advertising_Type = Advertising_Type;
 80119f4:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 80119f8:	1dfa      	adds	r2, r7, #7
 80119fa:	7812      	ldrb	r2, [r2, #0]
 80119fc:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 80119fe:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011a02:	3301      	adds	r3, #1
 8011a04:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Advertising_Interval_Min = Advertising_Interval_Min;
 8011a08:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8011a0c:	1d3a      	adds	r2, r7, #4
 8011a0e:	8812      	ldrh	r2, [r2, #0]
 8011a10:	f8a3 2001 	strh.w	r2, [r3, #1]
  index_input += 2;
 8011a14:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011a18:	3302      	adds	r3, #2
 8011a1a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Advertising_Interval_Max = Advertising_Interval_Max;
 8011a1e:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8011a22:	1cba      	adds	r2, r7, #2
 8011a24:	8812      	ldrh	r2, [r2, #0]
 8011a26:	f8a3 2003 	strh.w	r2, [r3, #3]
  index_input += 2;
 8011a2a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011a2e:	3302      	adds	r3, #2
 8011a30:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Own_Address_Type = Own_Address_Type;
 8011a34:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8011a38:	1dba      	adds	r2, r7, #6
 8011a3a:	7812      	ldrb	r2, [r2, #0]
 8011a3c:	715a      	strb	r2, [r3, #5]
  index_input += 1;
 8011a3e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011a42:	3301      	adds	r3, #1
 8011a44:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Advertising_Filter_Policy = Advertising_Filter_Policy;
 8011a48:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8011a4c:	f897 2148 	ldrb.w	r2, [r7, #328]	; 0x148
 8011a50:	719a      	strb	r2, [r3, #6]
  index_input += 1;
 8011a52:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011a56:	3301      	adds	r3, #1
 8011a58:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Local_Name_Length = Local_Name_Length;
 8011a5c:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8011a60:	f897 214c 	ldrb.w	r2, [r7, #332]	; 0x14c
 8011a64:	71da      	strb	r2, [r3, #7]
  index_input += 1;
 8011a66:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011a6a:	3301      	adds	r3, #1
 8011a6c:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  /* var_len_data input */
  {
    Osal_MemCpy( (void*)&cp0->Local_Name, (const void*)Local_Name, Local_Name_Length );
 8011a70:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8011a74:	3308      	adds	r3, #8
 8011a76:	f897 214c 	ldrb.w	r2, [r7, #332]	; 0x14c
 8011a7a:	f8d7 1150 	ldr.w	r1, [r7, #336]	; 0x150
 8011a7e:	4618      	mov	r0, r3
 8011a80:	f000 feea 	bl	8012858 <Osal_MemCpy>
    index_input += Local_Name_Length;
 8011a84:	f897 314c 	ldrb.w	r3, [r7, #332]	; 0x14c
 8011a88:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 8011a8c:	4413      	add	r3, r2
 8011a8e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    {
      cp1->Service_Uuid_length = Service_Uuid_length;
 8011a92:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8011a96:	f897 2154 	ldrb.w	r2, [r7, #340]	; 0x154
 8011a9a:	701a      	strb	r2, [r3, #0]
    }
    index_input += 1;
 8011a9c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011aa0:	3301      	adds	r3, #1
 8011aa2:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    Osal_MemCpy( (void*)&cp1->Service_Uuid_List, (const void*)Service_Uuid_List, Service_Uuid_length );
 8011aa6:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8011aaa:	3301      	adds	r3, #1
 8011aac:	f897 2154 	ldrb.w	r2, [r7, #340]	; 0x154
 8011ab0:	f8d7 1158 	ldr.w	r1, [r7, #344]	; 0x158
 8011ab4:	4618      	mov	r0, r3
 8011ab6:	f000 fecf 	bl	8012858 <Osal_MemCpy>
    index_input += Service_Uuid_length;
 8011aba:	f897 3154 	ldrb.w	r3, [r7, #340]	; 0x154
 8011abe:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 8011ac2:	4413      	add	r3, r2
 8011ac4:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    {
      cp2->Slave_Conn_Interval_Min = Slave_Conn_Interval_Min;
 8011ac8:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011acc:	f8b7 215c 	ldrh.w	r2, [r7, #348]	; 0x15c
 8011ad0:	801a      	strh	r2, [r3, #0]
    }
    index_input += 2;
 8011ad2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011ad6:	3302      	adds	r3, #2
 8011ad8:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    {
      cp2->Slave_Conn_Interval_Max = Slave_Conn_Interval_Max;
 8011adc:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011ae0:	f8b7 2160 	ldrh.w	r2, [r7, #352]	; 0x160
 8011ae4:	805a      	strh	r2, [r3, #2]
    }
    index_input += 2;
 8011ae6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011aea:	3302      	adds	r3, #2
 8011aec:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  }
  Osal_MemSet( &rq, 0, sizeof(rq) );
 8011af0:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8011af4:	2218      	movs	r2, #24
 8011af6:	2100      	movs	r1, #0
 8011af8:	4618      	mov	r0, r3
 8011afa:	f000 febd 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x3f;
 8011afe:	233f      	movs	r3, #63	; 0x3f
 8011b00:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x083;
 8011b04:	2383      	movs	r3, #131	; 0x83
 8011b06:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 8011b0a:	f107 0310 	add.w	r3, r7, #16
 8011b0e:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 8011b12:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011b16:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 8011b1a:	f107 030f 	add.w	r3, r7, #15
 8011b1e:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 8011b22:	2301      	movs	r3, #1
 8011b24:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 8011b28:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8011b2c:	2100      	movs	r1, #0
 8011b2e:	4618      	mov	r0, r3
 8011b30:	f001 f856 	bl	8012be0 <hci_send_req>
 8011b34:	4603      	mov	r3, r0
 8011b36:	2b00      	cmp	r3, #0
 8011b38:	da01      	bge.n	8011b3e <aci_gap_set_discoverable+0x1ac>
    return BLE_STATUS_TIMEOUT;
 8011b3a:	23ff      	movs	r3, #255	; 0xff
 8011b3c:	e002      	b.n	8011b44 <aci_gap_set_discoverable+0x1b2>
  return status;
 8011b3e:	f107 030f 	add.w	r3, r7, #15
 8011b42:	781b      	ldrb	r3, [r3, #0]
}
 8011b44:	4618      	mov	r0, r3
 8011b46:	f507 779c 	add.w	r7, r7, #312	; 0x138
 8011b4a:	46bd      	mov	sp, r7
 8011b4c:	bdb0      	pop	{r4, r5, r7, pc}

08011b4e <aci_gap_set_io_capability>:
    return BLE_STATUS_TIMEOUT;
  return status;
}

tBleStatus aci_gap_set_io_capability( uint8_t IO_Capability )
{
 8011b4e:	b580      	push	{r7, lr}
 8011b50:	b0cc      	sub	sp, #304	; 0x130
 8011b52:	af00      	add	r7, sp, #0
 8011b54:	4602      	mov	r2, r0
 8011b56:	1dfb      	adds	r3, r7, #7
 8011b58:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gap_set_io_capability_cp0 *cp0 = (aci_gap_set_io_capability_cp0*)(cmd_buffer);
 8011b5a:	f107 0310 	add.w	r3, r7, #16
 8011b5e:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 8011b62:	f107 030f 	add.w	r3, r7, #15
 8011b66:	2200      	movs	r2, #0
 8011b68:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 8011b6a:	2300      	movs	r3, #0
 8011b6c:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->IO_Capability = IO_Capability;
 8011b70:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011b74:	1dfa      	adds	r2, r7, #7
 8011b76:	7812      	ldrb	r2, [r2, #0]
 8011b78:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 8011b7a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011b7e:	3301      	adds	r3, #1
 8011b80:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 8011b84:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8011b88:	2218      	movs	r2, #24
 8011b8a:	2100      	movs	r1, #0
 8011b8c:	4618      	mov	r0, r3
 8011b8e:	f000 fe73 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x3f;
 8011b92:	233f      	movs	r3, #63	; 0x3f
 8011b94:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x085;
 8011b98:	2385      	movs	r3, #133	; 0x85
 8011b9a:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 8011b9e:	f107 0310 	add.w	r3, r7, #16
 8011ba2:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 8011ba6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011baa:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 8011bae:	f107 030f 	add.w	r3, r7, #15
 8011bb2:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 8011bb6:	2301      	movs	r3, #1
 8011bb8:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 8011bbc:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8011bc0:	2100      	movs	r1, #0
 8011bc2:	4618      	mov	r0, r3
 8011bc4:	f001 f80c 	bl	8012be0 <hci_send_req>
 8011bc8:	4603      	mov	r3, r0
 8011bca:	2b00      	cmp	r3, #0
 8011bcc:	da01      	bge.n	8011bd2 <aci_gap_set_io_capability+0x84>
    return BLE_STATUS_TIMEOUT;
 8011bce:	23ff      	movs	r3, #255	; 0xff
 8011bd0:	e002      	b.n	8011bd8 <aci_gap_set_io_capability+0x8a>
  return status;
 8011bd2:	f107 030f 	add.w	r3, r7, #15
 8011bd6:	781b      	ldrb	r3, [r3, #0]
}
 8011bd8:	4618      	mov	r0, r3
 8011bda:	f507 7798 	add.w	r7, r7, #304	; 0x130
 8011bde:	46bd      	mov	sp, r7
 8011be0:	bd80      	pop	{r7, pc}

08011be2 <aci_gap_set_authentication_requirement>:
                                                   uint8_t Min_Encryption_Key_Size,
                                                   uint8_t Max_Encryption_Key_Size,
                                                   uint8_t Use_Fixed_Pin,
                                                   uint32_t Fixed_Pin,
                                                   uint8_t Identity_Address_Type )
{
 8011be2:	b5b0      	push	{r4, r5, r7, lr}
 8011be4:	b0cc      	sub	sp, #304	; 0x130
 8011be6:	af00      	add	r7, sp, #0
 8011be8:	4605      	mov	r5, r0
 8011bea:	460c      	mov	r4, r1
 8011bec:	4610      	mov	r0, r2
 8011bee:	4619      	mov	r1, r3
 8011bf0:	1dfb      	adds	r3, r7, #7
 8011bf2:	462a      	mov	r2, r5
 8011bf4:	701a      	strb	r2, [r3, #0]
 8011bf6:	1dbb      	adds	r3, r7, #6
 8011bf8:	4622      	mov	r2, r4
 8011bfa:	701a      	strb	r2, [r3, #0]
 8011bfc:	1d7b      	adds	r3, r7, #5
 8011bfe:	4602      	mov	r2, r0
 8011c00:	701a      	strb	r2, [r3, #0]
 8011c02:	1d3b      	adds	r3, r7, #4
 8011c04:	460a      	mov	r2, r1
 8011c06:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gap_set_authentication_requirement_cp0 *cp0 = (aci_gap_set_authentication_requirement_cp0*)(cmd_buffer);
 8011c08:	f107 0310 	add.w	r3, r7, #16
 8011c0c:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 8011c10:	f107 030f 	add.w	r3, r7, #15
 8011c14:	2200      	movs	r2, #0
 8011c16:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 8011c18:	2300      	movs	r3, #0
 8011c1a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Bonding_Mode = Bonding_Mode;
 8011c1e:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011c22:	1dfa      	adds	r2, r7, #7
 8011c24:	7812      	ldrb	r2, [r2, #0]
 8011c26:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 8011c28:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011c2c:	3301      	adds	r3, #1
 8011c2e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->MITM_Mode = MITM_Mode;
 8011c32:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011c36:	1dba      	adds	r2, r7, #6
 8011c38:	7812      	ldrb	r2, [r2, #0]
 8011c3a:	705a      	strb	r2, [r3, #1]
  index_input += 1;
 8011c3c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011c40:	3301      	adds	r3, #1
 8011c42:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->SC_Support = SC_Support;
 8011c46:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011c4a:	1d7a      	adds	r2, r7, #5
 8011c4c:	7812      	ldrb	r2, [r2, #0]
 8011c4e:	709a      	strb	r2, [r3, #2]
  index_input += 1;
 8011c50:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011c54:	3301      	adds	r3, #1
 8011c56:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->KeyPress_Notification_Support = KeyPress_Notification_Support;
 8011c5a:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011c5e:	1d3a      	adds	r2, r7, #4
 8011c60:	7812      	ldrb	r2, [r2, #0]
 8011c62:	70da      	strb	r2, [r3, #3]
  index_input += 1;
 8011c64:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011c68:	3301      	adds	r3, #1
 8011c6a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Min_Encryption_Key_Size = Min_Encryption_Key_Size;
 8011c6e:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011c72:	f897 2140 	ldrb.w	r2, [r7, #320]	; 0x140
 8011c76:	711a      	strb	r2, [r3, #4]
  index_input += 1;
 8011c78:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011c7c:	3301      	adds	r3, #1
 8011c7e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Max_Encryption_Key_Size = Max_Encryption_Key_Size;
 8011c82:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011c86:	f897 2144 	ldrb.w	r2, [r7, #324]	; 0x144
 8011c8a:	715a      	strb	r2, [r3, #5]
  index_input += 1;
 8011c8c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011c90:	3301      	adds	r3, #1
 8011c92:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Use_Fixed_Pin = Use_Fixed_Pin;
 8011c96:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011c9a:	f897 2148 	ldrb.w	r2, [r7, #328]	; 0x148
 8011c9e:	719a      	strb	r2, [r3, #6]
  index_input += 1;
 8011ca0:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011ca4:	3301      	adds	r3, #1
 8011ca6:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Fixed_Pin = Fixed_Pin;
 8011caa:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011cae:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
 8011cb2:	f8c3 2007 	str.w	r2, [r3, #7]
  index_input += 4;
 8011cb6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011cba:	3304      	adds	r3, #4
 8011cbc:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Identity_Address_Type = Identity_Address_Type;
 8011cc0:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011cc4:	f897 2150 	ldrb.w	r2, [r7, #336]	; 0x150
 8011cc8:	72da      	strb	r2, [r3, #11]
  index_input += 1;
 8011cca:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011cce:	3301      	adds	r3, #1
 8011cd0:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 8011cd4:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8011cd8:	2218      	movs	r2, #24
 8011cda:	2100      	movs	r1, #0
 8011cdc:	4618      	mov	r0, r3
 8011cde:	f000 fdcb 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x3f;
 8011ce2:	233f      	movs	r3, #63	; 0x3f
 8011ce4:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x086;
 8011ce8:	2386      	movs	r3, #134	; 0x86
 8011cea:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 8011cee:	f107 0310 	add.w	r3, r7, #16
 8011cf2:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 8011cf6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011cfa:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 8011cfe:	f107 030f 	add.w	r3, r7, #15
 8011d02:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 8011d06:	2301      	movs	r3, #1
 8011d08:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 8011d0c:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8011d10:	2100      	movs	r1, #0
 8011d12:	4618      	mov	r0, r3
 8011d14:	f000 ff64 	bl	8012be0 <hci_send_req>
 8011d18:	4603      	mov	r3, r0
 8011d1a:	2b00      	cmp	r3, #0
 8011d1c:	da01      	bge.n	8011d22 <aci_gap_set_authentication_requirement+0x140>
    return BLE_STATUS_TIMEOUT;
 8011d1e:	23ff      	movs	r3, #255	; 0xff
 8011d20:	e002      	b.n	8011d28 <aci_gap_set_authentication_requirement+0x146>
  return status;
 8011d22:	f107 030f 	add.w	r3, r7, #15
 8011d26:	781b      	ldrb	r3, [r3, #0]
}
 8011d28:	4618      	mov	r0, r3
 8011d2a:	f507 7798 	add.w	r7, r7, #304	; 0x130
 8011d2e:	46bd      	mov	sp, r7
 8011d30:	bdb0      	pop	{r4, r5, r7, pc}

08011d32 <aci_gap_pass_key_resp>:
  return status;
}

tBleStatus aci_gap_pass_key_resp( uint16_t Connection_Handle,
                                  uint32_t Pass_Key )
{
 8011d32:	b580      	push	{r7, lr}
 8011d34:	b0cc      	sub	sp, #304	; 0x130
 8011d36:	af00      	add	r7, sp, #0
 8011d38:	4602      	mov	r2, r0
 8011d3a:	463b      	mov	r3, r7
 8011d3c:	6019      	str	r1, [r3, #0]
 8011d3e:	1dbb      	adds	r3, r7, #6
 8011d40:	801a      	strh	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gap_pass_key_resp_cp0 *cp0 = (aci_gap_pass_key_resp_cp0*)(cmd_buffer);
 8011d42:	f107 0310 	add.w	r3, r7, #16
 8011d46:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 8011d4a:	f107 030f 	add.w	r3, r7, #15
 8011d4e:	2200      	movs	r2, #0
 8011d50:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 8011d52:	2300      	movs	r3, #0
 8011d54:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Connection_Handle = Connection_Handle;
 8011d58:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011d5c:	1dba      	adds	r2, r7, #6
 8011d5e:	8812      	ldrh	r2, [r2, #0]
 8011d60:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 8011d62:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011d66:	3302      	adds	r3, #2
 8011d68:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Pass_Key = Pass_Key;
 8011d6c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011d70:	463a      	mov	r2, r7
 8011d72:	6812      	ldr	r2, [r2, #0]
 8011d74:	f8c3 2002 	str.w	r2, [r3, #2]
  index_input += 4;
 8011d78:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011d7c:	3304      	adds	r3, #4
 8011d7e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 8011d82:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8011d86:	2218      	movs	r2, #24
 8011d88:	2100      	movs	r1, #0
 8011d8a:	4618      	mov	r0, r3
 8011d8c:	f000 fd74 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x3f;
 8011d90:	233f      	movs	r3, #63	; 0x3f
 8011d92:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x088;
 8011d96:	2388      	movs	r3, #136	; 0x88
 8011d98:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 8011d9c:	f107 0310 	add.w	r3, r7, #16
 8011da0:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 8011da4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011da8:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 8011dac:	f107 030f 	add.w	r3, r7, #15
 8011db0:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 8011db4:	2301      	movs	r3, #1
 8011db6:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 8011dba:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8011dbe:	2100      	movs	r1, #0
 8011dc0:	4618      	mov	r0, r3
 8011dc2:	f000 ff0d 	bl	8012be0 <hci_send_req>
 8011dc6:	4603      	mov	r3, r0
 8011dc8:	2b00      	cmp	r3, #0
 8011dca:	da01      	bge.n	8011dd0 <aci_gap_pass_key_resp+0x9e>
    return BLE_STATUS_TIMEOUT;
 8011dcc:	23ff      	movs	r3, #255	; 0xff
 8011dce:	e002      	b.n	8011dd6 <aci_gap_pass_key_resp+0xa4>
  return status;
 8011dd0:	f107 030f 	add.w	r3, r7, #15
 8011dd4:	781b      	ldrb	r3, [r3, #0]
}
 8011dd6:	4618      	mov	r0, r3
 8011dd8:	f507 7798 	add.w	r7, r7, #304	; 0x130
 8011ddc:	46bd      	mov	sp, r7
 8011dde:	bd80      	pop	{r7, pc}

08011de0 <aci_gap_init>:
                         uint8_t privacy_enabled,
                         uint8_t device_name_char_len,
                         uint16_t* Service_Handle,
                         uint16_t* Dev_Name_Char_Handle,
                         uint16_t* Appearance_Char_Handle )
{
 8011de0:	b590      	push	{r4, r7, lr}
 8011de2:	b0cd      	sub	sp, #308	; 0x134
 8011de4:	af00      	add	r7, sp, #0
 8011de6:	4604      	mov	r4, r0
 8011de8:	4608      	mov	r0, r1
 8011dea:	4611      	mov	r1, r2
 8011dec:	463a      	mov	r2, r7
 8011dee:	6013      	str	r3, [r2, #0]
 8011df0:	1dfb      	adds	r3, r7, #7
 8011df2:	4622      	mov	r2, r4
 8011df4:	701a      	strb	r2, [r3, #0]
 8011df6:	1dbb      	adds	r3, r7, #6
 8011df8:	4602      	mov	r2, r0
 8011dfa:	701a      	strb	r2, [r3, #0]
 8011dfc:	1d7b      	adds	r3, r7, #5
 8011dfe:	460a      	mov	r2, r1
 8011e00:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gap_init_cp0 *cp0 = (aci_gap_init_cp0*)(cmd_buffer);
 8011e02:	f107 0310 	add.w	r3, r7, #16
 8011e06:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  aci_gap_init_rp0 resp;
  Osal_MemSet( &resp, 0, sizeof(resp) );
 8011e0a:	f107 0308 	add.w	r3, r7, #8
 8011e0e:	2207      	movs	r2, #7
 8011e10:	2100      	movs	r1, #0
 8011e12:	4618      	mov	r0, r3
 8011e14:	f000 fd30 	bl	8012878 <Osal_MemSet>
  int index_input = 0;
 8011e18:	2300      	movs	r3, #0
 8011e1a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Role = Role;
 8011e1e:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011e22:	1dfa      	adds	r2, r7, #7
 8011e24:	7812      	ldrb	r2, [r2, #0]
 8011e26:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 8011e28:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011e2c:	3301      	adds	r3, #1
 8011e2e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->privacy_enabled = privacy_enabled;
 8011e32:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011e36:	1dba      	adds	r2, r7, #6
 8011e38:	7812      	ldrb	r2, [r2, #0]
 8011e3a:	705a      	strb	r2, [r3, #1]
  index_input += 1;
 8011e3c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011e40:	3301      	adds	r3, #1
 8011e42:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->device_name_char_len = device_name_char_len;
 8011e46:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011e4a:	1d7a      	adds	r2, r7, #5
 8011e4c:	7812      	ldrb	r2, [r2, #0]
 8011e4e:	709a      	strb	r2, [r3, #2]
  index_input += 1;
 8011e50:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011e54:	3301      	adds	r3, #1
 8011e56:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 8011e5a:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8011e5e:	2218      	movs	r2, #24
 8011e60:	2100      	movs	r1, #0
 8011e62:	4618      	mov	r0, r3
 8011e64:	f000 fd08 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x3f;
 8011e68:	233f      	movs	r3, #63	; 0x3f
 8011e6a:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x08a;
 8011e6e:	238a      	movs	r3, #138	; 0x8a
 8011e70:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 8011e74:	f107 0310 	add.w	r3, r7, #16
 8011e78:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 8011e7c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011e80:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &resp;
 8011e84:	f107 0308 	add.w	r3, r7, #8
 8011e88:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = sizeof(resp);
 8011e8c:	2307      	movs	r3, #7
 8011e8e:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 8011e92:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8011e96:	2100      	movs	r1, #0
 8011e98:	4618      	mov	r0, r3
 8011e9a:	f000 fea1 	bl	8012be0 <hci_send_req>
 8011e9e:	4603      	mov	r3, r0
 8011ea0:	2b00      	cmp	r3, #0
 8011ea2:	da01      	bge.n	8011ea8 <aci_gap_init+0xc8>
    return BLE_STATUS_TIMEOUT;
 8011ea4:	23ff      	movs	r3, #255	; 0xff
 8011ea6:	e021      	b.n	8011eec <aci_gap_init+0x10c>
  if ( resp.Status )
 8011ea8:	f107 0308 	add.w	r3, r7, #8
 8011eac:	781b      	ldrb	r3, [r3, #0]
 8011eae:	2b00      	cmp	r3, #0
 8011eb0:	d003      	beq.n	8011eba <aci_gap_init+0xda>
    return resp.Status;
 8011eb2:	f107 0308 	add.w	r3, r7, #8
 8011eb6:	781b      	ldrb	r3, [r3, #0]
 8011eb8:	e018      	b.n	8011eec <aci_gap_init+0x10c>
  *Service_Handle = resp.Service_Handle;
 8011eba:	f107 0308 	add.w	r3, r7, #8
 8011ebe:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 8011ec2:	b29a      	uxth	r2, r3
 8011ec4:	463b      	mov	r3, r7
 8011ec6:	681b      	ldr	r3, [r3, #0]
 8011ec8:	801a      	strh	r2, [r3, #0]
  *Dev_Name_Char_Handle = resp.Dev_Name_Char_Handle;
 8011eca:	f107 0308 	add.w	r3, r7, #8
 8011ece:	f8b3 3003 	ldrh.w	r3, [r3, #3]
 8011ed2:	b29a      	uxth	r2, r3
 8011ed4:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8011ed8:	801a      	strh	r2, [r3, #0]
  *Appearance_Char_Handle = resp.Appearance_Char_Handle;
 8011eda:	f107 0308 	add.w	r3, r7, #8
 8011ede:	f8b3 3005 	ldrh.w	r3, [r3, #5]
 8011ee2:	b29a      	uxth	r2, r3
 8011ee4:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8011ee8:	801a      	strh	r2, [r3, #0]
  return BLE_STATUS_SUCCESS;
 8011eea:	2300      	movs	r3, #0
}
 8011eec:	4618      	mov	r0, r3
 8011eee:	f507 779a 	add.w	r7, r7, #308	; 0x134
 8011ef2:	46bd      	mov	sp, r7
 8011ef4:	bd90      	pop	{r4, r7, pc}

08011ef6 <aci_gap_update_adv_data>:
  return status;
}

tBleStatus aci_gap_update_adv_data( uint8_t AdvDataLen,
                                    const uint8_t* AdvData )
{
 8011ef6:	b580      	push	{r7, lr}
 8011ef8:	b0cc      	sub	sp, #304	; 0x130
 8011efa:	af00      	add	r7, sp, #0
 8011efc:	4602      	mov	r2, r0
 8011efe:	463b      	mov	r3, r7
 8011f00:	6019      	str	r1, [r3, #0]
 8011f02:	1dfb      	adds	r3, r7, #7
 8011f04:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gap_update_adv_data_cp0 *cp0 = (aci_gap_update_adv_data_cp0*)(cmd_buffer);
 8011f06:	f107 0310 	add.w	r3, r7, #16
 8011f0a:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 8011f0e:	f107 030f 	add.w	r3, r7, #15
 8011f12:	2200      	movs	r2, #0
 8011f14:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 8011f16:	2300      	movs	r3, #0
 8011f18:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->AdvDataLen = AdvDataLen;
 8011f1c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011f20:	1dfa      	adds	r2, r7, #7
 8011f22:	7812      	ldrb	r2, [r2, #0]
 8011f24:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 8011f26:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011f2a:	3301      	adds	r3, #1
 8011f2c:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemCpy( (void*)&cp0->AdvData, (const void*)AdvData, AdvDataLen );
 8011f30:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8011f34:	1c58      	adds	r0, r3, #1
 8011f36:	1dfb      	adds	r3, r7, #7
 8011f38:	781a      	ldrb	r2, [r3, #0]
 8011f3a:	463b      	mov	r3, r7
 8011f3c:	6819      	ldr	r1, [r3, #0]
 8011f3e:	f000 fc8b 	bl	8012858 <Osal_MemCpy>
  index_input += AdvDataLen;
 8011f42:	1dfb      	adds	r3, r7, #7
 8011f44:	781b      	ldrb	r3, [r3, #0]
 8011f46:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 8011f4a:	4413      	add	r3, r2
 8011f4c:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 8011f50:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8011f54:	2218      	movs	r2, #24
 8011f56:	2100      	movs	r1, #0
 8011f58:	4618      	mov	r0, r3
 8011f5a:	f000 fc8d 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x3f;
 8011f5e:	233f      	movs	r3, #63	; 0x3f
 8011f60:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x08e;
 8011f64:	238e      	movs	r3, #142	; 0x8e
 8011f66:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 8011f6a:	f107 0310 	add.w	r3, r7, #16
 8011f6e:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 8011f72:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8011f76:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 8011f7a:	f107 030f 	add.w	r3, r7, #15
 8011f7e:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 8011f82:	2301      	movs	r3, #1
 8011f84:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 8011f88:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8011f8c:	2100      	movs	r1, #0
 8011f8e:	4618      	mov	r0, r3
 8011f90:	f000 fe26 	bl	8012be0 <hci_send_req>
 8011f94:	4603      	mov	r3, r0
 8011f96:	2b00      	cmp	r3, #0
 8011f98:	da01      	bge.n	8011f9e <aci_gap_update_adv_data+0xa8>
    return BLE_STATUS_TIMEOUT;
 8011f9a:	23ff      	movs	r3, #255	; 0xff
 8011f9c:	e002      	b.n	8011fa4 <aci_gap_update_adv_data+0xae>
  return status;
 8011f9e:	f107 030f 	add.w	r3, r7, #15
 8011fa2:	781b      	ldrb	r3, [r3, #0]
}
 8011fa4:	4618      	mov	r0, r3
 8011fa6:	f507 7798 	add.w	r7, r7, #304	; 0x130
 8011faa:	46bd      	mov	sp, r7
 8011fac:	bd80      	pop	{r7, pc}

08011fae <aci_gap_configure_whitelist>:
    return BLE_STATUS_TIMEOUT;
  return status;
}

tBleStatus aci_gap_configure_whitelist( void )
{
 8011fae:	b580      	push	{r7, lr}
 8011fb0:	b088      	sub	sp, #32
 8011fb2:	af00      	add	r7, sp, #0
  struct hci_request rq;
  tBleStatus status = 0;
 8011fb4:	2300      	movs	r3, #0
 8011fb6:	71fb      	strb	r3, [r7, #7]
  Osal_MemSet( &rq, 0, sizeof(rq) );
 8011fb8:	f107 0308 	add.w	r3, r7, #8
 8011fbc:	2218      	movs	r2, #24
 8011fbe:	2100      	movs	r1, #0
 8011fc0:	4618      	mov	r0, r3
 8011fc2:	f000 fc59 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x3f;
 8011fc6:	233f      	movs	r3, #63	; 0x3f
 8011fc8:	813b      	strh	r3, [r7, #8]
  rq.ocf = 0x092;
 8011fca:	2392      	movs	r3, #146	; 0x92
 8011fcc:	817b      	strh	r3, [r7, #10]
  rq.rparam = &status;
 8011fce:	1dfb      	adds	r3, r7, #7
 8011fd0:	61bb      	str	r3, [r7, #24]
  rq.rlen = 1;
 8011fd2:	2301      	movs	r3, #1
 8011fd4:	61fb      	str	r3, [r7, #28]
  if ( hci_send_req(&rq, FALSE) < 0 )
 8011fd6:	f107 0308 	add.w	r3, r7, #8
 8011fda:	2100      	movs	r1, #0
 8011fdc:	4618      	mov	r0, r3
 8011fde:	f000 fdff 	bl	8012be0 <hci_send_req>
 8011fe2:	4603      	mov	r3, r0
 8011fe4:	2b00      	cmp	r3, #0
 8011fe6:	da01      	bge.n	8011fec <aci_gap_configure_whitelist+0x3e>
    return BLE_STATUS_TIMEOUT;
 8011fe8:	23ff      	movs	r3, #255	; 0xff
 8011fea:	e000      	b.n	8011fee <aci_gap_configure_whitelist+0x40>
  return status;
 8011fec:	79fb      	ldrb	r3, [r7, #7]
}
 8011fee:	4618      	mov	r0, r3
 8011ff0:	3720      	adds	r7, #32
 8011ff2:	46bd      	mov	sp, r7
 8011ff4:	bd80      	pop	{r7, pc}

08011ff6 <aci_gap_numeric_comparison_value_confirm_yesno>:
  return status;
}

tBleStatus aci_gap_numeric_comparison_value_confirm_yesno( uint16_t Connection_Handle,
                                                           uint8_t Confirm_Yes_No )
{
 8011ff6:	b580      	push	{r7, lr}
 8011ff8:	b0cc      	sub	sp, #304	; 0x130
 8011ffa:	af00      	add	r7, sp, #0
 8011ffc:	4602      	mov	r2, r0
 8011ffe:	1dbb      	adds	r3, r7, #6
 8012000:	801a      	strh	r2, [r3, #0]
 8012002:	1d7b      	adds	r3, r7, #5
 8012004:	460a      	mov	r2, r1
 8012006:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gap_numeric_comparison_value_confirm_yesno_cp0 *cp0 = (aci_gap_numeric_comparison_value_confirm_yesno_cp0*)(cmd_buffer);
 8012008:	f107 0310 	add.w	r3, r7, #16
 801200c:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 8012010:	f107 030f 	add.w	r3, r7, #15
 8012014:	2200      	movs	r2, #0
 8012016:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 8012018:	2300      	movs	r3, #0
 801201a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Connection_Handle = Connection_Handle;
 801201e:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8012022:	1dba      	adds	r2, r7, #6
 8012024:	8812      	ldrh	r2, [r2, #0]
 8012026:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 8012028:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801202c:	3302      	adds	r3, #2
 801202e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Confirm_Yes_No = Confirm_Yes_No;
 8012032:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8012036:	1d7a      	adds	r2, r7, #5
 8012038:	7812      	ldrb	r2, [r2, #0]
 801203a:	709a      	strb	r2, [r3, #2]
  index_input += 1;
 801203c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8012040:	3301      	adds	r3, #1
 8012042:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 8012046:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801204a:	2218      	movs	r2, #24
 801204c:	2100      	movs	r1, #0
 801204e:	4618      	mov	r0, r3
 8012050:	f000 fc12 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x3f;
 8012054:	233f      	movs	r3, #63	; 0x3f
 8012056:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x0a5;
 801205a:	23a5      	movs	r3, #165	; 0xa5
 801205c:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 8012060:	f107 0310 	add.w	r3, r7, #16
 8012064:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 8012068:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801206c:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 8012070:	f107 030f 	add.w	r3, r7, #15
 8012074:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 8012078:	2301      	movs	r3, #1
 801207a:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 801207e:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8012082:	2100      	movs	r1, #0
 8012084:	4618      	mov	r0, r3
 8012086:	f000 fdab 	bl	8012be0 <hci_send_req>
 801208a:	4603      	mov	r3, r0
 801208c:	2b00      	cmp	r3, #0
 801208e:	da01      	bge.n	8012094 <aci_gap_numeric_comparison_value_confirm_yesno+0x9e>
    return BLE_STATUS_TIMEOUT;
 8012090:	23ff      	movs	r3, #255	; 0xff
 8012092:	e002      	b.n	801209a <aci_gap_numeric_comparison_value_confirm_yesno+0xa4>
  return status;
 8012094:	f107 030f 	add.w	r3, r7, #15
 8012098:	781b      	ldrb	r3, [r3, #0]
}
 801209a:	4618      	mov	r0, r3
 801209c:	f507 7798 	add.w	r7, r7, #304	; 0x130
 80120a0:	46bd      	mov	sp, r7
 80120a2:	bd80      	pop	{r7, pc}

080120a4 <aci_gatt_init>:
 */

#include "ble_gatt_aci.h"

tBleStatus aci_gatt_init( void )
{
 80120a4:	b580      	push	{r7, lr}
 80120a6:	b088      	sub	sp, #32
 80120a8:	af00      	add	r7, sp, #0
  struct hci_request rq;
  tBleStatus status = 0;
 80120aa:	2300      	movs	r3, #0
 80120ac:	71fb      	strb	r3, [r7, #7]
  Osal_MemSet( &rq, 0, sizeof(rq) );
 80120ae:	f107 0308 	add.w	r3, r7, #8
 80120b2:	2218      	movs	r2, #24
 80120b4:	2100      	movs	r1, #0
 80120b6:	4618      	mov	r0, r3
 80120b8:	f000 fbde 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x3f;
 80120bc:	233f      	movs	r3, #63	; 0x3f
 80120be:	813b      	strh	r3, [r7, #8]
  rq.ocf = 0x101;
 80120c0:	f240 1301 	movw	r3, #257	; 0x101
 80120c4:	817b      	strh	r3, [r7, #10]
  rq.rparam = &status;
 80120c6:	1dfb      	adds	r3, r7, #7
 80120c8:	61bb      	str	r3, [r7, #24]
  rq.rlen = 1;
 80120ca:	2301      	movs	r3, #1
 80120cc:	61fb      	str	r3, [r7, #28]
  if ( hci_send_req(&rq, FALSE) < 0 )
 80120ce:	f107 0308 	add.w	r3, r7, #8
 80120d2:	2100      	movs	r1, #0
 80120d4:	4618      	mov	r0, r3
 80120d6:	f000 fd83 	bl	8012be0 <hci_send_req>
 80120da:	4603      	mov	r3, r0
 80120dc:	2b00      	cmp	r3, #0
 80120de:	da01      	bge.n	80120e4 <aci_gatt_init+0x40>
    return BLE_STATUS_TIMEOUT;
 80120e0:	23ff      	movs	r3, #255	; 0xff
 80120e2:	e000      	b.n	80120e6 <aci_gatt_init+0x42>
  return status;
 80120e4:	79fb      	ldrb	r3, [r7, #7]
}
 80120e6:	4618      	mov	r0, r3
 80120e8:	3720      	adds	r7, #32
 80120ea:	46bd      	mov	sp, r7
 80120ec:	bd80      	pop	{r7, pc}

080120ee <aci_gatt_add_service>:
tBleStatus aci_gatt_add_service( uint8_t Service_UUID_Type,
                                 const Service_UUID_t* Service_UUID,
                                 uint8_t Service_Type,
                                 uint8_t Max_Attribute_Records,
                                 uint16_t* Service_Handle )
{
 80120ee:	b590      	push	{r4, r7, lr}
 80120f0:	b0cf      	sub	sp, #316	; 0x13c
 80120f2:	af00      	add	r7, sp, #0
 80120f4:	4604      	mov	r4, r0
 80120f6:	4638      	mov	r0, r7
 80120f8:	6001      	str	r1, [r0, #0]
 80120fa:	4610      	mov	r0, r2
 80120fc:	4619      	mov	r1, r3
 80120fe:	1dfb      	adds	r3, r7, #7
 8012100:	4622      	mov	r2, r4
 8012102:	701a      	strb	r2, [r3, #0]
 8012104:	1dbb      	adds	r3, r7, #6
 8012106:	4602      	mov	r2, r0
 8012108:	701a      	strb	r2, [r3, #0]
 801210a:	1d7b      	adds	r3, r7, #5
 801210c:	460a      	mov	r2, r1
 801210e:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gatt_add_service_cp0 *cp0 = (aci_gatt_add_service_cp0*)(cmd_buffer);
 8012110:	f107 0310 	add.w	r3, r7, #16
 8012114:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
  aci_gatt_add_service_cp1 *cp1 = (aci_gatt_add_service_cp1*)(cmd_buffer + 1 + (Service_UUID_Type == 1 ? 2 : (Service_UUID_Type == 2 ? 16 : 0)));
 8012118:	1dfb      	adds	r3, r7, #7
 801211a:	781b      	ldrb	r3, [r3, #0]
 801211c:	2b01      	cmp	r3, #1
 801211e:	d007      	beq.n	8012130 <aci_gatt_add_service+0x42>
 8012120:	1dfb      	adds	r3, r7, #7
 8012122:	781b      	ldrb	r3, [r3, #0]
 8012124:	2b02      	cmp	r3, #2
 8012126:	d101      	bne.n	801212c <aci_gatt_add_service+0x3e>
 8012128:	2311      	movs	r3, #17
 801212a:	e002      	b.n	8012132 <aci_gatt_add_service+0x44>
 801212c:	2301      	movs	r3, #1
 801212e:	e000      	b.n	8012132 <aci_gatt_add_service+0x44>
 8012130:	2303      	movs	r3, #3
 8012132:	f107 0210 	add.w	r2, r7, #16
 8012136:	4413      	add	r3, r2
 8012138:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  aci_gatt_add_service_rp0 resp;
  Osal_MemSet( &resp, 0, sizeof(resp) );
 801213c:	f107 030c 	add.w	r3, r7, #12
 8012140:	2203      	movs	r2, #3
 8012142:	2100      	movs	r1, #0
 8012144:	4618      	mov	r0, r3
 8012146:	f000 fb97 	bl	8012878 <Osal_MemSet>
  int index_input = 0;
 801214a:	2300      	movs	r3, #0
 801214c:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Service_UUID_Type = Service_UUID_Type;
 8012150:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8012154:	1dfa      	adds	r2, r7, #7
 8012156:	7812      	ldrb	r2, [r2, #0]
 8012158:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 801215a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801215e:	3301      	adds	r3, #1
 8012160:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  /* var_len_data input */
  {
    uint8_t size;
    switch ( Service_UUID_Type )
 8012164:	1dfb      	adds	r3, r7, #7
 8012166:	781b      	ldrb	r3, [r3, #0]
 8012168:	2b01      	cmp	r3, #1
 801216a:	d002      	beq.n	8012172 <aci_gatt_add_service+0x84>
 801216c:	2b02      	cmp	r3, #2
 801216e:	d004      	beq.n	801217a <aci_gatt_add_service+0x8c>
 8012170:	e007      	b.n	8012182 <aci_gatt_add_service+0x94>
    {
      case 1: size = 2; break;
 8012172:	2302      	movs	r3, #2
 8012174:	f887 3137 	strb.w	r3, [r7, #311]	; 0x137
 8012178:	e005      	b.n	8012186 <aci_gatt_add_service+0x98>
      case 2: size = 16; break;
 801217a:	2310      	movs	r3, #16
 801217c:	f887 3137 	strb.w	r3, [r7, #311]	; 0x137
 8012180:	e001      	b.n	8012186 <aci_gatt_add_service+0x98>
      default: return BLE_STATUS_ERROR;
 8012182:	2347      	movs	r3, #71	; 0x47
 8012184:	e05d      	b.n	8012242 <aci_gatt_add_service+0x154>
    }
    Osal_MemCpy( (void*)&cp0->Service_UUID, (const void*)Service_UUID, size );
 8012186:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801218a:	1c58      	adds	r0, r3, #1
 801218c:	f897 2137 	ldrb.w	r2, [r7, #311]	; 0x137
 8012190:	463b      	mov	r3, r7
 8012192:	6819      	ldr	r1, [r3, #0]
 8012194:	f000 fb60 	bl	8012858 <Osal_MemCpy>
    index_input += size;
 8012198:	f897 3137 	ldrb.w	r3, [r7, #311]	; 0x137
 801219c:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 80121a0:	4413      	add	r3, r2
 80121a2:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    {
      cp1->Service_Type = Service_Type;
 80121a6:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80121aa:	1dba      	adds	r2, r7, #6
 80121ac:	7812      	ldrb	r2, [r2, #0]
 80121ae:	701a      	strb	r2, [r3, #0]
    }
    index_input += 1;
 80121b0:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80121b4:	3301      	adds	r3, #1
 80121b6:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
    {
      cp1->Max_Attribute_Records = Max_Attribute_Records;
 80121ba:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80121be:	1d7a      	adds	r2, r7, #5
 80121c0:	7812      	ldrb	r2, [r2, #0]
 80121c2:	705a      	strb	r2, [r3, #1]
    }
    index_input += 1;
 80121c4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80121c8:	3301      	adds	r3, #1
 80121ca:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  }
  Osal_MemSet( &rq, 0, sizeof(rq) );
 80121ce:	f507 7388 	add.w	r3, r7, #272	; 0x110
 80121d2:	2218      	movs	r2, #24
 80121d4:	2100      	movs	r1, #0
 80121d6:	4618      	mov	r0, r3
 80121d8:	f000 fb4e 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x3f;
 80121dc:	233f      	movs	r3, #63	; 0x3f
 80121de:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x102;
 80121e2:	f44f 7381 	mov.w	r3, #258	; 0x102
 80121e6:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 80121ea:	f107 0310 	add.w	r3, r7, #16
 80121ee:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 80121f2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80121f6:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &resp;
 80121fa:	f107 030c 	add.w	r3, r7, #12
 80121fe:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = sizeof(resp);
 8012202:	2303      	movs	r3, #3
 8012204:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 8012208:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801220c:	2100      	movs	r1, #0
 801220e:	4618      	mov	r0, r3
 8012210:	f000 fce6 	bl	8012be0 <hci_send_req>
 8012214:	4603      	mov	r3, r0
 8012216:	2b00      	cmp	r3, #0
 8012218:	da01      	bge.n	801221e <aci_gatt_add_service+0x130>
    return BLE_STATUS_TIMEOUT;
 801221a:	23ff      	movs	r3, #255	; 0xff
 801221c:	e011      	b.n	8012242 <aci_gatt_add_service+0x154>
  if ( resp.Status )
 801221e:	f107 030c 	add.w	r3, r7, #12
 8012222:	781b      	ldrb	r3, [r3, #0]
 8012224:	2b00      	cmp	r3, #0
 8012226:	d003      	beq.n	8012230 <aci_gatt_add_service+0x142>
    return resp.Status;
 8012228:	f107 030c 	add.w	r3, r7, #12
 801222c:	781b      	ldrb	r3, [r3, #0]
 801222e:	e008      	b.n	8012242 <aci_gatt_add_service+0x154>
  *Service_Handle = resp.Service_Handle;
 8012230:	f107 030c 	add.w	r3, r7, #12
 8012234:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 8012238:	b29a      	uxth	r2, r3
 801223a:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 801223e:	801a      	strh	r2, [r3, #0]
  return BLE_STATUS_SUCCESS;
 8012240:	2300      	movs	r3, #0
}
 8012242:	4618      	mov	r0, r3
 8012244:	f507 779e 	add.w	r7, r7, #316	; 0x13c
 8012248:	46bd      	mov	sp, r7
 801224a:	bd90      	pop	{r4, r7, pc}

0801224c <aci_gatt_add_char>:
                              uint8_t Security_Permissions,
                              uint8_t GATT_Evt_Mask,
                              uint8_t Enc_Key_Size,
                              uint8_t Is_Variable,
                              uint16_t* Char_Handle )
{
 801224c:	b590      	push	{r4, r7, lr}
 801224e:	b0d1      	sub	sp, #324	; 0x144
 8012250:	af00      	add	r7, sp, #0
 8012252:	4604      	mov	r4, r0
 8012254:	4608      	mov	r0, r1
 8012256:	f107 0108 	add.w	r1, r7, #8
 801225a:	600a      	str	r2, [r1, #0]
 801225c:	4619      	mov	r1, r3
 801225e:	f107 030e 	add.w	r3, r7, #14
 8012262:	4622      	mov	r2, r4
 8012264:	801a      	strh	r2, [r3, #0]
 8012266:	f107 030d 	add.w	r3, r7, #13
 801226a:	4602      	mov	r2, r0
 801226c:	701a      	strb	r2, [r3, #0]
 801226e:	1dbb      	adds	r3, r7, #6
 8012270:	460a      	mov	r2, r1
 8012272:	801a      	strh	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gatt_add_char_cp0 *cp0 = (aci_gatt_add_char_cp0*)(cmd_buffer);
 8012274:	f107 0318 	add.w	r3, r7, #24
 8012278:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
  aci_gatt_add_char_cp1 *cp1 = (aci_gatt_add_char_cp1*)(cmd_buffer + 2 + 1 + (Char_UUID_Type == 1 ? 2 : (Char_UUID_Type == 2 ? 16 : 0)));
 801227c:	f107 030d 	add.w	r3, r7, #13
 8012280:	781b      	ldrb	r3, [r3, #0]
 8012282:	2b01      	cmp	r3, #1
 8012284:	d008      	beq.n	8012298 <aci_gatt_add_char+0x4c>
 8012286:	f107 030d 	add.w	r3, r7, #13
 801228a:	781b      	ldrb	r3, [r3, #0]
 801228c:	2b02      	cmp	r3, #2
 801228e:	d101      	bne.n	8012294 <aci_gatt_add_char+0x48>
 8012290:	2313      	movs	r3, #19
 8012292:	e002      	b.n	801229a <aci_gatt_add_char+0x4e>
 8012294:	2303      	movs	r3, #3
 8012296:	e000      	b.n	801229a <aci_gatt_add_char+0x4e>
 8012298:	2305      	movs	r3, #5
 801229a:	f107 0218 	add.w	r2, r7, #24
 801229e:	4413      	add	r3, r2
 80122a0:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
  aci_gatt_add_char_rp0 resp;
  Osal_MemSet( &resp, 0, sizeof(resp) );
 80122a4:	f107 0314 	add.w	r3, r7, #20
 80122a8:	2203      	movs	r2, #3
 80122aa:	2100      	movs	r1, #0
 80122ac:	4618      	mov	r0, r3
 80122ae:	f000 fae3 	bl	8012878 <Osal_MemSet>
  int index_input = 0;
 80122b2:	2300      	movs	r3, #0
 80122b4:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
  cp0->Service_Handle = Service_Handle;
 80122b8:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 80122bc:	f107 020e 	add.w	r2, r7, #14
 80122c0:	8812      	ldrh	r2, [r2, #0]
 80122c2:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 80122c4:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 80122c8:	3302      	adds	r3, #2
 80122ca:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
  cp0->Char_UUID_Type = Char_UUID_Type;
 80122ce:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 80122d2:	f107 020d 	add.w	r2, r7, #13
 80122d6:	7812      	ldrb	r2, [r2, #0]
 80122d8:	709a      	strb	r2, [r3, #2]
  index_input += 1;
 80122da:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 80122de:	3301      	adds	r3, #1
 80122e0:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
  /* var_len_data input */
  {
    uint8_t size;
    switch ( Char_UUID_Type )
 80122e4:	f107 030d 	add.w	r3, r7, #13
 80122e8:	781b      	ldrb	r3, [r3, #0]
 80122ea:	2b01      	cmp	r3, #1
 80122ec:	d002      	beq.n	80122f4 <aci_gatt_add_char+0xa8>
 80122ee:	2b02      	cmp	r3, #2
 80122f0:	d004      	beq.n	80122fc <aci_gatt_add_char+0xb0>
 80122f2:	e007      	b.n	8012304 <aci_gatt_add_char+0xb8>
    {
      case 1: size = 2; break;
 80122f4:	2302      	movs	r3, #2
 80122f6:	f887 313f 	strb.w	r3, [r7, #319]	; 0x13f
 80122fa:	e005      	b.n	8012308 <aci_gatt_add_char+0xbc>
      case 2: size = 16; break;
 80122fc:	2310      	movs	r3, #16
 80122fe:	f887 313f 	strb.w	r3, [r7, #319]	; 0x13f
 8012302:	e001      	b.n	8012308 <aci_gatt_add_char+0xbc>
      default: return BLE_STATUS_ERROR;
 8012304:	2347      	movs	r3, #71	; 0x47
 8012306:	e086      	b.n	8012416 <aci_gatt_add_char+0x1ca>
    }
    Osal_MemCpy( (void*)&cp0->Char_UUID, (const void*)Char_UUID, size );
 8012308:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 801230c:	1cd8      	adds	r0, r3, #3
 801230e:	f897 213f 	ldrb.w	r2, [r7, #319]	; 0x13f
 8012312:	f107 0308 	add.w	r3, r7, #8
 8012316:	6819      	ldr	r1, [r3, #0]
 8012318:	f000 fa9e 	bl	8012858 <Osal_MemCpy>
    index_input += size;
 801231c:	f897 313f 	ldrb.w	r3, [r7, #319]	; 0x13f
 8012320:	f8d7 2130 	ldr.w	r2, [r7, #304]	; 0x130
 8012324:	4413      	add	r3, r2
 8012326:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    {
      cp1->Char_Value_Length = Char_Value_Length;
 801232a:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801232e:	1dba      	adds	r2, r7, #6
 8012330:	8812      	ldrh	r2, [r2, #0]
 8012332:	801a      	strh	r2, [r3, #0]
    }
    index_input += 2;
 8012334:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8012338:	3302      	adds	r3, #2
 801233a:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    {
      cp1->Char_Properties = Char_Properties;
 801233e:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8012342:	f897 2150 	ldrb.w	r2, [r7, #336]	; 0x150
 8012346:	709a      	strb	r2, [r3, #2]
    }
    index_input += 1;
 8012348:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801234c:	3301      	adds	r3, #1
 801234e:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    {
      cp1->Security_Permissions = Security_Permissions;
 8012352:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8012356:	f897 2154 	ldrb.w	r2, [r7, #340]	; 0x154
 801235a:	70da      	strb	r2, [r3, #3]
    }
    index_input += 1;
 801235c:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8012360:	3301      	adds	r3, #1
 8012362:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    {
      cp1->GATT_Evt_Mask = GATT_Evt_Mask;
 8012366:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801236a:	f897 2158 	ldrb.w	r2, [r7, #344]	; 0x158
 801236e:	711a      	strb	r2, [r3, #4]
    }
    index_input += 1;
 8012370:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8012374:	3301      	adds	r3, #1
 8012376:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    {
      cp1->Enc_Key_Size = Enc_Key_Size;
 801237a:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 801237e:	f897 215c 	ldrb.w	r2, [r7, #348]	; 0x15c
 8012382:	715a      	strb	r2, [r3, #5]
    }
    index_input += 1;
 8012384:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8012388:	3301      	adds	r3, #1
 801238a:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
    {
      cp1->Is_Variable = Is_Variable;
 801238e:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8012392:	f897 2160 	ldrb.w	r2, [r7, #352]	; 0x160
 8012396:	719a      	strb	r2, [r3, #6]
    }
    index_input += 1;
 8012398:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 801239c:	3301      	adds	r3, #1
 801239e:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
  }
  Osal_MemSet( &rq, 0, sizeof(rq) );
 80123a2:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80123a6:	2218      	movs	r2, #24
 80123a8:	2100      	movs	r1, #0
 80123aa:	4618      	mov	r0, r3
 80123ac:	f000 fa64 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x3f;
 80123b0:	233f      	movs	r3, #63	; 0x3f
 80123b2:	f8a7 3118 	strh.w	r3, [r7, #280]	; 0x118
  rq.ocf = 0x104;
 80123b6:	f44f 7382 	mov.w	r3, #260	; 0x104
 80123ba:	f8a7 311a 	strh.w	r3, [r7, #282]	; 0x11a
  rq.cparam = cmd_buffer;
 80123be:	f107 0318 	add.w	r3, r7, #24
 80123c2:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.clen = index_input;
 80123c6:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 80123ca:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  rq.rparam = &resp;
 80123ce:	f107 0314 	add.w	r3, r7, #20
 80123d2:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  rq.rlen = sizeof(resp);
 80123d6:	2303      	movs	r3, #3
 80123d8:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  if ( hci_send_req(&rq, FALSE) < 0 )
 80123dc:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80123e0:	2100      	movs	r1, #0
 80123e2:	4618      	mov	r0, r3
 80123e4:	f000 fbfc 	bl	8012be0 <hci_send_req>
 80123e8:	4603      	mov	r3, r0
 80123ea:	2b00      	cmp	r3, #0
 80123ec:	da01      	bge.n	80123f2 <aci_gatt_add_char+0x1a6>
    return BLE_STATUS_TIMEOUT;
 80123ee:	23ff      	movs	r3, #255	; 0xff
 80123f0:	e011      	b.n	8012416 <aci_gatt_add_char+0x1ca>
  if ( resp.Status )
 80123f2:	f107 0314 	add.w	r3, r7, #20
 80123f6:	781b      	ldrb	r3, [r3, #0]
 80123f8:	2b00      	cmp	r3, #0
 80123fa:	d003      	beq.n	8012404 <aci_gatt_add_char+0x1b8>
    return resp.Status;
 80123fc:	f107 0314 	add.w	r3, r7, #20
 8012400:	781b      	ldrb	r3, [r3, #0]
 8012402:	e008      	b.n	8012416 <aci_gatt_add_char+0x1ca>
  *Char_Handle = resp.Char_Handle;
 8012404:	f107 0314 	add.w	r3, r7, #20
 8012408:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801240c:	b29a      	uxth	r2, r3
 801240e:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8012412:	801a      	strh	r2, [r3, #0]
  return BLE_STATUS_SUCCESS;
 8012414:	2300      	movs	r3, #0
}
 8012416:	4618      	mov	r0, r3
 8012418:	f507 77a2 	add.w	r7, r7, #324	; 0x144
 801241c:	46bd      	mov	sp, r7
 801241e:	bd90      	pop	{r4, r7, pc}

08012420 <aci_gatt_update_char_value>:
tBleStatus aci_gatt_update_char_value( uint16_t Service_Handle,
                                       uint16_t Char_Handle,
                                       uint8_t Val_Offset,
                                       uint8_t Char_Value_Length,
                                       const uint8_t* Char_Value )
{
 8012420:	b5b0      	push	{r4, r5, r7, lr}
 8012422:	b0cc      	sub	sp, #304	; 0x130
 8012424:	af00      	add	r7, sp, #0
 8012426:	4605      	mov	r5, r0
 8012428:	460c      	mov	r4, r1
 801242a:	4610      	mov	r0, r2
 801242c:	4619      	mov	r1, r3
 801242e:	1dbb      	adds	r3, r7, #6
 8012430:	462a      	mov	r2, r5
 8012432:	801a      	strh	r2, [r3, #0]
 8012434:	1d3b      	adds	r3, r7, #4
 8012436:	4622      	mov	r2, r4
 8012438:	801a      	strh	r2, [r3, #0]
 801243a:	1cfb      	adds	r3, r7, #3
 801243c:	4602      	mov	r2, r0
 801243e:	701a      	strb	r2, [r3, #0]
 8012440:	1cbb      	adds	r3, r7, #2
 8012442:	460a      	mov	r2, r1
 8012444:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_gatt_update_char_value_cp0 *cp0 = (aci_gatt_update_char_value_cp0*)(cmd_buffer);
 8012446:	f107 0310 	add.w	r3, r7, #16
 801244a:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 801244e:	f107 030f 	add.w	r3, r7, #15
 8012452:	2200      	movs	r2, #0
 8012454:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 8012456:	2300      	movs	r3, #0
 8012458:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Service_Handle = Service_Handle;
 801245c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8012460:	1dba      	adds	r2, r7, #6
 8012462:	8812      	ldrh	r2, [r2, #0]
 8012464:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 8012466:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801246a:	3302      	adds	r3, #2
 801246c:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Char_Handle = Char_Handle;
 8012470:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8012474:	1d3a      	adds	r2, r7, #4
 8012476:	8812      	ldrh	r2, [r2, #0]
 8012478:	805a      	strh	r2, [r3, #2]
  index_input += 2;
 801247a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801247e:	3302      	adds	r3, #2
 8012480:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Val_Offset = Val_Offset;
 8012484:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8012488:	1cfa      	adds	r2, r7, #3
 801248a:	7812      	ldrb	r2, [r2, #0]
 801248c:	711a      	strb	r2, [r3, #4]
  index_input += 1;
 801248e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8012492:	3301      	adds	r3, #1
 8012494:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Char_Value_Length = Char_Value_Length;
 8012498:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801249c:	1cba      	adds	r2, r7, #2
 801249e:	7812      	ldrb	r2, [r2, #0]
 80124a0:	715a      	strb	r2, [r3, #5]
  index_input += 1;
 80124a2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80124a6:	3301      	adds	r3, #1
 80124a8:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemCpy( (void*)&cp0->Char_Value, (const void*)Char_Value, Char_Value_Length );
 80124ac:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80124b0:	1d98      	adds	r0, r3, #6
 80124b2:	1cbb      	adds	r3, r7, #2
 80124b4:	781b      	ldrb	r3, [r3, #0]
 80124b6:	461a      	mov	r2, r3
 80124b8:	f8d7 1140 	ldr.w	r1, [r7, #320]	; 0x140
 80124bc:	f000 f9cc 	bl	8012858 <Osal_MemCpy>
  index_input += Char_Value_Length;
 80124c0:	1cbb      	adds	r3, r7, #2
 80124c2:	781b      	ldrb	r3, [r3, #0]
 80124c4:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 80124c8:	4413      	add	r3, r2
 80124ca:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 80124ce:	f507 7388 	add.w	r3, r7, #272	; 0x110
 80124d2:	2218      	movs	r2, #24
 80124d4:	2100      	movs	r1, #0
 80124d6:	4618      	mov	r0, r3
 80124d8:	f000 f9ce 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x3f;
 80124dc:	233f      	movs	r3, #63	; 0x3f
 80124de:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x106;
 80124e2:	f44f 7383 	mov.w	r3, #262	; 0x106
 80124e6:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 80124ea:	f107 0310 	add.w	r3, r7, #16
 80124ee:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 80124f2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80124f6:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 80124fa:	f107 030f 	add.w	r3, r7, #15
 80124fe:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 8012502:	2301      	movs	r3, #1
 8012504:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 8012508:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801250c:	2100      	movs	r1, #0
 801250e:	4618      	mov	r0, r3
 8012510:	f000 fb66 	bl	8012be0 <hci_send_req>
 8012514:	4603      	mov	r3, r0
 8012516:	2b00      	cmp	r3, #0
 8012518:	da01      	bge.n	801251e <aci_gatt_update_char_value+0xfe>
    return BLE_STATUS_TIMEOUT;
 801251a:	23ff      	movs	r3, #255	; 0xff
 801251c:	e002      	b.n	8012524 <aci_gatt_update_char_value+0x104>
  return status;
 801251e:	f107 030f 	add.w	r3, r7, #15
 8012522:	781b      	ldrb	r3, [r3, #0]
}
 8012524:	4618      	mov	r0, r3
 8012526:	f507 7798 	add.w	r7, r7, #304	; 0x130
 801252a:	46bd      	mov	sp, r7
 801252c:	bdb0      	pop	{r4, r5, r7, pc}

0801252e <aci_hal_write_config_data>:
}

tBleStatus aci_hal_write_config_data( uint8_t Offset,
                                      uint8_t Length,
                                      const uint8_t* Value )
{
 801252e:	b580      	push	{r7, lr}
 8012530:	b0cc      	sub	sp, #304	; 0x130
 8012532:	af00      	add	r7, sp, #0
 8012534:	463b      	mov	r3, r7
 8012536:	601a      	str	r2, [r3, #0]
 8012538:	1dfb      	adds	r3, r7, #7
 801253a:	4602      	mov	r2, r0
 801253c:	701a      	strb	r2, [r3, #0]
 801253e:	1dbb      	adds	r3, r7, #6
 8012540:	460a      	mov	r2, r1
 8012542:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_hal_write_config_data_cp0 *cp0 = (aci_hal_write_config_data_cp0*)(cmd_buffer);
 8012544:	f107 0310 	add.w	r3, r7, #16
 8012548:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 801254c:	f107 030f 	add.w	r3, r7, #15
 8012550:	2200      	movs	r2, #0
 8012552:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 8012554:	2300      	movs	r3, #0
 8012556:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Offset = Offset;
 801255a:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801255e:	1dfa      	adds	r2, r7, #7
 8012560:	7812      	ldrb	r2, [r2, #0]
 8012562:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 8012564:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8012568:	3301      	adds	r3, #1
 801256a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Length = Length;
 801256e:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8012572:	1dba      	adds	r2, r7, #6
 8012574:	7812      	ldrb	r2, [r2, #0]
 8012576:	705a      	strb	r2, [r3, #1]
  index_input += 1;
 8012578:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801257c:	3301      	adds	r3, #1
 801257e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemCpy( (void*)&cp0->Value, (const void*)Value, Length );
 8012582:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8012586:	1c98      	adds	r0, r3, #2
 8012588:	1dbb      	adds	r3, r7, #6
 801258a:	781a      	ldrb	r2, [r3, #0]
 801258c:	463b      	mov	r3, r7
 801258e:	6819      	ldr	r1, [r3, #0]
 8012590:	f000 f962 	bl	8012858 <Osal_MemCpy>
  index_input += Length;
 8012594:	1dbb      	adds	r3, r7, #6
 8012596:	781b      	ldrb	r3, [r3, #0]
 8012598:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 801259c:	4413      	add	r3, r2
 801259e:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 80125a2:	f507 7388 	add.w	r3, r7, #272	; 0x110
 80125a6:	2218      	movs	r2, #24
 80125a8:	2100      	movs	r1, #0
 80125aa:	4618      	mov	r0, r3
 80125ac:	f000 f964 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x3f;
 80125b0:	233f      	movs	r3, #63	; 0x3f
 80125b2:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x00c;
 80125b6:	230c      	movs	r3, #12
 80125b8:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 80125bc:	f107 0310 	add.w	r3, r7, #16
 80125c0:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 80125c4:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80125c8:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 80125cc:	f107 030f 	add.w	r3, r7, #15
 80125d0:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 80125d4:	2301      	movs	r3, #1
 80125d6:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 80125da:	f507 7388 	add.w	r3, r7, #272	; 0x110
 80125de:	2100      	movs	r1, #0
 80125e0:	4618      	mov	r0, r3
 80125e2:	f000 fafd 	bl	8012be0 <hci_send_req>
 80125e6:	4603      	mov	r3, r0
 80125e8:	2b00      	cmp	r3, #0
 80125ea:	da01      	bge.n	80125f0 <aci_hal_write_config_data+0xc2>
    return BLE_STATUS_TIMEOUT;
 80125ec:	23ff      	movs	r3, #255	; 0xff
 80125ee:	e002      	b.n	80125f6 <aci_hal_write_config_data+0xc8>
  return status;
 80125f0:	f107 030f 	add.w	r3, r7, #15
 80125f4:	781b      	ldrb	r3, [r3, #0]
}
 80125f6:	4618      	mov	r0, r3
 80125f8:	f507 7798 	add.w	r7, r7, #304	; 0x130
 80125fc:	46bd      	mov	sp, r7
 80125fe:	bd80      	pop	{r7, pc}

08012600 <aci_hal_set_tx_power_level>:
  return BLE_STATUS_SUCCESS;
}

tBleStatus aci_hal_set_tx_power_level( uint8_t En_High_Power,
                                       uint8_t PA_Level )
{
 8012600:	b580      	push	{r7, lr}
 8012602:	b0cc      	sub	sp, #304	; 0x130
 8012604:	af00      	add	r7, sp, #0
 8012606:	4602      	mov	r2, r0
 8012608:	1dfb      	adds	r3, r7, #7
 801260a:	701a      	strb	r2, [r3, #0]
 801260c:	1dbb      	adds	r3, r7, #6
 801260e:	460a      	mov	r2, r1
 8012610:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_hal_set_tx_power_level_cp0 *cp0 = (aci_hal_set_tx_power_level_cp0*)(cmd_buffer);
 8012612:	f107 0310 	add.w	r3, r7, #16
 8012616:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 801261a:	f107 030f 	add.w	r3, r7, #15
 801261e:	2200      	movs	r2, #0
 8012620:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 8012622:	2300      	movs	r3, #0
 8012624:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->En_High_Power = En_High_Power;
 8012628:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 801262c:	1dfa      	adds	r2, r7, #7
 801262e:	7812      	ldrb	r2, [r2, #0]
 8012630:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 8012632:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8012636:	3301      	adds	r3, #1
 8012638:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->PA_Level = PA_Level;
 801263c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8012640:	1dba      	adds	r2, r7, #6
 8012642:	7812      	ldrb	r2, [r2, #0]
 8012644:	705a      	strb	r2, [r3, #1]
  index_input += 1;
 8012646:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801264a:	3301      	adds	r3, #1
 801264c:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 8012650:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8012654:	2218      	movs	r2, #24
 8012656:	2100      	movs	r1, #0
 8012658:	4618      	mov	r0, r3
 801265a:	f000 f90d 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x3f;
 801265e:	233f      	movs	r3, #63	; 0x3f
 8012660:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x00f;
 8012664:	230f      	movs	r3, #15
 8012666:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 801266a:	f107 0310 	add.w	r3, r7, #16
 801266e:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 8012672:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8012676:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 801267a:	f107 030f 	add.w	r3, r7, #15
 801267e:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 8012682:	2301      	movs	r3, #1
 8012684:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 8012688:	f507 7388 	add.w	r3, r7, #272	; 0x110
 801268c:	2100      	movs	r1, #0
 801268e:	4618      	mov	r0, r3
 8012690:	f000 faa6 	bl	8012be0 <hci_send_req>
 8012694:	4603      	mov	r3, r0
 8012696:	2b00      	cmp	r3, #0
 8012698:	da01      	bge.n	801269e <aci_hal_set_tx_power_level+0x9e>
    return BLE_STATUS_TIMEOUT;
 801269a:	23ff      	movs	r3, #255	; 0xff
 801269c:	e002      	b.n	80126a4 <aci_hal_set_tx_power_level+0xa4>
  return status;
 801269e:	f107 030f 	add.w	r3, r7, #15
 80126a2:	781b      	ldrb	r3, [r3, #0]
}
 80126a4:	4618      	mov	r0, r3
 80126a6:	f507 7798 	add.w	r7, r7, #304	; 0x130
 80126aa:	46bd      	mov	sp, r7
 80126ac:	bd80      	pop	{r7, pc}

080126ae <aci_hal_set_radio_activity_mask>:
  Osal_MemCpy( (void*)Link_Connection_Handle, (const void*)resp.Link_Connection_Handle, 16 );
  return BLE_STATUS_SUCCESS;
}

tBleStatus aci_hal_set_radio_activity_mask( uint16_t Radio_Activity_Mask )
{
 80126ae:	b580      	push	{r7, lr}
 80126b0:	b0cc      	sub	sp, #304	; 0x130
 80126b2:	af00      	add	r7, sp, #0
 80126b4:	4602      	mov	r2, r0
 80126b6:	1dbb      	adds	r3, r7, #6
 80126b8:	801a      	strh	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  aci_hal_set_radio_activity_mask_cp0 *cp0 = (aci_hal_set_radio_activity_mask_cp0*)(cmd_buffer);
 80126ba:	f107 0310 	add.w	r3, r7, #16
 80126be:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 80126c2:	f107 030f 	add.w	r3, r7, #15
 80126c6:	2200      	movs	r2, #0
 80126c8:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 80126ca:	2300      	movs	r3, #0
 80126cc:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->Radio_Activity_Mask = Radio_Activity_Mask;
 80126d0:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80126d4:	1dba      	adds	r2, r7, #6
 80126d6:	8812      	ldrh	r2, [r2, #0]
 80126d8:	801a      	strh	r2, [r3, #0]
  index_input += 2;
 80126da:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80126de:	3302      	adds	r3, #2
 80126e0:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 80126e4:	f507 7388 	add.w	r3, r7, #272	; 0x110
 80126e8:	2218      	movs	r2, #24
 80126ea:	2100      	movs	r1, #0
 80126ec:	4618      	mov	r0, r3
 80126ee:	f000 f8c3 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x3f;
 80126f2:	233f      	movs	r3, #63	; 0x3f
 80126f4:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x018;
 80126f8:	2318      	movs	r3, #24
 80126fa:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 80126fe:	f107 0310 	add.w	r3, r7, #16
 8012702:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 8012706:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801270a:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 801270e:	f107 030f 	add.w	r3, r7, #15
 8012712:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 8012716:	2301      	movs	r3, #1
 8012718:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 801271c:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8012720:	2100      	movs	r1, #0
 8012722:	4618      	mov	r0, r3
 8012724:	f000 fa5c 	bl	8012be0 <hci_send_req>
 8012728:	4603      	mov	r3, r0
 801272a:	2b00      	cmp	r3, #0
 801272c:	da01      	bge.n	8012732 <aci_hal_set_radio_activity_mask+0x84>
    return BLE_STATUS_TIMEOUT;
 801272e:	23ff      	movs	r3, #255	; 0xff
 8012730:	e002      	b.n	8012738 <aci_hal_set_radio_activity_mask+0x8a>
  return status;
 8012732:	f107 030f 	add.w	r3, r7, #15
 8012736:	781b      	ldrb	r3, [r3, #0]
}
 8012738:	4618      	mov	r0, r3
 801273a:	f507 7798 	add.w	r7, r7, #304	; 0x130
 801273e:	46bd      	mov	sp, r7
 8012740:	bd80      	pop	{r7, pc}

08012742 <hci_reset>:
    return BLE_STATUS_TIMEOUT;
  return status;
}

tBleStatus hci_reset( void )
{
 8012742:	b580      	push	{r7, lr}
 8012744:	b088      	sub	sp, #32
 8012746:	af00      	add	r7, sp, #0
  struct hci_request rq;
  tBleStatus status = 0;
 8012748:	2300      	movs	r3, #0
 801274a:	71fb      	strb	r3, [r7, #7]
  Osal_MemSet( &rq, 0, sizeof(rq) );
 801274c:	f107 0308 	add.w	r3, r7, #8
 8012750:	2218      	movs	r2, #24
 8012752:	2100      	movs	r1, #0
 8012754:	4618      	mov	r0, r3
 8012756:	f000 f88f 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x03;
 801275a:	2303      	movs	r3, #3
 801275c:	813b      	strh	r3, [r7, #8]
  rq.ocf = 0x003;
 801275e:	2303      	movs	r3, #3
 8012760:	817b      	strh	r3, [r7, #10]
  rq.rparam = &status;
 8012762:	1dfb      	adds	r3, r7, #7
 8012764:	61bb      	str	r3, [r7, #24]
  rq.rlen = 1;
 8012766:	2301      	movs	r3, #1
 8012768:	61fb      	str	r3, [r7, #28]
  if ( hci_send_req(&rq, FALSE) < 0 )
 801276a:	f107 0308 	add.w	r3, r7, #8
 801276e:	2100      	movs	r1, #0
 8012770:	4618      	mov	r0, r3
 8012772:	f000 fa35 	bl	8012be0 <hci_send_req>
 8012776:	4603      	mov	r3, r0
 8012778:	2b00      	cmp	r3, #0
 801277a:	da01      	bge.n	8012780 <hci_reset+0x3e>
    return BLE_STATUS_TIMEOUT;
 801277c:	23ff      	movs	r3, #255	; 0xff
 801277e:	e000      	b.n	8012782 <hci_reset+0x40>
  return status;
 8012780:	79fb      	ldrb	r3, [r7, #7]
}
 8012782:	4618      	mov	r0, r3
 8012784:	3720      	adds	r7, #32
 8012786:	46bd      	mov	sp, r7
 8012788:	bd80      	pop	{r7, pc}

0801278a <hci_le_set_default_phy>:
}

tBleStatus hci_le_set_default_phy( uint8_t ALL_PHYS,
                                   uint8_t TX_PHYS,
                                   uint8_t RX_PHYS )
{
 801278a:	b590      	push	{r4, r7, lr}
 801278c:	b0cd      	sub	sp, #308	; 0x134
 801278e:	af00      	add	r7, sp, #0
 8012790:	4604      	mov	r4, r0
 8012792:	4608      	mov	r0, r1
 8012794:	4611      	mov	r1, r2
 8012796:	1dfb      	adds	r3, r7, #7
 8012798:	4622      	mov	r2, r4
 801279a:	701a      	strb	r2, [r3, #0]
 801279c:	1dbb      	adds	r3, r7, #6
 801279e:	4602      	mov	r2, r0
 80127a0:	701a      	strb	r2, [r3, #0]
 80127a2:	1d7b      	adds	r3, r7, #5
 80127a4:	460a      	mov	r2, r1
 80127a6:	701a      	strb	r2, [r3, #0]
  struct hci_request rq;
  uint8_t cmd_buffer[BLE_CMD_MAX_PARAM_LEN];
  hci_le_set_default_phy_cp0 *cp0 = (hci_le_set_default_phy_cp0*)(cmd_buffer);
 80127a8:	f107 0310 	add.w	r3, r7, #16
 80127ac:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  tBleStatus status = 0;
 80127b0:	f107 030f 	add.w	r3, r7, #15
 80127b4:	2200      	movs	r2, #0
 80127b6:	701a      	strb	r2, [r3, #0]
  int index_input = 0;
 80127b8:	2300      	movs	r3, #0
 80127ba:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->ALL_PHYS = ALL_PHYS;
 80127be:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80127c2:	1dfa      	adds	r2, r7, #7
 80127c4:	7812      	ldrb	r2, [r2, #0]
 80127c6:	701a      	strb	r2, [r3, #0]
  index_input += 1;
 80127c8:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80127cc:	3301      	adds	r3, #1
 80127ce:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->TX_PHYS = TX_PHYS;
 80127d2:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80127d6:	1dba      	adds	r2, r7, #6
 80127d8:	7812      	ldrb	r2, [r2, #0]
 80127da:	705a      	strb	r2, [r3, #1]
  index_input += 1;
 80127dc:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80127e0:	3301      	adds	r3, #1
 80127e2:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  cp0->RX_PHYS = RX_PHYS;
 80127e6:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 80127ea:	1d7a      	adds	r2, r7, #5
 80127ec:	7812      	ldrb	r2, [r2, #0]
 80127ee:	709a      	strb	r2, [r3, #2]
  index_input += 1;
 80127f0:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80127f4:	3301      	adds	r3, #1
 80127f6:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
  Osal_MemSet( &rq, 0, sizeof(rq) );
 80127fa:	f507 7388 	add.w	r3, r7, #272	; 0x110
 80127fe:	2218      	movs	r2, #24
 8012800:	2100      	movs	r1, #0
 8012802:	4618      	mov	r0, r3
 8012804:	f000 f838 	bl	8012878 <Osal_MemSet>
  rq.ogf = 0x08;
 8012808:	2308      	movs	r3, #8
 801280a:	f8a7 3110 	strh.w	r3, [r7, #272]	; 0x110
  rq.ocf = 0x031;
 801280e:	2331      	movs	r3, #49	; 0x31
 8012810:	f8a7 3112 	strh.w	r3, [r7, #274]	; 0x112
  rq.cparam = cmd_buffer;
 8012814:	f107 0310 	add.w	r3, r7, #16
 8012818:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  rq.clen = index_input;
 801281c:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8012820:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  rq.rparam = &status;
 8012824:	f107 030f 	add.w	r3, r7, #15
 8012828:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  rq.rlen = 1;
 801282c:	2301      	movs	r3, #1
 801282e:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
  if ( hci_send_req(&rq, FALSE) < 0 )
 8012832:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8012836:	2100      	movs	r1, #0
 8012838:	4618      	mov	r0, r3
 801283a:	f000 f9d1 	bl	8012be0 <hci_send_req>
 801283e:	4603      	mov	r3, r0
 8012840:	2b00      	cmp	r3, #0
 8012842:	da01      	bge.n	8012848 <hci_le_set_default_phy+0xbe>
    return BLE_STATUS_TIMEOUT;
 8012844:	23ff      	movs	r3, #255	; 0xff
 8012846:	e002      	b.n	801284e <hci_le_set_default_phy+0xc4>
  return status;
 8012848:	f107 030f 	add.w	r3, r7, #15
 801284c:	781b      	ldrb	r3, [r3, #0]
}
 801284e:	4618      	mov	r0, r3
 8012850:	f507 779a 	add.w	r7, r7, #308	; 0x134
 8012854:	46bd      	mov	sp, r7
 8012856:	bd90      	pop	{r4, r7, pc}

08012858 <Osal_MemCpy>:
 * Osal_MemCpy
 * 
 */
 
void* Osal_MemCpy( void *dest, const void *src, unsigned int size )
{
 8012858:	b580      	push	{r7, lr}
 801285a:	b084      	sub	sp, #16
 801285c:	af00      	add	r7, sp, #0
 801285e:	60f8      	str	r0, [r7, #12]
 8012860:	60b9      	str	r1, [r7, #8]
 8012862:	607a      	str	r2, [r7, #4]
  return memcpy( dest, src, size ); 
 8012864:	687a      	ldr	r2, [r7, #4]
 8012866:	68b9      	ldr	r1, [r7, #8]
 8012868:	68f8      	ldr	r0, [r7, #12]
 801286a:	f002 f9a3 	bl	8014bb4 <memcpy>
 801286e:	4603      	mov	r3, r0
}
 8012870:	4618      	mov	r0, r3
 8012872:	3710      	adds	r7, #16
 8012874:	46bd      	mov	sp, r7
 8012876:	bd80      	pop	{r7, pc}

08012878 <Osal_MemSet>:
 * Osal_MemSet
 * 
 */
 
void* Osal_MemSet( void *ptr, int value, unsigned int size )
{
 8012878:	b580      	push	{r7, lr}
 801287a:	b084      	sub	sp, #16
 801287c:	af00      	add	r7, sp, #0
 801287e:	60f8      	str	r0, [r7, #12]
 8012880:	60b9      	str	r1, [r7, #8]
 8012882:	607a      	str	r2, [r7, #4]
  return memset( ptr, value, size );
 8012884:	687a      	ldr	r2, [r7, #4]
 8012886:	68b9      	ldr	r1, [r7, #8]
 8012888:	68f8      	ldr	r0, [r7, #12]
 801288a:	f002 f9a1 	bl	8014bd0 <memset>
 801288e:	4603      	mov	r3, r0
}
 8012890:	4618      	mov	r0, r3
 8012892:	3710      	adds	r7, #16
 8012894:	46bd      	mov	sp, r7
 8012896:	bd80      	pop	{r7, pc}

08012898 <BLS_Init>:
/* Private functions ----------------------------------------------------------*/
/* Weak functions ----------------------------------------------------------*/
void BVOPUS_STM_Init(void);

__weak void BLS_Init( void )
{
 8012898:	b480      	push	{r7}
 801289a:	af00      	add	r7, sp, #0
  return;
 801289c:	bf00      	nop
}
 801289e:	46bd      	mov	sp, r7
 80128a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80128a4:	4770      	bx	lr

080128a6 <CRS_STM_Init>:
__weak void CRS_STM_Init( void )
{
 80128a6:	b480      	push	{r7}
 80128a8:	af00      	add	r7, sp, #0
  return;
 80128aa:	bf00      	nop
}
 80128ac:	46bd      	mov	sp, r7
 80128ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80128b2:	4770      	bx	lr

080128b4 <DIS_Init>:
__weak void DIS_Init( void )
{
 80128b4:	b480      	push	{r7}
 80128b6:	af00      	add	r7, sp, #0
  return;
 80128b8:	bf00      	nop
}
 80128ba:	46bd      	mov	sp, r7
 80128bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80128c0:	4770      	bx	lr

080128c2 <EDS_STM_Init>:
__weak void EDS_STM_Init( void )
{
 80128c2:	b480      	push	{r7}
 80128c4:	af00      	add	r7, sp, #0
  return;
 80128c6:	bf00      	nop
}
 80128c8:	46bd      	mov	sp, r7
 80128ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80128ce:	4770      	bx	lr

080128d0 <HIDS_Init>:
__weak void HIDS_Init( void )
{
 80128d0:	b480      	push	{r7}
 80128d2:	af00      	add	r7, sp, #0
  return;
 80128d4:	bf00      	nop
}
 80128d6:	46bd      	mov	sp, r7
 80128d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80128dc:	4770      	bx	lr

080128de <HRS_Init>:
__weak void HRS_Init( void )
{
 80128de:	b480      	push	{r7}
 80128e0:	af00      	add	r7, sp, #0
  return;
 80128e2:	bf00      	nop
}
 80128e4:	46bd      	mov	sp, r7
 80128e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80128ea:	4770      	bx	lr

080128ec <HTS_Init>:
__weak void HTS_Init( void )
{
 80128ec:	b480      	push	{r7}
 80128ee:	af00      	add	r7, sp, #0
  return;
 80128f0:	bf00      	nop
}
 80128f2:	46bd      	mov	sp, r7
 80128f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80128f8:	4770      	bx	lr

080128fa <IAS_Init>:
__weak void IAS_Init( void )
{
 80128fa:	b480      	push	{r7}
 80128fc:	af00      	add	r7, sp, #0
  return;
 80128fe:	bf00      	nop
}
 8012900:	46bd      	mov	sp, r7
 8012902:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012906:	4770      	bx	lr

08012908 <LLS_Init>:
__weak void LLS_Init( void )
{
 8012908:	b480      	push	{r7}
 801290a:	af00      	add	r7, sp, #0
  return;
 801290c:	bf00      	nop
}
 801290e:	46bd      	mov	sp, r7
 8012910:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012914:	4770      	bx	lr

08012916 <TPS_Init>:
__weak void TPS_Init( void )
{
 8012916:	b480      	push	{r7}
 8012918:	af00      	add	r7, sp, #0
  return;
 801291a:	bf00      	nop
}
 801291c:	46bd      	mov	sp, r7
 801291e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012922:	4770      	bx	lr

08012924 <MOTENV_STM_Init>:
__weak void MOTENV_STM_Init( void )
{
 8012924:	b480      	push	{r7}
 8012926:	af00      	add	r7, sp, #0
  return;
 8012928:	bf00      	nop
}
 801292a:	46bd      	mov	sp, r7
 801292c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012930:	4770      	bx	lr

08012932 <P2PS_STM_Init>:
__weak void P2PS_STM_Init( void )
{
 8012932:	b480      	push	{r7}
 8012934:	af00      	add	r7, sp, #0
  return;
 8012936:	bf00      	nop
}
 8012938:	46bd      	mov	sp, r7
 801293a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801293e:	4770      	bx	lr

08012940 <OTAS_STM_Init>:
__weak void OTAS_STM_Init( void )
{
 8012940:	b480      	push	{r7}
 8012942:	af00      	add	r7, sp, #0
  return;
 8012944:	bf00      	nop
}
 8012946:	46bd      	mov	sp, r7
 8012948:	f85d 7b04 	ldr.w	r7, [sp], #4
 801294c:	4770      	bx	lr

0801294e <MESH_Init>:
__weak void MESH_Init( void )
{
 801294e:	b480      	push	{r7}
 8012950:	af00      	add	r7, sp, #0
  return;
 8012952:	bf00      	nop
}
 8012954:	46bd      	mov	sp, r7
 8012956:	f85d 7b04 	ldr.w	r7, [sp], #4
 801295a:	4770      	bx	lr

0801295c <BVOPUS_STM_Init>:
__weak void BVOPUS_STM_Init( void )
{
 801295c:	b480      	push	{r7}
 801295e:	af00      	add	r7, sp, #0
  return;
 8012960:	bf00      	nop
}
 8012962:	46bd      	mov	sp, r7
 8012964:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012968:	4770      	bx	lr
	...

0801296c <SVCCTL_Init>:
}

/* Functions Definition ------------------------------------------------------*/

void SVCCTL_Init( void )
{
 801296c:	b580      	push	{r7, lr}
 801296e:	af00      	add	r7, sp, #0
 
  /**
   * Initialize the number of registered Handler
   */
  SVCCTL_EvtHandler.NbreOfRegisteredHandler = 0;
 8012970:	4b04      	ldr	r3, [pc, #16]	; (8012984 <SVCCTL_Init+0x18>)
 8012972:	2200      	movs	r2, #0
 8012974:	771a      	strb	r2, [r3, #28]
  SVCCTL_CltHandler.NbreOfRegisteredHandler = 0;
 8012976:	4b04      	ldr	r3, [pc, #16]	; (8012988 <SVCCTL_Init+0x1c>)
 8012978:	2200      	movs	r2, #0
 801297a:	701a      	strb	r2, [r3, #0]

  /**
   * Add and Initialize requested services
   */
  SVCCTL_SvcInit();
 801297c:	f000 f806 	bl	801298c <SVCCTL_SvcInit>

  return;
 8012980:	bf00      	nop
}
 8012982:	bd80      	pop	{r7, pc}
 8012984:	200000c4 	.word	0x200000c4
 8012988:	200000e4 	.word	0x200000e4

0801298c <SVCCTL_SvcInit>:

__weak void SVCCTL_SvcInit(void)
{
 801298c:	b580      	push	{r7, lr}
 801298e:	af00      	add	r7, sp, #0
  BLS_Init();
 8012990:	f7ff ff82 	bl	8012898 <BLS_Init>

  CRS_STM_Init();
 8012994:	f7ff ff87 	bl	80128a6 <CRS_STM_Init>

  DIS_Init();
 8012998:	f7ff ff8c 	bl	80128b4 <DIS_Init>

  EDS_STM_Init();
 801299c:	f7ff ff91 	bl	80128c2 <EDS_STM_Init>

  HIDS_Init();
 80129a0:	f7ff ff96 	bl	80128d0 <HIDS_Init>

  HRS_Init();
 80129a4:	f7ff ff9b 	bl	80128de <HRS_Init>

  HTS_Init();
 80129a8:	f7ff ffa0 	bl	80128ec <HTS_Init>

  IAS_Init();
 80129ac:	f7ff ffa5 	bl	80128fa <IAS_Init>

  LLS_Init();
 80129b0:	f7ff ffaa 	bl	8012908 <LLS_Init>

  TPS_Init();
 80129b4:	f7ff ffaf 	bl	8012916 <TPS_Init>

  MOTENV_STM_Init();
 80129b8:	f7ff ffb4 	bl	8012924 <MOTENV_STM_Init>

  P2PS_STM_Init();
 80129bc:	f7ff ffb9 	bl	8012932 <P2PS_STM_Init>

  OTAS_STM_Init();
 80129c0:	f7ff ffbe 	bl	8012940 <OTAS_STM_Init>
  
  BVOPUS_STM_Init();
 80129c4:	f7ff ffca 	bl	801295c <BVOPUS_STM_Init>

  MESH_Init();
 80129c8:	f7ff ffc1 	bl	801294e <MESH_Init>

  SVCCTL_InitCustomSvc();
 80129cc:	f001 fa68 	bl	8013ea0 <SVCCTL_InitCustomSvc>
  
  return;
 80129d0:	bf00      	nop
}
 80129d2:	bd80      	pop	{r7, pc}

080129d4 <SVCCTL_RegisterSvcHandler>:
 * @brief  BLE Controller initialization
 * @param  None
 * @retval None
 */
void SVCCTL_RegisterSvcHandler( SVC_CTL_p_EvtHandler_t pfBLE_SVC_Service_Event_Handler )
{
 80129d4:	b480      	push	{r7}
 80129d6:	b083      	sub	sp, #12
 80129d8:	af00      	add	r7, sp, #0
 80129da:	6078      	str	r0, [r7, #4]
#if (BLE_CFG_SVC_MAX_NBR_CB > 0)
  SVCCTL_EvtHandler.SVCCTL__SvcHandlerTab[SVCCTL_EvtHandler.NbreOfRegisteredHandler] = pfBLE_SVC_Service_Event_Handler;
 80129dc:	4b09      	ldr	r3, [pc, #36]	; (8012a04 <SVCCTL_RegisterSvcHandler+0x30>)
 80129de:	7f1b      	ldrb	r3, [r3, #28]
 80129e0:	4619      	mov	r1, r3
 80129e2:	4a08      	ldr	r2, [pc, #32]	; (8012a04 <SVCCTL_RegisterSvcHandler+0x30>)
 80129e4:	687b      	ldr	r3, [r7, #4]
 80129e6:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  SVCCTL_EvtHandler.NbreOfRegisteredHandler++;
 80129ea:	4b06      	ldr	r3, [pc, #24]	; (8012a04 <SVCCTL_RegisterSvcHandler+0x30>)
 80129ec:	7f1b      	ldrb	r3, [r3, #28]
 80129ee:	3301      	adds	r3, #1
 80129f0:	b2da      	uxtb	r2, r3
 80129f2:	4b04      	ldr	r3, [pc, #16]	; (8012a04 <SVCCTL_RegisterSvcHandler+0x30>)
 80129f4:	771a      	strb	r2, [r3, #28]
#else
  (void)(pfBLE_SVC_Service_Event_Handler);
#endif

  return;
 80129f6:	bf00      	nop
}
 80129f8:	370c      	adds	r7, #12
 80129fa:	46bd      	mov	sp, r7
 80129fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012a00:	4770      	bx	lr
 8012a02:	bf00      	nop
 8012a04:	200000c4 	.word	0x200000c4

08012a08 <SVCCTL_UserEvtRx>:

  return;
}

SVCCTL_UserEvtFlowStatus_t SVCCTL_UserEvtRx( void *pckt )
{
 8012a08:	b580      	push	{r7, lr}
 8012a0a:	b086      	sub	sp, #24
 8012a0c:	af00      	add	r7, sp, #0
 8012a0e:	6078      	str	r0, [r7, #4]
  evt_blue_aci *blue_evt;
  SVCCTL_EvtAckStatus_t event_notification_status;
  SVCCTL_UserEvtFlowStatus_t return_status;
  uint8_t index;

  event_pckt = (hci_event_pckt*) ((hci_uart_pckt *) pckt)->data;
 8012a10:	687b      	ldr	r3, [r7, #4]
 8012a12:	3301      	adds	r3, #1
 8012a14:	613b      	str	r3, [r7, #16]
  event_notification_status = SVCCTL_EvtNotAck;
 8012a16:	2300      	movs	r3, #0
 8012a18:	75fb      	strb	r3, [r7, #23]

  switch (event_pckt->evt)
 8012a1a:	693b      	ldr	r3, [r7, #16]
 8012a1c:	781b      	ldrb	r3, [r3, #0]
 8012a1e:	2bff      	cmp	r3, #255	; 0xff
 8012a20:	d125      	bne.n	8012a6e <SVCCTL_UserEvtRx+0x66>
  {
    case EVT_VENDOR:
    {
      blue_evt = (evt_blue_aci*) event_pckt->data;
 8012a22:	693b      	ldr	r3, [r7, #16]
 8012a24:	3302      	adds	r3, #2
 8012a26:	60fb      	str	r3, [r7, #12]

      switch ((blue_evt->ecode) & SVCCTL_EGID_EVT_MASK)
 8012a28:	68fb      	ldr	r3, [r7, #12]
 8012a2a:	881b      	ldrh	r3, [r3, #0]
 8012a2c:	b29b      	uxth	r3, r3
 8012a2e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8012a32:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8012a36:	d118      	bne.n	8012a6a <SVCCTL_UserEvtRx+0x62>
      {
        case SVCCTL_GATT_EVT_TYPE:
#if (BLE_CFG_SVC_MAX_NBR_CB > 0)
          /* For Service event handler */
          for (index = 0; index < SVCCTL_EvtHandler.NbreOfRegisteredHandler; index++)
 8012a38:	2300      	movs	r3, #0
 8012a3a:	757b      	strb	r3, [r7, #21]
 8012a3c:	e00d      	b.n	8012a5a <SVCCTL_UserEvtRx+0x52>
          {
            event_notification_status = SVCCTL_EvtHandler.SVCCTL__SvcHandlerTab[index](pckt);
 8012a3e:	7d7b      	ldrb	r3, [r7, #21]
 8012a40:	4a1a      	ldr	r2, [pc, #104]	; (8012aac <SVCCTL_UserEvtRx+0xa4>)
 8012a42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012a46:	6878      	ldr	r0, [r7, #4]
 8012a48:	4798      	blx	r3
 8012a4a:	4603      	mov	r3, r0
 8012a4c:	75fb      	strb	r3, [r7, #23]
            /**
             * When a GATT event has been acknowledged by a Service, there is no need to call the other registered handlers
             * a GATT event is relevant for only one Service
             */
            if (event_notification_status != SVCCTL_EvtNotAck)
 8012a4e:	7dfb      	ldrb	r3, [r7, #23]
 8012a50:	2b00      	cmp	r3, #0
 8012a52:	d108      	bne.n	8012a66 <SVCCTL_UserEvtRx+0x5e>
          for (index = 0; index < SVCCTL_EvtHandler.NbreOfRegisteredHandler; index++)
 8012a54:	7d7b      	ldrb	r3, [r7, #21]
 8012a56:	3301      	adds	r3, #1
 8012a58:	757b      	strb	r3, [r7, #21]
 8012a5a:	4b14      	ldr	r3, [pc, #80]	; (8012aac <SVCCTL_UserEvtRx+0xa4>)
 8012a5c:	7f1b      	ldrb	r3, [r3, #28]
 8012a5e:	7d7a      	ldrb	r2, [r7, #21]
 8012a60:	429a      	cmp	r2, r3
 8012a62:	d3ec      	bcc.n	8012a3e <SVCCTL_UserEvtRx+0x36>
               */
              break;
            }
          }
#endif
          break;
 8012a64:	e002      	b.n	8012a6c <SVCCTL_UserEvtRx+0x64>
              break;
 8012a66:	bf00      	nop
          break;
 8012a68:	e000      	b.n	8012a6c <SVCCTL_UserEvtRx+0x64>

        default:
          break;
 8012a6a:	bf00      	nop
      }
    }
      break; /* HCI_EVT_VENDOR_SPECIFIC */
 8012a6c:	e000      	b.n	8012a70 <SVCCTL_UserEvtRx+0x68>

    default:
      break;
 8012a6e:	bf00      	nop

  /**
   * When no registered handlers (either Service or Client) has acknowledged the GATT event, it is reported to the application
   * a GAP event is always reported to the applicaiton.
   */
  switch (event_notification_status)
 8012a70:	7dfb      	ldrb	r3, [r7, #23]
 8012a72:	2b02      	cmp	r3, #2
 8012a74:	d00f      	beq.n	8012a96 <SVCCTL_UserEvtRx+0x8e>
 8012a76:	2b02      	cmp	r3, #2
 8012a78:	dc10      	bgt.n	8012a9c <SVCCTL_UserEvtRx+0x94>
 8012a7a:	2b00      	cmp	r3, #0
 8012a7c:	d002      	beq.n	8012a84 <SVCCTL_UserEvtRx+0x7c>
 8012a7e:	2b01      	cmp	r3, #1
 8012a80:	d006      	beq.n	8012a90 <SVCCTL_UserEvtRx+0x88>
 8012a82:	e00b      	b.n	8012a9c <SVCCTL_UserEvtRx+0x94>
    case SVCCTL_EvtNotAck:
      /**
       *  The event has NOT been managed.
       *  It shall be passed to the application for processing
       */
      return_status = SVCCTL_App_Notification(pckt);
 8012a84:	6878      	ldr	r0, [r7, #4]
 8012a86:	f000 feab 	bl	80137e0 <SVCCTL_App_Notification>
 8012a8a:	4603      	mov	r3, r0
 8012a8c:	75bb      	strb	r3, [r7, #22]
      break;
 8012a8e:	e008      	b.n	8012aa2 <SVCCTL_UserEvtRx+0x9a>

    case SVCCTL_EvtAckFlowEnable:
      return_status = SVCCTL_UserEvtFlowEnable;
 8012a90:	2301      	movs	r3, #1
 8012a92:	75bb      	strb	r3, [r7, #22]
      break;
 8012a94:	e005      	b.n	8012aa2 <SVCCTL_UserEvtRx+0x9a>

    case SVCCTL_EvtAckFlowDisable:
      return_status = SVCCTL_UserEvtFlowDisable;
 8012a96:	2300      	movs	r3, #0
 8012a98:	75bb      	strb	r3, [r7, #22]
      break;
 8012a9a:	e002      	b.n	8012aa2 <SVCCTL_UserEvtRx+0x9a>

    default:
      return_status = SVCCTL_UserEvtFlowEnable;
 8012a9c:	2301      	movs	r3, #1
 8012a9e:	75bb      	strb	r3, [r7, #22]
      break;
 8012aa0:	bf00      	nop
  }

  return (return_status);
 8012aa2:	7dbb      	ldrb	r3, [r7, #22]
}
 8012aa4:	4618      	mov	r0, r3
 8012aa6:	3718      	adds	r7, #24
 8012aa8:	46bd      	mov	sp, r7
 8012aaa:	bd80      	pop	{r7, pc}
 8012aac:	200000c4 	.word	0x200000c4

08012ab0 <SHCI_C2_BLE_Init>:

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
}

SHCI_CmdStatus_t SHCI_C2_BLE_Init( SHCI_C2_Ble_Init_Cmd_Packet_t *pCmdPacket )
{
 8012ab0:	b580      	push	{r7, lr}
 8012ab2:	b088      	sub	sp, #32
 8012ab4:	af00      	add	r7, sp, #0
 8012ab6:	6078      	str	r0, [r7, #4]
   * Buffer is large enough to hold command complete without payload
   */
  uint8_t local_buffer[TL_BLEEVT_CS_BUFFER_SIZE];
  TL_EvtPacket_t * p_rsp;

  p_rsp = (TL_EvtPacket_t *)local_buffer;
 8012ab8:	f107 030c 	add.w	r3, r7, #12
 8012abc:	61fb      	str	r3, [r7, #28]

 shci_send( SHCI_OPCODE_C2_BLE_INIT,
            sizeof( SHCI_C2_Ble_Init_Cmd_Param_t ),
            (uint8_t*)&pCmdPacket->Param,
 8012abe:	687b      	ldr	r3, [r7, #4]
 8012ac0:	f103 020c 	add.w	r2, r3, #12
 shci_send( SHCI_OPCODE_C2_BLE_INIT,
 8012ac4:	69fb      	ldr	r3, [r7, #28]
 8012ac6:	2121      	movs	r1, #33	; 0x21
 8012ac8:	f64f 4066 	movw	r0, #64614	; 0xfc66
 8012acc:	f000 fa1e 	bl	8012f0c <shci_send>
            p_rsp );

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
 8012ad0:	69fb      	ldr	r3, [r7, #28]
 8012ad2:	330b      	adds	r3, #11
 8012ad4:	78db      	ldrb	r3, [r3, #3]
}
 8012ad6:	4618      	mov	r0, r3
 8012ad8:	3720      	adds	r7, #32
 8012ada:	46bd      	mov	sp, r7
 8012adc:	bd80      	pop	{r7, pc}

08012ade <SHCI_C2_DEBUG_Init>:

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
}

SHCI_CmdStatus_t SHCI_C2_DEBUG_Init( SHCI_C2_DEBUG_Init_Cmd_Packet_t *pCmdPacket  )
{
 8012ade:	b580      	push	{r7, lr}
 8012ae0:	b088      	sub	sp, #32
 8012ae2:	af00      	add	r7, sp, #0
 8012ae4:	6078      	str	r0, [r7, #4]
   * Buffer is large enough to hold command complete without payload
   */
  uint8_t local_buffer[TL_BLEEVT_CS_BUFFER_SIZE];
  TL_EvtPacket_t * p_rsp;

  p_rsp = (TL_EvtPacket_t *)local_buffer;
 8012ae6:	f107 030c 	add.w	r3, r7, #12
 8012aea:	61fb      	str	r3, [r7, #28]

  shci_send( SHCI_OPCODE_C2_DEBUG_INIT,
             sizeof( SHCI_C2_DEBUG_init_Cmd_Param_t ),
             (uint8_t*)&pCmdPacket->Param,
 8012aec:	687b      	ldr	r3, [r7, #4]
 8012aee:	f103 020c 	add.w	r2, r3, #12
  shci_send( SHCI_OPCODE_C2_DEBUG_INIT,
 8012af2:	69fb      	ldr	r3, [r7, #28]
 8012af4:	210f      	movs	r1, #15
 8012af6:	f64f 4068 	movw	r0, #64616	; 0xfc68
 8012afa:	f000 fa07 	bl	8012f0c <shci_send>
             p_rsp );

  return (SHCI_CmdStatus_t)(((TL_CcEvt_t*)(p_rsp->evtserial.evt.payload))->payload[0]);
 8012afe:	69fb      	ldr	r3, [r7, #28]
 8012b00:	330b      	adds	r3, #11
 8012b02:	78db      	ldrb	r3, [r3, #3]
}
 8012b04:	4618      	mov	r0, r3
 8012b06:	3720      	adds	r7, #32
 8012b08:	46bd      	mov	sp, r7
 8012b0a:	bd80      	pop	{r7, pc}

08012b0c <hci_init>:
static void TlEvtReceived(TL_EvtPacket_t *hcievt);
static void TlInit( TL_CmdPacket_t * p_cmdbuffer );

/* Interface ------- ---------------------------------------------------------*/
void hci_init(void(* UserEvtRx)(void* pData), void* pConf)
{
 8012b0c:	b580      	push	{r7, lr}
 8012b0e:	b082      	sub	sp, #8
 8012b10:	af00      	add	r7, sp, #0
 8012b12:	6078      	str	r0, [r7, #4]
 8012b14:	6039      	str	r1, [r7, #0]
  StatusNotCallBackFunction = ((HCI_TL_HciInitConf_t *)pConf)->StatusNotCallBack;
 8012b16:	683b      	ldr	r3, [r7, #0]
 8012b18:	685b      	ldr	r3, [r3, #4]
 8012b1a:	4a08      	ldr	r2, [pc, #32]	; (8012b3c <hci_init+0x30>)
 8012b1c:	6013      	str	r3, [r2, #0]
  hciContext.UserEvtRx = UserEvtRx;
 8012b1e:	4a08      	ldr	r2, [pc, #32]	; (8012b40 <hci_init+0x34>)
 8012b20:	687b      	ldr	r3, [r7, #4]
 8012b22:	61d3      	str	r3, [r2, #28]

  hci_register_io_bus (&hciContext.io);
 8012b24:	4806      	ldr	r0, [pc, #24]	; (8012b40 <hci_init+0x34>)
 8012b26:	f000 f973 	bl	8012e10 <hci_register_io_bus>

  TlInit((TL_CmdPacket_t *)(((HCI_TL_HciInitConf_t *)pConf)->p_cmdbuffer));
 8012b2a:	683b      	ldr	r3, [r7, #0]
 8012b2c:	681b      	ldr	r3, [r3, #0]
 8012b2e:	4618      	mov	r0, r3
 8012b30:	f000 f8d4 	bl	8012cdc <TlInit>

  return;
 8012b34:	bf00      	nop
}
 8012b36:	3708      	adds	r7, #8
 8012b38:	46bd      	mov	sp, r7
 8012b3a:	bd80      	pop	{r7, pc}
 8012b3c:	20000f24 	.word	0x20000f24
 8012b40:	20000efc 	.word	0x20000efc

08012b44 <hci_user_evt_proc>:

void hci_user_evt_proc(void)
{
 8012b44:	b580      	push	{r7, lr}
 8012b46:	b084      	sub	sp, #16
 8012b48:	af00      	add	r7, sp, #0
  /**
   * It is more secure to use LST_remove_head()/LST_insert_head() compare to LST_get_next_node()/LST_remove_node()
   * in case the user overwrite the header where the next/prev pointers are located
   */

  if((LST_is_empty(&HciAsynchEventQueue) == FALSE) && (UserEventFlow != HCI_TL_UserEventFlow_Disable))
 8012b4a:	4822      	ldr	r0, [pc, #136]	; (8012bd4 <hci_user_evt_proc+0x90>)
 8012b4c:	f000 fd28 	bl	80135a0 <LST_is_empty>
 8012b50:	4603      	mov	r3, r0
 8012b52:	2b00      	cmp	r3, #0
 8012b54:	d12b      	bne.n	8012bae <hci_user_evt_proc+0x6a>
 8012b56:	4b20      	ldr	r3, [pc, #128]	; (8012bd8 <hci_user_evt_proc+0x94>)
 8012b58:	781b      	ldrb	r3, [r3, #0]
 8012b5a:	2b00      	cmp	r3, #0
 8012b5c:	d027      	beq.n	8012bae <hci_user_evt_proc+0x6a>
  {
    LST_remove_head ( &HciAsynchEventQueue, (tListNode **)&phcievtbuffer );
 8012b5e:	f107 030c 	add.w	r3, r7, #12
 8012b62:	4619      	mov	r1, r3
 8012b64:	481b      	ldr	r0, [pc, #108]	; (8012bd4 <hci_user_evt_proc+0x90>)
 8012b66:	f000 fdaa 	bl	80136be <LST_remove_head>

    if (hciContext.UserEvtRx != NULL)
 8012b6a:	4b1c      	ldr	r3, [pc, #112]	; (8012bdc <hci_user_evt_proc+0x98>)
 8012b6c:	69db      	ldr	r3, [r3, #28]
 8012b6e:	2b00      	cmp	r3, #0
 8012b70:	d00c      	beq.n	8012b8c <hci_user_evt_proc+0x48>
    {
      UserEvtRxParam.pckt = phcievtbuffer;
 8012b72:	68fb      	ldr	r3, [r7, #12]
 8012b74:	60bb      	str	r3, [r7, #8]
      UserEvtRxParam.status = HCI_TL_UserEventFlow_Enable;
 8012b76:	2301      	movs	r3, #1
 8012b78:	713b      	strb	r3, [r7, #4]
      hciContext.UserEvtRx((void *)&UserEvtRxParam);
 8012b7a:	4b18      	ldr	r3, [pc, #96]	; (8012bdc <hci_user_evt_proc+0x98>)
 8012b7c:	69db      	ldr	r3, [r3, #28]
 8012b7e:	1d3a      	adds	r2, r7, #4
 8012b80:	4610      	mov	r0, r2
 8012b82:	4798      	blx	r3
      UserEventFlow = UserEvtRxParam.status;
 8012b84:	793a      	ldrb	r2, [r7, #4]
 8012b86:	4b14      	ldr	r3, [pc, #80]	; (8012bd8 <hci_user_evt_proc+0x94>)
 8012b88:	701a      	strb	r2, [r3, #0]
 8012b8a:	e002      	b.n	8012b92 <hci_user_evt_proc+0x4e>
    }
    else
    {
      UserEventFlow = HCI_TL_UserEventFlow_Enable;
 8012b8c:	4b12      	ldr	r3, [pc, #72]	; (8012bd8 <hci_user_evt_proc+0x94>)
 8012b8e:	2201      	movs	r2, #1
 8012b90:	701a      	strb	r2, [r3, #0]
    }

    if(UserEventFlow != HCI_TL_UserEventFlow_Disable)
 8012b92:	4b11      	ldr	r3, [pc, #68]	; (8012bd8 <hci_user_evt_proc+0x94>)
 8012b94:	781b      	ldrb	r3, [r3, #0]
 8012b96:	2b00      	cmp	r3, #0
 8012b98:	d004      	beq.n	8012ba4 <hci_user_evt_proc+0x60>
    {
      TL_MM_EvtDone( phcievtbuffer );
 8012b9a:	68fb      	ldr	r3, [r7, #12]
 8012b9c:	4618      	mov	r0, r3
 8012b9e:	f000 fc03 	bl	80133a8 <TL_MM_EvtDone>
 8012ba2:	e004      	b.n	8012bae <hci_user_evt_proc+0x6a>
    else
    {
      /**
       * put back the event in the queue
       */
      LST_insert_head ( &HciAsynchEventQueue, (tListNode *)phcievtbuffer );
 8012ba4:	68fb      	ldr	r3, [r7, #12]
 8012ba6:	4619      	mov	r1, r3
 8012ba8:	480a      	ldr	r0, [pc, #40]	; (8012bd4 <hci_user_evt_proc+0x90>)
 8012baa:	f000 fd1b 	bl	80135e4 <LST_insert_head>
    }
  }

  if((LST_is_empty(&HciAsynchEventQueue) == FALSE) && (UserEventFlow != HCI_TL_UserEventFlow_Disable))
 8012bae:	4809      	ldr	r0, [pc, #36]	; (8012bd4 <hci_user_evt_proc+0x90>)
 8012bb0:	f000 fcf6 	bl	80135a0 <LST_is_empty>
 8012bb4:	4603      	mov	r3, r0
 8012bb6:	2b00      	cmp	r3, #0
 8012bb8:	d107      	bne.n	8012bca <hci_user_evt_proc+0x86>
 8012bba:	4b07      	ldr	r3, [pc, #28]	; (8012bd8 <hci_user_evt_proc+0x94>)
 8012bbc:	781b      	ldrb	r3, [r3, #0]
 8012bbe:	2b00      	cmp	r3, #0
 8012bc0:	d003      	beq.n	8012bca <hci_user_evt_proc+0x86>
  {
    hci_notify_asynch_evt((void*) &HciAsynchEventQueue);
 8012bc2:	4804      	ldr	r0, [pc, #16]	; (8012bd4 <hci_user_evt_proc+0x90>)
 8012bc4:	f001 f828 	bl	8013c18 <hci_notify_asynch_evt>
  }


  return;
 8012bc8:	bf00      	nop
 8012bca:	bf00      	nop
}
 8012bcc:	3710      	adds	r7, #16
 8012bce:	46bd      	mov	sp, r7
 8012bd0:	bd80      	pop	{r7, pc}
 8012bd2:	bf00      	nop
 8012bd4:	200000ec 	.word	0x200000ec
 8012bd8:	200000f8 	.word	0x200000f8
 8012bdc:	20000efc 	.word	0x20000efc

08012be0 <hci_send_req>:

  return;
}

int hci_send_req(struct hci_request *p_cmd, uint8_t async)
{
 8012be0:	b580      	push	{r7, lr}
 8012be2:	b088      	sub	sp, #32
 8012be4:	af00      	add	r7, sp, #0
 8012be6:	6078      	str	r0, [r7, #4]
 8012be8:	460b      	mov	r3, r1
 8012bea:	70fb      	strb	r3, [r7, #3]
  TL_CsEvt_t    *pcommand_status_event;
  TL_EvtPacket_t *pevtpacket;
  uint8_t hci_cmd_complete_return_parameters_length;
  HCI_TL_CmdStatus_t local_cmd_status;

  NotifyCmdStatus(HCI_TL_CmdBusy);
 8012bec:	2000      	movs	r0, #0
 8012bee:	f000 f8cb 	bl	8012d88 <NotifyCmdStatus>
  local_cmd_status = HCI_TL_CmdBusy;
 8012bf2:	2300      	movs	r3, #0
 8012bf4:	77fb      	strb	r3, [r7, #31]
  opcode = ((p_cmd->ocf) & 0x03ff) | ((p_cmd->ogf) << 10);
 8012bf6:	687b      	ldr	r3, [r7, #4]
 8012bf8:	885b      	ldrh	r3, [r3, #2]
 8012bfa:	b21b      	sxth	r3, r3
 8012bfc:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8012c00:	b21a      	sxth	r2, r3
 8012c02:	687b      	ldr	r3, [r7, #4]
 8012c04:	881b      	ldrh	r3, [r3, #0]
 8012c06:	029b      	lsls	r3, r3, #10
 8012c08:	b21b      	sxth	r3, r3
 8012c0a:	4313      	orrs	r3, r2
 8012c0c:	b21b      	sxth	r3, r3
 8012c0e:	83bb      	strh	r3, [r7, #28]
  SendCmd(opcode, p_cmd->clen, p_cmd->cparam);
 8012c10:	687b      	ldr	r3, [r7, #4]
 8012c12:	68db      	ldr	r3, [r3, #12]
 8012c14:	b2d9      	uxtb	r1, r3
 8012c16:	687b      	ldr	r3, [r7, #4]
 8012c18:	689a      	ldr	r2, [r3, #8]
 8012c1a:	8bbb      	ldrh	r3, [r7, #28]
 8012c1c:	4618      	mov	r0, r3
 8012c1e:	f000 f88d 	bl	8012d3c <SendCmd>

  while(local_cmd_status == HCI_TL_CmdBusy)
 8012c22:	e04e      	b.n	8012cc2 <hci_send_req+0xe2>
  {
    hci_cmd_resp_wait(HCI_TL_DEFAULT_TIMEOUT);
 8012c24:	f248 00e8 	movw	r0, #33000	; 0x80e8
 8012c28:	f001 f80d 	bl	8013c46 <hci_cmd_resp_wait>

    /**
     * Process Cmd Event
     */
    while(LST_is_empty(&HciCmdEventQueue) == FALSE)
 8012c2c:	e043      	b.n	8012cb6 <hci_send_req+0xd6>
    {
      LST_remove_head (&HciCmdEventQueue, (tListNode **)&pevtpacket);
 8012c2e:	f107 030c 	add.w	r3, r7, #12
 8012c32:	4619      	mov	r1, r3
 8012c34:	4828      	ldr	r0, [pc, #160]	; (8012cd8 <hci_send_req+0xf8>)
 8012c36:	f000 fd42 	bl	80136be <LST_remove_head>

      if(pevtpacket->evtserial.evt.evtcode == TL_BLEEVT_CS_OPCODE)
 8012c3a:	68fb      	ldr	r3, [r7, #12]
 8012c3c:	7a5b      	ldrb	r3, [r3, #9]
 8012c3e:	2b0f      	cmp	r3, #15
 8012c40:	d114      	bne.n	8012c6c <hci_send_req+0x8c>
      {
        pcommand_status_event = (TL_CsEvt_t*)pevtpacket->evtserial.evt.payload;
 8012c42:	68fb      	ldr	r3, [r7, #12]
 8012c44:	330b      	adds	r3, #11
 8012c46:	613b      	str	r3, [r7, #16]
        if(pcommand_status_event->cmdcode == opcode)
 8012c48:	693b      	ldr	r3, [r7, #16]
 8012c4a:	885b      	ldrh	r3, [r3, #2]
 8012c4c:	b29b      	uxth	r3, r3
 8012c4e:	8bba      	ldrh	r2, [r7, #28]
 8012c50:	429a      	cmp	r2, r3
 8012c52:	d104      	bne.n	8012c5e <hci_send_req+0x7e>
        {
          *(uint8_t *)(p_cmd->rparam) = pcommand_status_event->status;
 8012c54:	687b      	ldr	r3, [r7, #4]
 8012c56:	691b      	ldr	r3, [r3, #16]
 8012c58:	693a      	ldr	r2, [r7, #16]
 8012c5a:	7812      	ldrb	r2, [r2, #0]
 8012c5c:	701a      	strb	r2, [r3, #0]
        }

        if(pcommand_status_event->numcmd != 0)
 8012c5e:	693b      	ldr	r3, [r7, #16]
 8012c60:	785b      	ldrb	r3, [r3, #1]
 8012c62:	2b00      	cmp	r3, #0
 8012c64:	d027      	beq.n	8012cb6 <hci_send_req+0xd6>
        {
          local_cmd_status = HCI_TL_CmdAvailable;
 8012c66:	2301      	movs	r3, #1
 8012c68:	77fb      	strb	r3, [r7, #31]
 8012c6a:	e024      	b.n	8012cb6 <hci_send_req+0xd6>
        }
      }
      else
      {
        pcommand_complete_event = (TL_CcEvt_t*)pevtpacket->evtserial.evt.payload;
 8012c6c:	68fb      	ldr	r3, [r7, #12]
 8012c6e:	330b      	adds	r3, #11
 8012c70:	61bb      	str	r3, [r7, #24]

        if(pcommand_complete_event->cmdcode == opcode)
 8012c72:	69bb      	ldr	r3, [r7, #24]
 8012c74:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 8012c78:	b29b      	uxth	r3, r3
 8012c7a:	8bba      	ldrh	r2, [r7, #28]
 8012c7c:	429a      	cmp	r2, r3
 8012c7e:	d114      	bne.n	8012caa <hci_send_req+0xca>
        {
          hci_cmd_complete_return_parameters_length = pevtpacket->evtserial.evt.plen - TL_EVT_HDR_SIZE;
 8012c80:	68fb      	ldr	r3, [r7, #12]
 8012c82:	7a9b      	ldrb	r3, [r3, #10]
 8012c84:	3b03      	subs	r3, #3
 8012c86:	75fb      	strb	r3, [r7, #23]
          p_cmd->rlen = MIN(hci_cmd_complete_return_parameters_length, p_cmd->rlen);
 8012c88:	687b      	ldr	r3, [r7, #4]
 8012c8a:	695a      	ldr	r2, [r3, #20]
 8012c8c:	7dfb      	ldrb	r3, [r7, #23]
 8012c8e:	429a      	cmp	r2, r3
 8012c90:	bfa8      	it	ge
 8012c92:	461a      	movge	r2, r3
 8012c94:	687b      	ldr	r3, [r7, #4]
 8012c96:	615a      	str	r2, [r3, #20]
          memcpy(p_cmd->rparam, pcommand_complete_event->payload, p_cmd->rlen);
 8012c98:	687b      	ldr	r3, [r7, #4]
 8012c9a:	6918      	ldr	r0, [r3, #16]
 8012c9c:	69bb      	ldr	r3, [r7, #24]
 8012c9e:	1cd9      	adds	r1, r3, #3
 8012ca0:	687b      	ldr	r3, [r7, #4]
 8012ca2:	695b      	ldr	r3, [r3, #20]
 8012ca4:	461a      	mov	r2, r3
 8012ca6:	f001 ff85 	bl	8014bb4 <memcpy>
        }

        if(pcommand_complete_event->numcmd != 0)
 8012caa:	69bb      	ldr	r3, [r7, #24]
 8012cac:	781b      	ldrb	r3, [r3, #0]
 8012cae:	2b00      	cmp	r3, #0
 8012cb0:	d001      	beq.n	8012cb6 <hci_send_req+0xd6>
        {
          local_cmd_status = HCI_TL_CmdAvailable;
 8012cb2:	2301      	movs	r3, #1
 8012cb4:	77fb      	strb	r3, [r7, #31]
    while(LST_is_empty(&HciCmdEventQueue) == FALSE)
 8012cb6:	4808      	ldr	r0, [pc, #32]	; (8012cd8 <hci_send_req+0xf8>)
 8012cb8:	f000 fc72 	bl	80135a0 <LST_is_empty>
 8012cbc:	4603      	mov	r3, r0
 8012cbe:	2b00      	cmp	r3, #0
 8012cc0:	d0b5      	beq.n	8012c2e <hci_send_req+0x4e>
  while(local_cmd_status == HCI_TL_CmdBusy)
 8012cc2:	7ffb      	ldrb	r3, [r7, #31]
 8012cc4:	2b00      	cmp	r3, #0
 8012cc6:	d0ad      	beq.n	8012c24 <hci_send_req+0x44>
        }
      }
    }
  }

  NotifyCmdStatus(HCI_TL_CmdAvailable);
 8012cc8:	2001      	movs	r0, #1
 8012cca:	f000 f85d 	bl	8012d88 <NotifyCmdStatus>

  return 0;
 8012cce:	2300      	movs	r3, #0
}
 8012cd0:	4618      	mov	r0, r3
 8012cd2:	3720      	adds	r7, #32
 8012cd4:	46bd      	mov	sp, r7
 8012cd6:	bd80      	pop	{r7, pc}
 8012cd8:	20000f1c 	.word	0x20000f1c

08012cdc <TlInit>:

/* Private functions ---------------------------------------------------------*/
static void TlInit( TL_CmdPacket_t * p_cmdbuffer )
{
 8012cdc:	b580      	push	{r7, lr}
 8012cde:	b086      	sub	sp, #24
 8012ce0:	af00      	add	r7, sp, #0
 8012ce2:	6078      	str	r0, [r7, #4]
  TL_BLE_InitConf_t Conf;

  /**
   * Always initialize the command event queue
   */
  LST_init_head (&HciCmdEventQueue);
 8012ce4:	480f      	ldr	r0, [pc, #60]	; (8012d24 <TlInit+0x48>)
 8012ce6:	f000 fc4b 	bl	8013580 <LST_init_head>

  pCmdBuffer = p_cmdbuffer;
 8012cea:	4a0f      	ldr	r2, [pc, #60]	; (8012d28 <TlInit+0x4c>)
 8012cec:	687b      	ldr	r3, [r7, #4]
 8012cee:	6013      	str	r3, [r2, #0]

  LST_init_head (&HciAsynchEventQueue);
 8012cf0:	480e      	ldr	r0, [pc, #56]	; (8012d2c <TlInit+0x50>)
 8012cf2:	f000 fc45 	bl	8013580 <LST_init_head>

  UserEventFlow = HCI_TL_UserEventFlow_Enable;
 8012cf6:	4b0e      	ldr	r3, [pc, #56]	; (8012d30 <TlInit+0x54>)
 8012cf8:	2201      	movs	r2, #1
 8012cfa:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  if (hciContext.io.Init)
 8012cfc:	4b0d      	ldr	r3, [pc, #52]	; (8012d34 <TlInit+0x58>)
 8012cfe:	681b      	ldr	r3, [r3, #0]
 8012d00:	2b00      	cmp	r3, #0
 8012d02:	d00a      	beq.n	8012d1a <TlInit+0x3e>
  {

    Conf.p_cmdbuffer = (uint8_t *)p_cmdbuffer;
 8012d04:	687b      	ldr	r3, [r7, #4]
 8012d06:	613b      	str	r3, [r7, #16]
    Conf.IoBusEvtCallBack = TlEvtReceived;
 8012d08:	4b0b      	ldr	r3, [pc, #44]	; (8012d38 <TlInit+0x5c>)
 8012d0a:	60bb      	str	r3, [r7, #8]
    hciContext.io.Init(&Conf);
 8012d0c:	4b09      	ldr	r3, [pc, #36]	; (8012d34 <TlInit+0x58>)
 8012d0e:	681b      	ldr	r3, [r3, #0]
 8012d10:	f107 0208 	add.w	r2, r7, #8
 8012d14:	4610      	mov	r0, r2
 8012d16:	4798      	blx	r3
  }

  return;
 8012d18:	bf00      	nop
 8012d1a:	bf00      	nop
}
 8012d1c:	3718      	adds	r7, #24
 8012d1e:	46bd      	mov	sp, r7
 8012d20:	bd80      	pop	{r7, pc}
 8012d22:	bf00      	nop
 8012d24:	20000f1c 	.word	0x20000f1c
 8012d28:	200000f4 	.word	0x200000f4
 8012d2c:	200000ec 	.word	0x200000ec
 8012d30:	200000f8 	.word	0x200000f8
 8012d34:	20000efc 	.word	0x20000efc
 8012d38:	08012dc9 	.word	0x08012dc9

08012d3c <SendCmd>:

static void SendCmd(uint16_t opcode, uint8_t plen, void *param)
{
 8012d3c:	b580      	push	{r7, lr}
 8012d3e:	b082      	sub	sp, #8
 8012d40:	af00      	add	r7, sp, #0
 8012d42:	4603      	mov	r3, r0
 8012d44:	603a      	str	r2, [r7, #0]
 8012d46:	80fb      	strh	r3, [r7, #6]
 8012d48:	460b      	mov	r3, r1
 8012d4a:	717b      	strb	r3, [r7, #5]
  pCmdBuffer->cmdserial.cmd.cmdcode = opcode;
 8012d4c:	4b0c      	ldr	r3, [pc, #48]	; (8012d80 <SendCmd+0x44>)
 8012d4e:	681b      	ldr	r3, [r3, #0]
 8012d50:	88fa      	ldrh	r2, [r7, #6]
 8012d52:	f8a3 2009 	strh.w	r2, [r3, #9]
  pCmdBuffer->cmdserial.cmd.plen = plen;
 8012d56:	4b0a      	ldr	r3, [pc, #40]	; (8012d80 <SendCmd+0x44>)
 8012d58:	681b      	ldr	r3, [r3, #0]
 8012d5a:	797a      	ldrb	r2, [r7, #5]
 8012d5c:	72da      	strb	r2, [r3, #11]
  memcpy( pCmdBuffer->cmdserial.cmd.payload, param, plen );
 8012d5e:	4b08      	ldr	r3, [pc, #32]	; (8012d80 <SendCmd+0x44>)
 8012d60:	681b      	ldr	r3, [r3, #0]
 8012d62:	330c      	adds	r3, #12
 8012d64:	797a      	ldrb	r2, [r7, #5]
 8012d66:	6839      	ldr	r1, [r7, #0]
 8012d68:	4618      	mov	r0, r3
 8012d6a:	f001 ff23 	bl	8014bb4 <memcpy>

  hciContext.io.Send(0,0);
 8012d6e:	4b05      	ldr	r3, [pc, #20]	; (8012d84 <SendCmd+0x48>)
 8012d70:	691b      	ldr	r3, [r3, #16]
 8012d72:	2100      	movs	r1, #0
 8012d74:	2000      	movs	r0, #0
 8012d76:	4798      	blx	r3

  return;
 8012d78:	bf00      	nop
}
 8012d7a:	3708      	adds	r7, #8
 8012d7c:	46bd      	mov	sp, r7
 8012d7e:	bd80      	pop	{r7, pc}
 8012d80:	200000f4 	.word	0x200000f4
 8012d84:	20000efc 	.word	0x20000efc

08012d88 <NotifyCmdStatus>:

static void NotifyCmdStatus(HCI_TL_CmdStatus_t hcicmdstatus)
{
 8012d88:	b580      	push	{r7, lr}
 8012d8a:	b082      	sub	sp, #8
 8012d8c:	af00      	add	r7, sp, #0
 8012d8e:	4603      	mov	r3, r0
 8012d90:	71fb      	strb	r3, [r7, #7]
  if(hcicmdstatus == HCI_TL_CmdBusy)
 8012d92:	79fb      	ldrb	r3, [r7, #7]
 8012d94:	2b00      	cmp	r3, #0
 8012d96:	d108      	bne.n	8012daa <NotifyCmdStatus+0x22>
  {
    if(StatusNotCallBackFunction != 0)
 8012d98:	4b0a      	ldr	r3, [pc, #40]	; (8012dc4 <NotifyCmdStatus+0x3c>)
 8012d9a:	681b      	ldr	r3, [r3, #0]
 8012d9c:	2b00      	cmp	r3, #0
 8012d9e:	d00d      	beq.n	8012dbc <NotifyCmdStatus+0x34>
    {
      StatusNotCallBackFunction(HCI_TL_CmdBusy);
 8012da0:	4b08      	ldr	r3, [pc, #32]	; (8012dc4 <NotifyCmdStatus+0x3c>)
 8012da2:	681b      	ldr	r3, [r3, #0]
 8012da4:	2000      	movs	r0, #0
 8012da6:	4798      	blx	r3
    {
      StatusNotCallBackFunction(HCI_TL_CmdAvailable);
    }
  }

  return;
 8012da8:	e008      	b.n	8012dbc <NotifyCmdStatus+0x34>
    if(StatusNotCallBackFunction != 0)
 8012daa:	4b06      	ldr	r3, [pc, #24]	; (8012dc4 <NotifyCmdStatus+0x3c>)
 8012dac:	681b      	ldr	r3, [r3, #0]
 8012dae:	2b00      	cmp	r3, #0
 8012db0:	d004      	beq.n	8012dbc <NotifyCmdStatus+0x34>
      StatusNotCallBackFunction(HCI_TL_CmdAvailable);
 8012db2:	4b04      	ldr	r3, [pc, #16]	; (8012dc4 <NotifyCmdStatus+0x3c>)
 8012db4:	681b      	ldr	r3, [r3, #0]
 8012db6:	2001      	movs	r0, #1
 8012db8:	4798      	blx	r3
  return;
 8012dba:	bf00      	nop
 8012dbc:	bf00      	nop
}
 8012dbe:	3708      	adds	r7, #8
 8012dc0:	46bd      	mov	sp, r7
 8012dc2:	bd80      	pop	{r7, pc}
 8012dc4:	20000f24 	.word	0x20000f24

08012dc8 <TlEvtReceived>:

static void TlEvtReceived(TL_EvtPacket_t *hcievt)
{
 8012dc8:	b580      	push	{r7, lr}
 8012dca:	b082      	sub	sp, #8
 8012dcc:	af00      	add	r7, sp, #0
 8012dce:	6078      	str	r0, [r7, #4]
  if ( ((hcievt->evtserial.evt.evtcode) == TL_BLEEVT_CS_OPCODE) || ((hcievt->evtserial.evt.evtcode) == TL_BLEEVT_CC_OPCODE ) )
 8012dd0:	687b      	ldr	r3, [r7, #4]
 8012dd2:	7a5b      	ldrb	r3, [r3, #9]
 8012dd4:	2b0f      	cmp	r3, #15
 8012dd6:	d003      	beq.n	8012de0 <TlEvtReceived+0x18>
 8012dd8:	687b      	ldr	r3, [r7, #4]
 8012dda:	7a5b      	ldrb	r3, [r3, #9]
 8012ddc:	2b0e      	cmp	r3, #14
 8012dde:	d107      	bne.n	8012df0 <TlEvtReceived+0x28>
  {
    LST_insert_tail(&HciCmdEventQueue, (tListNode *)hcievt);
 8012de0:	6879      	ldr	r1, [r7, #4]
 8012de2:	4809      	ldr	r0, [pc, #36]	; (8012e08 <TlEvtReceived+0x40>)
 8012de4:	f000 fc24 	bl	8013630 <LST_insert_tail>
    hci_cmd_resp_release(0); /**< Notify the application a full Cmd Event has been received */
 8012de8:	2000      	movs	r0, #0
 8012dea:	f000 ff21 	bl	8013c30 <hci_cmd_resp_release>
 8012dee:	e006      	b.n	8012dfe <TlEvtReceived+0x36>
  }
  else
  {
    LST_insert_tail(&HciAsynchEventQueue, (tListNode *)hcievt);
 8012df0:	6879      	ldr	r1, [r7, #4]
 8012df2:	4806      	ldr	r0, [pc, #24]	; (8012e0c <TlEvtReceived+0x44>)
 8012df4:	f000 fc1c 	bl	8013630 <LST_insert_tail>
    hci_notify_asynch_evt((void*) &HciAsynchEventQueue); /**< Notify the application a full HCI event has been received */
 8012df8:	4804      	ldr	r0, [pc, #16]	; (8012e0c <TlEvtReceived+0x44>)
 8012dfa:	f000 ff0d 	bl	8013c18 <hci_notify_asynch_evt>
  }

  return;
 8012dfe:	bf00      	nop
}
 8012e00:	3708      	adds	r7, #8
 8012e02:	46bd      	mov	sp, r7
 8012e04:	bd80      	pop	{r7, pc}
 8012e06:	bf00      	nop
 8012e08:	20000f1c 	.word	0x20000f1c
 8012e0c:	200000ec 	.word	0x200000ec

08012e10 <hci_register_io_bus>:
#include "hci_tl.h"
#include "tl.h"


void hci_register_io_bus(tHciIO* fops)
{
 8012e10:	b480      	push	{r7}
 8012e12:	b083      	sub	sp, #12
 8012e14:	af00      	add	r7, sp, #0
 8012e16:	6078      	str	r0, [r7, #4]
  /* Register IO bus services */
  fops->Init    = TL_BLE_Init;
 8012e18:	687b      	ldr	r3, [r7, #4]
 8012e1a:	4a05      	ldr	r2, [pc, #20]	; (8012e30 <hci_register_io_bus+0x20>)
 8012e1c:	601a      	str	r2, [r3, #0]
  fops->Send    = TL_BLE_SendCmd;
 8012e1e:	687b      	ldr	r3, [r7, #4]
 8012e20:	4a04      	ldr	r2, [pc, #16]	; (8012e34 <hci_register_io_bus+0x24>)
 8012e22:	611a      	str	r2, [r3, #16]

  return;
 8012e24:	bf00      	nop
}
 8012e26:	370c      	adds	r7, #12
 8012e28:	46bd      	mov	sp, r7
 8012e2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012e2e:	4770      	bx	lr
 8012e30:	08013121 	.word	0x08013121
 8012e34:	08013189 	.word	0x08013189

08012e38 <shci_init>:
static void TlUserEvtReceived(TL_EvtPacket_t *shcievt);
static void TlInit( TL_CmdPacket_t * p_cmdbuffer );

/* Interface ------- ---------------------------------------------------------*/
void shci_init(void(* UserEvtRx)(void* pData), void* pConf)
{
 8012e38:	b580      	push	{r7, lr}
 8012e3a:	b082      	sub	sp, #8
 8012e3c:	af00      	add	r7, sp, #0
 8012e3e:	6078      	str	r0, [r7, #4]
 8012e40:	6039      	str	r1, [r7, #0]
  StatusNotCallBackFunction = ((SHCI_TL_HciInitConf_t *)pConf)->StatusNotCallBack;
 8012e42:	683b      	ldr	r3, [r7, #0]
 8012e44:	685b      	ldr	r3, [r3, #4]
 8012e46:	4a08      	ldr	r2, [pc, #32]	; (8012e68 <shci_init+0x30>)
 8012e48:	6013      	str	r3, [r2, #0]
  shciContext.UserEvtRx = UserEvtRx;
 8012e4a:	4a08      	ldr	r2, [pc, #32]	; (8012e6c <shci_init+0x34>)
 8012e4c:	687b      	ldr	r3, [r7, #4]
 8012e4e:	61d3      	str	r3, [r2, #28]

  shci_register_io_bus (&shciContext.io);
 8012e50:	4806      	ldr	r0, [pc, #24]	; (8012e6c <shci_init+0x34>)
 8012e52:	f000 f911 	bl	8013078 <shci_register_io_bus>

  TlInit((TL_CmdPacket_t *)(((SHCI_TL_HciInitConf_t *)pConf)->p_cmdbuffer));
 8012e56:	683b      	ldr	r3, [r7, #0]
 8012e58:	681b      	ldr	r3, [r3, #0]
 8012e5a:	4618      	mov	r0, r3
 8012e5c:	f000 f894 	bl	8012f88 <TlInit>

  return;
 8012e60:	bf00      	nop
}
 8012e62:	3708      	adds	r7, #8
 8012e64:	46bd      	mov	sp, r7
 8012e66:	bd80      	pop	{r7, pc}
 8012e68:	20000f48 	.word	0x20000f48
 8012e6c:	20000f28 	.word	0x20000f28

08012e70 <shci_user_evt_proc>:

void shci_user_evt_proc(void)
{
 8012e70:	b580      	push	{r7, lr}
 8012e72:	b084      	sub	sp, #16
 8012e74:	af00      	add	r7, sp, #0

  /**
   * It is more secure to use LST_remove_head()/LST_insert_head() compare to LST_get_next_node()/LST_remove_node()
   * in case the user overwrite the header where the next/prev pointers are located
   */
  if((LST_is_empty(&SHciAsynchEventQueue) == FALSE) && (SHCI_TL_UserEventFlow != SHCI_TL_UserEventFlow_Disable))
 8012e76:	4822      	ldr	r0, [pc, #136]	; (8012f00 <shci_user_evt_proc+0x90>)
 8012e78:	f000 fb92 	bl	80135a0 <LST_is_empty>
 8012e7c:	4603      	mov	r3, r0
 8012e7e:	2b00      	cmp	r3, #0
 8012e80:	d12b      	bne.n	8012eda <shci_user_evt_proc+0x6a>
 8012e82:	4b20      	ldr	r3, [pc, #128]	; (8012f04 <shci_user_evt_proc+0x94>)
 8012e84:	781b      	ldrb	r3, [r3, #0]
 8012e86:	2b00      	cmp	r3, #0
 8012e88:	d027      	beq.n	8012eda <shci_user_evt_proc+0x6a>
  {
    LST_remove_head ( &SHciAsynchEventQueue, (tListNode **)&phcievtbuffer );
 8012e8a:	f107 030c 	add.w	r3, r7, #12
 8012e8e:	4619      	mov	r1, r3
 8012e90:	481b      	ldr	r0, [pc, #108]	; (8012f00 <shci_user_evt_proc+0x90>)
 8012e92:	f000 fc14 	bl	80136be <LST_remove_head>

    if (shciContext.UserEvtRx != NULL)
 8012e96:	4b1c      	ldr	r3, [pc, #112]	; (8012f08 <shci_user_evt_proc+0x98>)
 8012e98:	69db      	ldr	r3, [r3, #28]
 8012e9a:	2b00      	cmp	r3, #0
 8012e9c:	d00c      	beq.n	8012eb8 <shci_user_evt_proc+0x48>
    {
      UserEvtRxParam.pckt = phcievtbuffer;
 8012e9e:	68fb      	ldr	r3, [r7, #12]
 8012ea0:	60bb      	str	r3, [r7, #8]
      UserEvtRxParam.status = SHCI_TL_UserEventFlow_Enable;
 8012ea2:	2301      	movs	r3, #1
 8012ea4:	713b      	strb	r3, [r7, #4]
      shciContext.UserEvtRx((void *)&UserEvtRxParam);
 8012ea6:	4b18      	ldr	r3, [pc, #96]	; (8012f08 <shci_user_evt_proc+0x98>)
 8012ea8:	69db      	ldr	r3, [r3, #28]
 8012eaa:	1d3a      	adds	r2, r7, #4
 8012eac:	4610      	mov	r0, r2
 8012eae:	4798      	blx	r3
      SHCI_TL_UserEventFlow = UserEvtRxParam.status;
 8012eb0:	793a      	ldrb	r2, [r7, #4]
 8012eb2:	4b14      	ldr	r3, [pc, #80]	; (8012f04 <shci_user_evt_proc+0x94>)
 8012eb4:	701a      	strb	r2, [r3, #0]
 8012eb6:	e002      	b.n	8012ebe <shci_user_evt_proc+0x4e>
    }
    else
    {
      SHCI_TL_UserEventFlow = SHCI_TL_UserEventFlow_Enable;
 8012eb8:	4b12      	ldr	r3, [pc, #72]	; (8012f04 <shci_user_evt_proc+0x94>)
 8012eba:	2201      	movs	r2, #1
 8012ebc:	701a      	strb	r2, [r3, #0]
    }

    if(SHCI_TL_UserEventFlow != SHCI_TL_UserEventFlow_Disable)
 8012ebe:	4b11      	ldr	r3, [pc, #68]	; (8012f04 <shci_user_evt_proc+0x94>)
 8012ec0:	781b      	ldrb	r3, [r3, #0]
 8012ec2:	2b00      	cmp	r3, #0
 8012ec4:	d004      	beq.n	8012ed0 <shci_user_evt_proc+0x60>
    {
      TL_MM_EvtDone( phcievtbuffer );
 8012ec6:	68fb      	ldr	r3, [r7, #12]
 8012ec8:	4618      	mov	r0, r3
 8012eca:	f000 fa6d 	bl	80133a8 <TL_MM_EvtDone>
 8012ece:	e004      	b.n	8012eda <shci_user_evt_proc+0x6a>
    else
    {
      /**
       * put back the event in the queue
       */
      LST_insert_head ( &SHciAsynchEventQueue, (tListNode *)phcievtbuffer );
 8012ed0:	68fb      	ldr	r3, [r7, #12]
 8012ed2:	4619      	mov	r1, r3
 8012ed4:	480a      	ldr	r0, [pc, #40]	; (8012f00 <shci_user_evt_proc+0x90>)
 8012ed6:	f000 fb85 	bl	80135e4 <LST_insert_head>
    }
  }

  if((LST_is_empty(&SHciAsynchEventQueue) == FALSE) && (SHCI_TL_UserEventFlow != SHCI_TL_UserEventFlow_Disable))
 8012eda:	4809      	ldr	r0, [pc, #36]	; (8012f00 <shci_user_evt_proc+0x90>)
 8012edc:	f000 fb60 	bl	80135a0 <LST_is_empty>
 8012ee0:	4603      	mov	r3, r0
 8012ee2:	2b00      	cmp	r3, #0
 8012ee4:	d107      	bne.n	8012ef6 <shci_user_evt_proc+0x86>
 8012ee6:	4b07      	ldr	r3, [pc, #28]	; (8012f04 <shci_user_evt_proc+0x94>)
 8012ee8:	781b      	ldrb	r3, [r3, #0]
 8012eea:	2b00      	cmp	r3, #0
 8012eec:	d003      	beq.n	8012ef6 <shci_user_evt_proc+0x86>
  {
    shci_notify_asynch_evt((void*) &SHciAsynchEventQueue);
 8012eee:	4804      	ldr	r0, [pc, #16]	; (8012f00 <shci_user_evt_proc+0x90>)
 8012ef0:	f7f8 fce9 	bl	800b8c6 <shci_notify_asynch_evt>
  }


  return;
 8012ef4:	bf00      	nop
 8012ef6:	bf00      	nop
}
 8012ef8:	3710      	adds	r7, #16
 8012efa:	46bd      	mov	sp, r7
 8012efc:	bd80      	pop	{r7, pc}
 8012efe:	bf00      	nop
 8012f00:	20000108 	.word	0x20000108
 8012f04:	20000118 	.word	0x20000118
 8012f08:	20000f28 	.word	0x20000f28

08012f0c <shci_send>:

  return;
}

void shci_send( uint16_t cmd_code, uint8_t len_cmd_payload, uint8_t * p_cmd_payload, TL_EvtPacket_t * p_rsp )
{
 8012f0c:	b580      	push	{r7, lr}
 8012f0e:	b084      	sub	sp, #16
 8012f10:	af00      	add	r7, sp, #0
 8012f12:	60ba      	str	r2, [r7, #8]
 8012f14:	607b      	str	r3, [r7, #4]
 8012f16:	4603      	mov	r3, r0
 8012f18:	81fb      	strh	r3, [r7, #14]
 8012f1a:	460b      	mov	r3, r1
 8012f1c:	737b      	strb	r3, [r7, #13]
  Cmd_SetStatus(SHCI_TL_CmdBusy);
 8012f1e:	2000      	movs	r0, #0
 8012f20:	f000 f864 	bl	8012fec <Cmd_SetStatus>

  pCmdBuffer->cmdserial.cmd.cmdcode = cmd_code;
 8012f24:	4b16      	ldr	r3, [pc, #88]	; (8012f80 <shci_send+0x74>)
 8012f26:	681b      	ldr	r3, [r3, #0]
 8012f28:	89fa      	ldrh	r2, [r7, #14]
 8012f2a:	f8a3 2009 	strh.w	r2, [r3, #9]
  pCmdBuffer->cmdserial.cmd.plen = len_cmd_payload;
 8012f2e:	4b14      	ldr	r3, [pc, #80]	; (8012f80 <shci_send+0x74>)
 8012f30:	681b      	ldr	r3, [r3, #0]
 8012f32:	7b7a      	ldrb	r2, [r7, #13]
 8012f34:	72da      	strb	r2, [r3, #11]

  memcpy(pCmdBuffer->cmdserial.cmd.payload, p_cmd_payload, len_cmd_payload );
 8012f36:	4b12      	ldr	r3, [pc, #72]	; (8012f80 <shci_send+0x74>)
 8012f38:	681b      	ldr	r3, [r3, #0]
 8012f3a:	330c      	adds	r3, #12
 8012f3c:	7b7a      	ldrb	r2, [r7, #13]
 8012f3e:	68b9      	ldr	r1, [r7, #8]
 8012f40:	4618      	mov	r0, r3
 8012f42:	f001 fe37 	bl	8014bb4 <memcpy>

  shciContext.io.Send(0,0);
 8012f46:	4b0f      	ldr	r3, [pc, #60]	; (8012f84 <shci_send+0x78>)
 8012f48:	691b      	ldr	r3, [r3, #16]
 8012f4a:	2100      	movs	r1, #0
 8012f4c:	2000      	movs	r0, #0
 8012f4e:	4798      	blx	r3

  shci_cmd_resp_wait(SHCI_TL_DEFAULT_TIMEOUT);
 8012f50:	f248 00e8 	movw	r0, #33000	; 0x80e8
 8012f54:	f7f8 fcce 	bl	800b8f4 <shci_cmd_resp_wait>

  /**
   * The command complete of a system command does not have the header
   * It starts immediately with the evtserial field
   */
  memcpy( &(p_rsp->evtserial), pCmdBuffer, ((TL_EvtSerial_t*)pCmdBuffer)->evt.plen + TL_EVT_HDR_SIZE );
 8012f58:	687b      	ldr	r3, [r7, #4]
 8012f5a:	f103 0008 	add.w	r0, r3, #8
 8012f5e:	4b08      	ldr	r3, [pc, #32]	; (8012f80 <shci_send+0x74>)
 8012f60:	6819      	ldr	r1, [r3, #0]
 8012f62:	4b07      	ldr	r3, [pc, #28]	; (8012f80 <shci_send+0x74>)
 8012f64:	681b      	ldr	r3, [r3, #0]
 8012f66:	789b      	ldrb	r3, [r3, #2]
 8012f68:	3303      	adds	r3, #3
 8012f6a:	461a      	mov	r2, r3
 8012f6c:	f001 fe22 	bl	8014bb4 <memcpy>

  Cmd_SetStatus(SHCI_TL_CmdAvailable);
 8012f70:	2001      	movs	r0, #1
 8012f72:	f000 f83b 	bl	8012fec <Cmd_SetStatus>

  return;
 8012f76:	bf00      	nop
}
 8012f78:	3710      	adds	r7, #16
 8012f7a:	46bd      	mov	sp, r7
 8012f7c:	bd80      	pop	{r7, pc}
 8012f7e:	bf00      	nop
 8012f80:	20000114 	.word	0x20000114
 8012f84:	20000f28 	.word	0x20000f28

08012f88 <TlInit>:

/* Private functions ---------------------------------------------------------*/
static void TlInit( TL_CmdPacket_t * p_cmdbuffer )
{
 8012f88:	b580      	push	{r7, lr}
 8012f8a:	b086      	sub	sp, #24
 8012f8c:	af00      	add	r7, sp, #0
 8012f8e:	6078      	str	r0, [r7, #4]
  TL_SYS_InitConf_t Conf;

  pCmdBuffer = p_cmdbuffer;
 8012f90:	4a10      	ldr	r2, [pc, #64]	; (8012fd4 <TlInit+0x4c>)
 8012f92:	687b      	ldr	r3, [r7, #4]
 8012f94:	6013      	str	r3, [r2, #0]

  LST_init_head (&SHciAsynchEventQueue);
 8012f96:	4810      	ldr	r0, [pc, #64]	; (8012fd8 <TlInit+0x50>)
 8012f98:	f000 faf2 	bl	8013580 <LST_init_head>

  Cmd_SetStatus(SHCI_TL_CmdAvailable);
 8012f9c:	2001      	movs	r0, #1
 8012f9e:	f000 f825 	bl	8012fec <Cmd_SetStatus>

  SHCI_TL_UserEventFlow = SHCI_TL_UserEventFlow_Enable;
 8012fa2:	4b0e      	ldr	r3, [pc, #56]	; (8012fdc <TlInit+0x54>)
 8012fa4:	2201      	movs	r2, #1
 8012fa6:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  if (shciContext.io.Init)
 8012fa8:	4b0d      	ldr	r3, [pc, #52]	; (8012fe0 <TlInit+0x58>)
 8012faa:	681b      	ldr	r3, [r3, #0]
 8012fac:	2b00      	cmp	r3, #0
 8012fae:	d00c      	beq.n	8012fca <TlInit+0x42>
  {

    Conf.p_cmdbuffer = (uint8_t *)p_cmdbuffer;
 8012fb0:	687b      	ldr	r3, [r7, #4]
 8012fb2:	617b      	str	r3, [r7, #20]
    Conf.IoBusCallBackCmdEvt = TlCmdEvtReceived;
 8012fb4:	4b0b      	ldr	r3, [pc, #44]	; (8012fe4 <TlInit+0x5c>)
 8012fb6:	60fb      	str	r3, [r7, #12]
    Conf.IoBusCallBackUserEvt = TlUserEvtReceived;
 8012fb8:	4b0b      	ldr	r3, [pc, #44]	; (8012fe8 <TlInit+0x60>)
 8012fba:	613b      	str	r3, [r7, #16]
    shciContext.io.Init(&Conf);
 8012fbc:	4b08      	ldr	r3, [pc, #32]	; (8012fe0 <TlInit+0x58>)
 8012fbe:	681b      	ldr	r3, [r3, #0]
 8012fc0:	f107 020c 	add.w	r2, r7, #12
 8012fc4:	4610      	mov	r0, r2
 8012fc6:	4798      	blx	r3
  }

  return;
 8012fc8:	bf00      	nop
 8012fca:	bf00      	nop
}
 8012fcc:	3718      	adds	r7, #24
 8012fce:	46bd      	mov	sp, r7
 8012fd0:	bd80      	pop	{r7, pc}
 8012fd2:	bf00      	nop
 8012fd4:	20000114 	.word	0x20000114
 8012fd8:	20000108 	.word	0x20000108
 8012fdc:	20000118 	.word	0x20000118
 8012fe0:	20000f28 	.word	0x20000f28
 8012fe4:	0801303d 	.word	0x0801303d
 8012fe8:	08013055 	.word	0x08013055

08012fec <Cmd_SetStatus>:

static void Cmd_SetStatus(SHCI_TL_CmdStatus_t shcicmdstatus)
{
 8012fec:	b580      	push	{r7, lr}
 8012fee:	b082      	sub	sp, #8
 8012ff0:	af00      	add	r7, sp, #0
 8012ff2:	4603      	mov	r3, r0
 8012ff4:	71fb      	strb	r3, [r7, #7]
  if(shcicmdstatus == SHCI_TL_CmdBusy)
 8012ff6:	79fb      	ldrb	r3, [r7, #7]
 8012ff8:	2b00      	cmp	r3, #0
 8012ffa:	d10b      	bne.n	8013014 <Cmd_SetStatus+0x28>
  {
    if(StatusNotCallBackFunction != 0)
 8012ffc:	4b0d      	ldr	r3, [pc, #52]	; (8013034 <Cmd_SetStatus+0x48>)
 8012ffe:	681b      	ldr	r3, [r3, #0]
 8013000:	2b00      	cmp	r3, #0
 8013002:	d003      	beq.n	801300c <Cmd_SetStatus+0x20>
    {
      StatusNotCallBackFunction( SHCI_TL_CmdBusy );
 8013004:	4b0b      	ldr	r3, [pc, #44]	; (8013034 <Cmd_SetStatus+0x48>)
 8013006:	681b      	ldr	r3, [r3, #0]
 8013008:	2000      	movs	r0, #0
 801300a:	4798      	blx	r3
    }
    SHCICmdStatus = SHCI_TL_CmdBusy;
 801300c:	4b0a      	ldr	r3, [pc, #40]	; (8013038 <Cmd_SetStatus+0x4c>)
 801300e:	2200      	movs	r2, #0
 8013010:	701a      	strb	r2, [r3, #0]
    {
      StatusNotCallBackFunction( SHCI_TL_CmdAvailable );
    }
  }

  return;
 8013012:	e00b      	b.n	801302c <Cmd_SetStatus+0x40>
    SHCICmdStatus = SHCI_TL_CmdAvailable;
 8013014:	4b08      	ldr	r3, [pc, #32]	; (8013038 <Cmd_SetStatus+0x4c>)
 8013016:	2201      	movs	r2, #1
 8013018:	701a      	strb	r2, [r3, #0]
    if(StatusNotCallBackFunction != 0)
 801301a:	4b06      	ldr	r3, [pc, #24]	; (8013034 <Cmd_SetStatus+0x48>)
 801301c:	681b      	ldr	r3, [r3, #0]
 801301e:	2b00      	cmp	r3, #0
 8013020:	d004      	beq.n	801302c <Cmd_SetStatus+0x40>
      StatusNotCallBackFunction( SHCI_TL_CmdAvailable );
 8013022:	4b04      	ldr	r3, [pc, #16]	; (8013034 <Cmd_SetStatus+0x48>)
 8013024:	681b      	ldr	r3, [r3, #0]
 8013026:	2001      	movs	r0, #1
 8013028:	4798      	blx	r3
  return;
 801302a:	bf00      	nop
 801302c:	bf00      	nop
}
 801302e:	3708      	adds	r7, #8
 8013030:	46bd      	mov	sp, r7
 8013032:	bd80      	pop	{r7, pc}
 8013034:	20000f48 	.word	0x20000f48
 8013038:	20000110 	.word	0x20000110

0801303c <TlCmdEvtReceived>:

static void TlCmdEvtReceived(TL_EvtPacket_t *shcievt)
{
 801303c:	b580      	push	{r7, lr}
 801303e:	b082      	sub	sp, #8
 8013040:	af00      	add	r7, sp, #0
 8013042:	6078      	str	r0, [r7, #4]
  (void)(shcievt);
  shci_cmd_resp_release(0); /**< Notify the application the Cmd response has been received */
 8013044:	2000      	movs	r0, #0
 8013046:	f7f8 fc4a 	bl	800b8de <shci_cmd_resp_release>

  return;
 801304a:	bf00      	nop
}
 801304c:	3708      	adds	r7, #8
 801304e:	46bd      	mov	sp, r7
 8013050:	bd80      	pop	{r7, pc}
	...

08013054 <TlUserEvtReceived>:

static void TlUserEvtReceived(TL_EvtPacket_t *shcievt)
{
 8013054:	b580      	push	{r7, lr}
 8013056:	b082      	sub	sp, #8
 8013058:	af00      	add	r7, sp, #0
 801305a:	6078      	str	r0, [r7, #4]
  LST_insert_tail(&SHciAsynchEventQueue, (tListNode *)shcievt);
 801305c:	6879      	ldr	r1, [r7, #4]
 801305e:	4805      	ldr	r0, [pc, #20]	; (8013074 <TlUserEvtReceived+0x20>)
 8013060:	f000 fae6 	bl	8013630 <LST_insert_tail>
  shci_notify_asynch_evt((void*) &SHciAsynchEventQueue); /**< Notify the application a full HCI event has been received */
 8013064:	4803      	ldr	r0, [pc, #12]	; (8013074 <TlUserEvtReceived+0x20>)
 8013066:	f7f8 fc2e 	bl	800b8c6 <shci_notify_asynch_evt>

  return;
 801306a:	bf00      	nop
}
 801306c:	3708      	adds	r7, #8
 801306e:	46bd      	mov	sp, r7
 8013070:	bd80      	pop	{r7, pc}
 8013072:	bf00      	nop
 8013074:	20000108 	.word	0x20000108

08013078 <shci_register_io_bus>:
#include "shci_tl.h"
#include "tl.h"


void shci_register_io_bus(tSHciIO* fops)
{
 8013078:	b480      	push	{r7}
 801307a:	b083      	sub	sp, #12
 801307c:	af00      	add	r7, sp, #0
 801307e:	6078      	str	r0, [r7, #4]
  /* Register IO bus services */
  fops->Init    = TL_SYS_Init;
 8013080:	687b      	ldr	r3, [r7, #4]
 8013082:	4a05      	ldr	r2, [pc, #20]	; (8013098 <shci_register_io_bus+0x20>)
 8013084:	601a      	str	r2, [r3, #0]
  fops->Send    = TL_SYS_SendCmd;
 8013086:	687b      	ldr	r3, [r7, #4]
 8013088:	4a04      	ldr	r2, [pc, #16]	; (801309c <shci_register_io_bus+0x24>)
 801308a:	611a      	str	r2, [r3, #16]

  return;
 801308c:	bf00      	nop
}
 801308e:	370c      	adds	r7, #12
 8013090:	46bd      	mov	sp, r7
 8013092:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013096:	4770      	bx	lr
 8013098:	08013235 	.word	0x08013235
 801309c:	08013289 	.word	0x08013289

080130a0 <TL_Enable>:

/******************************************************************************
 * GENERAL
 ******************************************************************************/
void TL_Enable( void )
{
 80130a0:	b580      	push	{r7, lr}
 80130a2:	af00      	add	r7, sp, #0
  HW_IPCC_Enable();
 80130a4:	f001 fa32 	bl	801450c <HW_IPCC_Enable>

  return;
 80130a8:	bf00      	nop
}
 80130aa:	bd80      	pop	{r7, pc}

080130ac <TL_Init>:


void TL_Init( void )
{
 80130ac:	b580      	push	{r7, lr}
 80130ae:	af00      	add	r7, sp, #0
  TL_RefTable.p_device_info_table = &TL_DeviceInfoTable;
 80130b0:	4b10      	ldr	r3, [pc, #64]	; (80130f4 <TL_Init+0x48>)
 80130b2:	4a11      	ldr	r2, [pc, #68]	; (80130f8 <TL_Init+0x4c>)
 80130b4:	601a      	str	r2, [r3, #0]
  TL_RefTable.p_ble_table = &TL_BleTable;
 80130b6:	4b0f      	ldr	r3, [pc, #60]	; (80130f4 <TL_Init+0x48>)
 80130b8:	4a10      	ldr	r2, [pc, #64]	; (80130fc <TL_Init+0x50>)
 80130ba:	605a      	str	r2, [r3, #4]
  TL_RefTable.p_thread_table = &TL_ThreadTable;
 80130bc:	4b0d      	ldr	r3, [pc, #52]	; (80130f4 <TL_Init+0x48>)
 80130be:	4a10      	ldr	r2, [pc, #64]	; (8013100 <TL_Init+0x54>)
 80130c0:	609a      	str	r2, [r3, #8]
  TL_RefTable.p_lld_tests_table = &TL_LldTestsTable;
 80130c2:	4b0c      	ldr	r3, [pc, #48]	; (80130f4 <TL_Init+0x48>)
 80130c4:	4a0f      	ldr	r2, [pc, #60]	; (8013104 <TL_Init+0x58>)
 80130c6:	621a      	str	r2, [r3, #32]
  TL_RefTable.p_lld_ble_table = &TL_LldBleTable;
 80130c8:	4b0a      	ldr	r3, [pc, #40]	; (80130f4 <TL_Init+0x48>)
 80130ca:	4a0f      	ldr	r2, [pc, #60]	; (8013108 <TL_Init+0x5c>)
 80130cc:	625a      	str	r2, [r3, #36]	; 0x24
  TL_RefTable.p_sys_table = &TL_SysTable;
 80130ce:	4b09      	ldr	r3, [pc, #36]	; (80130f4 <TL_Init+0x48>)
 80130d0:	4a0e      	ldr	r2, [pc, #56]	; (801310c <TL_Init+0x60>)
 80130d2:	60da      	str	r2, [r3, #12]
  TL_RefTable.p_mem_manager_table = &TL_MemManagerTable;
 80130d4:	4b07      	ldr	r3, [pc, #28]	; (80130f4 <TL_Init+0x48>)
 80130d6:	4a0e      	ldr	r2, [pc, #56]	; (8013110 <TL_Init+0x64>)
 80130d8:	611a      	str	r2, [r3, #16]
  TL_RefTable.p_traces_table = &TL_TracesTable;
 80130da:	4b06      	ldr	r3, [pc, #24]	; (80130f4 <TL_Init+0x48>)
 80130dc:	4a0d      	ldr	r2, [pc, #52]	; (8013114 <TL_Init+0x68>)
 80130de:	615a      	str	r2, [r3, #20]
  TL_RefTable.p_mac_802_15_4_table = &TL_Mac_802_15_4_Table;
 80130e0:	4b04      	ldr	r3, [pc, #16]	; (80130f4 <TL_Init+0x48>)
 80130e2:	4a0d      	ldr	r2, [pc, #52]	; (8013118 <TL_Init+0x6c>)
 80130e4:	619a      	str	r2, [r3, #24]
  TL_RefTable.p_zigbee_table = &TL_Zigbee_Table;
 80130e6:	4b03      	ldr	r3, [pc, #12]	; (80130f4 <TL_Init+0x48>)
 80130e8:	4a0c      	ldr	r2, [pc, #48]	; (801311c <TL_Init+0x70>)
 80130ea:	61da      	str	r2, [r3, #28]
  HW_IPCC_Init();
 80130ec:	f001 fa22 	bl	8014534 <HW_IPCC_Init>

  return;
 80130f0:	bf00      	nop
}
 80130f2:	bd80      	pop	{r7, pc}
 80130f4:	20030000 	.word	0x20030000
 80130f8:	20030028 	.word	0x20030028
 80130fc:	20030048 	.word	0x20030048
 8013100:	20030058 	.word	0x20030058
 8013104:	20030064 	.word	0x20030064
 8013108:	2003006c 	.word	0x2003006c
 801310c:	20030074 	.word	0x20030074
 8013110:	2003007c 	.word	0x2003007c
 8013114:	20030098 	.word	0x20030098
 8013118:	2003009c 	.word	0x2003009c
 801311c:	200300a8 	.word	0x200300a8

08013120 <TL_BLE_Init>:

/******************************************************************************
 * BLE
 ******************************************************************************/
int32_t TL_BLE_Init( void* pConf )
{
 8013120:	b580      	push	{r7, lr}
 8013122:	b084      	sub	sp, #16
 8013124:	af00      	add	r7, sp, #0
 8013126:	6078      	str	r0, [r7, #4]
  MB_BleTable_t  * p_bletable;

  TL_BLE_InitConf_t *pInitHciConf = (TL_BLE_InitConf_t *) pConf;
 8013128:	687b      	ldr	r3, [r7, #4]
 801312a:	60fb      	str	r3, [r7, #12]

  LST_init_head (&EvtQueue);
 801312c:	4811      	ldr	r0, [pc, #68]	; (8013174 <TL_BLE_Init+0x54>)
 801312e:	f000 fa27 	bl	8013580 <LST_init_head>

  p_bletable = TL_RefTable.p_ble_table;
 8013132:	4b11      	ldr	r3, [pc, #68]	; (8013178 <TL_BLE_Init+0x58>)
 8013134:	685b      	ldr	r3, [r3, #4]
 8013136:	60bb      	str	r3, [r7, #8]

  p_bletable->pcmd_buffer = pInitHciConf->p_cmdbuffer;
 8013138:	68fb      	ldr	r3, [r7, #12]
 801313a:	689a      	ldr	r2, [r3, #8]
 801313c:	68bb      	ldr	r3, [r7, #8]
 801313e:	601a      	str	r2, [r3, #0]
  p_bletable->phci_acl_data_buffer = pInitHciConf->p_AclDataBuffer;
 8013140:	68fb      	ldr	r3, [r7, #12]
 8013142:	68da      	ldr	r2, [r3, #12]
 8013144:	68bb      	ldr	r3, [r7, #8]
 8013146:	60da      	str	r2, [r3, #12]
  p_bletable->pcs_buffer  = (uint8_t*)CsBuffer;
 8013148:	68bb      	ldr	r3, [r7, #8]
 801314a:	4a0c      	ldr	r2, [pc, #48]	; (801317c <TL_BLE_Init+0x5c>)
 801314c:	605a      	str	r2, [r3, #4]
  p_bletable->pevt_queue  = (uint8_t*)&EvtQueue;
 801314e:	68bb      	ldr	r3, [r7, #8]
 8013150:	4a08      	ldr	r2, [pc, #32]	; (8013174 <TL_BLE_Init+0x54>)
 8013152:	609a      	str	r2, [r3, #8]

  HW_IPCC_BLE_Init();
 8013154:	f001 fa04 	bl	8014560 <HW_IPCC_BLE_Init>

  BLE_IoBusEvtCallBackFunction = pInitHciConf->IoBusEvtCallBack;
 8013158:	68fb      	ldr	r3, [r7, #12]
 801315a:	681b      	ldr	r3, [r3, #0]
 801315c:	4a08      	ldr	r2, [pc, #32]	; (8013180 <TL_BLE_Init+0x60>)
 801315e:	6013      	str	r3, [r2, #0]
  BLE_IoBusAclDataTxAck = pInitHciConf->IoBusAclDataTxAck;
 8013160:	68fb      	ldr	r3, [r7, #12]
 8013162:	685b      	ldr	r3, [r3, #4]
 8013164:	4a07      	ldr	r2, [pc, #28]	; (8013184 <TL_BLE_Init+0x64>)
 8013166:	6013      	str	r3, [r2, #0]

  return 0;
 8013168:	2300      	movs	r3, #0
}
 801316a:	4618      	mov	r0, r3
 801316c:	3710      	adds	r7, #16
 801316e:	46bd      	mov	sp, r7
 8013170:	bd80      	pop	{r7, pc}
 8013172:	bf00      	nop
 8013174:	200300c4 	.word	0x200300c4
 8013178:	20030000 	.word	0x20030000
 801317c:	20030a48 	.word	0x20030a48
 8013180:	20000f54 	.word	0x20000f54
 8013184:	20000f58 	.word	0x20000f58

08013188 <TL_BLE_SendCmd>:

int32_t TL_BLE_SendCmd( uint8_t* buffer, uint16_t size )
{
 8013188:	b580      	push	{r7, lr}
 801318a:	b082      	sub	sp, #8
 801318c:	af00      	add	r7, sp, #0
 801318e:	6078      	str	r0, [r7, #4]
 8013190:	460b      	mov	r3, r1
 8013192:	807b      	strh	r3, [r7, #2]
  (void)(buffer);
  (void)(size);

  ((TL_CmdPacket_t*)(TL_RefTable.p_ble_table->pcmd_buffer))->cmdserial.type = TL_BLECMD_PKT_TYPE;
 8013194:	4b09      	ldr	r3, [pc, #36]	; (80131bc <TL_BLE_SendCmd+0x34>)
 8013196:	685b      	ldr	r3, [r3, #4]
 8013198:	681b      	ldr	r3, [r3, #0]
 801319a:	2201      	movs	r2, #1
 801319c:	721a      	strb	r2, [r3, #8]

  OutputDbgTrace(TL_MB_BLE_CMD, TL_RefTable.p_ble_table->pcmd_buffer);
 801319e:	4b07      	ldr	r3, [pc, #28]	; (80131bc <TL_BLE_SendCmd+0x34>)
 80131a0:	685b      	ldr	r3, [r3, #4]
 80131a2:	681b      	ldr	r3, [r3, #0]
 80131a4:	4619      	mov	r1, r3
 80131a6:	2001      	movs	r0, #1
 80131a8:	f000 f96c 	bl	8013484 <OutputDbgTrace>

  HW_IPCC_BLE_SendCmd();
 80131ac:	f001 f9e2 	bl	8014574 <HW_IPCC_BLE_SendCmd>

  return 0;
 80131b0:	2300      	movs	r3, #0
}
 80131b2:	4618      	mov	r0, r3
 80131b4:	3708      	adds	r7, #8
 80131b6:	46bd      	mov	sp, r7
 80131b8:	bd80      	pop	{r7, pc}
 80131ba:	bf00      	nop
 80131bc:	20030000 	.word	0x20030000

080131c0 <HW_IPCC_BLE_RxEvtNot>:

void HW_IPCC_BLE_RxEvtNot(void)
{
 80131c0:	b580      	push	{r7, lr}
 80131c2:	b082      	sub	sp, #8
 80131c4:	af00      	add	r7, sp, #0
  TL_EvtPacket_t *phcievt;

  while(LST_is_empty(&EvtQueue) == FALSE)
 80131c6:	e01c      	b.n	8013202 <HW_IPCC_BLE_RxEvtNot+0x42>
  {
    LST_remove_head (&EvtQueue, (tListNode **)&phcievt);
 80131c8:	1d3b      	adds	r3, r7, #4
 80131ca:	4619      	mov	r1, r3
 80131cc:	4812      	ldr	r0, [pc, #72]	; (8013218 <HW_IPCC_BLE_RxEvtNot+0x58>)
 80131ce:	f000 fa76 	bl	80136be <LST_remove_head>

    if ( ((phcievt->evtserial.evt.evtcode) == TL_BLEEVT_CS_OPCODE) || ((phcievt->evtserial.evt.evtcode) == TL_BLEEVT_CC_OPCODE ) )
 80131d2:	687b      	ldr	r3, [r7, #4]
 80131d4:	7a5b      	ldrb	r3, [r3, #9]
 80131d6:	2b0f      	cmp	r3, #15
 80131d8:	d003      	beq.n	80131e2 <HW_IPCC_BLE_RxEvtNot+0x22>
 80131da:	687b      	ldr	r3, [r7, #4]
 80131dc:	7a5b      	ldrb	r3, [r3, #9]
 80131de:	2b0e      	cmp	r3, #14
 80131e0:	d105      	bne.n	80131ee <HW_IPCC_BLE_RxEvtNot+0x2e>
    {
      OutputDbgTrace(TL_MB_BLE_CMD_RSP, (uint8_t*)phcievt);
 80131e2:	687b      	ldr	r3, [r7, #4]
 80131e4:	4619      	mov	r1, r3
 80131e6:	2002      	movs	r0, #2
 80131e8:	f000 f94c 	bl	8013484 <OutputDbgTrace>
 80131ec:	e004      	b.n	80131f8 <HW_IPCC_BLE_RxEvtNot+0x38>
    }
    else
    {
      OutputDbgTrace(TL_MB_BLE_ASYNCH_EVT, (uint8_t*)phcievt);
 80131ee:	687b      	ldr	r3, [r7, #4]
 80131f0:	4619      	mov	r1, r3
 80131f2:	2003      	movs	r0, #3
 80131f4:	f000 f946 	bl	8013484 <OutputDbgTrace>
    }

    BLE_IoBusEvtCallBackFunction(phcievt);
 80131f8:	4b08      	ldr	r3, [pc, #32]	; (801321c <HW_IPCC_BLE_RxEvtNot+0x5c>)
 80131fa:	681b      	ldr	r3, [r3, #0]
 80131fc:	687a      	ldr	r2, [r7, #4]
 80131fe:	4610      	mov	r0, r2
 8013200:	4798      	blx	r3
  while(LST_is_empty(&EvtQueue) == FALSE)
 8013202:	4805      	ldr	r0, [pc, #20]	; (8013218 <HW_IPCC_BLE_RxEvtNot+0x58>)
 8013204:	f000 f9cc 	bl	80135a0 <LST_is_empty>
 8013208:	4603      	mov	r3, r0
 801320a:	2b00      	cmp	r3, #0
 801320c:	d0dc      	beq.n	80131c8 <HW_IPCC_BLE_RxEvtNot+0x8>
  }

  return;
 801320e:	bf00      	nop
}
 8013210:	3708      	adds	r7, #8
 8013212:	46bd      	mov	sp, r7
 8013214:	bd80      	pop	{r7, pc}
 8013216:	bf00      	nop
 8013218:	200300c4 	.word	0x200300c4
 801321c:	20000f54 	.word	0x20000f54

08013220 <HW_IPCC_BLE_AclDataAckNot>:

  return 0;
}

void HW_IPCC_BLE_AclDataAckNot(void)
{
 8013220:	b580      	push	{r7, lr}
 8013222:	af00      	add	r7, sp, #0
  BLE_IoBusAclDataTxAck( );
 8013224:	4b02      	ldr	r3, [pc, #8]	; (8013230 <HW_IPCC_BLE_AclDataAckNot+0x10>)
 8013226:	681b      	ldr	r3, [r3, #0]
 8013228:	4798      	blx	r3

  return;
 801322a:	bf00      	nop
}
 801322c:	bd80      	pop	{r7, pc}
 801322e:	bf00      	nop
 8013230:	20000f58 	.word	0x20000f58

08013234 <TL_SYS_Init>:

/******************************************************************************
 * SYSTEM
 ******************************************************************************/
int32_t TL_SYS_Init( void* pConf  )
{
 8013234:	b580      	push	{r7, lr}
 8013236:	b084      	sub	sp, #16
 8013238:	af00      	add	r7, sp, #0
 801323a:	6078      	str	r0, [r7, #4]
  MB_SysTable_t  * p_systable;

  TL_SYS_InitConf_t *pInitHciConf = (TL_SYS_InitConf_t *) pConf;
 801323c:	687b      	ldr	r3, [r7, #4]
 801323e:	60fb      	str	r3, [r7, #12]

  LST_init_head (&SystemEvtQueue);
 8013240:	480d      	ldr	r0, [pc, #52]	; (8013278 <TL_SYS_Init+0x44>)
 8013242:	f000 f99d 	bl	8013580 <LST_init_head>
  p_systable = TL_RefTable.p_sys_table;
 8013246:	4b0d      	ldr	r3, [pc, #52]	; (801327c <TL_SYS_Init+0x48>)
 8013248:	68db      	ldr	r3, [r3, #12]
 801324a:	60bb      	str	r3, [r7, #8]
  p_systable->pcmd_buffer = pInitHciConf->p_cmdbuffer;
 801324c:	68fb      	ldr	r3, [r7, #12]
 801324e:	689a      	ldr	r2, [r3, #8]
 8013250:	68bb      	ldr	r3, [r7, #8]
 8013252:	601a      	str	r2, [r3, #0]
  p_systable->sys_queue = (uint8_t*)&SystemEvtQueue;
 8013254:	68bb      	ldr	r3, [r7, #8]
 8013256:	4a08      	ldr	r2, [pc, #32]	; (8013278 <TL_SYS_Init+0x44>)
 8013258:	605a      	str	r2, [r3, #4]

  HW_IPCC_SYS_Init();
 801325a:	f001 f9ad 	bl	80145b8 <HW_IPCC_SYS_Init>

  SYS_CMD_IoBusCallBackFunction = pInitHciConf->IoBusCallBackCmdEvt;
 801325e:	68fb      	ldr	r3, [r7, #12]
 8013260:	681b      	ldr	r3, [r3, #0]
 8013262:	4a07      	ldr	r2, [pc, #28]	; (8013280 <TL_SYS_Init+0x4c>)
 8013264:	6013      	str	r3, [r2, #0]
  SYS_EVT_IoBusCallBackFunction = pInitHciConf->IoBusCallBackUserEvt;
 8013266:	68fb      	ldr	r3, [r7, #12]
 8013268:	685b      	ldr	r3, [r3, #4]
 801326a:	4a06      	ldr	r2, [pc, #24]	; (8013284 <TL_SYS_Init+0x50>)
 801326c:	6013      	str	r3, [r2, #0]

  return 0;
 801326e:	2300      	movs	r3, #0
}
 8013270:	4618      	mov	r0, r3
 8013272:	3710      	adds	r7, #16
 8013274:	46bd      	mov	sp, r7
 8013276:	bd80      	pop	{r7, pc}
 8013278:	200300cc 	.word	0x200300cc
 801327c:	20030000 	.word	0x20030000
 8013280:	20000f5c 	.word	0x20000f5c
 8013284:	20000f60 	.word	0x20000f60

08013288 <TL_SYS_SendCmd>:

int32_t TL_SYS_SendCmd( uint8_t* buffer, uint16_t size )
{
 8013288:	b580      	push	{r7, lr}
 801328a:	b082      	sub	sp, #8
 801328c:	af00      	add	r7, sp, #0
 801328e:	6078      	str	r0, [r7, #4]
 8013290:	460b      	mov	r3, r1
 8013292:	807b      	strh	r3, [r7, #2]
  (void)(buffer);
  (void)(size);

  ((TL_CmdPacket_t *)(TL_RefTable.p_sys_table->pcmd_buffer))->cmdserial.type = TL_SYSCMD_PKT_TYPE;
 8013294:	4b09      	ldr	r3, [pc, #36]	; (80132bc <TL_SYS_SendCmd+0x34>)
 8013296:	68db      	ldr	r3, [r3, #12]
 8013298:	681b      	ldr	r3, [r3, #0]
 801329a:	2210      	movs	r2, #16
 801329c:	721a      	strb	r2, [r3, #8]

  OutputDbgTrace(TL_MB_SYS_CMD, TL_RefTable.p_sys_table->pcmd_buffer);
 801329e:	4b07      	ldr	r3, [pc, #28]	; (80132bc <TL_SYS_SendCmd+0x34>)
 80132a0:	68db      	ldr	r3, [r3, #12]
 80132a2:	681b      	ldr	r3, [r3, #0]
 80132a4:	4619      	mov	r1, r3
 80132a6:	2004      	movs	r0, #4
 80132a8:	f000 f8ec 	bl	8013484 <OutputDbgTrace>

  HW_IPCC_SYS_SendCmd();
 80132ac:	f001 f98e 	bl	80145cc <HW_IPCC_SYS_SendCmd>

  return 0;
 80132b0:	2300      	movs	r3, #0
}
 80132b2:	4618      	mov	r0, r3
 80132b4:	3708      	adds	r7, #8
 80132b6:	46bd      	mov	sp, r7
 80132b8:	bd80      	pop	{r7, pc}
 80132ba:	bf00      	nop
 80132bc:	20030000 	.word	0x20030000

080132c0 <HW_IPCC_SYS_CmdEvtNot>:

void HW_IPCC_SYS_CmdEvtNot(void)
{
 80132c0:	b580      	push	{r7, lr}
 80132c2:	af00      	add	r7, sp, #0
  OutputDbgTrace(TL_MB_SYS_CMD_RSP, (uint8_t*)(TL_RefTable.p_sys_table->pcmd_buffer) );
 80132c4:	4b07      	ldr	r3, [pc, #28]	; (80132e4 <HW_IPCC_SYS_CmdEvtNot+0x24>)
 80132c6:	68db      	ldr	r3, [r3, #12]
 80132c8:	681b      	ldr	r3, [r3, #0]
 80132ca:	4619      	mov	r1, r3
 80132cc:	2005      	movs	r0, #5
 80132ce:	f000 f8d9 	bl	8013484 <OutputDbgTrace>

  SYS_CMD_IoBusCallBackFunction( (TL_EvtPacket_t*)(TL_RefTable.p_sys_table->pcmd_buffer) );
 80132d2:	4b05      	ldr	r3, [pc, #20]	; (80132e8 <HW_IPCC_SYS_CmdEvtNot+0x28>)
 80132d4:	681b      	ldr	r3, [r3, #0]
 80132d6:	4a03      	ldr	r2, [pc, #12]	; (80132e4 <HW_IPCC_SYS_CmdEvtNot+0x24>)
 80132d8:	68d2      	ldr	r2, [r2, #12]
 80132da:	6812      	ldr	r2, [r2, #0]
 80132dc:	4610      	mov	r0, r2
 80132de:	4798      	blx	r3

  return;
 80132e0:	bf00      	nop
}
 80132e2:	bd80      	pop	{r7, pc}
 80132e4:	20030000 	.word	0x20030000
 80132e8:	20000f5c 	.word	0x20000f5c

080132ec <HW_IPCC_SYS_EvtNot>:

void HW_IPCC_SYS_EvtNot( void )
{
 80132ec:	b580      	push	{r7, lr}
 80132ee:	b082      	sub	sp, #8
 80132f0:	af00      	add	r7, sp, #0
  TL_EvtPacket_t *p_evt;

  while(LST_is_empty(&SystemEvtQueue) == FALSE)
 80132f2:	e00e      	b.n	8013312 <HW_IPCC_SYS_EvtNot+0x26>
  {
    LST_remove_head (&SystemEvtQueue, (tListNode **)&p_evt);
 80132f4:	1d3b      	adds	r3, r7, #4
 80132f6:	4619      	mov	r1, r3
 80132f8:	480b      	ldr	r0, [pc, #44]	; (8013328 <HW_IPCC_SYS_EvtNot+0x3c>)
 80132fa:	f000 f9e0 	bl	80136be <LST_remove_head>

    OutputDbgTrace(TL_MB_SYS_ASYNCH_EVT, (uint8_t*)p_evt );
 80132fe:	687b      	ldr	r3, [r7, #4]
 8013300:	4619      	mov	r1, r3
 8013302:	2006      	movs	r0, #6
 8013304:	f000 f8be 	bl	8013484 <OutputDbgTrace>

    SYS_EVT_IoBusCallBackFunction( p_evt );
 8013308:	4b08      	ldr	r3, [pc, #32]	; (801332c <HW_IPCC_SYS_EvtNot+0x40>)
 801330a:	681b      	ldr	r3, [r3, #0]
 801330c:	687a      	ldr	r2, [r7, #4]
 801330e:	4610      	mov	r0, r2
 8013310:	4798      	blx	r3
  while(LST_is_empty(&SystemEvtQueue) == FALSE)
 8013312:	4805      	ldr	r0, [pc, #20]	; (8013328 <HW_IPCC_SYS_EvtNot+0x3c>)
 8013314:	f000 f944 	bl	80135a0 <LST_is_empty>
 8013318:	4603      	mov	r3, r0
 801331a:	2b00      	cmp	r3, #0
 801331c:	d0ea      	beq.n	80132f4 <HW_IPCC_SYS_EvtNot+0x8>
  }

  return;
 801331e:	bf00      	nop
}
 8013320:	3708      	adds	r7, #8
 8013322:	46bd      	mov	sp, r7
 8013324:	bd80      	pop	{r7, pc}
 8013326:	bf00      	nop
 8013328:	200300cc 	.word	0x200300cc
 801332c:	20000f60 	.word	0x20000f60

08013330 <TL_MM_Init>:

/******************************************************************************
 * MEMORY MANAGER
 ******************************************************************************/
void TL_MM_Init( TL_MM_Config_t *p_Config )
{
 8013330:	b580      	push	{r7, lr}
 8013332:	b082      	sub	sp, #8
 8013334:	af00      	add	r7, sp, #0
 8013336:	6078      	str	r0, [r7, #4]
  static MB_MemManagerTable_t  * p_mem_manager_table;

  LST_init_head (&FreeBufQueue);
 8013338:	4817      	ldr	r0, [pc, #92]	; (8013398 <TL_MM_Init+0x68>)
 801333a:	f000 f921 	bl	8013580 <LST_init_head>
  LST_init_head (&LocalFreeBufQueue);
 801333e:	4817      	ldr	r0, [pc, #92]	; (801339c <TL_MM_Init+0x6c>)
 8013340:	f000 f91e 	bl	8013580 <LST_init_head>

  p_mem_manager_table = TL_RefTable.p_mem_manager_table;
 8013344:	4b16      	ldr	r3, [pc, #88]	; (80133a0 <TL_MM_Init+0x70>)
 8013346:	691b      	ldr	r3, [r3, #16]
 8013348:	4a16      	ldr	r2, [pc, #88]	; (80133a4 <TL_MM_Init+0x74>)
 801334a:	6013      	str	r3, [r2, #0]

  p_mem_manager_table->blepool = p_Config->p_AsynchEvtPool;
 801334c:	4b15      	ldr	r3, [pc, #84]	; (80133a4 <TL_MM_Init+0x74>)
 801334e:	681b      	ldr	r3, [r3, #0]
 8013350:	687a      	ldr	r2, [r7, #4]
 8013352:	6892      	ldr	r2, [r2, #8]
 8013354:	609a      	str	r2, [r3, #8]
  p_mem_manager_table->blepoolsize = p_Config->AsynchEvtPoolSize;
 8013356:	4b13      	ldr	r3, [pc, #76]	; (80133a4 <TL_MM_Init+0x74>)
 8013358:	681b      	ldr	r3, [r3, #0]
 801335a:	687a      	ldr	r2, [r7, #4]
 801335c:	68d2      	ldr	r2, [r2, #12]
 801335e:	60da      	str	r2, [r3, #12]
  p_mem_manager_table->pevt_free_buffer_queue = (uint8_t*)&FreeBufQueue;
 8013360:	4b10      	ldr	r3, [pc, #64]	; (80133a4 <TL_MM_Init+0x74>)
 8013362:	681b      	ldr	r3, [r3, #0]
 8013364:	4a0c      	ldr	r2, [pc, #48]	; (8013398 <TL_MM_Init+0x68>)
 8013366:	611a      	str	r2, [r3, #16]
  p_mem_manager_table->spare_ble_buffer = p_Config->p_BleSpareEvtBuffer;
 8013368:	4b0e      	ldr	r3, [pc, #56]	; (80133a4 <TL_MM_Init+0x74>)
 801336a:	681b      	ldr	r3, [r3, #0]
 801336c:	687a      	ldr	r2, [r7, #4]
 801336e:	6812      	ldr	r2, [r2, #0]
 8013370:	601a      	str	r2, [r3, #0]
  p_mem_manager_table->spare_sys_buffer = p_Config->p_SystemSpareEvtBuffer;
 8013372:	4b0c      	ldr	r3, [pc, #48]	; (80133a4 <TL_MM_Init+0x74>)
 8013374:	681b      	ldr	r3, [r3, #0]
 8013376:	687a      	ldr	r2, [r7, #4]
 8013378:	6852      	ldr	r2, [r2, #4]
 801337a:	605a      	str	r2, [r3, #4]
  p_mem_manager_table->traces_evt_pool = p_Config->p_TracesEvtPool;
 801337c:	4b09      	ldr	r3, [pc, #36]	; (80133a4 <TL_MM_Init+0x74>)
 801337e:	681b      	ldr	r3, [r3, #0]
 8013380:	687a      	ldr	r2, [r7, #4]
 8013382:	6912      	ldr	r2, [r2, #16]
 8013384:	615a      	str	r2, [r3, #20]
  p_mem_manager_table->tracespoolsize = p_Config->TracesEvtPoolSize;
 8013386:	4b07      	ldr	r3, [pc, #28]	; (80133a4 <TL_MM_Init+0x74>)
 8013388:	681b      	ldr	r3, [r3, #0]
 801338a:	687a      	ldr	r2, [r7, #4]
 801338c:	6952      	ldr	r2, [r2, #20]
 801338e:	619a      	str	r2, [r3, #24]

  return;
 8013390:	bf00      	nop
}
 8013392:	3708      	adds	r7, #8
 8013394:	46bd      	mov	sp, r7
 8013396:	bd80      	pop	{r7, pc}
 8013398:	200300b4 	.word	0x200300b4
 801339c:	20000f4c 	.word	0x20000f4c
 80133a0:	20030000 	.word	0x20030000
 80133a4:	20000f64 	.word	0x20000f64

080133a8 <TL_MM_EvtDone>:

void TL_MM_EvtDone(TL_EvtPacket_t * phcievt)
{
 80133a8:	b580      	push	{r7, lr}
 80133aa:	b082      	sub	sp, #8
 80133ac:	af00      	add	r7, sp, #0
 80133ae:	6078      	str	r0, [r7, #4]
  LST_insert_tail(&LocalFreeBufQueue, (tListNode *)phcievt);
 80133b0:	6879      	ldr	r1, [r7, #4]
 80133b2:	4807      	ldr	r0, [pc, #28]	; (80133d0 <TL_MM_EvtDone+0x28>)
 80133b4:	f000 f93c 	bl	8013630 <LST_insert_tail>

  OutputDbgTrace(TL_MB_MM_RELEASE_BUFFER, (uint8_t*)phcievt);
 80133b8:	6879      	ldr	r1, [r7, #4]
 80133ba:	2000      	movs	r0, #0
 80133bc:	f000 f862 	bl	8013484 <OutputDbgTrace>

  HW_IPCC_MM_SendFreeBuf( SendFreeBuf );
 80133c0:	4804      	ldr	r0, [pc, #16]	; (80133d4 <TL_MM_EvtDone+0x2c>)
 80133c2:	f001 f929 	bl	8014618 <HW_IPCC_MM_SendFreeBuf>

  return;
 80133c6:	bf00      	nop
}
 80133c8:	3708      	adds	r7, #8
 80133ca:	46bd      	mov	sp, r7
 80133cc:	bd80      	pop	{r7, pc}
 80133ce:	bf00      	nop
 80133d0:	20000f4c 	.word	0x20000f4c
 80133d4:	080133d9 	.word	0x080133d9

080133d8 <SendFreeBuf>:

static void SendFreeBuf( void )
{
 80133d8:	b580      	push	{r7, lr}
 80133da:	b082      	sub	sp, #8
 80133dc:	af00      	add	r7, sp, #0
  tListNode *p_node;

  while ( FALSE == LST_is_empty (&LocalFreeBufQueue) )
 80133de:	e00c      	b.n	80133fa <SendFreeBuf+0x22>
  {
    LST_remove_head( &LocalFreeBufQueue, (tListNode **)&p_node );
 80133e0:	1d3b      	adds	r3, r7, #4
 80133e2:	4619      	mov	r1, r3
 80133e4:	480a      	ldr	r0, [pc, #40]	; (8013410 <SendFreeBuf+0x38>)
 80133e6:	f000 f96a 	bl	80136be <LST_remove_head>
    LST_insert_tail( (tListNode*)(TL_RefTable.p_mem_manager_table->pevt_free_buffer_queue), p_node );
 80133ea:	4b0a      	ldr	r3, [pc, #40]	; (8013414 <SendFreeBuf+0x3c>)
 80133ec:	691b      	ldr	r3, [r3, #16]
 80133ee:	691b      	ldr	r3, [r3, #16]
 80133f0:	687a      	ldr	r2, [r7, #4]
 80133f2:	4611      	mov	r1, r2
 80133f4:	4618      	mov	r0, r3
 80133f6:	f000 f91b 	bl	8013630 <LST_insert_tail>
  while ( FALSE == LST_is_empty (&LocalFreeBufQueue) )
 80133fa:	4805      	ldr	r0, [pc, #20]	; (8013410 <SendFreeBuf+0x38>)
 80133fc:	f000 f8d0 	bl	80135a0 <LST_is_empty>
 8013400:	4603      	mov	r3, r0
 8013402:	2b00      	cmp	r3, #0
 8013404:	d0ec      	beq.n	80133e0 <SendFreeBuf+0x8>
  }

  return;
 8013406:	bf00      	nop
}
 8013408:	3708      	adds	r7, #8
 801340a:	46bd      	mov	sp, r7
 801340c:	bd80      	pop	{r7, pc}
 801340e:	bf00      	nop
 8013410:	20000f4c 	.word	0x20000f4c
 8013414:	20030000 	.word	0x20030000

08013418 <TL_TRACES_Init>:

/******************************************************************************
 * TRACES
 ******************************************************************************/
void TL_TRACES_Init( void )
{
 8013418:	b580      	push	{r7, lr}
 801341a:	af00      	add	r7, sp, #0
  LST_init_head (&TracesEvtQueue);
 801341c:	4805      	ldr	r0, [pc, #20]	; (8013434 <TL_TRACES_Init+0x1c>)
 801341e:	f000 f8af 	bl	8013580 <LST_init_head>

  TL_RefTable.p_traces_table->traces_queue = (uint8_t*)&TracesEvtQueue;
 8013422:	4b05      	ldr	r3, [pc, #20]	; (8013438 <TL_TRACES_Init+0x20>)
 8013424:	695b      	ldr	r3, [r3, #20]
 8013426:	4a03      	ldr	r2, [pc, #12]	; (8013434 <TL_TRACES_Init+0x1c>)
 8013428:	601a      	str	r2, [r3, #0]

  HW_IPCC_TRACES_Init();
 801342a:	f001 f92b 	bl	8014684 <HW_IPCC_TRACES_Init>

  return;
 801342e:	bf00      	nop
}
 8013430:	bd80      	pop	{r7, pc}
 8013432:	bf00      	nop
 8013434:	200300bc 	.word	0x200300bc
 8013438:	20030000 	.word	0x20030000

0801343c <HW_IPCC_TRACES_EvtNot>:

void HW_IPCC_TRACES_EvtNot(void)
{
 801343c:	b580      	push	{r7, lr}
 801343e:	b082      	sub	sp, #8
 8013440:	af00      	add	r7, sp, #0
  TL_EvtPacket_t *phcievt;

  while(LST_is_empty(&TracesEvtQueue) == FALSE)
 8013442:	e008      	b.n	8013456 <HW_IPCC_TRACES_EvtNot+0x1a>
  {
    LST_remove_head (&TracesEvtQueue, (tListNode **)&phcievt);
 8013444:	1d3b      	adds	r3, r7, #4
 8013446:	4619      	mov	r1, r3
 8013448:	4808      	ldr	r0, [pc, #32]	; (801346c <HW_IPCC_TRACES_EvtNot+0x30>)
 801344a:	f000 f938 	bl	80136be <LST_remove_head>
    TL_TRACES_EvtReceived( phcievt );
 801344e:	687b      	ldr	r3, [r7, #4]
 8013450:	4618      	mov	r0, r3
 8013452:	f000 f80d 	bl	8013470 <TL_TRACES_EvtReceived>
  while(LST_is_empty(&TracesEvtQueue) == FALSE)
 8013456:	4805      	ldr	r0, [pc, #20]	; (801346c <HW_IPCC_TRACES_EvtNot+0x30>)
 8013458:	f000 f8a2 	bl	80135a0 <LST_is_empty>
 801345c:	4603      	mov	r3, r0
 801345e:	2b00      	cmp	r3, #0
 8013460:	d0f0      	beq.n	8013444 <HW_IPCC_TRACES_EvtNot+0x8>
  }

  return;
 8013462:	bf00      	nop
}
 8013464:	3708      	adds	r7, #8
 8013466:	46bd      	mov	sp, r7
 8013468:	bd80      	pop	{r7, pc}
 801346a:	bf00      	nop
 801346c:	200300bc 	.word	0x200300bc

08013470 <TL_TRACES_EvtReceived>:

__WEAK void TL_TRACES_EvtReceived( TL_EvtPacket_t * hcievt )
{
 8013470:	b480      	push	{r7}
 8013472:	b083      	sub	sp, #12
 8013474:	af00      	add	r7, sp, #0
 8013476:	6078      	str	r0, [r7, #4]
  (void)(hcievt);
}
 8013478:	bf00      	nop
 801347a:	370c      	adds	r7, #12
 801347c:	46bd      	mov	sp, r7
 801347e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013482:	4770      	bx	lr

08013484 <OutputDbgTrace>:

/******************************************************************************
 * DEBUG INFORMATION
 ******************************************************************************/
static void OutputDbgTrace(TL_MB_PacketType_t packet_type, uint8_t* buffer)
{
 8013484:	b480      	push	{r7}
 8013486:	b085      	sub	sp, #20
 8013488:	af00      	add	r7, sp, #0
 801348a:	4603      	mov	r3, r0
 801348c:	6039      	str	r1, [r7, #0]
 801348e:	71fb      	strb	r3, [r7, #7]
  TL_EvtPacket_t *p_evt_packet;
  TL_CmdPacket_t *p_cmd_packet;

  switch(packet_type)
 8013490:	79fb      	ldrb	r3, [r7, #7]
 8013492:	2b06      	cmp	r3, #6
 8013494:	d845      	bhi.n	8013522 <OutputDbgTrace+0x9e>
 8013496:	a201      	add	r2, pc, #4	; (adr r2, 801349c <OutputDbgTrace+0x18>)
 8013498:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801349c:	080134b9 	.word	0x080134b9
 80134a0:	080134dd 	.word	0x080134dd
 80134a4:	080134e3 	.word	0x080134e3
 80134a8:	080134f7 	.word	0x080134f7
 80134ac:	08013503 	.word	0x08013503
 80134b0:	08013509 	.word	0x08013509
 80134b4:	08013517 	.word	0x08013517
  {
    case TL_MB_MM_RELEASE_BUFFER:
      p_evt_packet = (TL_EvtPacket_t*)buffer;
 80134b8:	683b      	ldr	r3, [r7, #0]
 80134ba:	60fb      	str	r3, [r7, #12]
      switch(p_evt_packet->evtserial.evt.evtcode)
 80134bc:	68fb      	ldr	r3, [r7, #12]
 80134be:	7a5b      	ldrb	r3, [r3, #9]
 80134c0:	2bff      	cmp	r3, #255	; 0xff
 80134c2:	d005      	beq.n	80134d0 <OutputDbgTrace+0x4c>
 80134c4:	2bff      	cmp	r3, #255	; 0xff
 80134c6:	dc05      	bgt.n	80134d4 <OutputDbgTrace+0x50>
 80134c8:	2b0e      	cmp	r3, #14
 80134ca:	d005      	beq.n	80134d8 <OutputDbgTrace+0x54>
 80134cc:	2b0f      	cmp	r3, #15
          break;

        default:
          TL_MM_DBG_MSG("mm evt released: 0x%02X", p_evt_packet->evtserial.evt.evtcode);
          TL_MM_DBG_MSG(" buffer addr: 0x%08X", p_evt_packet);
          break;
 80134ce:	e001      	b.n	80134d4 <OutputDbgTrace+0x50>
          break;
 80134d0:	bf00      	nop
 80134d2:	e027      	b.n	8013524 <OutputDbgTrace+0xa0>
          break;
 80134d4:	bf00      	nop
 80134d6:	e025      	b.n	8013524 <OutputDbgTrace+0xa0>
          break;
 80134d8:	bf00      	nop
      }

      TL_MM_DBG_MSG("\r\n");
      break;
 80134da:	e023      	b.n	8013524 <OutputDbgTrace+0xa0>

    case TL_MB_BLE_CMD:
      p_cmd_packet = (TL_CmdPacket_t*)buffer;
 80134dc:	683b      	ldr	r3, [r7, #0]
 80134de:	60bb      	str	r3, [r7, #8]
        TL_HCI_CMD_DBG_BUF(p_cmd_packet->cmdserial.cmd.payload, p_cmd_packet->cmdserial.cmd.plen, "");
      }
      TL_HCI_CMD_DBG_MSG("\r\n");

      TL_HCI_CMD_DBG_RAW(&p_cmd_packet->cmdserial, p_cmd_packet->cmdserial.cmd.plen+TL_CMD_HDR_SIZE);
      break;
 80134e0:	e020      	b.n	8013524 <OutputDbgTrace+0xa0>

    case TL_MB_BLE_CMD_RSP:
      p_evt_packet = (TL_EvtPacket_t*)buffer;
 80134e2:	683b      	ldr	r3, [r7, #0]
 80134e4:	60fb      	str	r3, [r7, #12]
      switch(p_evt_packet->evtserial.evt.evtcode)
 80134e6:	68fb      	ldr	r3, [r7, #12]
 80134e8:	7a5b      	ldrb	r3, [r3, #9]
 80134ea:	2b0e      	cmp	r3, #14
 80134ec:	d001      	beq.n	80134f2 <OutputDbgTrace+0x6e>
 80134ee:	2b0f      	cmp	r3, #15
          }
          break;

        default:
          TL_HCI_CMD_DBG_MSG("unknown ble rsp received: %02X", p_evt_packet->evtserial.evt.evtcode);
          break;
 80134f0:	e000      	b.n	80134f4 <OutputDbgTrace+0x70>
          break;
 80134f2:	bf00      	nop
      }

      TL_HCI_CMD_DBG_MSG("\r\n");

      TL_HCI_CMD_DBG_RAW(&p_evt_packet->evtserial, p_evt_packet->evtserial.evt.plen+TL_EVT_HDR_SIZE);
      break;
 80134f4:	e016      	b.n	8013524 <OutputDbgTrace+0xa0>

    case TL_MB_BLE_ASYNCH_EVT:
      p_evt_packet = (TL_EvtPacket_t*)buffer;
 80134f6:	683b      	ldr	r3, [r7, #0]
 80134f8:	60fb      	str	r3, [r7, #12]
      if(p_evt_packet->evtserial.evt.evtcode != TL_BLEEVT_VS_OPCODE)
 80134fa:	68fb      	ldr	r3, [r7, #12]
 80134fc:	7a5b      	ldrb	r3, [r3, #9]
 80134fe:	2bff      	cmp	r3, #255	; 0xff
      }

      TL_HCI_EVT_DBG_MSG("\r\n");

      TL_HCI_EVT_DBG_RAW(&p_evt_packet->evtserial, p_evt_packet->evtserial.evt.plen+TL_EVT_HDR_SIZE);
      break;
 8013500:	e010      	b.n	8013524 <OutputDbgTrace+0xa0>

    case TL_MB_SYS_CMD:
      p_cmd_packet = (TL_CmdPacket_t*)buffer;
 8013502:	683b      	ldr	r3, [r7, #0]
 8013504:	60bb      	str	r3, [r7, #8]
        TL_SHCI_CMD_DBG_BUF(p_cmd_packet->cmdserial.cmd.payload, p_cmd_packet->cmdserial.cmd.plen, "");
      }
      TL_SHCI_CMD_DBG_MSG("\r\n");

      TL_SHCI_CMD_DBG_RAW(&p_cmd_packet->cmdserial, p_cmd_packet->cmdserial.cmd.plen+TL_CMD_HDR_SIZE);
      break;
 8013506:	e00d      	b.n	8013524 <OutputDbgTrace+0xa0>

    case TL_MB_SYS_CMD_RSP:
      p_evt_packet = (TL_EvtPacket_t*)buffer;
 8013508:	683b      	ldr	r3, [r7, #0]
 801350a:	60fb      	str	r3, [r7, #12]
      switch(p_evt_packet->evtserial.evt.evtcode)
 801350c:	68fb      	ldr	r3, [r7, #12]
 801350e:	7a5b      	ldrb	r3, [r3, #9]
 8013510:	2b0e      	cmp	r3, #14
          }
          break;

        default:
          TL_SHCI_CMD_DBG_MSG("unknown sys rsp received: %02X", p_evt_packet->evtserial.evt.evtcode);
          break;
 8013512:	bf00      	nop
      }

      TL_SHCI_CMD_DBG_MSG("\r\n");

      TL_SHCI_CMD_DBG_RAW(&p_evt_packet->evtserial, p_evt_packet->evtserial.evt.plen+TL_EVT_HDR_SIZE);
      break;
 8013514:	e006      	b.n	8013524 <OutputDbgTrace+0xa0>

    case  TL_MB_SYS_ASYNCH_EVT:
      p_evt_packet = (TL_EvtPacket_t*)buffer;
 8013516:	683b      	ldr	r3, [r7, #0]
 8013518:	60fb      	str	r3, [r7, #12]
      if(p_evt_packet->evtserial.evt.evtcode != TL_BLEEVT_VS_OPCODE)
 801351a:	68fb      	ldr	r3, [r7, #12]
 801351c:	7a5b      	ldrb	r3, [r3, #9]
 801351e:	2bff      	cmp	r3, #255	; 0xff
      }

      TL_SHCI_EVT_DBG_MSG("\r\n");

      TL_SHCI_EVT_DBG_RAW(&p_evt_packet->evtserial, p_evt_packet->evtserial.evt.plen+TL_EVT_HDR_SIZE);
      break;
 8013520:	e000      	b.n	8013524 <OutputDbgTrace+0xa0>

    default:
      break;
 8013522:	bf00      	nop
  }

  return;
 8013524:	bf00      	nop
}
 8013526:	3714      	adds	r7, #20
 8013528:	46bd      	mov	sp, r7
 801352a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801352e:	4770      	bx	lr

08013530 <OTP_Read>:
/* Global variables ----------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Functions Definition ------------------------------------------------------*/

uint8_t * OTP_Read( uint8_t id )
{
 8013530:	b480      	push	{r7}
 8013532:	b085      	sub	sp, #20
 8013534:	af00      	add	r7, sp, #0
 8013536:	4603      	mov	r3, r0
 8013538:	71fb      	strb	r3, [r7, #7]
  uint8_t *p_id;

  p_id = (uint8_t*)(CFG_OTP_END_ADRESS - 7) ;
 801353a:	4b0f      	ldr	r3, [pc, #60]	; (8013578 <OTP_Read+0x48>)
 801353c:	60fb      	str	r3, [r7, #12]

  while( ((*( p_id + 7 )) != id) && ( p_id != (uint8_t*)CFG_OTP_BASE_ADDRESS) )
 801353e:	e002      	b.n	8013546 <OTP_Read+0x16>
  {
    p_id -= 8 ;
 8013540:	68fb      	ldr	r3, [r7, #12]
 8013542:	3b08      	subs	r3, #8
 8013544:	60fb      	str	r3, [r7, #12]
  while( ((*( p_id + 7 )) != id) && ( p_id != (uint8_t*)CFG_OTP_BASE_ADDRESS) )
 8013546:	68fb      	ldr	r3, [r7, #12]
 8013548:	3307      	adds	r3, #7
 801354a:	781b      	ldrb	r3, [r3, #0]
 801354c:	79fa      	ldrb	r2, [r7, #7]
 801354e:	429a      	cmp	r2, r3
 8013550:	d003      	beq.n	801355a <OTP_Read+0x2a>
 8013552:	68fb      	ldr	r3, [r7, #12]
 8013554:	4a09      	ldr	r2, [pc, #36]	; (801357c <OTP_Read+0x4c>)
 8013556:	4293      	cmp	r3, r2
 8013558:	d1f2      	bne.n	8013540 <OTP_Read+0x10>
  }

  if((*( p_id + 7 )) != id)
 801355a:	68fb      	ldr	r3, [r7, #12]
 801355c:	3307      	adds	r3, #7
 801355e:	781b      	ldrb	r3, [r3, #0]
 8013560:	79fa      	ldrb	r2, [r7, #7]
 8013562:	429a      	cmp	r2, r3
 8013564:	d001      	beq.n	801356a <OTP_Read+0x3a>
  {
    p_id = 0 ;
 8013566:	2300      	movs	r3, #0
 8013568:	60fb      	str	r3, [r7, #12]
  }

  return p_id ;
 801356a:	68fb      	ldr	r3, [r7, #12]
}
 801356c:	4618      	mov	r0, r3
 801356e:	3714      	adds	r7, #20
 8013570:	46bd      	mov	sp, r7
 8013572:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013576:	4770      	bx	lr
 8013578:	1fff73f8 	.word	0x1fff73f8
 801357c:	1fff7000 	.word	0x1fff7000

08013580 <LST_init_head>:

/******************************************************************************
 * Function Definitions 
 ******************************************************************************/
void LST_init_head (tListNode * listHead)
{
 8013580:	b480      	push	{r7}
 8013582:	b083      	sub	sp, #12
 8013584:	af00      	add	r7, sp, #0
 8013586:	6078      	str	r0, [r7, #4]
  listHead->next = listHead;
 8013588:	687b      	ldr	r3, [r7, #4]
 801358a:	687a      	ldr	r2, [r7, #4]
 801358c:	601a      	str	r2, [r3, #0]
  listHead->prev = listHead;
 801358e:	687b      	ldr	r3, [r7, #4]
 8013590:	687a      	ldr	r2, [r7, #4]
 8013592:	605a      	str	r2, [r3, #4]
}
 8013594:	bf00      	nop
 8013596:	370c      	adds	r7, #12
 8013598:	46bd      	mov	sp, r7
 801359a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801359e:	4770      	bx	lr

080135a0 <LST_is_empty>:

uint8_t LST_is_empty (tListNode * listHead)
{
 80135a0:	b480      	push	{r7}
 80135a2:	b087      	sub	sp, #28
 80135a4:	af00      	add	r7, sp, #0
 80135a6:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80135a8:	f3ef 8310 	mrs	r3, PRIMASK
 80135ac:	60fb      	str	r3, [r7, #12]
  return(result);
 80135ae:	68fb      	ldr	r3, [r7, #12]
  uint32_t primask_bit;
  uint8_t return_value;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 80135b0:	613b      	str	r3, [r7, #16]
  __ASM volatile ("cpsid i" : : : "memory");
 80135b2:	b672      	cpsid	i
}
 80135b4:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/
  if(listHead->next == listHead)
 80135b6:	687b      	ldr	r3, [r7, #4]
 80135b8:	681b      	ldr	r3, [r3, #0]
 80135ba:	687a      	ldr	r2, [r7, #4]
 80135bc:	429a      	cmp	r2, r3
 80135be:	d102      	bne.n	80135c6 <LST_is_empty+0x26>
  {
    return_value = TRUE;
 80135c0:	2301      	movs	r3, #1
 80135c2:	75fb      	strb	r3, [r7, #23]
 80135c4:	e001      	b.n	80135ca <LST_is_empty+0x2a>
  }
  else
  {
    return_value = FALSE;
 80135c6:	2300      	movs	r3, #0
 80135c8:	75fb      	strb	r3, [r7, #23]
 80135ca:	693b      	ldr	r3, [r7, #16]
 80135cc:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80135ce:	68bb      	ldr	r3, [r7, #8]
 80135d0:	f383 8810 	msr	PRIMASK, r3
}
 80135d4:	bf00      	nop
  }
  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/

  return return_value;
 80135d6:	7dfb      	ldrb	r3, [r7, #23]
}
 80135d8:	4618      	mov	r0, r3
 80135da:	371c      	adds	r7, #28
 80135dc:	46bd      	mov	sp, r7
 80135de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80135e2:	4770      	bx	lr

080135e4 <LST_insert_head>:

void LST_insert_head (tListNode * listHead, tListNode * node)
{
 80135e4:	b480      	push	{r7}
 80135e6:	b087      	sub	sp, #28
 80135e8:	af00      	add	r7, sp, #0
 80135ea:	6078      	str	r0, [r7, #4]
 80135ec:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80135ee:	f3ef 8310 	mrs	r3, PRIMASK
 80135f2:	60fb      	str	r3, [r7, #12]
  return(result);
 80135f4:	68fb      	ldr	r3, [r7, #12]
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 80135f6:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 80135f8:	b672      	cpsid	i
}
 80135fa:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  node->next = listHead->next;
 80135fc:	687b      	ldr	r3, [r7, #4]
 80135fe:	681a      	ldr	r2, [r3, #0]
 8013600:	683b      	ldr	r3, [r7, #0]
 8013602:	601a      	str	r2, [r3, #0]
  node->prev = listHead;
 8013604:	683b      	ldr	r3, [r7, #0]
 8013606:	687a      	ldr	r2, [r7, #4]
 8013608:	605a      	str	r2, [r3, #4]
  listHead->next = node;
 801360a:	687b      	ldr	r3, [r7, #4]
 801360c:	683a      	ldr	r2, [r7, #0]
 801360e:	601a      	str	r2, [r3, #0]
  (node->next)->prev = node;
 8013610:	683b      	ldr	r3, [r7, #0]
 8013612:	681b      	ldr	r3, [r3, #0]
 8013614:	683a      	ldr	r2, [r7, #0]
 8013616:	605a      	str	r2, [r3, #4]
 8013618:	697b      	ldr	r3, [r7, #20]
 801361a:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801361c:	693b      	ldr	r3, [r7, #16]
 801361e:	f383 8810 	msr	PRIMASK, r3
}
 8013622:	bf00      	nop

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 8013624:	bf00      	nop
 8013626:	371c      	adds	r7, #28
 8013628:	46bd      	mov	sp, r7
 801362a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801362e:	4770      	bx	lr

08013630 <LST_insert_tail>:


void LST_insert_tail (tListNode * listHead, tListNode * node)
{
 8013630:	b480      	push	{r7}
 8013632:	b087      	sub	sp, #28
 8013634:	af00      	add	r7, sp, #0
 8013636:	6078      	str	r0, [r7, #4]
 8013638:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801363a:	f3ef 8310 	mrs	r3, PRIMASK
 801363e:	60fb      	str	r3, [r7, #12]
  return(result);
 8013640:	68fb      	ldr	r3, [r7, #12]
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 8013642:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 8013644:	b672      	cpsid	i
}
 8013646:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  node->next = listHead;
 8013648:	683b      	ldr	r3, [r7, #0]
 801364a:	687a      	ldr	r2, [r7, #4]
 801364c:	601a      	str	r2, [r3, #0]
  node->prev = listHead->prev;
 801364e:	687b      	ldr	r3, [r7, #4]
 8013650:	685a      	ldr	r2, [r3, #4]
 8013652:	683b      	ldr	r3, [r7, #0]
 8013654:	605a      	str	r2, [r3, #4]
  listHead->prev = node;
 8013656:	687b      	ldr	r3, [r7, #4]
 8013658:	683a      	ldr	r2, [r7, #0]
 801365a:	605a      	str	r2, [r3, #4]
  (node->prev)->next = node;
 801365c:	683b      	ldr	r3, [r7, #0]
 801365e:	685b      	ldr	r3, [r3, #4]
 8013660:	683a      	ldr	r2, [r7, #0]
 8013662:	601a      	str	r2, [r3, #0]
 8013664:	697b      	ldr	r3, [r7, #20]
 8013666:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8013668:	693b      	ldr	r3, [r7, #16]
 801366a:	f383 8810 	msr	PRIMASK, r3
}
 801366e:	bf00      	nop

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 8013670:	bf00      	nop
 8013672:	371c      	adds	r7, #28
 8013674:	46bd      	mov	sp, r7
 8013676:	f85d 7b04 	ldr.w	r7, [sp], #4
 801367a:	4770      	bx	lr

0801367c <LST_remove_node>:


void LST_remove_node (tListNode * node)
{
 801367c:	b480      	push	{r7}
 801367e:	b087      	sub	sp, #28
 8013680:	af00      	add	r7, sp, #0
 8013682:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8013684:	f3ef 8310 	mrs	r3, PRIMASK
 8013688:	60fb      	str	r3, [r7, #12]
  return(result);
 801368a:	68fb      	ldr	r3, [r7, #12]
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 801368c:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 801368e:	b672      	cpsid	i
}
 8013690:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  (node->prev)->next = node->next;
 8013692:	687b      	ldr	r3, [r7, #4]
 8013694:	685b      	ldr	r3, [r3, #4]
 8013696:	687a      	ldr	r2, [r7, #4]
 8013698:	6812      	ldr	r2, [r2, #0]
 801369a:	601a      	str	r2, [r3, #0]
  (node->next)->prev = node->prev;
 801369c:	687b      	ldr	r3, [r7, #4]
 801369e:	681b      	ldr	r3, [r3, #0]
 80136a0:	687a      	ldr	r2, [r7, #4]
 80136a2:	6852      	ldr	r2, [r2, #4]
 80136a4:	605a      	str	r2, [r3, #4]
 80136a6:	697b      	ldr	r3, [r7, #20]
 80136a8:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80136aa:	693b      	ldr	r3, [r7, #16]
 80136ac:	f383 8810 	msr	PRIMASK, r3
}
 80136b0:	bf00      	nop

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 80136b2:	bf00      	nop
 80136b4:	371c      	adds	r7, #28
 80136b6:	46bd      	mov	sp, r7
 80136b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80136bc:	4770      	bx	lr

080136be <LST_remove_head>:


void LST_remove_head (tListNode * listHead, tListNode ** node )
{
 80136be:	b580      	push	{r7, lr}
 80136c0:	b086      	sub	sp, #24
 80136c2:	af00      	add	r7, sp, #0
 80136c4:	6078      	str	r0, [r7, #4]
 80136c6:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80136c8:	f3ef 8310 	mrs	r3, PRIMASK
 80136cc:	60fb      	str	r3, [r7, #12]
  return(result);
 80136ce:	68fb      	ldr	r3, [r7, #12]
  uint32_t primask_bit;

  primask_bit = __get_PRIMASK();  /**< backup PRIMASK bit */
 80136d0:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 80136d2:	b672      	cpsid	i
}
 80136d4:	bf00      	nop
  __disable_irq();                  /**< Disable all interrupts by setting PRIMASK bit on Cortex*/

  *node = listHead->next;
 80136d6:	687b      	ldr	r3, [r7, #4]
 80136d8:	681a      	ldr	r2, [r3, #0]
 80136da:	683b      	ldr	r3, [r7, #0]
 80136dc:	601a      	str	r2, [r3, #0]
  LST_remove_node (listHead->next);
 80136de:	687b      	ldr	r3, [r7, #4]
 80136e0:	681b      	ldr	r3, [r3, #0]
 80136e2:	4618      	mov	r0, r3
 80136e4:	f7ff ffca 	bl	801367c <LST_remove_node>
 80136e8:	697b      	ldr	r3, [r7, #20]
 80136ea:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80136ec:	693b      	ldr	r3, [r7, #16]
 80136ee:	f383 8810 	msr	PRIMASK, r3
}
 80136f2:	bf00      	nop

  __set_PRIMASK(primask_bit);     /**< Restore PRIMASK bit*/
}
 80136f4:	bf00      	nop
 80136f6:	3718      	adds	r7, #24
 80136f8:	46bd      	mov	sp, r7
 80136fa:	bd80      	pop	{r7, pc}

080136fc <LL_FLASH_GetUDN>:
  * @note   The 64-bit UID64 may be used by Firmware to derive BLE 48-bit Device Address EUI-48 or
  *         802.15.4 64-bit Device Address EUI-64.
  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFF
  */
__STATIC_INLINE uint32_t LL_FLASH_GetUDN(void)
{
 80136fc:	b480      	push	{r7}
 80136fe:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_REG(*((uint32_t *)UID64_BASE)));
 8013700:	4b03      	ldr	r3, [pc, #12]	; (8013710 <LL_FLASH_GetUDN+0x14>)
 8013702:	681b      	ldr	r3, [r3, #0]
}
 8013704:	4618      	mov	r0, r3
 8013706:	46bd      	mov	sp, r7
 8013708:	f85d 7b04 	ldr.w	r7, [sp], #4
 801370c:	4770      	bx	lr
 801370e:	bf00      	nop
 8013710:	1fff7580 	.word	0x1fff7580

08013714 <LL_FLASH_GetDeviceID>:
  *         802.15.4 64-bit Device Address EUI-64.
  *         For STM32WBxxxx devices, the device ID is 0x26
  * @retval Values between Min_Data=0x00 and Max_Data=0xFF (ex: Device ID is 0x26 fo STM32WB55x)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetDeviceID(void)
{
 8013714:	b480      	push	{r7}
 8013716:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_REG(*((uint32_t *)UID64_BASE + 1U))) & 0x000000FFU);
 8013718:	4b03      	ldr	r3, [pc, #12]	; (8013728 <LL_FLASH_GetDeviceID+0x14>)
 801371a:	681b      	ldr	r3, [r3, #0]
 801371c:	b2db      	uxtb	r3, r3
}
 801371e:	4618      	mov	r0, r3
 8013720:	46bd      	mov	sp, r7
 8013722:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013726:	4770      	bx	lr
 8013728:	1fff7584 	.word	0x1fff7584

0801372c <LL_FLASH_GetSTCompanyID>:
  *         802.15.4 64-bit Device Address EUI-64.
  *         For STM32WBxxxx devices, the ST Compagny ID is 0x0080E1
  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFFFF (ex: ST Compagny ID is 0x0080E1)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetSTCompanyID(void)
{
 801372c:	b480      	push	{r7}
 801372e:	af00      	add	r7, sp, #0
  return (uint32_t)(((READ_REG(*((uint32_t *)UID64_BASE + 1U))) >> 8U ) & 0x00FFFFFFU);
 8013730:	4b03      	ldr	r3, [pc, #12]	; (8013740 <LL_FLASH_GetSTCompanyID+0x14>)
 8013732:	681b      	ldr	r3, [r3, #0]
 8013734:	0a1b      	lsrs	r3, r3, #8
}
 8013736:	4618      	mov	r0, r3
 8013738:	46bd      	mov	sp, r7
 801373a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801373e:	4770      	bx	lr
 8013740:	1fff7584 	.word	0x1fff7584

08013744 <APP_BLE_Init>:

/* USER CODE END PFP */

/* Functions Definition ------------------------------------------------------*/
void APP_BLE_Init( void )
{
 8013744:	b5b0      	push	{r4, r5, r7, lr}
 8013746:	b08c      	sub	sp, #48	; 0x30
 8013748:	af00      	add	r7, sp, #0
/* USER CODE BEGIN APP_BLE_Init_1 */


/* USER CODE END APP_BLE_Init_1 */
  SHCI_C2_Ble_Init_Cmd_Packet_t ble_init_cmd_packet =
 801374a:	4b21      	ldr	r3, [pc, #132]	; (80137d0 <APP_BLE_Init+0x8c>)
 801374c:	463c      	mov	r4, r7
 801374e:	461d      	mov	r5, r3
 8013750:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8013752:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8013754:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8013756:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8013758:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 801375c:	c407      	stmia	r4!, {r0, r1, r2}
 801375e:	7023      	strb	r3, [r4, #0]
  };

  /**
   * Initialize Ble Transport Layer
   */
  Ble_Tl_Init( );
 8013760:	f000 f90e 	bl	8013980 <Ble_Tl_Init>

  /**
   * Do not allow standby in the application
   */
  UTIL_LPM_SetOffMode(1 << CFG_LPM_APP_BLE, UTIL_LPM_DISABLE);
 8013764:	2101      	movs	r1, #1
 8013766:	2002      	movs	r0, #2
 8013768:	f000 ffb4 	bl	80146d4 <UTIL_LPM_SetOffMode>

  /**
   * Register the hci transport layer to handle BLE User Asynchronous Events
   */
  UTIL_SEQ_RegTask( 1<<CFG_TASK_HCI_ASYNCH_EVT_ID, UTIL_SEQ_RFU, hci_user_evt_proc);
 801376c:	4a19      	ldr	r2, [pc, #100]	; (80137d4 <APP_BLE_Init+0x90>)
 801376e:	2100      	movs	r1, #0
 8013770:	2004      	movs	r0, #4
 8013772:	f001 f8c3 	bl	80148fc <UTIL_SEQ_RegTask>

  /**
   * Starts the BLE Stack on CPU2
   */
  if (SHCI_C2_BLE_Init( &ble_init_cmd_packet ) != SHCI_Success)
 8013776:	463b      	mov	r3, r7
 8013778:	4618      	mov	r0, r3
 801377a:	f7ff f999 	bl	8012ab0 <SHCI_C2_BLE_Init>
 801377e:	4603      	mov	r3, r0
 8013780:	2b00      	cmp	r3, #0
 8013782:	d001      	beq.n	8013788 <APP_BLE_Init+0x44>
  {
    Error_Handler();
 8013784:	f7f9 fa02 	bl	800cb8c <Error_Handler>
  }

  /**
   * Initialization of HCI & GATT & GAP layer
   */
  Ble_Hci_Gap_Gatt_Init();
 8013788:	f000 f910 	bl	80139ac <Ble_Hci_Gap_Gatt_Init>

  /**
   * Initialization of the BLE Services
   */
  SVCCTL_Init();
 801378c:	f7ff f8ee 	bl	801296c <SVCCTL_Init>

  /**
   * Initialization of the BLE App Context
   */
  BleApplicationContext.Device_Connection_Status = APP_BLE_IDLE;
 8013790:	4b11      	ldr	r3, [pc, #68]	; (80137d8 <APP_BLE_Init+0x94>)
 8013792:	2200      	movs	r2, #0
 8013794:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
  BleApplicationContext.BleApplicationContext_legacy.connectionHandle = 0xFFFF;
 8013798:	4b0f      	ldr	r3, [pc, #60]	; (80137d8 <APP_BLE_Init+0x94>)
 801379a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801379e:	82da      	strh	r2, [r3, #22]
  /**
   * From here, all initialization are BLE application specific
   */
  UTIL_SEQ_RegTask( 1<<CFG_TASK_ADV_CANCEL_ID, UTIL_SEQ_RFU, Adv_Cancel);
 80137a0:	4a0e      	ldr	r2, [pc, #56]	; (80137dc <APP_BLE_Init+0x98>)
 80137a2:	2100      	movs	r1, #0
 80137a4:	2001      	movs	r0, #1
 80137a6:	f001 f8a9 	bl	80148fc <UTIL_SEQ_RegTask>
  /**
   * Initialization of ADV - Ad Manufacturer Element - Support OTA Bit Mask
   */
#if(RADIO_ACTIVITY_EVENT != 0)
  aci_hal_set_radio_activity_mask(0x0006);
 80137aa:	2006      	movs	r0, #6
 80137ac:	f7fe ff7f 	bl	80126ae <aci_hal_set_radio_activity_mask>
  mutex = 1;
#endif
  /**
   * Initialize Custom Template Application
   */
  Custom_APP_Init();
 80137b0:	f000 fa9f 	bl	8013cf2 <Custom_APP_Init>

  /**
   * Make device discoverable
   */
  BleApplicationContext.BleApplicationContext_legacy.advtServUUID[0] = NULL;
 80137b4:	4b08      	ldr	r3, [pc, #32]	; (80137d8 <APP_BLE_Init+0x94>)
 80137b6:	2200      	movs	r2, #0
 80137b8:	765a      	strb	r2, [r3, #25]
  BleApplicationContext.BleApplicationContext_legacy.advtServUUIDlen = 0;
 80137ba:	4b07      	ldr	r3, [pc, #28]	; (80137d8 <APP_BLE_Init+0x94>)
 80137bc:	2200      	movs	r2, #0
 80137be:	761a      	strb	r2, [r3, #24]

  /**
   * Start to Advertise to be connected by a Client
   */
   Adv_Request(APP_BLE_FAST_ADV);
 80137c0:	2001      	movs	r0, #1
 80137c2:	f000 f99b 	bl	8013afc <Adv_Request>

/* USER CODE BEGIN APP_BLE_Init_2 */

/* USER CODE END APP_BLE_Init_2 */
  return;
 80137c6:	bf00      	nop
}
 80137c8:	3730      	adds	r7, #48	; 0x30
 80137ca:	46bd      	mov	sp, r7
 80137cc:	bdb0      	pop	{r4, r5, r7, pc}
 80137ce:	bf00      	nop
 80137d0:	08014d7c 	.word	0x08014d7c
 80137d4:	08012b45 	.word	0x08012b45
 80137d8:	2000011c 	.word	0x2000011c
 80137dc:	08013be5 	.word	0x08013be5

080137e0 <SVCCTL_App_Notification>:

SVCCTL_UserEvtFlowStatus_t SVCCTL_App_Notification( void *pckt )
{
 80137e0:	b580      	push	{r7, lr}
 80137e2:	b08a      	sub	sp, #40	; 0x28
 80137e4:	af00      	add	r7, sp, #0
 80137e6:	6078      	str	r0, [r7, #4]
  hci_event_pckt *event_pckt;
  evt_le_meta_event *meta_evt;
  evt_blue_aci *blue_evt;

  event_pckt = (hci_event_pckt*) ((hci_uart_pckt *) pckt)->data;
 80137e8:	687b      	ldr	r3, [r7, #4]
 80137ea:	3301      	adds	r3, #1
 80137ec:	627b      	str	r3, [r7, #36]	; 0x24

  /* USER CODE BEGIN SVCCTL_App_Notification */

  /* USER CODE END SVCCTL_App_Notification */

  switch (event_pckt->evt)
 80137ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80137f0:	781b      	ldrb	r3, [r3, #0]
 80137f2:	2bff      	cmp	r3, #255	; 0xff
 80137f4:	d061      	beq.n	80138ba <SVCCTL_App_Notification+0xda>
 80137f6:	2bff      	cmp	r3, #255	; 0xff
 80137f8:	f300 80b1 	bgt.w	801395e <SVCCTL_App_Notification+0x17e>
 80137fc:	2b05      	cmp	r3, #5
 80137fe:	d002      	beq.n	8013806 <SVCCTL_App_Notification+0x26>
 8013800:	2b3e      	cmp	r3, #62	; 0x3e
 8013802:	d027      	beq.n	8013854 <SVCCTL_App_Notification+0x74>

      default:
      /* USER CODE BEGIN ECODE_DEFAULT*/

      /* USER CODE END ECODE_DEFAULT*/
        break;
 8013804:	e0ab      	b.n	801395e <SVCCTL_App_Notification+0x17e>
      disconnection_complete_event = (hci_disconnection_complete_event_rp0 *) event_pckt->data;
 8013806:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013808:	3302      	adds	r3, #2
 801380a:	60bb      	str	r3, [r7, #8]
      if (disconnection_complete_event->Connection_Handle == BleApplicationContext.BleApplicationContext_legacy.connectionHandle)
 801380c:	68bb      	ldr	r3, [r7, #8]
 801380e:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 8013812:	b29a      	uxth	r2, r3
 8013814:	4b56      	ldr	r3, [pc, #344]	; (8013970 <SVCCTL_App_Notification+0x190>)
 8013816:	8adb      	ldrh	r3, [r3, #22]
 8013818:	429a      	cmp	r2, r3
 801381a:	d106      	bne.n	801382a <SVCCTL_App_Notification+0x4a>
        BleApplicationContext.BleApplicationContext_legacy.connectionHandle = 0;
 801381c:	4b54      	ldr	r3, [pc, #336]	; (8013970 <SVCCTL_App_Notification+0x190>)
 801381e:	2200      	movs	r2, #0
 8013820:	82da      	strh	r2, [r3, #22]
        BleApplicationContext.Device_Connection_Status = APP_BLE_IDLE;
 8013822:	4b53      	ldr	r3, [pc, #332]	; (8013970 <SVCCTL_App_Notification+0x190>)
 8013824:	2200      	movs	r2, #0
 8013826:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
      Adv_Request(APP_BLE_FAST_ADV);
 801382a:	2001      	movs	r0, #1
 801382c:	f000 f966 	bl	8013afc <Adv_Request>
      handleNotification.Custom_Evt_Opcode = CUSTOM_DISCON_HANDLE_EVT;
 8013830:	4b50      	ldr	r3, [pc, #320]	; (8013974 <SVCCTL_App_Notification+0x194>)
 8013832:	2201      	movs	r2, #1
 8013834:	701a      	strb	r2, [r3, #0]
      handleNotification.ConnectionHandle = BleApplicationContext.BleApplicationContext_legacy.connectionHandle;
 8013836:	4b4e      	ldr	r3, [pc, #312]	; (8013970 <SVCCTL_App_Notification+0x190>)
 8013838:	8ada      	ldrh	r2, [r3, #22]
 801383a:	4b4e      	ldr	r3, [pc, #312]	; (8013974 <SVCCTL_App_Notification+0x194>)
 801383c:	805a      	strh	r2, [r3, #2]
      Custom_APP_Notification(&handleNotification);
 801383e:	484d      	ldr	r0, [pc, #308]	; (8013974 <SVCCTL_App_Notification+0x194>)
 8013840:	f000 fa43 	bl	8013cca <Custom_APP_Notification>
      sys.rf.setConnected(0);
 8013844:	4b4c      	ldr	r3, [pc, #304]	; (8013978 <SVCCTL_App_Notification+0x198>)
 8013846:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 801384a:	3350      	adds	r3, #80	; 0x50
 801384c:	681b      	ldr	r3, [r3, #0]
 801384e:	2000      	movs	r0, #0
 8013850:	4798      	blx	r3
    break; /* EVT_DISCONN_COMPLETE */
 8013852:	e087      	b.n	8013964 <SVCCTL_App_Notification+0x184>
      meta_evt = (evt_le_meta_event*) event_pckt->data;
 8013854:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013856:	3302      	adds	r3, #2
 8013858:	613b      	str	r3, [r7, #16]
      switch (meta_evt->subevent)
 801385a:	693b      	ldr	r3, [r7, #16]
 801385c:	781b      	ldrb	r3, [r3, #0]
 801385e:	2b01      	cmp	r3, #1
 8013860:	d001      	beq.n	8013866 <SVCCTL_App_Notification+0x86>
 8013862:	2b03      	cmp	r3, #3
          break;
 8013864:	e028      	b.n	80138b8 <SVCCTL_App_Notification+0xd8>
          connection_complete_event = (hci_le_connection_complete_event_rp0 *) meta_evt->data;
 8013866:	693b      	ldr	r3, [r7, #16]
 8013868:	3301      	adds	r3, #1
 801386a:	60fb      	str	r3, [r7, #12]
          if (BleApplicationContext.Device_Connection_Status == APP_BLE_LP_CONNECTING)
 801386c:	4b40      	ldr	r3, [pc, #256]	; (8013970 <SVCCTL_App_Notification+0x190>)
 801386e:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 8013872:	2b04      	cmp	r3, #4
 8013874:	d104      	bne.n	8013880 <SVCCTL_App_Notification+0xa0>
            BleApplicationContext.Device_Connection_Status = APP_BLE_CONNECTED_CLIENT;
 8013876:	4b3e      	ldr	r3, [pc, #248]	; (8013970 <SVCCTL_App_Notification+0x190>)
 8013878:	2206      	movs	r2, #6
 801387a:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
 801387e:	e003      	b.n	8013888 <SVCCTL_App_Notification+0xa8>
            BleApplicationContext.Device_Connection_Status = APP_BLE_CONNECTED_SERVER;
 8013880:	4b3b      	ldr	r3, [pc, #236]	; (8013970 <SVCCTL_App_Notification+0x190>)
 8013882:	2205      	movs	r2, #5
 8013884:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
          BleApplicationContext.BleApplicationContext_legacy.connectionHandle = connection_complete_event->Connection_Handle;
 8013888:	68fb      	ldr	r3, [r7, #12]
 801388a:	f8b3 3001 	ldrh.w	r3, [r3, #1]
 801388e:	b29a      	uxth	r2, r3
 8013890:	4b37      	ldr	r3, [pc, #220]	; (8013970 <SVCCTL_App_Notification+0x190>)
 8013892:	82da      	strh	r2, [r3, #22]
          handleNotification.Custom_Evt_Opcode = CUSTOM_CONN_HANDLE_EVT;
 8013894:	4b37      	ldr	r3, [pc, #220]	; (8013974 <SVCCTL_App_Notification+0x194>)
 8013896:	2200      	movs	r2, #0
 8013898:	701a      	strb	r2, [r3, #0]
          handleNotification.ConnectionHandle = BleApplicationContext.BleApplicationContext_legacy.connectionHandle;
 801389a:	4b35      	ldr	r3, [pc, #212]	; (8013970 <SVCCTL_App_Notification+0x190>)
 801389c:	8ada      	ldrh	r2, [r3, #22]
 801389e:	4b35      	ldr	r3, [pc, #212]	; (8013974 <SVCCTL_App_Notification+0x194>)
 80138a0:	805a      	strh	r2, [r3, #2]
          Custom_APP_Notification(&handleNotification);
 80138a2:	4834      	ldr	r0, [pc, #208]	; (8013974 <SVCCTL_App_Notification+0x194>)
 80138a4:	f000 fa11 	bl	8013cca <Custom_APP_Notification>
          sys.rf.setConnected(1);
 80138a8:	4b33      	ldr	r3, [pc, #204]	; (8013978 <SVCCTL_App_Notification+0x198>)
 80138aa:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 80138ae:	3350      	adds	r3, #80	; 0x50
 80138b0:	681b      	ldr	r3, [r3, #0]
 80138b2:	2001      	movs	r0, #1
 80138b4:	4798      	blx	r3
        break; /* HCI_EVT_LE_CONN_COMPLETE */
 80138b6:	bf00      	nop
    break; /* HCI_EVT_LE_META_EVENT */
 80138b8:	e054      	b.n	8013964 <SVCCTL_App_Notification+0x184>
      blue_evt = (evt_blue_aci*) event_pckt->data;
 80138ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80138bc:	3302      	adds	r3, #2
 80138be:	623b      	str	r3, [r7, #32]
      switch (blue_evt->ecode)
 80138c0:	6a3b      	ldr	r3, [r7, #32]
 80138c2:	881b      	ldrh	r3, [r3, #0]
 80138c4:	b29b      	uxth	r3, r3
 80138c6:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80138ca:	d042      	beq.n	8013952 <SVCCTL_App_Notification+0x172>
 80138cc:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80138d0:	dc47      	bgt.n	8013962 <SVCCTL_App_Notification+0x182>
 80138d2:	2b04      	cmp	r3, #4
 80138d4:	d03f      	beq.n	8013956 <SVCCTL_App_Notification+0x176>
 80138d6:	2b04      	cmp	r3, #4
 80138d8:	db43      	blt.n	8013962 <SVCCTL_App_Notification+0x182>
 80138da:	f240 420a 	movw	r2, #1034	; 0x40a
 80138de:	4293      	cmp	r3, r2
 80138e0:	dc3f      	bgt.n	8013962 <SVCCTL_App_Notification+0x182>
 80138e2:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80138e6:	dd3c      	ble.n	8013962 <SVCCTL_App_Notification+0x182>
 80138e8:	f2a3 4301 	subw	r3, r3, #1025	; 0x401
 80138ec:	2b09      	cmp	r3, #9
 80138ee:	d838      	bhi.n	8013962 <SVCCTL_App_Notification+0x182>
 80138f0:	a201      	add	r2, pc, #4	; (adr r2, 80138f8 <SVCCTL_App_Notification+0x118>)
 80138f2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80138f6:	bf00      	nop
 80138f8:	0801394b 	.word	0x0801394b
 80138fc:	08013921 	.word	0x08013921
 8013900:	08013963 	.word	0x08013963
 8013904:	08013963 	.word	0x08013963
 8013908:	08013963 	.word	0x08013963
 801390c:	08013963 	.word	0x08013963
 8013910:	0801395b 	.word	0x0801395b
 8013914:	08013963 	.word	0x08013963
 8013918:	0801392f 	.word	0x0801392f
 801391c:	0801395b 	.word	0x0801395b
            aci_gap_pass_key_resp(BleApplicationContext.BleApplicationContext_legacy.connectionHandle, CFG_FIXED_PIN);
 8013920:	4b13      	ldr	r3, [pc, #76]	; (8013970 <SVCCTL_App_Notification+0x190>)
 8013922:	8adb      	ldrh	r3, [r3, #22]
 8013924:	4915      	ldr	r1, [pc, #84]	; (801397c <SVCCTL_App_Notification+0x19c>)
 8013926:	4618      	mov	r0, r3
 8013928:	f7fe fa03 	bl	8011d32 <aci_gap_pass_key_resp>
        break;
 801392c:	e016      	b.n	801395c <SVCCTL_App_Notification+0x17c>
            evt_numeric_value = (aci_gap_numeric_comparison_value_event_rp0 *)blue_evt->data;
 801392e:	6a3b      	ldr	r3, [r7, #32]
 8013930:	3302      	adds	r3, #2
 8013932:	61fb      	str	r3, [r7, #28]
            numeric_value = evt_numeric_value->Numeric_Value;
 8013934:	69fb      	ldr	r3, [r7, #28]
 8013936:	f8d3 3002 	ldr.w	r3, [r3, #2]
 801393a:	61bb      	str	r3, [r7, #24]
            aci_gap_numeric_comparison_value_confirm_yesno(BleApplicationContext.BleApplicationContext_legacy.connectionHandle, YES);
 801393c:	4b0c      	ldr	r3, [pc, #48]	; (8013970 <SVCCTL_App_Notification+0x190>)
 801393e:	8adb      	ldrh	r3, [r3, #22]
 8013940:	2101      	movs	r1, #1
 8013942:	4618      	mov	r0, r3
 8013944:	f7fe fb57 	bl	8011ff6 <aci_gap_numeric_comparison_value_confirm_yesno>
        break;
 8013948:	e008      	b.n	801395c <SVCCTL_App_Notification+0x17c>
            pairing_complete = (aci_gap_pairing_complete_event_rp0*)blue_evt->data;
 801394a:	6a3b      	ldr	r3, [r7, #32]
 801394c:	3302      	adds	r3, #2
 801394e:	617b      	str	r3, [r7, #20]
        break;
 8013950:	e004      	b.n	801395c <SVCCTL_App_Notification+0x17c>
      break;
 8013952:	bf00      	nop
 8013954:	e005      	b.n	8013962 <SVCCTL_App_Notification+0x182>
          break; /* RADIO_ACTIVITY_EVENT */
 8013956:	bf00      	nop
 8013958:	e003      	b.n	8013962 <SVCCTL_App_Notification+0x182>
          break; /* EVT_BLUE_GAP_PROCEDURE_COMPLETE */
 801395a:	bf00      	nop
      break; /* EVT_VENDOR */
 801395c:	e001      	b.n	8013962 <SVCCTL_App_Notification+0x182>
        break;
 801395e:	bf00      	nop
 8013960:	e000      	b.n	8013964 <SVCCTL_App_Notification+0x184>
      break; /* EVT_VENDOR */
 8013962:	bf00      	nop
  }

  return (SVCCTL_UserEvtFlowEnable);
 8013964:	2301      	movs	r3, #1
}
 8013966:	4618      	mov	r0, r3
 8013968:	3728      	adds	r7, #40	; 0x28
 801396a:	46bd      	mov	sp, r7
 801396c:	bd80      	pop	{r7, pc}
 801396e:	bf00      	nop
 8013970:	2000011c 	.word	0x2000011c
 8013974:	20005508 	.word	0x20005508
 8013978:	20001020 	.word	0x20001020
 801397c:	0001b207 	.word	0x0001b207

08013980 <Ble_Tl_Init>:
 *
 * LOCAL FUNCTIONS
 *
 *************************************************************/
static void Ble_Tl_Init( void )
{
 8013980:	b580      	push	{r7, lr}
 8013982:	b082      	sub	sp, #8
 8013984:	af00      	add	r7, sp, #0
  HCI_TL_HciInitConf_t Hci_Tl_Init_Conf;

  Hci_Tl_Init_Conf.p_cmdbuffer = (uint8_t*)&BleCmdBuffer;
 8013986:	4b06      	ldr	r3, [pc, #24]	; (80139a0 <Ble_Tl_Init+0x20>)
 8013988:	603b      	str	r3, [r7, #0]
  Hci_Tl_Init_Conf.StatusNotCallBack = BLE_StatusNot;
 801398a:	4b06      	ldr	r3, [pc, #24]	; (80139a4 <Ble_Tl_Init+0x24>)
 801398c:	607b      	str	r3, [r7, #4]
  hci_init(BLE_UserEvtRx, (void*) &Hci_Tl_Init_Conf);
 801398e:	463b      	mov	r3, r7
 8013990:	4619      	mov	r1, r3
 8013992:	4805      	ldr	r0, [pc, #20]	; (80139a8 <Ble_Tl_Init+0x28>)
 8013994:	f7ff f8ba 	bl	8012b0c <hci_init>

  return;
 8013998:	bf00      	nop
}
 801399a:	3708      	adds	r7, #8
 801399c:	46bd      	mov	sp, r7
 801399e:	bd80      	pop	{r7, pc}
 80139a0:	200300d4 	.word	0x200300d4
 80139a4:	08013c95 	.word	0x08013c95
 80139a8:	08013c5d 	.word	0x08013c5d

080139ac <Ble_Hci_Gap_Gatt_Init>:

static void Ble_Hci_Gap_Gatt_Init(void){
 80139ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80139ae:	b08f      	sub	sp, #60	; 0x3c
 80139b0:	af06      	add	r7, sp, #24

  uint8_t role;
  uint16_t gap_service_handle, gap_dev_name_char_handle, gap_appearance_char_handle;
  const uint8_t *bd_addr;
  uint32_t srd_bd_addr[2];
  uint16_t appearance[1] = { BLE_CFG_GAP_APPEARANCE };
 80139b2:	2300      	movs	r3, #0
 80139b4:	803b      	strh	r3, [r7, #0]

  /**
   * Initialize HCI layer
   */
  /*HCI Reset to synchronise BLE Stack*/
  hci_reset();
 80139b6:	f7fe fec4 	bl	8012742 <hci_reset>

  /**
   * Write the BD Address
   */

  bd_addr = BleGetBdAddress();
 80139ba:	f000 f8cf 	bl	8013b5c <BleGetBdAddress>
 80139be:	61f8      	str	r0, [r7, #28]
  aci_hal_write_config_data(CONFIG_DATA_PUBADDR_OFFSET,
 80139c0:	69fa      	ldr	r2, [r7, #28]
 80139c2:	2106      	movs	r1, #6
 80139c4:	2000      	movs	r0, #0
 80139c6:	f7fe fdb2 	bl	801252e <aci_hal_write_config_data>
   * Static random Address
   * The two upper bits shall be set to 1
   * The lowest 32bits is read from the UDN to differentiate between devices
   * The RNG may be used to provide a random number on each power on
   */
  srd_bd_addr[1] =  0x0000ED6E;
 80139ca:	f64e 536e 	movw	r3, #60782	; 0xed6e
 80139ce:	60bb      	str	r3, [r7, #8]
  srd_bd_addr[0] =  LL_FLASH_GetUDN( );
 80139d0:	f7ff fe94 	bl	80136fc <LL_FLASH_GetUDN>
 80139d4:	4603      	mov	r3, r0
 80139d6:	607b      	str	r3, [r7, #4]
  aci_hal_write_config_data( CONFIG_DATA_RANDOM_ADDRESS_OFFSET, CONFIG_DATA_RANDOM_ADDRESS_LEN, (uint8_t*)srd_bd_addr );
 80139d8:	1d3b      	adds	r3, r7, #4
 80139da:	461a      	mov	r2, r3
 80139dc:	2106      	movs	r1, #6
 80139de:	202e      	movs	r0, #46	; 0x2e
 80139e0:	f7fe fda5 	bl	801252e <aci_hal_write_config_data>

  /**
   * Write Identity root key used to derive LTK and CSRK
   */
    aci_hal_write_config_data( CONFIG_DATA_IR_OFFSET, CONFIG_DATA_IR_LEN, (uint8_t*)BLE_CFG_IR_VALUE );
 80139e4:	4a40      	ldr	r2, [pc, #256]	; (8013ae8 <Ble_Hci_Gap_Gatt_Init+0x13c>)
 80139e6:	2110      	movs	r1, #16
 80139e8:	2018      	movs	r0, #24
 80139ea:	f7fe fda0 	bl	801252e <aci_hal_write_config_data>

   /**
   * Write Encryption root key used to derive LTK and CSRK
   */
    aci_hal_write_config_data( CONFIG_DATA_ER_OFFSET, CONFIG_DATA_ER_LEN, (uint8_t*)BLE_CFG_ER_VALUE );
 80139ee:	4a3f      	ldr	r2, [pc, #252]	; (8013aec <Ble_Hci_Gap_Gatt_Init+0x140>)
 80139f0:	2110      	movs	r1, #16
 80139f2:	2008      	movs	r0, #8
 80139f4:	f7fe fd9b 	bl	801252e <aci_hal_write_config_data>

  /**
   * Set TX Power to 0dBm.
   */
  aci_hal_set_tx_power_level(1, CFG_TX_POWER);
 80139f8:	211f      	movs	r1, #31
 80139fa:	2001      	movs	r0, #1
 80139fc:	f7fe fe00 	bl	8012600 <aci_hal_set_tx_power_level>

  /**
   * Initialize GATT interface
   */
  aci_gatt_init();
 8013a00:	f7fe fb50 	bl	80120a4 <aci_gatt_init>

  /**
   * Initialize GAP interface
   */
  role = 0;
 8013a04:	2300      	movs	r3, #0
 8013a06:	76fb      	strb	r3, [r7, #27]

#if (BLE_CFG_PERIPHERAL == 1)
  role |= GAP_PERIPHERAL_ROLE;
 8013a08:	7efb      	ldrb	r3, [r7, #27]
 8013a0a:	f043 0301 	orr.w	r3, r3, #1
 8013a0e:	76fb      	strb	r3, [r7, #27]

#if (BLE_CFG_CENTRAL == 1)
  role |= GAP_CENTRAL_ROLE;
#endif

  if (role > 0)
 8013a10:	7efb      	ldrb	r3, [r7, #27]
 8013a12:	2b00      	cmp	r3, #0
 8013a14:	d01e      	beq.n	8013a54 <Ble_Hci_Gap_Gatt_Init+0xa8>
  {
    const char *name = CFG_GAP_DEVICE_NAME;
 8013a16:	4b36      	ldr	r3, [pc, #216]	; (8013af0 <Ble_Hci_Gap_Gatt_Init+0x144>)
 8013a18:	617b      	str	r3, [r7, #20]
    aci_gap_init(role, 0,
 8013a1a:	f107 0212 	add.w	r2, r7, #18
 8013a1e:	7ef8      	ldrb	r0, [r7, #27]
 8013a20:	f107 030e 	add.w	r3, r7, #14
 8013a24:	9301      	str	r3, [sp, #4]
 8013a26:	f107 0310 	add.w	r3, r7, #16
 8013a2a:	9300      	str	r3, [sp, #0]
 8013a2c:	4613      	mov	r3, r2
 8013a2e:	2208      	movs	r2, #8
 8013a30:	2100      	movs	r1, #0
 8013a32:	f7fe f9d5 	bl	8011de0 <aci_gap_init>
                CFG_GAP_DEVICE_NAME_LENGTH,
                 &gap_service_handle, &gap_dev_name_char_handle, &gap_appearance_char_handle);

    if (aci_gatt_update_char_value(gap_service_handle, gap_dev_name_char_handle, 0, strlen(name), (uint8_t *) name))
 8013a36:	8a7c      	ldrh	r4, [r7, #18]
 8013a38:	8a3d      	ldrh	r5, [r7, #16]
 8013a3a:	6978      	ldr	r0, [r7, #20]
 8013a3c:	f7f1 fb9e 	bl	800517c <strlen>
 8013a40:	4603      	mov	r3, r0
 8013a42:	b2da      	uxtb	r2, r3
 8013a44:	697b      	ldr	r3, [r7, #20]
 8013a46:	9300      	str	r3, [sp, #0]
 8013a48:	4613      	mov	r3, r2
 8013a4a:	2200      	movs	r2, #0
 8013a4c:	4629      	mov	r1, r5
 8013a4e:	4620      	mov	r0, r4
 8013a50:	f7fe fce6 	bl	8012420 <aci_gatt_update_char_value>
    {
      BLE_DBG_SVCCTL_MSG("Device Name aci_gatt_update_char_value failed.\n");
    }
  }

  if(aci_gatt_update_char_value(gap_service_handle,
 8013a54:	8a78      	ldrh	r0, [r7, #18]
 8013a56:	89f9      	ldrh	r1, [r7, #14]
 8013a58:	463b      	mov	r3, r7
 8013a5a:	9300      	str	r3, [sp, #0]
 8013a5c:	2302      	movs	r3, #2
 8013a5e:	2200      	movs	r2, #0
 8013a60:	f7fe fcde 	bl	8012420 <aci_gatt_update_char_value>
    BLE_DBG_SVCCTL_MSG("Appearance aci_gatt_update_char_value failed.\n");
  }
  /**
   * Initialize Default PHY
   */
  hci_le_set_default_phy(ALL_PHYS_PREFERENCE,TX_2M_PREFERRED,RX_2M_PREFERRED);
 8013a64:	2202      	movs	r2, #2
 8013a66:	2102      	movs	r1, #2
 8013a68:	2000      	movs	r0, #0
 8013a6a:	f7fe fe8e 	bl	801278a <hci_le_set_default_phy>

  /**
   * Initialize IO capability
   */
  BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.ioCapability = CFG_IO_CAPABILITY;
 8013a6e:	4b21      	ldr	r3, [pc, #132]	; (8013af4 <Ble_Hci_Gap_Gatt_Init+0x148>)
 8013a70:	2201      	movs	r2, #1
 8013a72:	701a      	strb	r2, [r3, #0]
  aci_gap_set_io_capability(BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.ioCapability);
 8013a74:	4b1f      	ldr	r3, [pc, #124]	; (8013af4 <Ble_Hci_Gap_Gatt_Init+0x148>)
 8013a76:	781b      	ldrb	r3, [r3, #0]
 8013a78:	4618      	mov	r0, r3
 8013a7a:	f7fe f868 	bl	8011b4e <aci_gap_set_io_capability>

  /**
   * Initialize authentication
   */
  BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.mitm_mode = CFG_MITM_PROTECTION;
 8013a7e:	4b1d      	ldr	r3, [pc, #116]	; (8013af4 <Ble_Hci_Gap_Gatt_Init+0x148>)
 8013a80:	2201      	movs	r2, #1
 8013a82:	705a      	strb	r2, [r3, #1]
  BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.encryptionKeySizeMin = CFG_ENCRYPTION_KEY_SIZE_MIN;
 8013a84:	4b1b      	ldr	r3, [pc, #108]	; (8013af4 <Ble_Hci_Gap_Gatt_Init+0x148>)
 8013a86:	2208      	movs	r2, #8
 8013a88:	711a      	strb	r2, [r3, #4]
  BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.encryptionKeySizeMax = CFG_ENCRYPTION_KEY_SIZE_MAX;
 8013a8a:	4b1a      	ldr	r3, [pc, #104]	; (8013af4 <Ble_Hci_Gap_Gatt_Init+0x148>)
 8013a8c:	2210      	movs	r2, #16
 8013a8e:	715a      	strb	r2, [r3, #5]
  BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.Use_Fixed_Pin = CFG_USED_FIXED_PIN;
 8013a90:	4b18      	ldr	r3, [pc, #96]	; (8013af4 <Ble_Hci_Gap_Gatt_Init+0x148>)
 8013a92:	2200      	movs	r2, #0
 8013a94:	70da      	strb	r2, [r3, #3]
  BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.Fixed_Pin = CFG_FIXED_PIN;
 8013a96:	4b17      	ldr	r3, [pc, #92]	; (8013af4 <Ble_Hci_Gap_Gatt_Init+0x148>)
 8013a98:	4a17      	ldr	r2, [pc, #92]	; (8013af8 <Ble_Hci_Gap_Gatt_Init+0x14c>)
 8013a9a:	609a      	str	r2, [r3, #8]
  BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.bonding_mode = CFG_BONDING_MODE;
 8013a9c:	4b15      	ldr	r3, [pc, #84]	; (8013af4 <Ble_Hci_Gap_Gatt_Init+0x148>)
 8013a9e:	2200      	movs	r2, #0
 8013aa0:	709a      	strb	r2, [r3, #2]

  aci_gap_set_authentication_requirement(BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.bonding_mode,
 8013aa2:	4b14      	ldr	r3, [pc, #80]	; (8013af4 <Ble_Hci_Gap_Gatt_Init+0x148>)
 8013aa4:	789c      	ldrb	r4, [r3, #2]
 8013aa6:	4b13      	ldr	r3, [pc, #76]	; (8013af4 <Ble_Hci_Gap_Gatt_Init+0x148>)
 8013aa8:	785d      	ldrb	r5, [r3, #1]
 8013aaa:	4b12      	ldr	r3, [pc, #72]	; (8013af4 <Ble_Hci_Gap_Gatt_Init+0x148>)
 8013aac:	791b      	ldrb	r3, [r3, #4]
 8013aae:	4a11      	ldr	r2, [pc, #68]	; (8013af4 <Ble_Hci_Gap_Gatt_Init+0x148>)
 8013ab0:	7952      	ldrb	r2, [r2, #5]
 8013ab2:	4910      	ldr	r1, [pc, #64]	; (8013af4 <Ble_Hci_Gap_Gatt_Init+0x148>)
 8013ab4:	78c9      	ldrb	r1, [r1, #3]
 8013ab6:	480f      	ldr	r0, [pc, #60]	; (8013af4 <Ble_Hci_Gap_Gatt_Init+0x148>)
 8013ab8:	6880      	ldr	r0, [r0, #8]
 8013aba:	2600      	movs	r6, #0
 8013abc:	9604      	str	r6, [sp, #16]
 8013abe:	9003      	str	r0, [sp, #12]
 8013ac0:	9102      	str	r1, [sp, #8]
 8013ac2:	9201      	str	r2, [sp, #4]
 8013ac4:	9300      	str	r3, [sp, #0]
 8013ac6:	2300      	movs	r3, #0
 8013ac8:	2201      	movs	r2, #1
 8013aca:	4629      	mov	r1, r5
 8013acc:	4620      	mov	r0, r4
 8013ace:	f7fe f888 	bl	8011be2 <aci_gap_set_authentication_requirement>
                                         );

  /**
   * Initialize whitelist
   */
   if (BleApplicationContext.BleApplicationContext_legacy.bleSecurityParam.bonding_mode)
 8013ad2:	4b08      	ldr	r3, [pc, #32]	; (8013af4 <Ble_Hci_Gap_Gatt_Init+0x148>)
 8013ad4:	789b      	ldrb	r3, [r3, #2]
 8013ad6:	2b00      	cmp	r3, #0
 8013ad8:	d001      	beq.n	8013ade <Ble_Hci_Gap_Gatt_Init+0x132>
   {
     aci_gap_configure_whitelist();
 8013ada:	f7fe fa68 	bl	8011fae <aci_gap_configure_whitelist>
   }
}
 8013ade:	bf00      	nop
 8013ae0:	3724      	adds	r7, #36	; 0x24
 8013ae2:	46bd      	mov	sp, r7
 8013ae4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013ae6:	bf00      	nop
 8013ae8:	08015390 	.word	0x08015390
 8013aec:	080153a0 	.word	0x080153a0
 8013af0:	08014dac 	.word	0x08014dac
 8013af4:	2000011c 	.word	0x2000011c
 8013af8:	0001b207 	.word	0x0001b207

08013afc <Adv_Request>:

static void Adv_Request(APP_BLE_ConnStatus_t New_Status)
{
 8013afc:	b580      	push	{r7, lr}
 8013afe:	b08c      	sub	sp, #48	; 0x30
 8013b00:	af08      	add	r7, sp, #32
 8013b02:	4603      	mov	r3, r0
 8013b04:	71fb      	strb	r3, [r7, #7]
  tBleStatus ret = BLE_STATUS_INVALID_PARAMS;
 8013b06:	2342      	movs	r3, #66	; 0x42
 8013b08:	73fb      	strb	r3, [r7, #15]

    BleApplicationContext.Device_Connection_Status = New_Status;
 8013b0a:	4a12      	ldr	r2, [pc, #72]	; (8013b54 <Adv_Request+0x58>)
 8013b0c:	79fb      	ldrb	r3, [r7, #7]
 8013b0e:	f882 3080 	strb.w	r3, [r2, #128]	; 0x80
    /* Start Fast or Low Power Advertising */
    ret = aci_gap_set_discoverable(
 8013b12:	2300      	movs	r3, #0
 8013b14:	9306      	str	r3, [sp, #24]
 8013b16:	2300      	movs	r3, #0
 8013b18:	9305      	str	r3, [sp, #20]
 8013b1a:	2300      	movs	r3, #0
 8013b1c:	9304      	str	r3, [sp, #16]
 8013b1e:	2300      	movs	r3, #0
 8013b20:	9303      	str	r3, [sp, #12]
 8013b22:	2300      	movs	r3, #0
 8013b24:	9302      	str	r3, [sp, #8]
 8013b26:	2300      	movs	r3, #0
 8013b28:	9301      	str	r3, [sp, #4]
 8013b2a:	2300      	movs	r3, #0
 8013b2c:	9300      	str	r3, [sp, #0]
 8013b2e:	2300      	movs	r3, #0
 8013b30:	22a0      	movs	r2, #160	; 0xa0
 8013b32:	2180      	movs	r1, #128	; 0x80
 8013b34:	2000      	movs	r0, #0
 8013b36:	f7fd ff2c 	bl	8011992 <aci_gap_set_discoverable>
 8013b3a:	4603      	mov	r3, r0
 8013b3c:	73fb      	strb	r3, [r7, #15]
        0,
        0,
        0);

    /* Update Advertising data */
    ret = aci_gap_update_adv_data(sizeof(ad_data), (uint8_t*) ad_data);
 8013b3e:	4906      	ldr	r1, [pc, #24]	; (8013b58 <Adv_Request+0x5c>)
 8013b40:	2010      	movs	r0, #16
 8013b42:	f7fe f9d8 	bl	8011ef6 <aci_gap_update_adv_data>
 8013b46:	4603      	mov	r3, r0
 8013b48:	73fb      	strb	r3, [r7, #15]
    else
    {
        APP_DBG_MSG("Start Fast Advertising Failed , result: %d \n", ret);
    }

  return;
 8013b4a:	bf00      	nop
}
 8013b4c:	3710      	adds	r7, #16
 8013b4e:	46bd      	mov	sp, r7
 8013b50:	bd80      	pop	{r7, pc}
 8013b52:	bf00      	nop
 8013b54:	2000011c 	.word	0x2000011c
 8013b58:	20000010 	.word	0x20000010

08013b5c <BleGetBdAddress>:

const uint8_t* BleGetBdAddress( void )
{
 8013b5c:	b580      	push	{r7, lr}
 8013b5e:	b086      	sub	sp, #24
 8013b60:	af00      	add	r7, sp, #0
  const uint8_t *bd_addr;
  uint32_t udn;
  uint32_t company_id;
  uint32_t device_id;

  udn = LL_FLASH_GetUDN();
 8013b62:	f7ff fdcb 	bl	80136fc <LL_FLASH_GetUDN>
 8013b66:	6138      	str	r0, [r7, #16]

  if(udn != 0xFFFFFFFF)
 8013b68:	693b      	ldr	r3, [r7, #16]
 8013b6a:	f1b3 3fff 	cmp.w	r3, #4294967295
 8013b6e:	d023      	beq.n	8013bb8 <BleGetBdAddress+0x5c>
  {
    company_id = LL_FLASH_GetSTCompanyID();
 8013b70:	f7ff fddc 	bl	801372c <LL_FLASH_GetSTCompanyID>
 8013b74:	60b8      	str	r0, [r7, #8]
    device_id = LL_FLASH_GetDeviceID();
 8013b76:	f7ff fdcd 	bl	8013714 <LL_FLASH_GetDeviceID>
 8013b7a:	6078      	str	r0, [r7, #4]

    bd_addr_udn[0] = (uint8_t)(udn & 0x000000FF);
 8013b7c:	693b      	ldr	r3, [r7, #16]
 8013b7e:	b2da      	uxtb	r2, r3
 8013b80:	4b16      	ldr	r3, [pc, #88]	; (8013bdc <BleGetBdAddress+0x80>)
 8013b82:	701a      	strb	r2, [r3, #0]
    bd_addr_udn[1] = (uint8_t)( (udn & 0x0000FF00) >> 8 );
 8013b84:	693b      	ldr	r3, [r7, #16]
 8013b86:	0a1b      	lsrs	r3, r3, #8
 8013b88:	b2da      	uxtb	r2, r3
 8013b8a:	4b14      	ldr	r3, [pc, #80]	; (8013bdc <BleGetBdAddress+0x80>)
 8013b8c:	705a      	strb	r2, [r3, #1]
    bd_addr_udn[2] = (uint8_t)( (udn & 0x00FF0000) >> 16 );
 8013b8e:	693b      	ldr	r3, [r7, #16]
 8013b90:	0c1b      	lsrs	r3, r3, #16
 8013b92:	b2da      	uxtb	r2, r3
 8013b94:	4b11      	ldr	r3, [pc, #68]	; (8013bdc <BleGetBdAddress+0x80>)
 8013b96:	709a      	strb	r2, [r3, #2]
    bd_addr_udn[3] = (uint8_t)device_id;
 8013b98:	687b      	ldr	r3, [r7, #4]
 8013b9a:	b2da      	uxtb	r2, r3
 8013b9c:	4b0f      	ldr	r3, [pc, #60]	; (8013bdc <BleGetBdAddress+0x80>)
 8013b9e:	70da      	strb	r2, [r3, #3]
    bd_addr_udn[4] = (uint8_t)(company_id & 0x000000FF);;
 8013ba0:	68bb      	ldr	r3, [r7, #8]
 8013ba2:	b2da      	uxtb	r2, r3
 8013ba4:	4b0d      	ldr	r3, [pc, #52]	; (8013bdc <BleGetBdAddress+0x80>)
 8013ba6:	711a      	strb	r2, [r3, #4]
    bd_addr_udn[5] = (uint8_t)( (company_id & 0x0000FF00) >> 8 );
 8013ba8:	68bb      	ldr	r3, [r7, #8]
 8013baa:	0a1b      	lsrs	r3, r3, #8
 8013bac:	b2da      	uxtb	r2, r3
 8013bae:	4b0b      	ldr	r3, [pc, #44]	; (8013bdc <BleGetBdAddress+0x80>)
 8013bb0:	715a      	strb	r2, [r3, #5]

    bd_addr = (const uint8_t *)bd_addr_udn;
 8013bb2:	4b0a      	ldr	r3, [pc, #40]	; (8013bdc <BleGetBdAddress+0x80>)
 8013bb4:	617b      	str	r3, [r7, #20]
 8013bb6:	e00b      	b.n	8013bd0 <BleGetBdAddress+0x74>
  }
  else
  {
    otp_addr = OTP_Read(0);
 8013bb8:	2000      	movs	r0, #0
 8013bba:	f7ff fcb9 	bl	8013530 <OTP_Read>
 8013bbe:	60f8      	str	r0, [r7, #12]
    if(otp_addr)
 8013bc0:	68fb      	ldr	r3, [r7, #12]
 8013bc2:	2b00      	cmp	r3, #0
 8013bc4:	d002      	beq.n	8013bcc <BleGetBdAddress+0x70>
    {
      bd_addr = ((OTP_ID0_t*)otp_addr)->bd_address;
 8013bc6:	68fb      	ldr	r3, [r7, #12]
 8013bc8:	617b      	str	r3, [r7, #20]
 8013bca:	e001      	b.n	8013bd0 <BleGetBdAddress+0x74>
    }
    else
    {
      bd_addr = M_bd_addr;
 8013bcc:	4b04      	ldr	r3, [pc, #16]	; (8013be0 <BleGetBdAddress+0x84>)
 8013bce:	617b      	str	r3, [r7, #20]
    }

  }

  return bd_addr;
 8013bd0:	697b      	ldr	r3, [r7, #20]
}
 8013bd2:	4618      	mov	r0, r3
 8013bd4:	3718      	adds	r7, #24
 8013bd6:	46bd      	mov	sp, r7
 8013bd8:	bd80      	pop	{r7, pc}
 8013bda:	bf00      	nop
 8013bdc:	20000f68 	.word	0x20000f68
 8013be0:	08015388 	.word	0x08015388

08013be4 <Adv_Cancel>:
 *
 *SPECIFIC FUNCTIONS FOR CUSTOM
 *
 *************************************************************/
static void Adv_Cancel( void )
{
 8013be4:	b580      	push	{r7, lr}
 8013be6:	b082      	sub	sp, #8
 8013be8:	af00      	add	r7, sp, #0
/* USER CODE BEGIN Adv_Cancel_1 */

/* USER CODE END Adv_Cancel_1 */

  if (BleApplicationContext.Device_Connection_Status != APP_BLE_CONNECTED_SERVER)
 8013bea:	4b0a      	ldr	r3, [pc, #40]	; (8013c14 <Adv_Cancel+0x30>)
 8013bec:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 8013bf0:	2b05      	cmp	r3, #5
 8013bf2:	d00a      	beq.n	8013c0a <Adv_Cancel+0x26>

  {

    tBleStatus result = 0x00;
 8013bf4:	2300      	movs	r3, #0
 8013bf6:	71fb      	strb	r3, [r7, #7]

    result = aci_gap_set_non_discoverable();
 8013bf8:	f7fd fea7 	bl	801194a <aci_gap_set_non_discoverable>
 8013bfc:	4603      	mov	r3, r0
 8013bfe:	71fb      	strb	r3, [r7, #7]

    BleApplicationContext.Device_Connection_Status = APP_BLE_IDLE;
 8013c00:	4b04      	ldr	r3, [pc, #16]	; (8013c14 <Adv_Cancel+0x30>)
 8013c02:	2200      	movs	r2, #0
 8013c04:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
  }

/* USER CODE BEGIN Adv_Cancel_2 */

/* USER CODE END Adv_Cancel_2 */
  return;
 8013c08:	bf00      	nop
 8013c0a:	bf00      	nop
}
 8013c0c:	3708      	adds	r7, #8
 8013c0e:	46bd      	mov	sp, r7
 8013c10:	bd80      	pop	{r7, pc}
 8013c12:	bf00      	nop
 8013c14:	2000011c 	.word	0x2000011c

08013c18 <hci_notify_asynch_evt>:
 *
 * WRAP FUNCTIONS
 *
 *************************************************************/
void hci_notify_asynch_evt(void* pdata)
{
 8013c18:	b580      	push	{r7, lr}
 8013c1a:	b082      	sub	sp, #8
 8013c1c:	af00      	add	r7, sp, #0
 8013c1e:	6078      	str	r0, [r7, #4]
  UTIL_SEQ_SetTask(1 << CFG_TASK_HCI_ASYNCH_EVT_ID, CFG_SCH_PRIO_0);
 8013c20:	2100      	movs	r1, #0
 8013c22:	2004      	movs	r0, #4
 8013c24:	f000 fe8c 	bl	8014940 <UTIL_SEQ_SetTask>
  return;
 8013c28:	bf00      	nop
}
 8013c2a:	3708      	adds	r7, #8
 8013c2c:	46bd      	mov	sp, r7
 8013c2e:	bd80      	pop	{r7, pc}

08013c30 <hci_cmd_resp_release>:

void hci_cmd_resp_release(uint32_t flag)
{
 8013c30:	b580      	push	{r7, lr}
 8013c32:	b082      	sub	sp, #8
 8013c34:	af00      	add	r7, sp, #0
 8013c36:	6078      	str	r0, [r7, #4]
  UTIL_SEQ_SetEvt(1 << CFG_IDLEEVT_HCI_CMD_EVT_RSP_ID);
 8013c38:	2001      	movs	r0, #1
 8013c3a:	f000 feed 	bl	8014a18 <UTIL_SEQ_SetEvt>
  return;
 8013c3e:	bf00      	nop
}
 8013c40:	3708      	adds	r7, #8
 8013c42:	46bd      	mov	sp, r7
 8013c44:	bd80      	pop	{r7, pc}

08013c46 <hci_cmd_resp_wait>:

void hci_cmd_resp_wait(uint32_t timeout)
{
 8013c46:	b580      	push	{r7, lr}
 8013c48:	b082      	sub	sp, #8
 8013c4a:	af00      	add	r7, sp, #0
 8013c4c:	6078      	str	r0, [r7, #4]
  UTIL_SEQ_WaitEvt(1 << CFG_IDLEEVT_HCI_CMD_EVT_RSP_ID);
 8013c4e:	2001      	movs	r0, #1
 8013c50:	f000 ff02 	bl	8014a58 <UTIL_SEQ_WaitEvt>
  return;
 8013c54:	bf00      	nop
}
 8013c56:	3708      	adds	r7, #8
 8013c58:	46bd      	mov	sp, r7
 8013c5a:	bd80      	pop	{r7, pc}

08013c5c <BLE_UserEvtRx>:

static void BLE_UserEvtRx( void * pPayload )
{
 8013c5c:	b580      	push	{r7, lr}
 8013c5e:	b084      	sub	sp, #16
 8013c60:	af00      	add	r7, sp, #0
 8013c62:	6078      	str	r0, [r7, #4]
  SVCCTL_UserEvtFlowStatus_t svctl_return_status;
  tHCI_UserEvtRxParam *pParam;

  pParam = (tHCI_UserEvtRxParam *)pPayload;
 8013c64:	687b      	ldr	r3, [r7, #4]
 8013c66:	60fb      	str	r3, [r7, #12]

  svctl_return_status = SVCCTL_UserEvtRx((void *)&(pParam->pckt->evtserial));
 8013c68:	68fb      	ldr	r3, [r7, #12]
 8013c6a:	685b      	ldr	r3, [r3, #4]
 8013c6c:	3308      	adds	r3, #8
 8013c6e:	4618      	mov	r0, r3
 8013c70:	f7fe feca 	bl	8012a08 <SVCCTL_UserEvtRx>
 8013c74:	4603      	mov	r3, r0
 8013c76:	72fb      	strb	r3, [r7, #11]
  if (svctl_return_status != SVCCTL_UserEvtFlowDisable)
 8013c78:	7afb      	ldrb	r3, [r7, #11]
 8013c7a:	2b00      	cmp	r3, #0
 8013c7c:	d003      	beq.n	8013c86 <BLE_UserEvtRx+0x2a>
  {
    pParam->status = HCI_TL_UserEventFlow_Enable;
 8013c7e:	68fb      	ldr	r3, [r7, #12]
 8013c80:	2201      	movs	r2, #1
 8013c82:	701a      	strb	r2, [r3, #0]
  }
  else
  {
    pParam->status = HCI_TL_UserEventFlow_Disable;
  }
}
 8013c84:	e002      	b.n	8013c8c <BLE_UserEvtRx+0x30>
    pParam->status = HCI_TL_UserEventFlow_Disable;
 8013c86:	68fb      	ldr	r3, [r7, #12]
 8013c88:	2200      	movs	r2, #0
 8013c8a:	701a      	strb	r2, [r3, #0]
}
 8013c8c:	bf00      	nop
 8013c8e:	3710      	adds	r7, #16
 8013c90:	46bd      	mov	sp, r7
 8013c92:	bd80      	pop	{r7, pc}

08013c94 <BLE_StatusNot>:

static void BLE_StatusNot( HCI_TL_CmdStatus_t status )
{
 8013c94:	b580      	push	{r7, lr}
 8013c96:	b084      	sub	sp, #16
 8013c98:	af00      	add	r7, sp, #0
 8013c9a:	4603      	mov	r3, r0
 8013c9c:	71fb      	strb	r3, [r7, #7]
  uint32_t task_id_list;
  switch (status)
 8013c9e:	79fb      	ldrb	r3, [r7, #7]
 8013ca0:	2b00      	cmp	r3, #0
 8013ca2:	d002      	beq.n	8013caa <BLE_StatusNot+0x16>
 8013ca4:	2b01      	cmp	r3, #1
 8013ca6:	d006      	beq.n	8013cb6 <BLE_StatusNot+0x22>
      UTIL_SEQ_ResumeTask(task_id_list);

      break;

    default:
      break;
 8013ca8:	e00b      	b.n	8013cc2 <BLE_StatusNot+0x2e>
      task_id_list = (1 << CFG_LAST_TASK_ID_WITH_HCICMD) - 1;
 8013caa:	233f      	movs	r3, #63	; 0x3f
 8013cac:	60fb      	str	r3, [r7, #12]
      UTIL_SEQ_PauseTask(task_id_list);
 8013cae:	68f8      	ldr	r0, [r7, #12]
 8013cb0:	f000 fe72 	bl	8014998 <UTIL_SEQ_PauseTask>
      break;
 8013cb4:	e005      	b.n	8013cc2 <BLE_StatusNot+0x2e>
      task_id_list = (1 << CFG_LAST_TASK_ID_WITH_HCICMD) - 1;
 8013cb6:	233f      	movs	r3, #63	; 0x3f
 8013cb8:	60fb      	str	r3, [r7, #12]
      UTIL_SEQ_ResumeTask(task_id_list);
 8013cba:	68f8      	ldr	r0, [r7, #12]
 8013cbc:	f000 fe8c 	bl	80149d8 <UTIL_SEQ_ResumeTask>
      break;
 8013cc0:	bf00      	nop
  }
  return;
 8013cc2:	bf00      	nop
}
 8013cc4:	3710      	adds	r7, #16
 8013cc6:	46bd      	mov	sp, r7
 8013cc8:	bd80      	pop	{r7, pc}

08013cca <Custom_APP_Notification>:
/* USER CODE END CUSTOM_STM_App_Notification_2 */
  return;
}

void Custom_APP_Notification(Custom_App_ConnHandle_Not_evt_t *pNotification)
{
 8013cca:	b480      	push	{r7}
 8013ccc:	b083      	sub	sp, #12
 8013cce:	af00      	add	r7, sp, #0
 8013cd0:	6078      	str	r0, [r7, #4]
/* USER CODE BEGIN CUSTOM_APP_Notification_1 */

/* USER CODE END CUSTOM_APP_Notification_1 */

  switch(pNotification->Custom_Evt_Opcode)
 8013cd2:	687b      	ldr	r3, [r7, #4]
 8013cd4:	781b      	ldrb	r3, [r3, #0]
 8013cd6:	2b00      	cmp	r3, #0
 8013cd8:	d002      	beq.n	8013ce0 <Custom_APP_Notification+0x16>
 8013cda:	2b01      	cmp	r3, #1
 8013cdc:	d002      	beq.n	8013ce4 <Custom_APP_Notification+0x1a>

    default:
/* USER CODE BEGIN CUSTOM_APP_Notification_default */

/* USER CODE END CUSTOM_APP_Notification_default */
      break;
 8013cde:	e002      	b.n	8013ce6 <Custom_APP_Notification+0x1c>
    break;
 8013ce0:	bf00      	nop
 8013ce2:	e000      	b.n	8013ce6 <Custom_APP_Notification+0x1c>
    break;
 8013ce4:	bf00      	nop

/* USER CODE BEGIN CUSTOM_APP_Notification_2 */

/* USER CODE END CUSTOM_APP_Notification_2 */

  return;
 8013ce6:	bf00      	nop
}
 8013ce8:	370c      	adds	r7, #12
 8013cea:	46bd      	mov	sp, r7
 8013cec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013cf0:	4770      	bx	lr

08013cf2 <Custom_APP_Init>:

void Custom_APP_Init(void)
{
 8013cf2:	b480      	push	{r7}
 8013cf4:	af00      	add	r7, sp, #0
/* USER CODE BEGIN CUSTOM_APP_Init */

/* USER CODE END CUSTOM_APP_Init */
  return;
 8013cf6:	bf00      	nop
}
 8013cf8:	46bd      	mov	sp, r7
 8013cfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013cfe:	4770      	bx	lr

08013d00 <Custom_STM_Event_Handler>:
 * @brief  Event handler
 * @param  Event: Address of the buffer holding the Event
 * @retval Ack: Return whether the Event has been managed or not
 */
static SVCCTL_EvtAckStatus_t Custom_STM_Event_Handler(void *Event)
{
 8013d00:	b580      	push	{r7, lr}
 8013d02:	b086      	sub	sp, #24
 8013d04:	af00      	add	r7, sp, #0
 8013d06:	6078      	str	r0, [r7, #4]
/* USER CODE BEGIN Custom_STM_Event_Handler_1 */
  aci_gatt_attribute_modified_event_rp0    * attribute_modified;
  //Custom_STM_App_Notification_evt_t Notification;
/* USER CODE END Custom_STM_Event_Handler_1 */

  return_value = SVCCTL_EvtNotAck;
 8013d08:	2300      	movs	r3, #0
 8013d0a:	75fb      	strb	r3, [r7, #23]
  event_pckt = (hci_event_pckt *)(((hci_uart_pckt*)Event)->data);
 8013d0c:	687b      	ldr	r3, [r7, #4]
 8013d0e:	3301      	adds	r3, #1
 8013d10:	613b      	str	r3, [r7, #16]

  switch(event_pckt->evt)
 8013d12:	693b      	ldr	r3, [r7, #16]
 8013d14:	781b      	ldrb	r3, [r3, #0]
 8013d16:	2bff      	cmp	r3, #255	; 0xff
 8013d18:	f040 80b8 	bne.w	8013e8c <Custom_STM_Event_Handler+0x18c>
  {
    case EVT_VENDOR:
      blue_evt = (evt_blue_aci*)event_pckt->data;
 8013d1c:	693b      	ldr	r3, [r7, #16]
 8013d1e:	3302      	adds	r3, #2
 8013d20:	60fb      	str	r3, [r7, #12]
      switch(blue_evt->ecode)
 8013d22:	68fb      	ldr	r3, [r7, #12]
 8013d24:	881b      	ldrh	r3, [r3, #0]
 8013d26:	b29b      	uxth	r3, r3
 8013d28:	f640 4214 	movw	r2, #3092	; 0xc14
 8013d2c:	4293      	cmp	r3, r2
 8013d2e:	f000 80a7 	beq.w	8013e80 <Custom_STM_Event_Handler+0x180>
 8013d32:	f640 4214 	movw	r2, #3092	; 0xc14
 8013d36:	4293      	cmp	r3, r2
 8013d38:	f300 80a4 	bgt.w	8013e84 <Custom_STM_Event_Handler+0x184>
 8013d3c:	f640 4201 	movw	r2, #3073	; 0xc01
 8013d40:	4293      	cmp	r3, r2
 8013d42:	d003      	beq.n	8013d4c <Custom_STM_Event_Handler+0x4c>
 8013d44:	f640 4213 	movw	r2, #3091	; 0xc13
 8013d48:	4293      	cmp	r3, r2
          break;
        case EVT_BLUE_GATT_WRITE_PERMIT_REQ:
          /* USER CODE BEGIN EVT_BLUE_GATT_WRITE_PERMIT_REQ */

          /* USER CODE END EVT_BLUE_GATT_WRITE_PERMIT_REQ */
          break;
 8013d4a:	e09e      	b.n	8013e8a <Custom_STM_Event_Handler+0x18a>
        	attribute_modified = (aci_gatt_attribute_modified_event_rp0*)blue_evt->data;
 8013d4c:	68fb      	ldr	r3, [r7, #12]
 8013d4e:	3302      	adds	r3, #2
 8013d50:	60bb      	str	r3, [r7, #8]
        	if (attribute_modified->Attr_Handle == (CustomContext.CustomP_Mcu_CmdHdle + 1)) // characteristic 1 changed p_mcu_cmd
 8013d52:	68bb      	ldr	r3, [r7, #8]
 8013d54:	885b      	ldrh	r3, [r3, #2]
 8013d56:	b29b      	uxth	r3, r3
 8013d58:	461a      	mov	r2, r3
 8013d5a:	4b4f      	ldr	r3, [pc, #316]	; (8013e98 <Custom_STM_Event_Handler+0x198>)
 8013d5c:	885b      	ldrh	r3, [r3, #2]
 8013d5e:	3301      	adds	r3, #1
 8013d60:	429a      	cmp	r2, r3
 8013d62:	d10d      	bne.n	8013d80 <Custom_STM_Event_Handler+0x80>
        		sys.rf.processFirstCharWrite(attribute_modified->Attr_Data, attribute_modified->Attr_Data_Length);
 8013d64:	4b4d      	ldr	r3, [pc, #308]	; (8013e9c <Custom_STM_Event_Handler+0x19c>)
 8013d66:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 8013d6a:	3354      	adds	r3, #84	; 0x54
 8013d6c:	681b      	ldr	r3, [r3, #0]
 8013d6e:	68ba      	ldr	r2, [r7, #8]
 8013d70:	f102 0008 	add.w	r0, r2, #8
 8013d74:	68ba      	ldr	r2, [r7, #8]
 8013d76:	88d2      	ldrh	r2, [r2, #6]
 8013d78:	b292      	uxth	r2, r2
 8013d7a:	4611      	mov	r1, r2
 8013d7c:	4798      	blx	r3
          break;
 8013d7e:	e083      	b.n	8013e88 <Custom_STM_Event_Handler+0x188>
        	else if (attribute_modified->Attr_Handle == (CustomContext.CustomP_Mcu_DataHdle + 1)) // characteristic 2 changed p_mcu_data
 8013d80:	68bb      	ldr	r3, [r7, #8]
 8013d82:	885b      	ldrh	r3, [r3, #2]
 8013d84:	b29b      	uxth	r3, r3
 8013d86:	461a      	mov	r2, r3
 8013d88:	4b43      	ldr	r3, [pc, #268]	; (8013e98 <Custom_STM_Event_Handler+0x198>)
 8013d8a:	889b      	ldrh	r3, [r3, #4]
 8013d8c:	3301      	adds	r3, #1
 8013d8e:	429a      	cmp	r2, r3
 8013d90:	d10d      	bne.n	8013dae <Custom_STM_Event_Handler+0xae>
        		sys.rf.processSecondCharWrite(attribute_modified->Attr_Data, attribute_modified->Attr_Data_Length);
 8013d92:	4b42      	ldr	r3, [pc, #264]	; (8013e9c <Custom_STM_Event_Handler+0x19c>)
 8013d94:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 8013d98:	3358      	adds	r3, #88	; 0x58
 8013d9a:	681b      	ldr	r3, [r3, #0]
 8013d9c:	68ba      	ldr	r2, [r7, #8]
 8013d9e:	f102 0008 	add.w	r0, r2, #8
 8013da2:	68ba      	ldr	r2, [r7, #8]
 8013da4:	88d2      	ldrh	r2, [r2, #6]
 8013da6:	b292      	uxth	r2, r2
 8013da8:	4611      	mov	r1, r2
 8013daa:	4798      	blx	r3
          break;
 8013dac:	e06c      	b.n	8013e88 <Custom_STM_Event_Handler+0x188>
        	else if (attribute_modified->Attr_Handle == (CustomContext.CustomMcu_P_CpsHdle + 2)) // characteristic 3 notification handle mcu_p_cps
 8013dae:	68bb      	ldr	r3, [r7, #8]
 8013db0:	885b      	ldrh	r3, [r3, #2]
 8013db2:	b29b      	uxth	r3, r3
 8013db4:	461a      	mov	r2, r3
 8013db6:	4b38      	ldr	r3, [pc, #224]	; (8013e98 <Custom_STM_Event_Handler+0x198>)
 8013db8:	88db      	ldrh	r3, [r3, #6]
 8013dba:	3302      	adds	r3, #2
 8013dbc:	429a      	cmp	r2, r3
 8013dbe:	d119      	bne.n	8013df4 <Custom_STM_Event_Handler+0xf4>
        		return_value = SVCCTL_EvtAckFlowEnable;
 8013dc0:	2301      	movs	r3, #1
 8013dc2:	75fb      	strb	r3, [r7, #23]
        		if (attribute_modified->Attr_Data[0] & COMSVC_Notification) // if notification enabled
 8013dc4:	68bb      	ldr	r3, [r7, #8]
 8013dc6:	7a1b      	ldrb	r3, [r3, #8]
 8013dc8:	f003 0301 	and.w	r3, r3, #1
 8013dcc:	2b00      	cmp	r3, #0
 8013dce:	d008      	beq.n	8013de2 <Custom_STM_Event_Handler+0xe2>
        			sys.rf.processNotification(0, 1);
 8013dd0:	4b32      	ldr	r3, [pc, #200]	; (8013e9c <Custom_STM_Event_Handler+0x19c>)
 8013dd2:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 8013dd6:	335c      	adds	r3, #92	; 0x5c
 8013dd8:	681b      	ldr	r3, [r3, #0]
 8013dda:	2101      	movs	r1, #1
 8013ddc:	2000      	movs	r0, #0
 8013dde:	4798      	blx	r3
          break;
 8013de0:	e052      	b.n	8013e88 <Custom_STM_Event_Handler+0x188>
        			sys.rf.processNotification(0, 0);
 8013de2:	4b2e      	ldr	r3, [pc, #184]	; (8013e9c <Custom_STM_Event_Handler+0x19c>)
 8013de4:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 8013de8:	335c      	adds	r3, #92	; 0x5c
 8013dea:	681b      	ldr	r3, [r3, #0]
 8013dec:	2100      	movs	r1, #0
 8013dee:	2000      	movs	r0, #0
 8013df0:	4798      	blx	r3
          break;
 8013df2:	e049      	b.n	8013e88 <Custom_STM_Event_Handler+0x188>
        	else if (attribute_modified->Attr_Handle == (CustomContext.CustomMcu_P_DataHdle + 2)) // characteristic 4 notification handle mcu_p_data
 8013df4:	68bb      	ldr	r3, [r7, #8]
 8013df6:	885b      	ldrh	r3, [r3, #2]
 8013df8:	b29b      	uxth	r3, r3
 8013dfa:	461a      	mov	r2, r3
 8013dfc:	4b26      	ldr	r3, [pc, #152]	; (8013e98 <Custom_STM_Event_Handler+0x198>)
 8013dfe:	891b      	ldrh	r3, [r3, #8]
 8013e00:	3302      	adds	r3, #2
 8013e02:	429a      	cmp	r2, r3
 8013e04:	d119      	bne.n	8013e3a <Custom_STM_Event_Handler+0x13a>
        		return_value = SVCCTL_EvtAckFlowEnable;
 8013e06:	2301      	movs	r3, #1
 8013e08:	75fb      	strb	r3, [r7, #23]
        		if (attribute_modified->Attr_Data[0] & COMSVC_Notification) // if notification enabled
 8013e0a:	68bb      	ldr	r3, [r7, #8]
 8013e0c:	7a1b      	ldrb	r3, [r3, #8]
 8013e0e:	f003 0301 	and.w	r3, r3, #1
 8013e12:	2b00      	cmp	r3, #0
 8013e14:	d008      	beq.n	8013e28 <Custom_STM_Event_Handler+0x128>
        			sys.rf.processNotification(1, 1);
 8013e16:	4b21      	ldr	r3, [pc, #132]	; (8013e9c <Custom_STM_Event_Handler+0x19c>)
 8013e18:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 8013e1c:	335c      	adds	r3, #92	; 0x5c
 8013e1e:	681b      	ldr	r3, [r3, #0]
 8013e20:	2101      	movs	r1, #1
 8013e22:	2001      	movs	r0, #1
 8013e24:	4798      	blx	r3
          break;
 8013e26:	e02f      	b.n	8013e88 <Custom_STM_Event_Handler+0x188>
        			sys.rf.processNotification(1, 0);
 8013e28:	4b1c      	ldr	r3, [pc, #112]	; (8013e9c <Custom_STM_Event_Handler+0x19c>)
 8013e2a:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 8013e2e:	335c      	adds	r3, #92	; 0x5c
 8013e30:	681b      	ldr	r3, [r3, #0]
 8013e32:	2100      	movs	r1, #0
 8013e34:	2001      	movs	r0, #1
 8013e36:	4798      	blx	r3
          break;
 8013e38:	e026      	b.n	8013e88 <Custom_STM_Event_Handler+0x188>
        	else if (attribute_modified->Attr_Handle == (CustomContext.CustomMcu_P_SpcbHdle + 2)) // characteristic 5 notification handle mdu_p_spcb
 8013e3a:	68bb      	ldr	r3, [r7, #8]
 8013e3c:	885b      	ldrh	r3, [r3, #2]
 8013e3e:	b29b      	uxth	r3, r3
 8013e40:	461a      	mov	r2, r3
 8013e42:	4b15      	ldr	r3, [pc, #84]	; (8013e98 <Custom_STM_Event_Handler+0x198>)
 8013e44:	895b      	ldrh	r3, [r3, #10]
 8013e46:	3302      	adds	r3, #2
 8013e48:	429a      	cmp	r2, r3
 8013e4a:	d11d      	bne.n	8013e88 <Custom_STM_Event_Handler+0x188>
        		return_value = SVCCTL_EvtAckFlowEnable;
 8013e4c:	2301      	movs	r3, #1
 8013e4e:	75fb      	strb	r3, [r7, #23]
        		if (attribute_modified->Attr_Data[0] & COMSVC_Notification) // if notification enabled
 8013e50:	68bb      	ldr	r3, [r7, #8]
 8013e52:	7a1b      	ldrb	r3, [r3, #8]
 8013e54:	f003 0301 	and.w	r3, r3, #1
 8013e58:	2b00      	cmp	r3, #0
 8013e5a:	d008      	beq.n	8013e6e <Custom_STM_Event_Handler+0x16e>
        			sys.rf.processNotification(2, 1);
 8013e5c:	4b0f      	ldr	r3, [pc, #60]	; (8013e9c <Custom_STM_Event_Handler+0x19c>)
 8013e5e:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 8013e62:	335c      	adds	r3, #92	; 0x5c
 8013e64:	681b      	ldr	r3, [r3, #0]
 8013e66:	2101      	movs	r1, #1
 8013e68:	2002      	movs	r0, #2
 8013e6a:	4798      	blx	r3
          break;
 8013e6c:	e00c      	b.n	8013e88 <Custom_STM_Event_Handler+0x188>
        			sys.rf.processNotification(2, 0);
 8013e6e:	4b0b      	ldr	r3, [pc, #44]	; (8013e9c <Custom_STM_Event_Handler+0x19c>)
 8013e70:	f503 4386 	add.w	r3, r3, #17152	; 0x4300
 8013e74:	335c      	adds	r3, #92	; 0x5c
 8013e76:	681b      	ldr	r3, [r3, #0]
 8013e78:	2100      	movs	r1, #0
 8013e7a:	2002      	movs	r0, #2
 8013e7c:	4798      	blx	r3
          break;
 8013e7e:	e003      	b.n	8013e88 <Custom_STM_Event_Handler+0x188>
          break;
 8013e80:	bf00      	nop
 8013e82:	e004      	b.n	8013e8e <Custom_STM_Event_Handler+0x18e>

        default:
          /* USER CODE BEGIN EVT_DEFAULT */

          /* USER CODE END EVT_DEFAULT */
          break;
 8013e84:	bf00      	nop
 8013e86:	e002      	b.n	8013e8e <Custom_STM_Event_Handler+0x18e>
          break;
 8013e88:	bf00      	nop
      }
      /* USER CODE BEGIN EVT_VENDOR*/

      /* USER CODE END EVT_VENDOR*/
      break; /* EVT_VENDOR */
 8013e8a:	e000      	b.n	8013e8e <Custom_STM_Event_Handler+0x18e>
    /* USER CODE BEGIN EVENT_PCKT_CASES*/

    /* USER CODE END EVENT_PCKT_CASES*/

    default:
      break;
 8013e8c:	bf00      	nop

/* USER CODE BEGIN Custom_STM_Event_Handler_2 */

/* USER CODE END Custom_STM_Event_Handler_2 */

  return(return_value);
 8013e8e:	7dfb      	ldrb	r3, [r7, #23]
}/* end Custom_STM_Event_Handler */
 8013e90:	4618      	mov	r0, r3
 8013e92:	3718      	adds	r7, #24
 8013e94:	46bd      	mov	sp, r7
 8013e96:	bd80      	pop	{r7, pc}
 8013e98:	200000fc 	.word	0x200000fc
 8013e9c:	20001020 	.word	0x20001020

08013ea0 <SVCCTL_InitCustomSvc>:
 * @brief  Service initialization
 * @param  None
 * @retval None
 */
void SVCCTL_InitCustomSvc(void)
{
 8013ea0:	b580      	push	{r7, lr}
 8013ea2:	b08a      	sub	sp, #40	; 0x28
 8013ea4:	af06      	add	r7, sp, #24
/* USER CODE END SVCCTL_InitCustomSvc_1 */

  /**
   *	Register the event handler to the BLE controller
   */
  SVCCTL_RegisterSvcHandler(Custom_STM_Event_Handler);
 8013ea6:	4899      	ldr	r0, [pc, #612]	; (801410c <SVCCTL_InitCustomSvc+0x26c>)
 8013ea8:	f7fe fd94 	bl	80129d4 <SVCCTL_RegisterSvcHandler>
     *                                1 for MCU_to_phone_data_char configuration descriptor +
     *                                1 for MCU_to_phone_cpcb_char configuration descriptor +
     *                              = 14
     */

    COPY_MAINMCUSERVICE_UUID(uuid.Char_UUID_128);
 8013eac:	238f      	movs	r3, #143	; 0x8f
 8013eae:	703b      	strb	r3, [r7, #0]
 8013eb0:	23e5      	movs	r3, #229	; 0xe5
 8013eb2:	707b      	strb	r3, [r7, #1]
 8013eb4:	23b3      	movs	r3, #179	; 0xb3
 8013eb6:	70bb      	strb	r3, [r7, #2]
 8013eb8:	23d5      	movs	r3, #213	; 0xd5
 8013eba:	70fb      	strb	r3, [r7, #3]
 8013ebc:	232e      	movs	r3, #46	; 0x2e
 8013ebe:	713b      	strb	r3, [r7, #4]
 8013ec0:	237f      	movs	r3, #127	; 0x7f
 8013ec2:	717b      	strb	r3, [r7, #5]
 8013ec4:	234a      	movs	r3, #74	; 0x4a
 8013ec6:	71bb      	strb	r3, [r7, #6]
 8013ec8:	2398      	movs	r3, #152	; 0x98
 8013eca:	71fb      	strb	r3, [r7, #7]
 8013ecc:	232a      	movs	r3, #42	; 0x2a
 8013ece:	723b      	strb	r3, [r7, #8]
 8013ed0:	2348      	movs	r3, #72	; 0x48
 8013ed2:	727b      	strb	r3, [r7, #9]
 8013ed4:	237a      	movs	r3, #122	; 0x7a
 8013ed6:	72bb      	strb	r3, [r7, #10]
 8013ed8:	23cc      	movs	r3, #204	; 0xcc
 8013eda:	72fb      	strb	r3, [r7, #11]
 8013edc:	2301      	movs	r3, #1
 8013ede:	733b      	strb	r3, [r7, #12]
 8013ee0:	23ad      	movs	r3, #173	; 0xad
 8013ee2:	737b      	strb	r3, [r7, #13]
 8013ee4:	2300      	movs	r3, #0
 8013ee6:	73bb      	strb	r3, [r7, #14]
 8013ee8:	2300      	movs	r3, #0
 8013eea:	73fb      	strb	r3, [r7, #15]
    aci_gatt_add_service(UUID_TYPE_128,
 8013eec:	4639      	mov	r1, r7
 8013eee:	4b88      	ldr	r3, [pc, #544]	; (8014110 <SVCCTL_InitCustomSvc+0x270>)
 8013ef0:	9300      	str	r3, [sp, #0]
 8013ef2:	230e      	movs	r3, #14
 8013ef4:	2201      	movs	r2, #1
 8013ef6:	2002      	movs	r0, #2
 8013ef8:	f7fe f8f9 	bl	80120ee <aci_gatt_add_service>
                      &(CustomContext.CustomMmcuserHdle));

    /**
     *  Phone_to_mcu_command_char
     */
    COPY_PHONE_TO_MCU_COMMAND_CHAR_UUID(uuid.Char_UUID_128);
 8013efc:	2319      	movs	r3, #25
 8013efe:	703b      	strb	r3, [r7, #0]
 8013f00:	23ed      	movs	r3, #237	; 0xed
 8013f02:	707b      	strb	r3, [r7, #1]
 8013f04:	2382      	movs	r3, #130	; 0x82
 8013f06:	70bb      	strb	r3, [r7, #2]
 8013f08:	23ae      	movs	r3, #174	; 0xae
 8013f0a:	70fb      	strb	r3, [r7, #3]
 8013f0c:	23ed      	movs	r3, #237	; 0xed
 8013f0e:	713b      	strb	r3, [r7, #4]
 8013f10:	2321      	movs	r3, #33	; 0x21
 8013f12:	717b      	strb	r3, [r7, #5]
 8013f14:	234c      	movs	r3, #76	; 0x4c
 8013f16:	71bb      	strb	r3, [r7, #6]
 8013f18:	239d      	movs	r3, #157	; 0x9d
 8013f1a:	71fb      	strb	r3, [r7, #7]
 8013f1c:	2341      	movs	r3, #65	; 0x41
 8013f1e:	723b      	strb	r3, [r7, #8]
 8013f20:	2345      	movs	r3, #69	; 0x45
 8013f22:	727b      	strb	r3, [r7, #9]
 8013f24:	2322      	movs	r3, #34	; 0x22
 8013f26:	72bb      	strb	r3, [r7, #10]
 8013f28:	238e      	movs	r3, #142	; 0x8e
 8013f2a:	72fb      	strb	r3, [r7, #11]
 8013f2c:	2302      	movs	r3, #2
 8013f2e:	733b      	strb	r3, [r7, #12]
 8013f30:	23ad      	movs	r3, #173	; 0xad
 8013f32:	737b      	strb	r3, [r7, #13]
 8013f34:	2300      	movs	r3, #0
 8013f36:	73bb      	strb	r3, [r7, #14]
 8013f38:	2300      	movs	r3, #0
 8013f3a:	73fb      	strb	r3, [r7, #15]
    aci_gatt_add_char(CustomContext.CustomMmcuserHdle,
 8013f3c:	4b74      	ldr	r3, [pc, #464]	; (8014110 <SVCCTL_InitCustomSvc+0x270>)
 8013f3e:	8818      	ldrh	r0, [r3, #0]
 8013f40:	2314      	movs	r3, #20
 8013f42:	b29b      	uxth	r3, r3
 8013f44:	463a      	mov	r2, r7
 8013f46:	4973      	ldr	r1, [pc, #460]	; (8014114 <SVCCTL_InitCustomSvc+0x274>)
 8013f48:	9105      	str	r1, [sp, #20]
 8013f4a:	2100      	movs	r1, #0
 8013f4c:	9104      	str	r1, [sp, #16]
 8013f4e:	2110      	movs	r1, #16
 8013f50:	9103      	str	r1, [sp, #12]
 8013f52:	2101      	movs	r1, #1
 8013f54:	9102      	str	r1, [sp, #8]
 8013f56:	2100      	movs	r1, #0
 8013f58:	9101      	str	r1, [sp, #4]
 8013f5a:	2104      	movs	r1, #4
 8013f5c:	9100      	str	r1, [sp, #0]
 8013f5e:	2102      	movs	r1, #2
 8013f60:	f7fe f974 	bl	801224c <aci_gatt_add_char>
                      CHAR_VALUE_LEN_CONSTANT,
                      &(CustomContext.CustomP_Mcu_CmdHdle));
    /**
     *  Phone_to_mcu_data_char
     */
    COPY_PHONE_TO_MCU_DATA_CHAR_UUID(uuid.Char_UUID_128);
 8013f64:	2319      	movs	r3, #25
 8013f66:	703b      	strb	r3, [r7, #0]
 8013f68:	23ed      	movs	r3, #237	; 0xed
 8013f6a:	707b      	strb	r3, [r7, #1]
 8013f6c:	2382      	movs	r3, #130	; 0x82
 8013f6e:	70bb      	strb	r3, [r7, #2]
 8013f70:	23ae      	movs	r3, #174	; 0xae
 8013f72:	70fb      	strb	r3, [r7, #3]
 8013f74:	23ed      	movs	r3, #237	; 0xed
 8013f76:	713b      	strb	r3, [r7, #4]
 8013f78:	2321      	movs	r3, #33	; 0x21
 8013f7a:	717b      	strb	r3, [r7, #5]
 8013f7c:	234c      	movs	r3, #76	; 0x4c
 8013f7e:	71bb      	strb	r3, [r7, #6]
 8013f80:	239d      	movs	r3, #157	; 0x9d
 8013f82:	71fb      	strb	r3, [r7, #7]
 8013f84:	2341      	movs	r3, #65	; 0x41
 8013f86:	723b      	strb	r3, [r7, #8]
 8013f88:	2345      	movs	r3, #69	; 0x45
 8013f8a:	727b      	strb	r3, [r7, #9]
 8013f8c:	2322      	movs	r3, #34	; 0x22
 8013f8e:	72bb      	strb	r3, [r7, #10]
 8013f90:	238e      	movs	r3, #142	; 0x8e
 8013f92:	72fb      	strb	r3, [r7, #11]
 8013f94:	2303      	movs	r3, #3
 8013f96:	733b      	strb	r3, [r7, #12]
 8013f98:	23ad      	movs	r3, #173	; 0xad
 8013f9a:	737b      	strb	r3, [r7, #13]
 8013f9c:	2300      	movs	r3, #0
 8013f9e:	73bb      	strb	r3, [r7, #14]
 8013fa0:	2300      	movs	r3, #0
 8013fa2:	73fb      	strb	r3, [r7, #15]
    aci_gatt_add_char(CustomContext.CustomMmcuserHdle,
 8013fa4:	4b5a      	ldr	r3, [pc, #360]	; (8014110 <SVCCTL_InitCustomSvc+0x270>)
 8013fa6:	8818      	ldrh	r0, [r3, #0]
 8013fa8:	23f0      	movs	r3, #240	; 0xf0
 8013faa:	b29b      	uxth	r3, r3
 8013fac:	463a      	mov	r2, r7
 8013fae:	495a      	ldr	r1, [pc, #360]	; (8014118 <SVCCTL_InitCustomSvc+0x278>)
 8013fb0:	9105      	str	r1, [sp, #20]
 8013fb2:	2100      	movs	r1, #0
 8013fb4:	9104      	str	r1, [sp, #16]
 8013fb6:	2110      	movs	r1, #16
 8013fb8:	9103      	str	r1, [sp, #12]
 8013fba:	2101      	movs	r1, #1
 8013fbc:	9102      	str	r1, [sp, #8]
 8013fbe:	2100      	movs	r1, #0
 8013fc0:	9101      	str	r1, [sp, #4]
 8013fc2:	2106      	movs	r1, #6
 8013fc4:	9100      	str	r1, [sp, #0]
 8013fc6:	2102      	movs	r1, #2
 8013fc8:	f7fe f940 	bl	801224c <aci_gatt_add_char>
                      CHAR_VALUE_LEN_CONSTANT,
                      &(CustomContext.CustomP_Mcu_DataHdle));
    /**
     *  MCU_to_phone_CPS_char
     */
    COPY_MCU_TO_PHONE_CPS_CHAR_UUID(uuid.Char_UUID_128);
 8013fcc:	2319      	movs	r3, #25
 8013fce:	703b      	strb	r3, [r7, #0]
 8013fd0:	23ed      	movs	r3, #237	; 0xed
 8013fd2:	707b      	strb	r3, [r7, #1]
 8013fd4:	2382      	movs	r3, #130	; 0x82
 8013fd6:	70bb      	strb	r3, [r7, #2]
 8013fd8:	23ae      	movs	r3, #174	; 0xae
 8013fda:	70fb      	strb	r3, [r7, #3]
 8013fdc:	23ed      	movs	r3, #237	; 0xed
 8013fde:	713b      	strb	r3, [r7, #4]
 8013fe0:	2321      	movs	r3, #33	; 0x21
 8013fe2:	717b      	strb	r3, [r7, #5]
 8013fe4:	234c      	movs	r3, #76	; 0x4c
 8013fe6:	71bb      	strb	r3, [r7, #6]
 8013fe8:	239d      	movs	r3, #157	; 0x9d
 8013fea:	71fb      	strb	r3, [r7, #7]
 8013fec:	2341      	movs	r3, #65	; 0x41
 8013fee:	723b      	strb	r3, [r7, #8]
 8013ff0:	2345      	movs	r3, #69	; 0x45
 8013ff2:	727b      	strb	r3, [r7, #9]
 8013ff4:	2322      	movs	r3, #34	; 0x22
 8013ff6:	72bb      	strb	r3, [r7, #10]
 8013ff8:	238e      	movs	r3, #142	; 0x8e
 8013ffa:	72fb      	strb	r3, [r7, #11]
 8013ffc:	2304      	movs	r3, #4
 8013ffe:	733b      	strb	r3, [r7, #12]
 8014000:	23ad      	movs	r3, #173	; 0xad
 8014002:	737b      	strb	r3, [r7, #13]
 8014004:	2300      	movs	r3, #0
 8014006:	73bb      	strb	r3, [r7, #14]
 8014008:	2300      	movs	r3, #0
 801400a:	73fb      	strb	r3, [r7, #15]
    aci_gatt_add_char(CustomContext.CustomMmcuserHdle,
 801400c:	4b40      	ldr	r3, [pc, #256]	; (8014110 <SVCCTL_InitCustomSvc+0x270>)
 801400e:	8818      	ldrh	r0, [r3, #0]
 8014010:	2310      	movs	r3, #16
 8014012:	b29b      	uxth	r3, r3
 8014014:	463a      	mov	r2, r7
 8014016:	4941      	ldr	r1, [pc, #260]	; (801411c <SVCCTL_InitCustomSvc+0x27c>)
 8014018:	9105      	str	r1, [sp, #20]
 801401a:	2100      	movs	r1, #0
 801401c:	9104      	str	r1, [sp, #16]
 801401e:	2110      	movs	r1, #16
 8014020:	9103      	str	r1, [sp, #12]
 8014022:	2101      	movs	r1, #1
 8014024:	9102      	str	r1, [sp, #8]
 8014026:	2100      	movs	r1, #0
 8014028:	9101      	str	r1, [sp, #4]
 801402a:	2112      	movs	r1, #18
 801402c:	9100      	str	r1, [sp, #0]
 801402e:	2102      	movs	r1, #2
 8014030:	f7fe f90c 	bl	801224c <aci_gatt_add_char>
                      CHAR_VALUE_LEN_CONSTANT,
                      &(CustomContext.CustomMcu_P_CpsHdle));
    /**
     *  MCU_to_phone_data_char
     */
    COPY_MCU_TO_PHONE_DATA_CHAR_UUID(uuid.Char_UUID_128);
 8014034:	2319      	movs	r3, #25
 8014036:	703b      	strb	r3, [r7, #0]
 8014038:	23ed      	movs	r3, #237	; 0xed
 801403a:	707b      	strb	r3, [r7, #1]
 801403c:	2382      	movs	r3, #130	; 0x82
 801403e:	70bb      	strb	r3, [r7, #2]
 8014040:	23ae      	movs	r3, #174	; 0xae
 8014042:	70fb      	strb	r3, [r7, #3]
 8014044:	23ed      	movs	r3, #237	; 0xed
 8014046:	713b      	strb	r3, [r7, #4]
 8014048:	2321      	movs	r3, #33	; 0x21
 801404a:	717b      	strb	r3, [r7, #5]
 801404c:	234c      	movs	r3, #76	; 0x4c
 801404e:	71bb      	strb	r3, [r7, #6]
 8014050:	239d      	movs	r3, #157	; 0x9d
 8014052:	71fb      	strb	r3, [r7, #7]
 8014054:	2341      	movs	r3, #65	; 0x41
 8014056:	723b      	strb	r3, [r7, #8]
 8014058:	2345      	movs	r3, #69	; 0x45
 801405a:	727b      	strb	r3, [r7, #9]
 801405c:	2322      	movs	r3, #34	; 0x22
 801405e:	72bb      	strb	r3, [r7, #10]
 8014060:	238e      	movs	r3, #142	; 0x8e
 8014062:	72fb      	strb	r3, [r7, #11]
 8014064:	2305      	movs	r3, #5
 8014066:	733b      	strb	r3, [r7, #12]
 8014068:	23ad      	movs	r3, #173	; 0xad
 801406a:	737b      	strb	r3, [r7, #13]
 801406c:	2300      	movs	r3, #0
 801406e:	73bb      	strb	r3, [r7, #14]
 8014070:	2300      	movs	r3, #0
 8014072:	73fb      	strb	r3, [r7, #15]
    aci_gatt_add_char(CustomContext.CustomMmcuserHdle,
 8014074:	4b26      	ldr	r3, [pc, #152]	; (8014110 <SVCCTL_InitCustomSvc+0x270>)
 8014076:	8818      	ldrh	r0, [r3, #0]
 8014078:	23f0      	movs	r3, #240	; 0xf0
 801407a:	b29b      	uxth	r3, r3
 801407c:	463a      	mov	r2, r7
 801407e:	4928      	ldr	r1, [pc, #160]	; (8014120 <SVCCTL_InitCustomSvc+0x280>)
 8014080:	9105      	str	r1, [sp, #20]
 8014082:	2100      	movs	r1, #0
 8014084:	9104      	str	r1, [sp, #16]
 8014086:	2110      	movs	r1, #16
 8014088:	9103      	str	r1, [sp, #12]
 801408a:	2101      	movs	r1, #1
 801408c:	9102      	str	r1, [sp, #8]
 801408e:	2100      	movs	r1, #0
 8014090:	9101      	str	r1, [sp, #4]
 8014092:	2112      	movs	r1, #18
 8014094:	9100      	str	r1, [sp, #0]
 8014096:	2102      	movs	r1, #2
 8014098:	f7fe f8d8 	bl	801224c <aci_gatt_add_char>
                      CHAR_VALUE_LEN_CONSTANT,
                      &(CustomContext.CustomMcu_P_DataHdle));
    /**
     *  MCU_to_phone_cpcb_char
     */
    COPY_MCU_TO_PHONE_CPCB_CHAR_UUID(uuid.Char_UUID_128);
 801409c:	2319      	movs	r3, #25
 801409e:	703b      	strb	r3, [r7, #0]
 80140a0:	23ed      	movs	r3, #237	; 0xed
 80140a2:	707b      	strb	r3, [r7, #1]
 80140a4:	2382      	movs	r3, #130	; 0x82
 80140a6:	70bb      	strb	r3, [r7, #2]
 80140a8:	23ae      	movs	r3, #174	; 0xae
 80140aa:	70fb      	strb	r3, [r7, #3]
 80140ac:	23ed      	movs	r3, #237	; 0xed
 80140ae:	713b      	strb	r3, [r7, #4]
 80140b0:	2321      	movs	r3, #33	; 0x21
 80140b2:	717b      	strb	r3, [r7, #5]
 80140b4:	234c      	movs	r3, #76	; 0x4c
 80140b6:	71bb      	strb	r3, [r7, #6]
 80140b8:	239d      	movs	r3, #157	; 0x9d
 80140ba:	71fb      	strb	r3, [r7, #7]
 80140bc:	2341      	movs	r3, #65	; 0x41
 80140be:	723b      	strb	r3, [r7, #8]
 80140c0:	2345      	movs	r3, #69	; 0x45
 80140c2:	727b      	strb	r3, [r7, #9]
 80140c4:	2322      	movs	r3, #34	; 0x22
 80140c6:	72bb      	strb	r3, [r7, #10]
 80140c8:	238e      	movs	r3, #142	; 0x8e
 80140ca:	72fb      	strb	r3, [r7, #11]
 80140cc:	2306      	movs	r3, #6
 80140ce:	733b      	strb	r3, [r7, #12]
 80140d0:	23ad      	movs	r3, #173	; 0xad
 80140d2:	737b      	strb	r3, [r7, #13]
 80140d4:	2300      	movs	r3, #0
 80140d6:	73bb      	strb	r3, [r7, #14]
 80140d8:	2300      	movs	r3, #0
 80140da:	73fb      	strb	r3, [r7, #15]
    aci_gatt_add_char(CustomContext.CustomMmcuserHdle,
 80140dc:	4b0c      	ldr	r3, [pc, #48]	; (8014110 <SVCCTL_InitCustomSvc+0x270>)
 80140de:	8818      	ldrh	r0, [r3, #0]
 80140e0:	2314      	movs	r3, #20
 80140e2:	b29b      	uxth	r3, r3
 80140e4:	463a      	mov	r2, r7
 80140e6:	490f      	ldr	r1, [pc, #60]	; (8014124 <SVCCTL_InitCustomSvc+0x284>)
 80140e8:	9105      	str	r1, [sp, #20]
 80140ea:	2100      	movs	r1, #0
 80140ec:	9104      	str	r1, [sp, #16]
 80140ee:	2110      	movs	r1, #16
 80140f0:	9103      	str	r1, [sp, #12]
 80140f2:	2101      	movs	r1, #1
 80140f4:	9102      	str	r1, [sp, #8]
 80140f6:	2100      	movs	r1, #0
 80140f8:	9101      	str	r1, [sp, #4]
 80140fa:	2112      	movs	r1, #18
 80140fc:	9100      	str	r1, [sp, #0]
 80140fe:	2102      	movs	r1, #2
 8014100:	f7fe f8a4 	bl	801224c <aci_gatt_add_char>

/* USER CODE BEGIN SVCCTL_InitCustomSvc_2 */

/* USER CODE END SVCCTL_InitCustomSvc_2 */

  return;
 8014104:	bf00      	nop
}
 8014106:	3710      	adds	r7, #16
 8014108:	46bd      	mov	sp, r7
 801410a:	bd80      	pop	{r7, pc}
 801410c:	08013d01 	.word	0x08013d01
 8014110:	200000fc 	.word	0x200000fc
 8014114:	200000fe 	.word	0x200000fe
 8014118:	20000100 	.word	0x20000100
 801411c:	20000102 	.word	0x20000102
 8014120:	20000104 	.word	0x20000104
 8014124:	20000106 	.word	0x20000106

08014128 <Custom_STM_App_Update_Char>:
 * @param  CharOpcode: Characteristic identifier
 * @param  Service_Instance: Instance of the service to which the characteristic belongs
 *
 */
tBleStatus Custom_STM_App_Update_Char(Custom_STM_Char_Opcode_t CharOpcode, uint8_t *pPayload)
{
 8014128:	b580      	push	{r7, lr}
 801412a:	b086      	sub	sp, #24
 801412c:	af02      	add	r7, sp, #8
 801412e:	4603      	mov	r3, r0
 8014130:	6039      	str	r1, [r7, #0]
 8014132:	71fb      	strb	r3, [r7, #7]
  tBleStatus result = BLE_STATUS_INVALID_PARAMS;
 8014134:	2342      	movs	r3, #66	; 0x42
 8014136:	73fb      	strb	r3, [r7, #15]
/* USER CODE BEGIN Custom_STM_App_Update_Char_1 */

/* USER CODE END Custom_STM_App_Update_Char_1 */

  switch(CharOpcode)
 8014138:	79fb      	ldrb	r3, [r7, #7]
 801413a:	2b04      	cmp	r3, #4
 801413c:	d852      	bhi.n	80141e4 <Custom_STM_App_Update_Char+0xbc>
 801413e:	a201      	add	r2, pc, #4	; (adr r2, 8014144 <Custom_STM_App_Update_Char+0x1c>)
 8014140:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014144:	08014159 	.word	0x08014159
 8014148:	08014175 	.word	0x08014175
 801414c:	08014191 	.word	0x08014191
 8014150:	080141ad 	.word	0x080141ad
 8014154:	080141c9 	.word	0x080141c9
  {

    case CUSTOM_STM_P_MCU_CMD:
      result = aci_gatt_update_char_value(CustomContext.CustomMmcuserHdle,
 8014158:	4b25      	ldr	r3, [pc, #148]	; (80141f0 <Custom_STM_App_Update_Char+0xc8>)
 801415a:	8818      	ldrh	r0, [r3, #0]
 801415c:	4b24      	ldr	r3, [pc, #144]	; (80141f0 <Custom_STM_App_Update_Char+0xc8>)
 801415e:	8859      	ldrh	r1, [r3, #2]
 8014160:	2214      	movs	r2, #20
 8014162:	683b      	ldr	r3, [r7, #0]
 8014164:	9300      	str	r3, [sp, #0]
 8014166:	4613      	mov	r3, r2
 8014168:	2200      	movs	r2, #0
 801416a:	f7fe f959 	bl	8012420 <aci_gatt_update_char_value>
 801416e:	4603      	mov	r3, r0
 8014170:	73fb      	strb	r3, [r7, #15]
                            SizeP_Mcu_Cmd, /* charValueLen */
                            (uint8_t *)  pPayload);
    /* USER CODE BEGIN CUSTOM_STM_P_MCU_CMD*/

    /* USER CODE END CUSTOM_STM_P_MCU_CMD*/
      break;
 8014172:	e038      	b.n	80141e6 <Custom_STM_App_Update_Char+0xbe>

    case CUSTOM_STM_P_MCU_DATA:
      result = aci_gatt_update_char_value(CustomContext.CustomMmcuserHdle,
 8014174:	4b1e      	ldr	r3, [pc, #120]	; (80141f0 <Custom_STM_App_Update_Char+0xc8>)
 8014176:	8818      	ldrh	r0, [r3, #0]
 8014178:	4b1d      	ldr	r3, [pc, #116]	; (80141f0 <Custom_STM_App_Update_Char+0xc8>)
 801417a:	8899      	ldrh	r1, [r3, #4]
 801417c:	22f0      	movs	r2, #240	; 0xf0
 801417e:	683b      	ldr	r3, [r7, #0]
 8014180:	9300      	str	r3, [sp, #0]
 8014182:	4613      	mov	r3, r2
 8014184:	2200      	movs	r2, #0
 8014186:	f7fe f94b 	bl	8012420 <aci_gatt_update_char_value>
 801418a:	4603      	mov	r3, r0
 801418c:	73fb      	strb	r3, [r7, #15]
                            SizeP_Mcu_Data, /* charValueLen */
                            (uint8_t *)  pPayload);
    /* USER CODE BEGIN CUSTOM_STM_P_MCU_DATA*/

    /* USER CODE END CUSTOM_STM_P_MCU_DATA*/
      break;
 801418e:	e02a      	b.n	80141e6 <Custom_STM_App_Update_Char+0xbe>

    case CUSTOM_STM_MCU_P_CPS:
      result = aci_gatt_update_char_value(CustomContext.CustomMmcuserHdle,
 8014190:	4b17      	ldr	r3, [pc, #92]	; (80141f0 <Custom_STM_App_Update_Char+0xc8>)
 8014192:	8818      	ldrh	r0, [r3, #0]
 8014194:	4b16      	ldr	r3, [pc, #88]	; (80141f0 <Custom_STM_App_Update_Char+0xc8>)
 8014196:	88d9      	ldrh	r1, [r3, #6]
 8014198:	2210      	movs	r2, #16
 801419a:	683b      	ldr	r3, [r7, #0]
 801419c:	9300      	str	r3, [sp, #0]
 801419e:	4613      	mov	r3, r2
 80141a0:	2200      	movs	r2, #0
 80141a2:	f7fe f93d 	bl	8012420 <aci_gatt_update_char_value>
 80141a6:	4603      	mov	r3, r0
 80141a8:	73fb      	strb	r3, [r7, #15]
                            SizeMcu_P_Cps, /* charValueLen */
                            (uint8_t *)  pPayload);
    /* USER CODE BEGIN CUSTOM_STM_MCU_P_CPS*/

    /* USER CODE END CUSTOM_STM_MCU_P_CPS*/
      break;
 80141aa:	e01c      	b.n	80141e6 <Custom_STM_App_Update_Char+0xbe>

    case CUSTOM_STM_MCU_P_DATA:
      result = aci_gatt_update_char_value(CustomContext.CustomMmcuserHdle,
 80141ac:	4b10      	ldr	r3, [pc, #64]	; (80141f0 <Custom_STM_App_Update_Char+0xc8>)
 80141ae:	8818      	ldrh	r0, [r3, #0]
 80141b0:	4b0f      	ldr	r3, [pc, #60]	; (80141f0 <Custom_STM_App_Update_Char+0xc8>)
 80141b2:	8919      	ldrh	r1, [r3, #8]
 80141b4:	22f0      	movs	r2, #240	; 0xf0
 80141b6:	683b      	ldr	r3, [r7, #0]
 80141b8:	9300      	str	r3, [sp, #0]
 80141ba:	4613      	mov	r3, r2
 80141bc:	2200      	movs	r2, #0
 80141be:	f7fe f92f 	bl	8012420 <aci_gatt_update_char_value>
 80141c2:	4603      	mov	r3, r0
 80141c4:	73fb      	strb	r3, [r7, #15]
                            SizeMcu_P_Data, /* charValueLen */
                            (uint8_t *)  pPayload);
    /* USER CODE BEGIN CUSTOM_STM_MCU_P_DATA*/

    /* USER CODE END CUSTOM_STM_MCU_P_DATA*/
      break;
 80141c6:	e00e      	b.n	80141e6 <Custom_STM_App_Update_Char+0xbe>

    case CUSTOM_STM_MCU_P_SPCB:
      result = aci_gatt_update_char_value(CustomContext.CustomMmcuserHdle,
 80141c8:	4b09      	ldr	r3, [pc, #36]	; (80141f0 <Custom_STM_App_Update_Char+0xc8>)
 80141ca:	8818      	ldrh	r0, [r3, #0]
 80141cc:	4b08      	ldr	r3, [pc, #32]	; (80141f0 <Custom_STM_App_Update_Char+0xc8>)
 80141ce:	8959      	ldrh	r1, [r3, #10]
 80141d0:	2214      	movs	r2, #20
 80141d2:	683b      	ldr	r3, [r7, #0]
 80141d4:	9300      	str	r3, [sp, #0]
 80141d6:	4613      	mov	r3, r2
 80141d8:	2200      	movs	r2, #0
 80141da:	f7fe f921 	bl	8012420 <aci_gatt_update_char_value>
 80141de:	4603      	mov	r3, r0
 80141e0:	73fb      	strb	r3, [r7, #15]
                            SizeMcu_P_Spcb, /* charValueLen */
                            (uint8_t *)  pPayload);
    /* USER CODE BEGIN CUSTOM_STM_MCU_P_SPCB*/

    /* USER CODE END CUSTOM_STM_MCU_P_SPCB*/
      break;
 80141e2:	e000      	b.n	80141e6 <Custom_STM_App_Update_Char+0xbe>

    default:
      break;
 80141e4:	bf00      	nop

/* USER CODE BEGIN Custom_STM_App_Update_Char_2 */

/* USER CODE END Custom_STM_App_Update_Char_2 */

  return result;
 80141e6:	7bfb      	ldrb	r3, [r7, #15]
}
 80141e8:	4618      	mov	r0, r3
 80141ea:	3710      	adds	r7, #16
 80141ec:	46bd      	mov	sp, r7
 80141ee:	bd80      	pop	{r7, pc}
 80141f0:	200000fc 	.word	0x200000fc

080141f4 <LL_C2_EXTI_EnableEvent_32_63>:
{
 80141f4:	b480      	push	{r7}
 80141f6:	b083      	sub	sp, #12
 80141f8:	af00      	add	r7, sp, #0
 80141fa:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->C2EMR2, ExtiLine);
 80141fc:	4b06      	ldr	r3, [pc, #24]	; (8014218 <LL_C2_EXTI_EnableEvent_32_63+0x24>)
 80141fe:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 8014202:	4905      	ldr	r1, [pc, #20]	; (8014218 <LL_C2_EXTI_EnableEvent_32_63+0x24>)
 8014204:	687b      	ldr	r3, [r7, #4]
 8014206:	4313      	orrs	r3, r2
 8014208:	f8c1 30d4 	str.w	r3, [r1, #212]	; 0xd4
}
 801420c:	bf00      	nop
 801420e:	370c      	adds	r7, #12
 8014210:	46bd      	mov	sp, r7
 8014212:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014216:	4770      	bx	lr
 8014218:	58000800 	.word	0x58000800

0801421c <LL_EXTI_EnableRisingTrig_32_63>:
{
 801421c:	b480      	push	{r7}
 801421e:	b083      	sub	sp, #12
 8014220:	af00      	add	r7, sp, #0
 8014222:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->RTSR2, ExtiLine);
 8014224:	4b05      	ldr	r3, [pc, #20]	; (801423c <LL_EXTI_EnableRisingTrig_32_63+0x20>)
 8014226:	6a1a      	ldr	r2, [r3, #32]
 8014228:	4904      	ldr	r1, [pc, #16]	; (801423c <LL_EXTI_EnableRisingTrig_32_63+0x20>)
 801422a:	687b      	ldr	r3, [r7, #4]
 801422c:	4313      	orrs	r3, r2
 801422e:	620b      	str	r3, [r1, #32]
}
 8014230:	bf00      	nop
 8014232:	370c      	adds	r7, #12
 8014234:	46bd      	mov	sp, r7
 8014236:	f85d 7b04 	ldr.w	r7, [sp], #4
 801423a:	4770      	bx	lr
 801423c:	58000800 	.word	0x58000800

08014240 <LL_PWR_EnableBootC2>:
{
 8014240:	b480      	push	{r7}
 8014242:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR4, PWR_CR4_C2BOOT);
 8014244:	4b05      	ldr	r3, [pc, #20]	; (801425c <LL_PWR_EnableBootC2+0x1c>)
 8014246:	68db      	ldr	r3, [r3, #12]
 8014248:	4a04      	ldr	r2, [pc, #16]	; (801425c <LL_PWR_EnableBootC2+0x1c>)
 801424a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 801424e:	60d3      	str	r3, [r2, #12]
}
 8014250:	bf00      	nop
 8014252:	46bd      	mov	sp, r7
 8014254:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014258:	4770      	bx	lr
 801425a:	bf00      	nop
 801425c:	58000400 	.word	0x58000400

08014260 <LL_AHB3_GRP1_EnableClock>:
{
 8014260:	b480      	push	{r7}
 8014262:	b085      	sub	sp, #20
 8014264:	af00      	add	r7, sp, #0
 8014266:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB3ENR, Periphs);
 8014268:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801426c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801426e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8014272:	687b      	ldr	r3, [r7, #4]
 8014274:	4313      	orrs	r3, r2
 8014276:	650b      	str	r3, [r1, #80]	; 0x50
  tmpreg = READ_BIT(RCC->AHB3ENR, Periphs);
 8014278:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801427c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801427e:	687b      	ldr	r3, [r7, #4]
 8014280:	4013      	ands	r3, r2
 8014282:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8014284:	68fb      	ldr	r3, [r7, #12]
}
 8014286:	bf00      	nop
 8014288:	3714      	adds	r7, #20
 801428a:	46bd      	mov	sp, r7
 801428c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014290:	4770      	bx	lr

08014292 <LL_C2_AHB3_GRP1_EnableClock>:
  *         @arg @ref LL_C2_AHB3_GRP1_PERIPH_IPCC
  *         @arg @ref LL_C2_AHB3_GRP1_PERIPH_FLASH
  * @retval None
  */
__STATIC_INLINE void LL_C2_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
 8014292:	b480      	push	{r7}
 8014294:	b085      	sub	sp, #20
 8014296:	af00      	add	r7, sp, #0
 8014298:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->C2AHB3ENR, Periphs);
 801429a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 801429e:	f8d3 2150 	ldr.w	r2, [r3, #336]	; 0x150
 80142a2:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80142a6:	687b      	ldr	r3, [r7, #4]
 80142a8:	4313      	orrs	r3, r2
 80142aa:	f8c1 3150 	str.w	r3, [r1, #336]	; 0x150
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->C2AHB3ENR, Periphs);
 80142ae:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80142b2:	f8d3 2150 	ldr.w	r2, [r3, #336]	; 0x150
 80142b6:	687b      	ldr	r3, [r7, #4]
 80142b8:	4013      	ands	r3, r2
 80142ba:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 80142bc:	68fb      	ldr	r3, [r7, #12]
}
 80142be:	bf00      	nop
 80142c0:	3714      	adds	r7, #20
 80142c2:	46bd      	mov	sp, r7
 80142c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80142c8:	4770      	bx	lr

080142ca <LL_C1_IPCC_EnableIT_TXF>:
  * @rmtoll C1CR          TXFIE         LL_C1_IPCC_EnableIT_TXF
  * @param  IPCCx IPCC Instance.
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_EnableIT_TXF(IPCC_TypeDef *IPCCx)
{
 80142ca:	b480      	push	{r7}
 80142cc:	b083      	sub	sp, #12
 80142ce:	af00      	add	r7, sp, #0
 80142d0:	6078      	str	r0, [r7, #4]
  SET_BIT(IPCCx->C1CR, IPCC_C1CR_TXFIE);
 80142d2:	687b      	ldr	r3, [r7, #4]
 80142d4:	681b      	ldr	r3, [r3, #0]
 80142d6:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 80142da:	687b      	ldr	r3, [r7, #4]
 80142dc:	601a      	str	r2, [r3, #0]
}
 80142de:	bf00      	nop
 80142e0:	370c      	adds	r7, #12
 80142e2:	46bd      	mov	sp, r7
 80142e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80142e8:	4770      	bx	lr

080142ea <LL_C1_IPCC_EnableIT_RXO>:
  * @rmtoll C1CR          RXOIE         LL_C1_IPCC_EnableIT_RXO
  * @param  IPCCx IPCC Instance.
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_EnableIT_RXO(IPCC_TypeDef *IPCCx)
{
 80142ea:	b480      	push	{r7}
 80142ec:	b083      	sub	sp, #12
 80142ee:	af00      	add	r7, sp, #0
 80142f0:	6078      	str	r0, [r7, #4]
  SET_BIT(IPCCx->C1CR, IPCC_C1CR_RXOIE);
 80142f2:	687b      	ldr	r3, [r7, #4]
 80142f4:	681b      	ldr	r3, [r3, #0]
 80142f6:	f043 0201 	orr.w	r2, r3, #1
 80142fa:	687b      	ldr	r3, [r7, #4]
 80142fc:	601a      	str	r2, [r3, #0]
}
 80142fe:	bf00      	nop
 8014300:	370c      	adds	r7, #12
 8014302:	46bd      	mov	sp, r7
 8014304:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014308:	4770      	bx	lr

0801430a <LL_C1_IPCC_EnableTransmitChannel>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_EnableTransmitChannel(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 801430a:	b480      	push	{r7}
 801430c:	b083      	sub	sp, #12
 801430e:	af00      	add	r7, sp, #0
 8014310:	6078      	str	r0, [r7, #4]
 8014312:	6039      	str	r1, [r7, #0]
  CLEAR_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 8014314:	687b      	ldr	r3, [r7, #4]
 8014316:	685a      	ldr	r2, [r3, #4]
 8014318:	683b      	ldr	r3, [r7, #0]
 801431a:	041b      	lsls	r3, r3, #16
 801431c:	43db      	mvns	r3, r3
 801431e:	401a      	ands	r2, r3
 8014320:	687b      	ldr	r3, [r7, #4]
 8014322:	605a      	str	r2, [r3, #4]
}
 8014324:	bf00      	nop
 8014326:	370c      	adds	r7, #12
 8014328:	46bd      	mov	sp, r7
 801432a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801432e:	4770      	bx	lr

08014330 <LL_C1_IPCC_DisableTransmitChannel>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_DisableTransmitChannel(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 8014330:	b480      	push	{r7}
 8014332:	b083      	sub	sp, #12
 8014334:	af00      	add	r7, sp, #0
 8014336:	6078      	str	r0, [r7, #4]
 8014338:	6039      	str	r1, [r7, #0]
  SET_BIT(IPCCx->C1MR, Channel << IPCC_C1MR_CH1FM_Pos);
 801433a:	687b      	ldr	r3, [r7, #4]
 801433c:	685a      	ldr	r2, [r3, #4]
 801433e:	683b      	ldr	r3, [r7, #0]
 8014340:	041b      	lsls	r3, r3, #16
 8014342:	431a      	orrs	r2, r3
 8014344:	687b      	ldr	r3, [r7, #4]
 8014346:	605a      	str	r2, [r3, #4]
}
 8014348:	bf00      	nop
 801434a:	370c      	adds	r7, #12
 801434c:	46bd      	mov	sp, r7
 801434e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014352:	4770      	bx	lr

08014354 <LL_C1_IPCC_EnableReceiveChannel>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_EnableReceiveChannel(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 8014354:	b480      	push	{r7}
 8014356:	b083      	sub	sp, #12
 8014358:	af00      	add	r7, sp, #0
 801435a:	6078      	str	r0, [r7, #4]
 801435c:	6039      	str	r1, [r7, #0]
  CLEAR_BIT(IPCCx->C1MR, Channel);
 801435e:	687b      	ldr	r3, [r7, #4]
 8014360:	685a      	ldr	r2, [r3, #4]
 8014362:	683b      	ldr	r3, [r7, #0]
 8014364:	43db      	mvns	r3, r3
 8014366:	401a      	ands	r2, r3
 8014368:	687b      	ldr	r3, [r7, #4]
 801436a:	605a      	str	r2, [r3, #4]
}
 801436c:	bf00      	nop
 801436e:	370c      	adds	r7, #12
 8014370:	46bd      	mov	sp, r7
 8014372:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014376:	4770      	bx	lr

08014378 <LL_C1_IPCC_ClearFlag_CHx>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_ClearFlag_CHx(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 8014378:	b480      	push	{r7}
 801437a:	b083      	sub	sp, #12
 801437c:	af00      	add	r7, sp, #0
 801437e:	6078      	str	r0, [r7, #4]
 8014380:	6039      	str	r1, [r7, #0]
  WRITE_REG(IPCCx->C1SCR, Channel);
 8014382:	687b      	ldr	r3, [r7, #4]
 8014384:	683a      	ldr	r2, [r7, #0]
 8014386:	609a      	str	r2, [r3, #8]
}
 8014388:	bf00      	nop
 801438a:	370c      	adds	r7, #12
 801438c:	46bd      	mov	sp, r7
 801438e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014392:	4770      	bx	lr

08014394 <LL_C1_IPCC_SetFlag_CHx>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval None
  */
__STATIC_INLINE void LL_C1_IPCC_SetFlag_CHx(IPCC_TypeDef *IPCCx, uint32_t Channel)
{
 8014394:	b480      	push	{r7}
 8014396:	b083      	sub	sp, #12
 8014398:	af00      	add	r7, sp, #0
 801439a:	6078      	str	r0, [r7, #4]
 801439c:	6039      	str	r1, [r7, #0]
  WRITE_REG(IPCCx->C1SCR, Channel << IPCC_C1SCR_CH1S_Pos);
 801439e:	683b      	ldr	r3, [r7, #0]
 80143a0:	041a      	lsls	r2, r3, #16
 80143a2:	687b      	ldr	r3, [r7, #4]
 80143a4:	609a      	str	r2, [r3, #8]
}
 80143a6:	bf00      	nop
 80143a8:	370c      	adds	r7, #12
 80143aa:	46bd      	mov	sp, r7
 80143ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80143b0:	4770      	bx	lr

080143b2 <LL_C1_IPCC_IsActiveFlag_CHx>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_C1_IPCC_IsActiveFlag_CHx(IPCC_TypeDef  const *const IPCCx, uint32_t Channel)
{
 80143b2:	b480      	push	{r7}
 80143b4:	b083      	sub	sp, #12
 80143b6:	af00      	add	r7, sp, #0
 80143b8:	6078      	str	r0, [r7, #4]
 80143ba:	6039      	str	r1, [r7, #0]
  return ((READ_BIT(IPCCx->C1TOC2SR, Channel) == (Channel)) ? 1UL : 0UL);
 80143bc:	687b      	ldr	r3, [r7, #4]
 80143be:	68da      	ldr	r2, [r3, #12]
 80143c0:	683b      	ldr	r3, [r7, #0]
 80143c2:	4013      	ands	r3, r2
 80143c4:	683a      	ldr	r2, [r7, #0]
 80143c6:	429a      	cmp	r2, r3
 80143c8:	d101      	bne.n	80143ce <LL_C1_IPCC_IsActiveFlag_CHx+0x1c>
 80143ca:	2301      	movs	r3, #1
 80143cc:	e000      	b.n	80143d0 <LL_C1_IPCC_IsActiveFlag_CHx+0x1e>
 80143ce:	2300      	movs	r3, #0
}
 80143d0:	4618      	mov	r0, r3
 80143d2:	370c      	adds	r7, #12
 80143d4:	46bd      	mov	sp, r7
 80143d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80143da:	4770      	bx	lr

080143dc <LL_C2_IPCC_IsActiveFlag_CHx>:
  *         @arg @ref LL_IPCC_CHANNEL_5
  *         @arg @ref LL_IPCC_CHANNEL_6
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_C2_IPCC_IsActiveFlag_CHx(IPCC_TypeDef  const *const IPCCx, uint32_t Channel)
{
 80143dc:	b480      	push	{r7}
 80143de:	b083      	sub	sp, #12
 80143e0:	af00      	add	r7, sp, #0
 80143e2:	6078      	str	r0, [r7, #4]
 80143e4:	6039      	str	r1, [r7, #0]
  return ((READ_BIT(IPCCx->C2TOC1SR, Channel) == (Channel)) ? 1UL : 0UL);
 80143e6:	687b      	ldr	r3, [r7, #4]
 80143e8:	69da      	ldr	r2, [r3, #28]
 80143ea:	683b      	ldr	r3, [r7, #0]
 80143ec:	4013      	ands	r3, r2
 80143ee:	683a      	ldr	r2, [r7, #0]
 80143f0:	429a      	cmp	r2, r3
 80143f2:	d101      	bne.n	80143f8 <LL_C2_IPCC_IsActiveFlag_CHx+0x1c>
 80143f4:	2301      	movs	r3, #1
 80143f6:	e000      	b.n	80143fa <LL_C2_IPCC_IsActiveFlag_CHx+0x1e>
 80143f8:	2300      	movs	r3, #0
}
 80143fa:	4618      	mov	r0, r3
 80143fc:	370c      	adds	r7, #12
 80143fe:	46bd      	mov	sp, r7
 8014400:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014404:	4770      	bx	lr
	...

08014408 <HW_IPCC_Rx_Handler>:

/******************************************************************************
 * INTERRUPT HANDLER
 ******************************************************************************/
void HW_IPCC_Rx_Handler( void )
{
 8014408:	b580      	push	{r7, lr}
 801440a:	af00      	add	r7, sp, #0
  if (HW_IPCC_RX_PENDING( HW_IPCC_SYSTEM_EVENT_CHANNEL ))
 801440c:	2102      	movs	r1, #2
 801440e:	4819      	ldr	r0, [pc, #100]	; (8014474 <HW_IPCC_Rx_Handler+0x6c>)
 8014410:	f7ff ffe4 	bl	80143dc <LL_C2_IPCC_IsActiveFlag_CHx>
 8014414:	4603      	mov	r3, r0
 8014416:	2b00      	cmp	r3, #0
 8014418:	d009      	beq.n	801442e <HW_IPCC_Rx_Handler+0x26>
 801441a:	4b16      	ldr	r3, [pc, #88]	; (8014474 <HW_IPCC_Rx_Handler+0x6c>)
 801441c:	685b      	ldr	r3, [r3, #4]
 801441e:	43db      	mvns	r3, r3
 8014420:	f003 0302 	and.w	r3, r3, #2
 8014424:	2b00      	cmp	r3, #0
 8014426:	d002      	beq.n	801442e <HW_IPCC_Rx_Handler+0x26>
  {
      HW_IPCC_SYS_EvtHandler();
 8014428:	f000 f8ea 	bl	8014600 <HW_IPCC_SYS_EvtHandler>
 801442c:	e01f      	b.n	801446e <HW_IPCC_Rx_Handler+0x66>
  else if (HW_IPCC_RX_PENDING( HW_IPCC_ZIGBEE_M0_REQUEST_CHANNEL ))
  {
    HW_IPCC_ZIGBEE_StackM0RequestHandler();
  }
#endif /* ZIGBEE_WB */
  else if (HW_IPCC_RX_PENDING( HW_IPCC_BLE_EVENT_CHANNEL ))
 801442e:	2101      	movs	r1, #1
 8014430:	4810      	ldr	r0, [pc, #64]	; (8014474 <HW_IPCC_Rx_Handler+0x6c>)
 8014432:	f7ff ffd3 	bl	80143dc <LL_C2_IPCC_IsActiveFlag_CHx>
 8014436:	4603      	mov	r3, r0
 8014438:	2b00      	cmp	r3, #0
 801443a:	d008      	beq.n	801444e <HW_IPCC_Rx_Handler+0x46>
 801443c:	4b0d      	ldr	r3, [pc, #52]	; (8014474 <HW_IPCC_Rx_Handler+0x6c>)
 801443e:	685b      	ldr	r3, [r3, #4]
 8014440:	f003 0301 	and.w	r3, r3, #1
 8014444:	2b00      	cmp	r3, #0
 8014446:	d102      	bne.n	801444e <HW_IPCC_Rx_Handler+0x46>
  {
    HW_IPCC_BLE_EvtHandler();
 8014448:	f000 f89e 	bl	8014588 <HW_IPCC_BLE_EvtHandler>
 801444c:	e00f      	b.n	801446e <HW_IPCC_Rx_Handler+0x66>
  }
  else if (HW_IPCC_RX_PENDING( HW_IPCC_TRACES_CHANNEL ))
 801444e:	2108      	movs	r1, #8
 8014450:	4808      	ldr	r0, [pc, #32]	; (8014474 <HW_IPCC_Rx_Handler+0x6c>)
 8014452:	f7ff ffc3 	bl	80143dc <LL_C2_IPCC_IsActiveFlag_CHx>
 8014456:	4603      	mov	r3, r0
 8014458:	2b00      	cmp	r3, #0
 801445a:	d009      	beq.n	8014470 <HW_IPCC_Rx_Handler+0x68>
 801445c:	4b05      	ldr	r3, [pc, #20]	; (8014474 <HW_IPCC_Rx_Handler+0x6c>)
 801445e:	685b      	ldr	r3, [r3, #4]
 8014460:	43db      	mvns	r3, r3
 8014462:	f003 0308 	and.w	r3, r3, #8
 8014466:	2b00      	cmp	r3, #0
 8014468:	d002      	beq.n	8014470 <HW_IPCC_Rx_Handler+0x68>
  {
    HW_IPCC_TRACES_EvtHandler();
 801446a:	f000 f915 	bl	8014698 <HW_IPCC_TRACES_EvtHandler>
  }

  return;
 801446e:	bf00      	nop
 8014470:	bf00      	nop
}
 8014472:	bd80      	pop	{r7, pc}
 8014474:	58000c00 	.word	0x58000c00

08014478 <HW_IPCC_Tx_Handler>:

void HW_IPCC_Tx_Handler( void )
{
 8014478:	b580      	push	{r7, lr}
 801447a:	af00      	add	r7, sp, #0
  if (HW_IPCC_TX_PENDING( HW_IPCC_SYSTEM_CMD_RSP_CHANNEL ))
 801447c:	2102      	movs	r1, #2
 801447e:	4822      	ldr	r0, [pc, #136]	; (8014508 <HW_IPCC_Tx_Handler+0x90>)
 8014480:	f7ff ff97 	bl	80143b2 <LL_C1_IPCC_IsActiveFlag_CHx>
 8014484:	4603      	mov	r3, r0
 8014486:	2b00      	cmp	r3, #0
 8014488:	d109      	bne.n	801449e <HW_IPCC_Tx_Handler+0x26>
 801448a:	4b1f      	ldr	r3, [pc, #124]	; (8014508 <HW_IPCC_Tx_Handler+0x90>)
 801448c:	685b      	ldr	r3, [r3, #4]
 801448e:	43db      	mvns	r3, r3
 8014490:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8014494:	2b00      	cmp	r3, #0
 8014496:	d002      	beq.n	801449e <HW_IPCC_Tx_Handler+0x26>
  {
    HW_IPCC_SYS_CmdEvtHandler();
 8014498:	f000 f8a6 	bl	80145e8 <HW_IPCC_SYS_CmdEvtHandler>
 801449c:	e031      	b.n	8014502 <HW_IPCC_Tx_Handler+0x8a>
  if (HW_IPCC_TX_PENDING( HW_IPCC_ZIGBEE_CMD_APPLI_CHANNEL ))
  {
      HW_IPCC_ZIGBEE_CmdEvtHandler();
  }
#endif /* ZIGBEE_WB */
  else if (HW_IPCC_TX_PENDING( HW_IPCC_SYSTEM_CMD_RSP_CHANNEL ))
 801449e:	2102      	movs	r1, #2
 80144a0:	4819      	ldr	r0, [pc, #100]	; (8014508 <HW_IPCC_Tx_Handler+0x90>)
 80144a2:	f7ff ff86 	bl	80143b2 <LL_C1_IPCC_IsActiveFlag_CHx>
 80144a6:	4603      	mov	r3, r0
 80144a8:	2b00      	cmp	r3, #0
 80144aa:	d109      	bne.n	80144c0 <HW_IPCC_Tx_Handler+0x48>
 80144ac:	4b16      	ldr	r3, [pc, #88]	; (8014508 <HW_IPCC_Tx_Handler+0x90>)
 80144ae:	685b      	ldr	r3, [r3, #4]
 80144b0:	43db      	mvns	r3, r3
 80144b2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80144b6:	2b00      	cmp	r3, #0
 80144b8:	d002      	beq.n	80144c0 <HW_IPCC_Tx_Handler+0x48>
  {
    HW_IPCC_SYS_CmdEvtHandler();
 80144ba:	f000 f895 	bl	80145e8 <HW_IPCC_SYS_CmdEvtHandler>
 80144be:	e020      	b.n	8014502 <HW_IPCC_Tx_Handler+0x8a>
  }
  else if (HW_IPCC_TX_PENDING( HW_IPCC_MM_RELEASE_BUFFER_CHANNEL ))
 80144c0:	2108      	movs	r1, #8
 80144c2:	4811      	ldr	r0, [pc, #68]	; (8014508 <HW_IPCC_Tx_Handler+0x90>)
 80144c4:	f7ff ff75 	bl	80143b2 <LL_C1_IPCC_IsActiveFlag_CHx>
 80144c8:	4603      	mov	r3, r0
 80144ca:	2b00      	cmp	r3, #0
 80144cc:	d109      	bne.n	80144e2 <HW_IPCC_Tx_Handler+0x6a>
 80144ce:	4b0e      	ldr	r3, [pc, #56]	; (8014508 <HW_IPCC_Tx_Handler+0x90>)
 80144d0:	685b      	ldr	r3, [r3, #4]
 80144d2:	43db      	mvns	r3, r3
 80144d4:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 80144d8:	2b00      	cmp	r3, #0
 80144da:	d002      	beq.n	80144e2 <HW_IPCC_Tx_Handler+0x6a>
  {
    HW_IPCC_MM_FreeBufHandler();
 80144dc:	f000 f8be 	bl	801465c <HW_IPCC_MM_FreeBufHandler>
 80144e0:	e00f      	b.n	8014502 <HW_IPCC_Tx_Handler+0x8a>
  }
  else if (HW_IPCC_TX_PENDING( HW_IPCC_HCI_ACL_DATA_CHANNEL ))
 80144e2:	2120      	movs	r1, #32
 80144e4:	4808      	ldr	r0, [pc, #32]	; (8014508 <HW_IPCC_Tx_Handler+0x90>)
 80144e6:	f7ff ff64 	bl	80143b2 <LL_C1_IPCC_IsActiveFlag_CHx>
 80144ea:	4603      	mov	r3, r0
 80144ec:	2b00      	cmp	r3, #0
 80144ee:	d109      	bne.n	8014504 <HW_IPCC_Tx_Handler+0x8c>
 80144f0:	4b05      	ldr	r3, [pc, #20]	; (8014508 <HW_IPCC_Tx_Handler+0x90>)
 80144f2:	685b      	ldr	r3, [r3, #4]
 80144f4:	43db      	mvns	r3, r3
 80144f6:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80144fa:	2b00      	cmp	r3, #0
 80144fc:	d002      	beq.n	8014504 <HW_IPCC_Tx_Handler+0x8c>
  {
    HW_IPCC_BLE_AclDataEvtHandler();
 80144fe:	f000 f84f 	bl	80145a0 <HW_IPCC_BLE_AclDataEvtHandler>
  }

  return;
 8014502:	bf00      	nop
 8014504:	bf00      	nop
}
 8014506:	bd80      	pop	{r7, pc}
 8014508:	58000c00 	.word	0x58000c00

0801450c <HW_IPCC_Enable>:
/******************************************************************************
 * GENERAL
 ******************************************************************************/
void HW_IPCC_Enable( void )
{
 801450c:	b580      	push	{r7, lr}
 801450e:	af00      	add	r7, sp, #0
  /**
  * Such as IPCC IP available to the CPU2, it is required to keep the IPCC clock running
    when FUS is running on CPU2 and CPU1 enters deep sleep mode
  */
  LL_C2_AHB3_GRP1_EnableClock(LL_C2_AHB3_GRP1_PERIPH_IPCC);
 8014510:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8014514:	f7ff febd 	bl	8014292 <LL_C2_AHB3_GRP1_EnableClock>

   /**
   * When the device is out of standby, it is required to use the EXTI mechanism to wakeup CPU2
   */
  LL_C2_EXTI_EnableEvent_32_63( LL_EXTI_LINE_41 );
 8014518:	f44f 7000 	mov.w	r0, #512	; 0x200
 801451c:	f7ff fe6a 	bl	80141f4 <LL_C2_EXTI_EnableEvent_32_63>
  LL_EXTI_EnableRisingTrig_32_63( LL_EXTI_LINE_41 );
 8014520:	f44f 7000 	mov.w	r0, #512	; 0x200
 8014524:	f7ff fe7a 	bl	801421c <LL_EXTI_EnableRisingTrig_32_63>
   * When the CPU2 receives that command, it waits for its event input to be set to restart the CPU2 firmware.
   * This is required because once C2BOOT has been set once, a clear/set on C2BOOT has no effect.
   * When SHCI_C2_Reinit( ) is not called, generating an event to the CPU2 does not have any effect
   * So, by default, the application shall both set the event flag and set the C2BOOT bit.
   */
  __SEV( );       /* Set the internal event flag and send an event to the CPU2 */
 8014528:	bf40      	sev
  __WFE( );       /* Clear the internal event flag */
 801452a:	bf20      	wfe
  LL_PWR_EnableBootC2( );
 801452c:	f7ff fe88 	bl	8014240 <LL_PWR_EnableBootC2>

  return;
 8014530:	bf00      	nop
}
 8014532:	bd80      	pop	{r7, pc}

08014534 <HW_IPCC_Init>:

void HW_IPCC_Init( void )
{
 8014534:	b580      	push	{r7, lr}
 8014536:	af00      	add	r7, sp, #0
  LL_AHB3_GRP1_EnableClock( LL_AHB3_GRP1_PERIPH_IPCC );
 8014538:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 801453c:	f7ff fe90 	bl	8014260 <LL_AHB3_GRP1_EnableClock>

  LL_C1_IPCC_EnableIT_RXO( IPCC );
 8014540:	4806      	ldr	r0, [pc, #24]	; (801455c <HW_IPCC_Init+0x28>)
 8014542:	f7ff fed2 	bl	80142ea <LL_C1_IPCC_EnableIT_RXO>
  LL_C1_IPCC_EnableIT_TXF( IPCC );
 8014546:	4805      	ldr	r0, [pc, #20]	; (801455c <HW_IPCC_Init+0x28>)
 8014548:	f7ff febf 	bl	80142ca <LL_C1_IPCC_EnableIT_TXF>

  HAL_NVIC_EnableIRQ(IPCC_C1_RX_IRQn);
 801454c:	202c      	movs	r0, #44	; 0x2c
 801454e:	f7fa fef6 	bl	800f33e <HAL_NVIC_EnableIRQ>
  HAL_NVIC_EnableIRQ(IPCC_C1_TX_IRQn);
 8014552:	202d      	movs	r0, #45	; 0x2d
 8014554:	f7fa fef3 	bl	800f33e <HAL_NVIC_EnableIRQ>

  return;
 8014558:	bf00      	nop
}
 801455a:	bd80      	pop	{r7, pc}
 801455c:	58000c00 	.word	0x58000c00

08014560 <HW_IPCC_BLE_Init>:

/******************************************************************************
 * BLE
 ******************************************************************************/
void HW_IPCC_BLE_Init( void )
{
 8014560:	b580      	push	{r7, lr}
 8014562:	af00      	add	r7, sp, #0
  LL_C1_IPCC_EnableReceiveChannel( IPCC, HW_IPCC_BLE_EVENT_CHANNEL );
 8014564:	2101      	movs	r1, #1
 8014566:	4802      	ldr	r0, [pc, #8]	; (8014570 <HW_IPCC_BLE_Init+0x10>)
 8014568:	f7ff fef4 	bl	8014354 <LL_C1_IPCC_EnableReceiveChannel>

  return;
 801456c:	bf00      	nop
}
 801456e:	bd80      	pop	{r7, pc}
 8014570:	58000c00 	.word	0x58000c00

08014574 <HW_IPCC_BLE_SendCmd>:

void HW_IPCC_BLE_SendCmd( void )
{
 8014574:	b580      	push	{r7, lr}
 8014576:	af00      	add	r7, sp, #0
  LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_BLE_CMD_CHANNEL );
 8014578:	2101      	movs	r1, #1
 801457a:	4802      	ldr	r0, [pc, #8]	; (8014584 <HW_IPCC_BLE_SendCmd+0x10>)
 801457c:	f7ff ff0a 	bl	8014394 <LL_C1_IPCC_SetFlag_CHx>

  return;
 8014580:	bf00      	nop
}
 8014582:	bd80      	pop	{r7, pc}
 8014584:	58000c00 	.word	0x58000c00

08014588 <HW_IPCC_BLE_EvtHandler>:

static void HW_IPCC_BLE_EvtHandler( void )
{
 8014588:	b580      	push	{r7, lr}
 801458a:	af00      	add	r7, sp, #0
  HW_IPCC_BLE_RxEvtNot();
 801458c:	f7fe fe18 	bl	80131c0 <HW_IPCC_BLE_RxEvtNot>

  LL_C1_IPCC_ClearFlag_CHx( IPCC, HW_IPCC_BLE_EVENT_CHANNEL );
 8014590:	2101      	movs	r1, #1
 8014592:	4802      	ldr	r0, [pc, #8]	; (801459c <HW_IPCC_BLE_EvtHandler+0x14>)
 8014594:	f7ff fef0 	bl	8014378 <LL_C1_IPCC_ClearFlag_CHx>

  return;
 8014598:	bf00      	nop
}
 801459a:	bd80      	pop	{r7, pc}
 801459c:	58000c00 	.word	0x58000c00

080145a0 <HW_IPCC_BLE_AclDataEvtHandler>:

  return;
}

static void HW_IPCC_BLE_AclDataEvtHandler( void )
{
 80145a0:	b580      	push	{r7, lr}
 80145a2:	af00      	add	r7, sp, #0
  LL_C1_IPCC_DisableTransmitChannel( IPCC, HW_IPCC_HCI_ACL_DATA_CHANNEL );
 80145a4:	2120      	movs	r1, #32
 80145a6:	4803      	ldr	r0, [pc, #12]	; (80145b4 <HW_IPCC_BLE_AclDataEvtHandler+0x14>)
 80145a8:	f7ff fec2 	bl	8014330 <LL_C1_IPCC_DisableTransmitChannel>

  HW_IPCC_BLE_AclDataAckNot();
 80145ac:	f7fe fe38 	bl	8013220 <HW_IPCC_BLE_AclDataAckNot>

  return;
 80145b0:	bf00      	nop
}
 80145b2:	bd80      	pop	{r7, pc}
 80145b4:	58000c00 	.word	0x58000c00

080145b8 <HW_IPCC_SYS_Init>:

/******************************************************************************
 * SYSTEM
 ******************************************************************************/
void HW_IPCC_SYS_Init( void )
{
 80145b8:	b580      	push	{r7, lr}
 80145ba:	af00      	add	r7, sp, #0
  LL_C1_IPCC_EnableReceiveChannel( IPCC, HW_IPCC_SYSTEM_EVENT_CHANNEL );
 80145bc:	2102      	movs	r1, #2
 80145be:	4802      	ldr	r0, [pc, #8]	; (80145c8 <HW_IPCC_SYS_Init+0x10>)
 80145c0:	f7ff fec8 	bl	8014354 <LL_C1_IPCC_EnableReceiveChannel>

  return;
 80145c4:	bf00      	nop
}
 80145c6:	bd80      	pop	{r7, pc}
 80145c8:	58000c00 	.word	0x58000c00

080145cc <HW_IPCC_SYS_SendCmd>:

void HW_IPCC_SYS_SendCmd( void )
{
 80145cc:	b580      	push	{r7, lr}
 80145ce:	af00      	add	r7, sp, #0
  LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_SYSTEM_CMD_RSP_CHANNEL );
 80145d0:	2102      	movs	r1, #2
 80145d2:	4804      	ldr	r0, [pc, #16]	; (80145e4 <HW_IPCC_SYS_SendCmd+0x18>)
 80145d4:	f7ff fede 	bl	8014394 <LL_C1_IPCC_SetFlag_CHx>
  LL_C1_IPCC_EnableTransmitChannel( IPCC, HW_IPCC_SYSTEM_CMD_RSP_CHANNEL );
 80145d8:	2102      	movs	r1, #2
 80145da:	4802      	ldr	r0, [pc, #8]	; (80145e4 <HW_IPCC_SYS_SendCmd+0x18>)
 80145dc:	f7ff fe95 	bl	801430a <LL_C1_IPCC_EnableTransmitChannel>

  return;
 80145e0:	bf00      	nop
}
 80145e2:	bd80      	pop	{r7, pc}
 80145e4:	58000c00 	.word	0x58000c00

080145e8 <HW_IPCC_SYS_CmdEvtHandler>:

static void HW_IPCC_SYS_CmdEvtHandler( void )
{
 80145e8:	b580      	push	{r7, lr}
 80145ea:	af00      	add	r7, sp, #0
  LL_C1_IPCC_DisableTransmitChannel( IPCC, HW_IPCC_SYSTEM_CMD_RSP_CHANNEL );
 80145ec:	2102      	movs	r1, #2
 80145ee:	4803      	ldr	r0, [pc, #12]	; (80145fc <HW_IPCC_SYS_CmdEvtHandler+0x14>)
 80145f0:	f7ff fe9e 	bl	8014330 <LL_C1_IPCC_DisableTransmitChannel>

  HW_IPCC_SYS_CmdEvtNot();
 80145f4:	f7fe fe64 	bl	80132c0 <HW_IPCC_SYS_CmdEvtNot>

  return;
 80145f8:	bf00      	nop
}
 80145fa:	bd80      	pop	{r7, pc}
 80145fc:	58000c00 	.word	0x58000c00

08014600 <HW_IPCC_SYS_EvtHandler>:

static void HW_IPCC_SYS_EvtHandler( void )
{
 8014600:	b580      	push	{r7, lr}
 8014602:	af00      	add	r7, sp, #0
  HW_IPCC_SYS_EvtNot();
 8014604:	f7fe fe72 	bl	80132ec <HW_IPCC_SYS_EvtNot>

  LL_C1_IPCC_ClearFlag_CHx( IPCC, HW_IPCC_SYSTEM_EVENT_CHANNEL );
 8014608:	2102      	movs	r1, #2
 801460a:	4802      	ldr	r0, [pc, #8]	; (8014614 <HW_IPCC_SYS_EvtHandler+0x14>)
 801460c:	f7ff feb4 	bl	8014378 <LL_C1_IPCC_ClearFlag_CHx>

  return;
 8014610:	bf00      	nop
}
 8014612:	bd80      	pop	{r7, pc}
 8014614:	58000c00 	.word	0x58000c00

08014618 <HW_IPCC_MM_SendFreeBuf>:

/******************************************************************************
 * MEMORY MANAGER
 ******************************************************************************/
void HW_IPCC_MM_SendFreeBuf( void (*cb)( void ) )
{
 8014618:	b580      	push	{r7, lr}
 801461a:	b082      	sub	sp, #8
 801461c:	af00      	add	r7, sp, #0
 801461e:	6078      	str	r0, [r7, #4]
  if ( LL_C1_IPCC_IsActiveFlag_CHx( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL ) )
 8014620:	2108      	movs	r1, #8
 8014622:	480c      	ldr	r0, [pc, #48]	; (8014654 <HW_IPCC_MM_SendFreeBuf+0x3c>)
 8014624:	f7ff fec5 	bl	80143b2 <LL_C1_IPCC_IsActiveFlag_CHx>
 8014628:	4603      	mov	r3, r0
 801462a:	2b00      	cmp	r3, #0
 801462c:	d007      	beq.n	801463e <HW_IPCC_MM_SendFreeBuf+0x26>
  {
    FreeBufCb = cb;
 801462e:	4a0a      	ldr	r2, [pc, #40]	; (8014658 <HW_IPCC_MM_SendFreeBuf+0x40>)
 8014630:	687b      	ldr	r3, [r7, #4]
 8014632:	6013      	str	r3, [r2, #0]
    LL_C1_IPCC_EnableTransmitChannel( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );
 8014634:	2108      	movs	r1, #8
 8014636:	4807      	ldr	r0, [pc, #28]	; (8014654 <HW_IPCC_MM_SendFreeBuf+0x3c>)
 8014638:	f7ff fe67 	bl	801430a <LL_C1_IPCC_EnableTransmitChannel>
    cb();

    LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );
  }

  return;
 801463c:	e006      	b.n	801464c <HW_IPCC_MM_SendFreeBuf+0x34>
    cb();
 801463e:	687b      	ldr	r3, [r7, #4]
 8014640:	4798      	blx	r3
    LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );
 8014642:	2108      	movs	r1, #8
 8014644:	4803      	ldr	r0, [pc, #12]	; (8014654 <HW_IPCC_MM_SendFreeBuf+0x3c>)
 8014646:	f7ff fea5 	bl	8014394 <LL_C1_IPCC_SetFlag_CHx>
  return;
 801464a:	bf00      	nop
}
 801464c:	3708      	adds	r7, #8
 801464e:	46bd      	mov	sp, r7
 8014650:	bd80      	pop	{r7, pc}
 8014652:	bf00      	nop
 8014654:	58000c00 	.word	0x58000c00
 8014658:	20000f70 	.word	0x20000f70

0801465c <HW_IPCC_MM_FreeBufHandler>:

static void HW_IPCC_MM_FreeBufHandler( void )
{
 801465c:	b580      	push	{r7, lr}
 801465e:	af00      	add	r7, sp, #0
  LL_C1_IPCC_DisableTransmitChannel( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );
 8014660:	2108      	movs	r1, #8
 8014662:	4806      	ldr	r0, [pc, #24]	; (801467c <HW_IPCC_MM_FreeBufHandler+0x20>)
 8014664:	f7ff fe64 	bl	8014330 <LL_C1_IPCC_DisableTransmitChannel>

  FreeBufCb();
 8014668:	4b05      	ldr	r3, [pc, #20]	; (8014680 <HW_IPCC_MM_FreeBufHandler+0x24>)
 801466a:	681b      	ldr	r3, [r3, #0]
 801466c:	4798      	blx	r3

  LL_C1_IPCC_SetFlag_CHx( IPCC, HW_IPCC_MM_RELEASE_BUFFER_CHANNEL );
 801466e:	2108      	movs	r1, #8
 8014670:	4802      	ldr	r0, [pc, #8]	; (801467c <HW_IPCC_MM_FreeBufHandler+0x20>)
 8014672:	f7ff fe8f 	bl	8014394 <LL_C1_IPCC_SetFlag_CHx>

  return;
 8014676:	bf00      	nop
}
 8014678:	bd80      	pop	{r7, pc}
 801467a:	bf00      	nop
 801467c:	58000c00 	.word	0x58000c00
 8014680:	20000f70 	.word	0x20000f70

08014684 <HW_IPCC_TRACES_Init>:

/******************************************************************************
 * TRACES
 ******************************************************************************/
void HW_IPCC_TRACES_Init( void )
{
 8014684:	b580      	push	{r7, lr}
 8014686:	af00      	add	r7, sp, #0
  LL_C1_IPCC_EnableReceiveChannel( IPCC, HW_IPCC_TRACES_CHANNEL );
 8014688:	2108      	movs	r1, #8
 801468a:	4802      	ldr	r0, [pc, #8]	; (8014694 <HW_IPCC_TRACES_Init+0x10>)
 801468c:	f7ff fe62 	bl	8014354 <LL_C1_IPCC_EnableReceiveChannel>

  return;
 8014690:	bf00      	nop
}
 8014692:	bd80      	pop	{r7, pc}
 8014694:	58000c00 	.word	0x58000c00

08014698 <HW_IPCC_TRACES_EvtHandler>:

static void HW_IPCC_TRACES_EvtHandler( void )
{
 8014698:	b580      	push	{r7, lr}
 801469a:	af00      	add	r7, sp, #0
  HW_IPCC_TRACES_EvtNot();
 801469c:	f7fe fece 	bl	801343c <HW_IPCC_TRACES_EvtNot>

  LL_C1_IPCC_ClearFlag_CHx( IPCC, HW_IPCC_TRACES_CHANNEL );
 80146a0:	2108      	movs	r1, #8
 80146a2:	4802      	ldr	r0, [pc, #8]	; (80146ac <HW_IPCC_TRACES_EvtHandler+0x14>)
 80146a4:	f7ff fe68 	bl	8014378 <LL_C1_IPCC_ClearFlag_CHx>

  return;
 80146a8:	bf00      	nop
}
 80146aa:	bd80      	pop	{r7, pc}
 80146ac:	58000c00 	.word	0x58000c00

080146b0 <UTIL_LPM_Init>:

/** @addtogroup TINY_LPM_Exported_function
  * @{
  */
void UTIL_LPM_Init( void )
{
 80146b0:	b480      	push	{r7}
 80146b2:	af00      	add	r7, sp, #0
  StopModeDisable = UTIL_LPM_NO_BIT_SET;
 80146b4:	4b05      	ldr	r3, [pc, #20]	; (80146cc <UTIL_LPM_Init+0x1c>)
 80146b6:	2200      	movs	r2, #0
 80146b8:	601a      	str	r2, [r3, #0]
  OffModeDisable = UTIL_LPM_NO_BIT_SET;
 80146ba:	4b05      	ldr	r3, [pc, #20]	; (80146d0 <UTIL_LPM_Init+0x20>)
 80146bc:	2200      	movs	r2, #0
 80146be:	601a      	str	r2, [r3, #0]
  UTIL_LPM_INIT_CRITICAL_SECTION( );
}
 80146c0:	bf00      	nop
 80146c2:	46bd      	mov	sp, r7
 80146c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80146c8:	4770      	bx	lr
 80146ca:	bf00      	nop
 80146cc:	20000f74 	.word	0x20000f74
 80146d0:	20000f78 	.word	0x20000f78

080146d4 <UTIL_LPM_SetOffMode>:
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}

void UTIL_LPM_SetOffMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
 80146d4:	b480      	push	{r7}
 80146d6:	b087      	sub	sp, #28
 80146d8:	af00      	add	r7, sp, #0
 80146da:	6078      	str	r0, [r7, #4]
 80146dc:	460b      	mov	r3, r1
 80146de:	70fb      	strb	r3, [r7, #3]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80146e0:	f3ef 8310 	mrs	r3, PRIMASK
 80146e4:	613b      	str	r3, [r7, #16]
  return(result);
 80146e6:	693b      	ldr	r3, [r7, #16]
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
 80146e8:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 80146ea:	b672      	cpsid	i
}
 80146ec:	bf00      	nop
  
  switch(state)
 80146ee:	78fb      	ldrb	r3, [r7, #3]
 80146f0:	2b00      	cmp	r3, #0
 80146f2:	d008      	beq.n	8014706 <UTIL_LPM_SetOffMode+0x32>
 80146f4:	2b01      	cmp	r3, #1
 80146f6:	d10e      	bne.n	8014716 <UTIL_LPM_SetOffMode+0x42>
  {
  case UTIL_LPM_DISABLE:
    {
      OffModeDisable |= lpm_id_bm;
 80146f8:	4b0d      	ldr	r3, [pc, #52]	; (8014730 <UTIL_LPM_SetOffMode+0x5c>)
 80146fa:	681a      	ldr	r2, [r3, #0]
 80146fc:	687b      	ldr	r3, [r7, #4]
 80146fe:	4313      	orrs	r3, r2
 8014700:	4a0b      	ldr	r2, [pc, #44]	; (8014730 <UTIL_LPM_SetOffMode+0x5c>)
 8014702:	6013      	str	r3, [r2, #0]
      break;
 8014704:	e008      	b.n	8014718 <UTIL_LPM_SetOffMode+0x44>
    }
  case UTIL_LPM_ENABLE:
    {
      OffModeDisable &= ( ~lpm_id_bm );
 8014706:	687b      	ldr	r3, [r7, #4]
 8014708:	43da      	mvns	r2, r3
 801470a:	4b09      	ldr	r3, [pc, #36]	; (8014730 <UTIL_LPM_SetOffMode+0x5c>)
 801470c:	681b      	ldr	r3, [r3, #0]
 801470e:	4013      	ands	r3, r2
 8014710:	4a07      	ldr	r2, [pc, #28]	; (8014730 <UTIL_LPM_SetOffMode+0x5c>)
 8014712:	6013      	str	r3, [r2, #0]
      break;
 8014714:	e000      	b.n	8014718 <UTIL_LPM_SetOffMode+0x44>
    }
  default :
    {
      break;
 8014716:	bf00      	nop
 8014718:	697b      	ldr	r3, [r7, #20]
 801471a:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801471c:	68fb      	ldr	r3, [r7, #12]
 801471e:	f383 8810 	msr	PRIMASK, r3
}
 8014722:	bf00      	nop
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 8014724:	bf00      	nop
 8014726:	371c      	adds	r7, #28
 8014728:	46bd      	mov	sp, r7
 801472a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801472e:	4770      	bx	lr
 8014730:	20000f78 	.word	0x20000f78

08014734 <UTIL_SEQ_Run>:
 * This function can be nested.
 * That is the reason why many variables that are used only in that function are declared static.
 * Note: These variables could have been declared static in the function.
 */
void UTIL_SEQ_Run( UTIL_SEQ_bm_t Mask_bm )
{
 8014734:	b580      	push	{r7, lr}
 8014736:	b08c      	sub	sp, #48	; 0x30
 8014738:	af00      	add	r7, sp, #0
 801473a:	6078      	str	r0, [r7, #4]
  /**
   *  When this function is nested, the mask to be applied cannot be larger than the first call
   *  The mask is always getting smaller and smaller
   *  A copy is made of the mask set by UTIL_SEQ_Run() in case it is called again in the task
   */
  super_mask_backup = SuperMask;
 801473c:	4b67      	ldr	r3, [pc, #412]	; (80148dc <UTIL_SEQ_Run+0x1a8>)
 801473e:	681b      	ldr	r3, [r3, #0]
 8014740:	62bb      	str	r3, [r7, #40]	; 0x28
  SuperMask &= Mask_bm;
 8014742:	4b66      	ldr	r3, [pc, #408]	; (80148dc <UTIL_SEQ_Run+0x1a8>)
 8014744:	681a      	ldr	r2, [r3, #0]
 8014746:	687b      	ldr	r3, [r7, #4]
 8014748:	4013      	ands	r3, r2
 801474a:	4a64      	ldr	r2, [pc, #400]	; (80148dc <UTIL_SEQ_Run+0x1a8>)
 801474c:	6013      	str	r3, [r2, #0]
   * TaskMask that comes from UTIL_SEQ_PauseTask() / UTIL_SEQ_ResumeTask
   * SuperMask that comes from UTIL_SEQ_Run
   * If the waited event is there, exit from  UTIL_SEQ_Run() to return to the
   * waiting task
   */
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 801474e:	e083      	b.n	8014858 <UTIL_SEQ_Run+0x124>
  {
    counter = 0U;
 8014750:	2300      	movs	r3, #0
 8014752:	62fb      	str	r3, [r7, #44]	; 0x2c
    /**
     * When a flag is set, the associated bit is set in TaskPrio[counter].priority mask depending
     * on the priority parameter given from UTIL_SEQ_SetTask()
     * The while loop is looking for a flag set from the highest priority maskr to the lower
     */
    while((TaskPrio[counter].priority & TaskMask & SuperMask)== 0U)
 8014754:	e002      	b.n	801475c <UTIL_SEQ_Run+0x28>
    {
      counter++;
 8014756:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014758:	3301      	adds	r3, #1
 801475a:	62fb      	str	r3, [r7, #44]	; 0x2c
    while((TaskPrio[counter].priority & TaskMask & SuperMask)== 0U)
 801475c:	4a60      	ldr	r2, [pc, #384]	; (80148e0 <UTIL_SEQ_Run+0x1ac>)
 801475e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014760:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 8014764:	4b5f      	ldr	r3, [pc, #380]	; (80148e4 <UTIL_SEQ_Run+0x1b0>)
 8014766:	681b      	ldr	r3, [r3, #0]
 8014768:	401a      	ands	r2, r3
 801476a:	4b5c      	ldr	r3, [pc, #368]	; (80148dc <UTIL_SEQ_Run+0x1a8>)
 801476c:	681b      	ldr	r3, [r3, #0]
 801476e:	4013      	ands	r3, r2
 8014770:	2b00      	cmp	r3, #0
 8014772:	d0f0      	beq.n	8014756 <UTIL_SEQ_Run+0x22>
    }

    current_task_set = TaskPrio[counter].priority & TaskMask & SuperMask;
 8014774:	4a5a      	ldr	r2, [pc, #360]	; (80148e0 <UTIL_SEQ_Run+0x1ac>)
 8014776:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014778:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 801477c:	4b59      	ldr	r3, [pc, #356]	; (80148e4 <UTIL_SEQ_Run+0x1b0>)
 801477e:	681b      	ldr	r3, [r3, #0]
 8014780:	401a      	ands	r2, r3
 8014782:	4b56      	ldr	r3, [pc, #344]	; (80148dc <UTIL_SEQ_Run+0x1a8>)
 8014784:	681b      	ldr	r3, [r3, #0]
 8014786:	4013      	ands	r3, r2
 8014788:	627b      	str	r3, [r7, #36]	; 0x24
     * so that the second one can be executed.
     * Note that the first flag is not removed from the list of pending task but just masked by the round_robin mask
     *
     * In the check below, the round_robin mask is reitialize in case all pending tasks haven been executed at least once
     */
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 801478a:	4a55      	ldr	r2, [pc, #340]	; (80148e0 <UTIL_SEQ_Run+0x1ac>)
 801478c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801478e:	00db      	lsls	r3, r3, #3
 8014790:	4413      	add	r3, r2
 8014792:	685a      	ldr	r2, [r3, #4]
 8014794:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014796:	4013      	ands	r3, r2
 8014798:	2b00      	cmp	r3, #0
 801479a:	d106      	bne.n	80147aa <UTIL_SEQ_Run+0x76>
    {
      TaskPrio[counter].round_robin = UTIL_SEQ_ALL_BIT_SET;
 801479c:	4a50      	ldr	r2, [pc, #320]	; (80148e0 <UTIL_SEQ_Run+0x1ac>)
 801479e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80147a0:	00db      	lsls	r3, r3, #3
 80147a2:	4413      	add	r3, r2
 80147a4:	f04f 32ff 	mov.w	r2, #4294967295
 80147a8:	605a      	str	r2, [r3, #4]

    /** Read the flag index of the task to be executed
	 *  Once the index is read, the associated task will be executed even though a higher priority stack is requested
	 *  before task execution.
	 */
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 80147aa:	4a4d      	ldr	r2, [pc, #308]	; (80148e0 <UTIL_SEQ_Run+0x1ac>)
 80147ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80147ae:	00db      	lsls	r3, r3, #3
 80147b0:	4413      	add	r3, r2
 80147b2:	685a      	ldr	r2, [r3, #4]
 80147b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80147b6:	4013      	ands	r3, r2
 80147b8:	4618      	mov	r0, r3
 80147ba:	f000 f99d 	bl	8014af8 <SEQ_BitPosition>
 80147be:	4603      	mov	r3, r0
 80147c0:	461a      	mov	r2, r3
 80147c2:	4b49      	ldr	r3, [pc, #292]	; (80148e8 <UTIL_SEQ_Run+0x1b4>)
 80147c4:	601a      	str	r2, [r3, #0]

    /** remove from the roun_robin mask the task that has been selected to be executed */
    TaskPrio[counter].round_robin &= ~(1U << CurrentTaskIdx);
 80147c6:	4a46      	ldr	r2, [pc, #280]	; (80148e0 <UTIL_SEQ_Run+0x1ac>)
 80147c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80147ca:	00db      	lsls	r3, r3, #3
 80147cc:	4413      	add	r3, r2
 80147ce:	685a      	ldr	r2, [r3, #4]
 80147d0:	4b45      	ldr	r3, [pc, #276]	; (80148e8 <UTIL_SEQ_Run+0x1b4>)
 80147d2:	681b      	ldr	r3, [r3, #0]
 80147d4:	2101      	movs	r1, #1
 80147d6:	fa01 f303 	lsl.w	r3, r1, r3
 80147da:	43db      	mvns	r3, r3
 80147dc:	401a      	ands	r2, r3
 80147de:	4940      	ldr	r1, [pc, #256]	; (80148e0 <UTIL_SEQ_Run+0x1ac>)
 80147e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80147e2:	00db      	lsls	r3, r3, #3
 80147e4:	440b      	add	r3, r1
 80147e6:	605a      	str	r2, [r3, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80147e8:	f3ef 8310 	mrs	r3, PRIMASK
 80147ec:	61bb      	str	r3, [r7, #24]
  return(result);
 80147ee:	69bb      	ldr	r3, [r7, #24]

    UTIL_SEQ_ENTER_CRITICAL_SECTION( );
 80147f0:	623b      	str	r3, [r7, #32]
  __ASM volatile ("cpsid i" : : : "memory");
 80147f2:	b672      	cpsid	i
}
 80147f4:	bf00      	nop
    /** remove from the list or pending task the one that has been selected to be executed */
    TaskSet &= ~(1U << CurrentTaskIdx);
 80147f6:	4b3c      	ldr	r3, [pc, #240]	; (80148e8 <UTIL_SEQ_Run+0x1b4>)
 80147f8:	681b      	ldr	r3, [r3, #0]
 80147fa:	2201      	movs	r2, #1
 80147fc:	fa02 f303 	lsl.w	r3, r2, r3
 8014800:	43da      	mvns	r2, r3
 8014802:	4b3a      	ldr	r3, [pc, #232]	; (80148ec <UTIL_SEQ_Run+0x1b8>)
 8014804:	681b      	ldr	r3, [r3, #0]
 8014806:	4013      	ands	r3, r2
 8014808:	4a38      	ldr	r2, [pc, #224]	; (80148ec <UTIL_SEQ_Run+0x1b8>)
 801480a:	6013      	str	r3, [r2, #0]
    /** remove from all priority mask the task that has been selected to be executed */
    for (counter = UTIL_SEQ_CONF_PRIO_NBR; counter != 0U; counter--)
 801480c:	2302      	movs	r3, #2
 801480e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8014810:	e013      	b.n	801483a <UTIL_SEQ_Run+0x106>
    {
      TaskPrio[counter - 1U].priority &= ~(1U << CurrentTaskIdx);
 8014812:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014814:	3b01      	subs	r3, #1
 8014816:	4a32      	ldr	r2, [pc, #200]	; (80148e0 <UTIL_SEQ_Run+0x1ac>)
 8014818:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
 801481c:	4b32      	ldr	r3, [pc, #200]	; (80148e8 <UTIL_SEQ_Run+0x1b4>)
 801481e:	681b      	ldr	r3, [r3, #0]
 8014820:	2201      	movs	r2, #1
 8014822:	fa02 f303 	lsl.w	r3, r2, r3
 8014826:	43da      	mvns	r2, r3
 8014828:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801482a:	3b01      	subs	r3, #1
 801482c:	400a      	ands	r2, r1
 801482e:	492c      	ldr	r1, [pc, #176]	; (80148e0 <UTIL_SEQ_Run+0x1ac>)
 8014830:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
    for (counter = UTIL_SEQ_CONF_PRIO_NBR; counter != 0U; counter--)
 8014834:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014836:	3b01      	subs	r3, #1
 8014838:	62fb      	str	r3, [r7, #44]	; 0x2c
 801483a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801483c:	2b00      	cmp	r3, #0
 801483e:	d1e8      	bne.n	8014812 <UTIL_SEQ_Run+0xde>
 8014840:	6a3b      	ldr	r3, [r7, #32]
 8014842:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014844:	697b      	ldr	r3, [r7, #20]
 8014846:	f383 8810 	msr	PRIMASK, r3
}
 801484a:	bf00      	nop
    }
    UTIL_SEQ_EXIT_CRITICAL_SECTION( );
    /** Execute the task */
    TaskCb[CurrentTaskIdx]( );
 801484c:	4b26      	ldr	r3, [pc, #152]	; (80148e8 <UTIL_SEQ_Run+0x1b4>)
 801484e:	681b      	ldr	r3, [r3, #0]
 8014850:	4a27      	ldr	r2, [pc, #156]	; (80148f0 <UTIL_SEQ_Run+0x1bc>)
 8014852:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8014856:	4798      	blx	r3
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 8014858:	4b24      	ldr	r3, [pc, #144]	; (80148ec <UTIL_SEQ_Run+0x1b8>)
 801485a:	681a      	ldr	r2, [r3, #0]
 801485c:	4b21      	ldr	r3, [pc, #132]	; (80148e4 <UTIL_SEQ_Run+0x1b0>)
 801485e:	681b      	ldr	r3, [r3, #0]
 8014860:	401a      	ands	r2, r3
 8014862:	4b1e      	ldr	r3, [pc, #120]	; (80148dc <UTIL_SEQ_Run+0x1a8>)
 8014864:	681b      	ldr	r3, [r3, #0]
 8014866:	4013      	ands	r3, r2
 8014868:	2b00      	cmp	r3, #0
 801486a:	d007      	beq.n	801487c <UTIL_SEQ_Run+0x148>
 801486c:	4b21      	ldr	r3, [pc, #132]	; (80148f4 <UTIL_SEQ_Run+0x1c0>)
 801486e:	681a      	ldr	r2, [r3, #0]
 8014870:	4b21      	ldr	r3, [pc, #132]	; (80148f8 <UTIL_SEQ_Run+0x1c4>)
 8014872:	681b      	ldr	r3, [r3, #0]
 8014874:	4013      	ands	r3, r2
 8014876:	2b00      	cmp	r3, #0
 8014878:	f43f af6a 	beq.w	8014750 <UTIL_SEQ_Run+0x1c>
  }

  /* the set of CurrentTaskIdx to no task running allows to call WaitEvt in the Pre/Post ilde context */
  CurrentTaskIdx = UTIL_SEQ_NOTASKRUNNING;
 801487c:	4b1a      	ldr	r3, [pc, #104]	; (80148e8 <UTIL_SEQ_Run+0x1b4>)
 801487e:	f04f 32ff 	mov.w	r2, #4294967295
 8014882:	601a      	str	r2, [r3, #0]
  UTIL_SEQ_PreIdle( );
 8014884:	f000 f92a 	bl	8014adc <UTIL_SEQ_PreIdle>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014888:	f3ef 8310 	mrs	r3, PRIMASK
 801488c:	613b      	str	r3, [r7, #16]
  return(result);
 801488e:	693b      	ldr	r3, [r7, #16]
  
  UTIL_SEQ_ENTER_CRITICAL_SECTION_IDLE( );
 8014890:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("cpsid i" : : : "memory");
 8014892:	b672      	cpsid	i
}
 8014894:	bf00      	nop
  if (!(((TaskSet & TaskMask & SuperMask) != 0U) || ((EvtSet & EvtWaited)!= 0U))) 
 8014896:	4b15      	ldr	r3, [pc, #84]	; (80148ec <UTIL_SEQ_Run+0x1b8>)
 8014898:	681a      	ldr	r2, [r3, #0]
 801489a:	4b12      	ldr	r3, [pc, #72]	; (80148e4 <UTIL_SEQ_Run+0x1b0>)
 801489c:	681b      	ldr	r3, [r3, #0]
 801489e:	401a      	ands	r2, r3
 80148a0:	4b0e      	ldr	r3, [pc, #56]	; (80148dc <UTIL_SEQ_Run+0x1a8>)
 80148a2:	681b      	ldr	r3, [r3, #0]
 80148a4:	4013      	ands	r3, r2
 80148a6:	2b00      	cmp	r3, #0
 80148a8:	d108      	bne.n	80148bc <UTIL_SEQ_Run+0x188>
 80148aa:	4b12      	ldr	r3, [pc, #72]	; (80148f4 <UTIL_SEQ_Run+0x1c0>)
 80148ac:	681a      	ldr	r2, [r3, #0]
 80148ae:	4b12      	ldr	r3, [pc, #72]	; (80148f8 <UTIL_SEQ_Run+0x1c4>)
 80148b0:	681b      	ldr	r3, [r3, #0]
 80148b2:	4013      	ands	r3, r2
 80148b4:	2b00      	cmp	r3, #0
 80148b6:	d101      	bne.n	80148bc <UTIL_SEQ_Run+0x188>
  {
	UTIL_SEQ_Idle( );
 80148b8:	f7f6 fff1 	bl	800b89e <UTIL_SEQ_Idle>
 80148bc:	69fb      	ldr	r3, [r7, #28]
 80148be:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80148c0:	68fb      	ldr	r3, [r7, #12]
 80148c2:	f383 8810 	msr	PRIMASK, r3
}
 80148c6:	bf00      	nop
  }
  UTIL_SEQ_EXIT_CRITICAL_SECTION_IDLE( );
  
  UTIL_SEQ_PostIdle( );
 80148c8:	f000 f90f 	bl	8014aea <UTIL_SEQ_PostIdle>

  /** restore the mask from UTIL_SEQ_Run() */
  SuperMask = super_mask_backup;
 80148cc:	4a03      	ldr	r2, [pc, #12]	; (80148dc <UTIL_SEQ_Run+0x1a8>)
 80148ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80148d0:	6013      	str	r3, [r2, #0]

  return;
 80148d2:	bf00      	nop
}
 80148d4:	3730      	adds	r7, #48	; 0x30
 80148d6:	46bd      	mov	sp, r7
 80148d8:	bd80      	pop	{r7, pc}
 80148da:	bf00      	nop
 80148dc:	20000024 	.word	0x20000024
 80148e0:	2000100c 	.word	0x2000100c
 80148e4:	20000020 	.word	0x20000020
 80148e8:	20000f88 	.word	0x20000f88
 80148ec:	20000f7c 	.word	0x20000f7c
 80148f0:	20000f8c 	.word	0x20000f8c
 80148f4:	20000f80 	.word	0x20000f80
 80148f8:	20000f84 	.word	0x20000f84

080148fc <UTIL_SEQ_RegTask>:

void UTIL_SEQ_RegTask(UTIL_SEQ_bm_t TaskId_bm, uint32_t Flags, void (*Task)( void ))
{
 80148fc:	b580      	push	{r7, lr}
 80148fe:	b088      	sub	sp, #32
 8014900:	af00      	add	r7, sp, #0
 8014902:	60f8      	str	r0, [r7, #12]
 8014904:	60b9      	str	r1, [r7, #8]
 8014906:	607a      	str	r2, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014908:	f3ef 8310 	mrs	r3, PRIMASK
 801490c:	617b      	str	r3, [r7, #20]
  return(result);
 801490e:	697b      	ldr	r3, [r7, #20]
  UTIL_SEQ_ENTER_CRITICAL_SECTION();
 8014910:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("cpsid i" : : : "memory");
 8014912:	b672      	cpsid	i
}
 8014914:	bf00      	nop

  TaskCb[SEQ_BitPosition(TaskId_bm)] = Task;
 8014916:	68f8      	ldr	r0, [r7, #12]
 8014918:	f000 f8ee 	bl	8014af8 <SEQ_BitPosition>
 801491c:	4603      	mov	r3, r0
 801491e:	4619      	mov	r1, r3
 8014920:	4a06      	ldr	r2, [pc, #24]	; (801493c <UTIL_SEQ_RegTask+0x40>)
 8014922:	687b      	ldr	r3, [r7, #4]
 8014924:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 8014928:	69fb      	ldr	r3, [r7, #28]
 801492a:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801492c:	69bb      	ldr	r3, [r7, #24]
 801492e:	f383 8810 	msr	PRIMASK, r3
}
 8014932:	bf00      	nop

  UTIL_SEQ_EXIT_CRITICAL_SECTION();

  return;
 8014934:	bf00      	nop
}
 8014936:	3720      	adds	r7, #32
 8014938:	46bd      	mov	sp, r7
 801493a:	bd80      	pop	{r7, pc}
 801493c:	20000f8c 	.word	0x20000f8c

08014940 <UTIL_SEQ_SetTask>:

void UTIL_SEQ_SetTask( UTIL_SEQ_bm_t TaskId_bm , uint32_t Task_Prio )
{
 8014940:	b480      	push	{r7}
 8014942:	b087      	sub	sp, #28
 8014944:	af00      	add	r7, sp, #0
 8014946:	6078      	str	r0, [r7, #4]
 8014948:	6039      	str	r1, [r7, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 801494a:	f3ef 8310 	mrs	r3, PRIMASK
 801494e:	60fb      	str	r3, [r7, #12]
  return(result);
 8014950:	68fb      	ldr	r3, [r7, #12]
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );
 8014952:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 8014954:	b672      	cpsid	i
}
 8014956:	bf00      	nop

  TaskSet |= TaskId_bm;
 8014958:	4b0d      	ldr	r3, [pc, #52]	; (8014990 <UTIL_SEQ_SetTask+0x50>)
 801495a:	681a      	ldr	r2, [r3, #0]
 801495c:	687b      	ldr	r3, [r7, #4]
 801495e:	4313      	orrs	r3, r2
 8014960:	4a0b      	ldr	r2, [pc, #44]	; (8014990 <UTIL_SEQ_SetTask+0x50>)
 8014962:	6013      	str	r3, [r2, #0]
  TaskPrio[Task_Prio].priority |= TaskId_bm;
 8014964:	4a0b      	ldr	r2, [pc, #44]	; (8014994 <UTIL_SEQ_SetTask+0x54>)
 8014966:	683b      	ldr	r3, [r7, #0]
 8014968:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 801496c:	687b      	ldr	r3, [r7, #4]
 801496e:	431a      	orrs	r2, r3
 8014970:	4908      	ldr	r1, [pc, #32]	; (8014994 <UTIL_SEQ_SetTask+0x54>)
 8014972:	683b      	ldr	r3, [r7, #0]
 8014974:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
 8014978:	697b      	ldr	r3, [r7, #20]
 801497a:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 801497c:	693b      	ldr	r3, [r7, #16]
 801497e:	f383 8810 	msr	PRIMASK, r3
}
 8014982:	bf00      	nop

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
 8014984:	bf00      	nop
}
 8014986:	371c      	adds	r7, #28
 8014988:	46bd      	mov	sp, r7
 801498a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801498e:	4770      	bx	lr
 8014990:	20000f7c 	.word	0x20000f7c
 8014994:	2000100c 	.word	0x2000100c

08014998 <UTIL_SEQ_PauseTask>:
  UTIL_SEQ_EXIT_CRITICAL_SECTION();
  return _status;
}

void UTIL_SEQ_PauseTask( UTIL_SEQ_bm_t TaskId_bm )
{
 8014998:	b480      	push	{r7}
 801499a:	b087      	sub	sp, #28
 801499c:	af00      	add	r7, sp, #0
 801499e:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80149a0:	f3ef 8310 	mrs	r3, PRIMASK
 80149a4:	60fb      	str	r3, [r7, #12]
  return(result);
 80149a6:	68fb      	ldr	r3, [r7, #12]
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );
 80149a8:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 80149aa:	b672      	cpsid	i
}
 80149ac:	bf00      	nop

  TaskMask &= (~TaskId_bm);
 80149ae:	687b      	ldr	r3, [r7, #4]
 80149b0:	43da      	mvns	r2, r3
 80149b2:	4b08      	ldr	r3, [pc, #32]	; (80149d4 <UTIL_SEQ_PauseTask+0x3c>)
 80149b4:	681b      	ldr	r3, [r3, #0]
 80149b6:	4013      	ands	r3, r2
 80149b8:	4a06      	ldr	r2, [pc, #24]	; (80149d4 <UTIL_SEQ_PauseTask+0x3c>)
 80149ba:	6013      	str	r3, [r2, #0]
 80149bc:	697b      	ldr	r3, [r7, #20]
 80149be:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80149c0:	693b      	ldr	r3, [r7, #16]
 80149c2:	f383 8810 	msr	PRIMASK, r3
}
 80149c6:	bf00      	nop

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
 80149c8:	bf00      	nop
}
 80149ca:	371c      	adds	r7, #28
 80149cc:	46bd      	mov	sp, r7
 80149ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80149d2:	4770      	bx	lr
 80149d4:	20000020 	.word	0x20000020

080149d8 <UTIL_SEQ_ResumeTask>:
  UTIL_SEQ_EXIT_CRITICAL_SECTION( );
  return _status;
}

void UTIL_SEQ_ResumeTask( UTIL_SEQ_bm_t TaskId_bm )
{
 80149d8:	b480      	push	{r7}
 80149da:	b087      	sub	sp, #28
 80149dc:	af00      	add	r7, sp, #0
 80149de:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80149e0:	f3ef 8310 	mrs	r3, PRIMASK
 80149e4:	60fb      	str	r3, [r7, #12]
  return(result);
 80149e6:	68fb      	ldr	r3, [r7, #12]
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );
 80149e8:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 80149ea:	b672      	cpsid	i
}
 80149ec:	bf00      	nop

  TaskMask |= TaskId_bm;
 80149ee:	4b09      	ldr	r3, [pc, #36]	; (8014a14 <UTIL_SEQ_ResumeTask+0x3c>)
 80149f0:	681a      	ldr	r2, [r3, #0]
 80149f2:	687b      	ldr	r3, [r7, #4]
 80149f4:	4313      	orrs	r3, r2
 80149f6:	4a07      	ldr	r2, [pc, #28]	; (8014a14 <UTIL_SEQ_ResumeTask+0x3c>)
 80149f8:	6013      	str	r3, [r2, #0]
 80149fa:	697b      	ldr	r3, [r7, #20]
 80149fc:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80149fe:	693b      	ldr	r3, [r7, #16]
 8014a00:	f383 8810 	msr	PRIMASK, r3
}
 8014a04:	bf00      	nop

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
 8014a06:	bf00      	nop
}
 8014a08:	371c      	adds	r7, #28
 8014a0a:	46bd      	mov	sp, r7
 8014a0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014a10:	4770      	bx	lr
 8014a12:	bf00      	nop
 8014a14:	20000020 	.word	0x20000020

08014a18 <UTIL_SEQ_SetEvt>:

void UTIL_SEQ_SetEvt( UTIL_SEQ_bm_t EvtId_bm )
{
 8014a18:	b480      	push	{r7}
 8014a1a:	b087      	sub	sp, #28
 8014a1c:	af00      	add	r7, sp, #0
 8014a1e:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8014a20:	f3ef 8310 	mrs	r3, PRIMASK
 8014a24:	60fb      	str	r3, [r7, #12]
  return(result);
 8014a26:	68fb      	ldr	r3, [r7, #12]
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );
 8014a28:	617b      	str	r3, [r7, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 8014a2a:	b672      	cpsid	i
}
 8014a2c:	bf00      	nop

  EvtSet |= EvtId_bm;
 8014a2e:	4b09      	ldr	r3, [pc, #36]	; (8014a54 <UTIL_SEQ_SetEvt+0x3c>)
 8014a30:	681a      	ldr	r2, [r3, #0]
 8014a32:	687b      	ldr	r3, [r7, #4]
 8014a34:	4313      	orrs	r3, r2
 8014a36:	4a07      	ldr	r2, [pc, #28]	; (8014a54 <UTIL_SEQ_SetEvt+0x3c>)
 8014a38:	6013      	str	r3, [r2, #0]
 8014a3a:	697b      	ldr	r3, [r7, #20]
 8014a3c:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8014a3e:	693b      	ldr	r3, [r7, #16]
 8014a40:	f383 8810 	msr	PRIMASK, r3
}
 8014a44:	bf00      	nop

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
 8014a46:	bf00      	nop
}
 8014a48:	371c      	adds	r7, #28
 8014a4a:	46bd      	mov	sp, r7
 8014a4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014a50:	4770      	bx	lr
 8014a52:	bf00      	nop
 8014a54:	20000f80 	.word	0x20000f80

08014a58 <UTIL_SEQ_WaitEvt>:

  return;
}

void UTIL_SEQ_WaitEvt(UTIL_SEQ_bm_t EvtId_bm)
{
 8014a58:	b580      	push	{r7, lr}
 8014a5a:	b086      	sub	sp, #24
 8014a5c:	af00      	add	r7, sp, #0
 8014a5e:	6078      	str	r0, [r7, #4]
  UTIL_SEQ_bm_t current_task_idx;
  UTIL_SEQ_bm_t wait_task_idx;
  /** store in local the current_task_id_bm as the global variable CurrentTaskIdx
   *  may be overwritten in case there are nested call of UTIL_SEQ_Run()
   */
  current_task_idx = CurrentTaskIdx;
 8014a60:	4b1b      	ldr	r3, [pc, #108]	; (8014ad0 <UTIL_SEQ_WaitEvt+0x78>)
 8014a62:	681b      	ldr	r3, [r3, #0]
 8014a64:	613b      	str	r3, [r7, #16]
  if(UTIL_SEQ_NOTASKRUNNING == CurrentTaskIdx)
 8014a66:	4b1a      	ldr	r3, [pc, #104]	; (8014ad0 <UTIL_SEQ_WaitEvt+0x78>)
 8014a68:	681b      	ldr	r3, [r3, #0]
 8014a6a:	f1b3 3fff 	cmp.w	r3, #4294967295
 8014a6e:	d102      	bne.n	8014a76 <UTIL_SEQ_WaitEvt+0x1e>
  {
    wait_task_idx = 0;
 8014a70:	2300      	movs	r3, #0
 8014a72:	617b      	str	r3, [r7, #20]
 8014a74:	e005      	b.n	8014a82 <UTIL_SEQ_WaitEvt+0x2a>
  }
  else
  {
    wait_task_idx = 1 << CurrentTaskIdx;
 8014a76:	4b16      	ldr	r3, [pc, #88]	; (8014ad0 <UTIL_SEQ_WaitEvt+0x78>)
 8014a78:	681b      	ldr	r3, [r3, #0]
 8014a7a:	2201      	movs	r2, #1
 8014a7c:	fa02 f303 	lsl.w	r3, r2, r3
 8014a80:	617b      	str	r3, [r7, #20]
  }

  /** backup the event id that was currently waited */
  event_waited_id_backup = EvtWaited;
 8014a82:	4b14      	ldr	r3, [pc, #80]	; (8014ad4 <UTIL_SEQ_WaitEvt+0x7c>)
 8014a84:	681b      	ldr	r3, [r3, #0]
 8014a86:	60fb      	str	r3, [r7, #12]
  EvtWaited = EvtId_bm;
 8014a88:	4a12      	ldr	r2, [pc, #72]	; (8014ad4 <UTIL_SEQ_WaitEvt+0x7c>)
 8014a8a:	687b      	ldr	r3, [r7, #4]
 8014a8c:	6013      	str	r3, [r2, #0]
   *  the while loop below.
   *  The system is waiting only for the last waited event.
   *  When it will go out, it will wait again from the previous one.
   *  It case it occurs while waiting for the second one, the while loop will exit immediately
   */
  while ((EvtSet & EvtWaited) == 0U)
 8014a8e:	e005      	b.n	8014a9c <UTIL_SEQ_WaitEvt+0x44>
  {
    UTIL_SEQ_EvtIdle(wait_task_idx, EvtWaited);
 8014a90:	4b10      	ldr	r3, [pc, #64]	; (8014ad4 <UTIL_SEQ_WaitEvt+0x7c>)
 8014a92:	681b      	ldr	r3, [r3, #0]
 8014a94:	4619      	mov	r1, r3
 8014a96:	6978      	ldr	r0, [r7, #20]
 8014a98:	f7f6 ff08 	bl	800b8ac <UTIL_SEQ_EvtIdle>
  while ((EvtSet & EvtWaited) == 0U)
 8014a9c:	4b0e      	ldr	r3, [pc, #56]	; (8014ad8 <UTIL_SEQ_WaitEvt+0x80>)
 8014a9e:	681a      	ldr	r2, [r3, #0]
 8014aa0:	4b0c      	ldr	r3, [pc, #48]	; (8014ad4 <UTIL_SEQ_WaitEvt+0x7c>)
 8014aa2:	681b      	ldr	r3, [r3, #0]
 8014aa4:	4013      	ands	r3, r2
 8014aa6:	2b00      	cmp	r3, #0
 8014aa8:	d0f2      	beq.n	8014a90 <UTIL_SEQ_WaitEvt+0x38>
  /**
   * Restore the CurrentTaskIdx that may have been modified by call of UTIL_SEQ_Run() from UTIL_SEQ_EvtIdle()
   * This is required so that a second call of UTIL_SEQ_WaitEvt() in the same process pass the correct current_task_id_bm
   * in the call of UTIL_SEQ_EvtIdle()
   */
  CurrentTaskIdx = current_task_idx;
 8014aaa:	4a09      	ldr	r2, [pc, #36]	; (8014ad0 <UTIL_SEQ_WaitEvt+0x78>)
 8014aac:	693b      	ldr	r3, [r7, #16]
 8014aae:	6013      	str	r3, [r2, #0]

  EvtSet &= (~EvtWaited);
 8014ab0:	4b08      	ldr	r3, [pc, #32]	; (8014ad4 <UTIL_SEQ_WaitEvt+0x7c>)
 8014ab2:	681b      	ldr	r3, [r3, #0]
 8014ab4:	43da      	mvns	r2, r3
 8014ab6:	4b08      	ldr	r3, [pc, #32]	; (8014ad8 <UTIL_SEQ_WaitEvt+0x80>)
 8014ab8:	681b      	ldr	r3, [r3, #0]
 8014aba:	4013      	ands	r3, r2
 8014abc:	4a06      	ldr	r2, [pc, #24]	; (8014ad8 <UTIL_SEQ_WaitEvt+0x80>)
 8014abe:	6013      	str	r3, [r2, #0]
  EvtWaited = event_waited_id_backup;
 8014ac0:	4a04      	ldr	r2, [pc, #16]	; (8014ad4 <UTIL_SEQ_WaitEvt+0x7c>)
 8014ac2:	68fb      	ldr	r3, [r7, #12]
 8014ac4:	6013      	str	r3, [r2, #0]

  return;
 8014ac6:	bf00      	nop
}
 8014ac8:	3718      	adds	r7, #24
 8014aca:	46bd      	mov	sp, r7
 8014acc:	bd80      	pop	{r7, pc}
 8014ace:	bf00      	nop
 8014ad0:	20000f88 	.word	0x20000f88
 8014ad4:	20000f84 	.word	0x20000f84
 8014ad8:	20000f80 	.word	0x20000f80

08014adc <UTIL_SEQ_PreIdle>:
{
  return;
}

__WEAK void UTIL_SEQ_PreIdle( void )
{
 8014adc:	b480      	push	{r7}
 8014ade:	af00      	add	r7, sp, #0
  /**
   * Unless specified by the application, there is nothing to be done
   */
  return;
 8014ae0:	bf00      	nop
}
 8014ae2:	46bd      	mov	sp, r7
 8014ae4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014ae8:	4770      	bx	lr

08014aea <UTIL_SEQ_PostIdle>:

__WEAK void UTIL_SEQ_PostIdle( void )
{
 8014aea:	b480      	push	{r7}
 8014aec:	af00      	add	r7, sp, #0
  /**
   * Unless specified by the application, there is nothing to be done
   */
  return;
 8014aee:	bf00      	nop
}
 8014af0:	46bd      	mov	sp, r7
 8014af2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014af6:	4770      	bx	lr

08014af8 <SEQ_BitPosition>:
 * @brief return the position of the first bit set to 1
 * @param Value 32 bit value
 * @retval bit position
 */
uint8_t SEQ_BitPosition(uint32_t Value)
{
 8014af8:	b480      	push	{r7}
 8014afa:	b085      	sub	sp, #20
 8014afc:	af00      	add	r7, sp, #0
 8014afe:	6078      	str	r0, [r7, #4]
  uint8_t n = 0U;
 8014b00:	2300      	movs	r3, #0
 8014b02:	73fb      	strb	r3, [r7, #15]

  if ((Value & 0xFFFF0000U) == 0U)  { n  = 16U; Value <<= 16U;  }
 8014b04:	687b      	ldr	r3, [r7, #4]
 8014b06:	0c1b      	lsrs	r3, r3, #16
 8014b08:	041b      	lsls	r3, r3, #16
 8014b0a:	2b00      	cmp	r3, #0
 8014b0c:	d104      	bne.n	8014b18 <SEQ_BitPosition+0x20>
 8014b0e:	2310      	movs	r3, #16
 8014b10:	73fb      	strb	r3, [r7, #15]
 8014b12:	687b      	ldr	r3, [r7, #4]
 8014b14:	041b      	lsls	r3, r3, #16
 8014b16:	607b      	str	r3, [r7, #4]
  if ((Value & 0xFF000000U) == 0U)  { n +=  8U; Value <<=  8U;  }
 8014b18:	687b      	ldr	r3, [r7, #4]
 8014b1a:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 8014b1e:	2b00      	cmp	r3, #0
 8014b20:	d105      	bne.n	8014b2e <SEQ_BitPosition+0x36>
 8014b22:	7bfb      	ldrb	r3, [r7, #15]
 8014b24:	3308      	adds	r3, #8
 8014b26:	73fb      	strb	r3, [r7, #15]
 8014b28:	687b      	ldr	r3, [r7, #4]
 8014b2a:	021b      	lsls	r3, r3, #8
 8014b2c:	607b      	str	r3, [r7, #4]
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 8014b2e:	687b      	ldr	r3, [r7, #4]
 8014b30:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 8014b34:	2b00      	cmp	r3, #0
 8014b36:	d105      	bne.n	8014b44 <SEQ_BitPosition+0x4c>
 8014b38:	7bfb      	ldrb	r3, [r7, #15]
 8014b3a:	3304      	adds	r3, #4
 8014b3c:	73fb      	strb	r3, [r7, #15]
 8014b3e:	687b      	ldr	r3, [r7, #4]
 8014b40:	011b      	lsls	r3, r3, #4
 8014b42:	607b      	str	r3, [r7, #4]

  n += SEQ_clz_table_4bit[Value >> (32-4)];
 8014b44:	687b      	ldr	r3, [r7, #4]
 8014b46:	0f1b      	lsrs	r3, r3, #28
 8014b48:	4a07      	ldr	r2, [pc, #28]	; (8014b68 <SEQ_BitPosition+0x70>)
 8014b4a:	5cd2      	ldrb	r2, [r2, r3]
 8014b4c:	7bfb      	ldrb	r3, [r7, #15]
 8014b4e:	4413      	add	r3, r2
 8014b50:	73fb      	strb	r3, [r7, #15]

  return (uint8_t)(31U-n);
 8014b52:	7bfb      	ldrb	r3, [r7, #15]
 8014b54:	f1c3 031f 	rsb	r3, r3, #31
 8014b58:	b2db      	uxtb	r3, r3
}
 8014b5a:	4618      	mov	r0, r3
 8014b5c:	3714      	adds	r7, #20
 8014b5e:	46bd      	mov	sp, r7
 8014b60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014b64:	4770      	bx	lr
 8014b66:	bf00      	nop
 8014b68:	080153b0 	.word	0x080153b0

08014b6c <__libc_init_array>:
 8014b6c:	b570      	push	{r4, r5, r6, lr}
 8014b6e:	4d0d      	ldr	r5, [pc, #52]	; (8014ba4 <__libc_init_array+0x38>)
 8014b70:	4c0d      	ldr	r4, [pc, #52]	; (8014ba8 <__libc_init_array+0x3c>)
 8014b72:	1b64      	subs	r4, r4, r5
 8014b74:	10a4      	asrs	r4, r4, #2
 8014b76:	2600      	movs	r6, #0
 8014b78:	42a6      	cmp	r6, r4
 8014b7a:	d109      	bne.n	8014b90 <__libc_init_array+0x24>
 8014b7c:	4d0b      	ldr	r5, [pc, #44]	; (8014bac <__libc_init_array+0x40>)
 8014b7e:	4c0c      	ldr	r4, [pc, #48]	; (8014bb0 <__libc_init_array+0x44>)
 8014b80:	f000 f82e 	bl	8014be0 <_init>
 8014b84:	1b64      	subs	r4, r4, r5
 8014b86:	10a4      	asrs	r4, r4, #2
 8014b88:	2600      	movs	r6, #0
 8014b8a:	42a6      	cmp	r6, r4
 8014b8c:	d105      	bne.n	8014b9a <__libc_init_array+0x2e>
 8014b8e:	bd70      	pop	{r4, r5, r6, pc}
 8014b90:	f855 3b04 	ldr.w	r3, [r5], #4
 8014b94:	4798      	blx	r3
 8014b96:	3601      	adds	r6, #1
 8014b98:	e7ee      	b.n	8014b78 <__libc_init_array+0xc>
 8014b9a:	f855 3b04 	ldr.w	r3, [r5], #4
 8014b9e:	4798      	blx	r3
 8014ba0:	3601      	adds	r6, #1
 8014ba2:	e7f2      	b.n	8014b8a <__libc_init_array+0x1e>
 8014ba4:	080153c0 	.word	0x080153c0
 8014ba8:	080153c0 	.word	0x080153c0
 8014bac:	080153c0 	.word	0x080153c0
 8014bb0:	080153c4 	.word	0x080153c4

08014bb4 <memcpy>:
 8014bb4:	440a      	add	r2, r1
 8014bb6:	4291      	cmp	r1, r2
 8014bb8:	f100 33ff 	add.w	r3, r0, #4294967295
 8014bbc:	d100      	bne.n	8014bc0 <memcpy+0xc>
 8014bbe:	4770      	bx	lr
 8014bc0:	b510      	push	{r4, lr}
 8014bc2:	f811 4b01 	ldrb.w	r4, [r1], #1
 8014bc6:	f803 4f01 	strb.w	r4, [r3, #1]!
 8014bca:	4291      	cmp	r1, r2
 8014bcc:	d1f9      	bne.n	8014bc2 <memcpy+0xe>
 8014bce:	bd10      	pop	{r4, pc}

08014bd0 <memset>:
 8014bd0:	4402      	add	r2, r0
 8014bd2:	4603      	mov	r3, r0
 8014bd4:	4293      	cmp	r3, r2
 8014bd6:	d100      	bne.n	8014bda <memset+0xa>
 8014bd8:	4770      	bx	lr
 8014bda:	f803 1b01 	strb.w	r1, [r3], #1
 8014bde:	e7f9      	b.n	8014bd4 <memset+0x4>

08014be0 <_init>:
 8014be0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014be2:	bf00      	nop
 8014be4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8014be6:	bc08      	pop	{r3}
 8014be8:	469e      	mov	lr, r3
 8014bea:	4770      	bx	lr

08014bec <_fini>:
 8014bec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014bee:	bf00      	nop
 8014bf0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8014bf2:	bc08      	pop	{r3}
 8014bf4:	469e      	mov	lr, r3
 8014bf6:	4770      	bx	lr
